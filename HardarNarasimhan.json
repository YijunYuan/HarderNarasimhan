[{"references": ["Inhabited"],
  "name": "Inhabited.mk",
  "constType": "{α : Sort u} → α → Inhabited α",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Prod.fst",
   "Nat.instPreorder",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_1",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "instHAdd",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_2",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_3",
   "OfNat.ofNat",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.impl.prop4d1₁_seq",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf",
   "StrictMono"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._proof_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S)\n  (h₁ : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩)\n  (h₂ :\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty) (k : ℕ),\n  ↑(HardarNarasimhan.impl.prop4d1₁_seq μ h₁ h₂ h₃ k) < ⊤",
  "constCategory": "Theorem"},
 {"references": ["Subsingleton.allEq", "Subsingleton", "Eq"],
  "name": "Subsingleton.elim",
  "constType": "∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable", "Classical.propDecidable._proof_3", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references": ["SMul", "SMulZeroClass", "Zero"],
  "name": "SMulZeroClass.toSMul",
  "constType":
  "{M : Type u_12} → {A : Type u_13} → {inst : Zero A} → [self : SMulZeroClass M A] → SMul M A",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Equiv",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references": ["Min"],
  "name": "Min.mk",
  "constType": "{α : Type u} → (α → α → α) → Min α",
  "constCategory": "Other"},
 {"references":
  ["Real.instIsStrictOrderedRing",
   "Real",
   "Nonneg.linearOrderedCommGroupWithZero",
   "NNReal",
   "Real.field",
   "Real.linearOrder",
   "LinearOrderedCommGroupWithZero"],
  "name": "NNReal.instLinearOrderedCommGroupWithZero",
  "constType": "LinearOrderedCommGroupWithZero NNReal",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HardarNarasimhan.WeakDescendingChainCondition.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.WeakDescendingChainCondition.rec",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakDescendingChainCondition.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakDescendingChainCondition μ → Sort u} →\n                (t : HardarNarasimhan.WeakDescendingChainCondition μ) →\n                  ((wdcc : ∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "congrFun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Preorder.toLE",
   "GT.gt",
   "le_of_not_lt"],
  "name": "le_of_not_gt",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬a > b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "instOfNat",
   "instHAdd",
   "Int.instAdd",
   "LE.le",
   "Int.instLEInt",
   "Int.instLTInt",
   "OfNat.ofNat",
   "Int"],
  "name": "Int.add_one_le_of_lt",
  "constType": "∀ {a b : ℤ}, a < b → a + 1 ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "Nat.cast",
   "SubNegMonoid.zsmul_zero'._autoParam",
   "SubNegMonoid.zsmul_neg'._autoParam",
   "HSub.hSub",
   "Zero.toOfNat0",
   "Eq",
   "AddSemigroup.toAdd",
   "instNatCastInt",
   "SubNegMonoid.zsmul_succ'._autoParam",
   "Neg.neg",
   "instHAdd",
   "Int.negSucc",
   "Sub",
   "Neg",
   "AddMonoid",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "Nat",
   "instOfNat",
   "Nat.succ",
   "SubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "autoParam",
   "instHSub",
   "SubNegMonoid.sub_eq_add_neg._autoParam"],
  "name": "SubNegMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toAddMonoid : AddMonoid G] →\n    [toNeg : Neg G] →\n      [toSub : Sub G] →\n        autoParam (∀ (a b : G), a - b = a + -b) SubNegMonoid.sub_eq_add_neg._autoParam →\n          (zsmul : ℤ → G → G) →\n            autoParam (∀ (a : G), zsmul 0 a = 0) SubNegMonoid.zsmul_zero'._autoParam →\n              autoParam (∀ (n : ℕ) (a : G), zsmul (↑n.succ) a = zsmul (↑n) a + a) SubNegMonoid.zsmul_succ'._autoParam →\n                autoParam (∀ (n : ℕ) (a : G), zsmul (Int.negSucc n) a = -zsmul (↑n.succ) a)\n                    SubNegMonoid.zsmul_neg'._autoParam →\n                  SubNegMonoid G",
  "constCategory": "Other"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "Lattice",
   "inferInstance",
   "Int.instLinearOrder",
   "Int"],
  "name": "instLatticeInt",
  "constType": "Lattice ℤ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.SlopeLike",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "Preorder.toLT",
   "And",
   "Prod.snd",
   "lt_of_le_of_ne",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "PartialOrder",
   "LE.le",
   "Ne",
   "Preorder.toLE",
   "And.left"],
  "name": "HardarNarasimhan.μA._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (I : { p // p.1 < p.2 }) (a : ℒ),\n  HardarNarasimhan.InIntvl I a ∧ a ≠ (↑I).2 → (a, (↑I).2).1 < (a, (↑I).2).2",
  "constCategory": "Theorem"},
 {"references": ["Inter"],
  "name": "Inter.inter._@.Mathlib.Data.Set.Operations._hyg.7",
  "constType": "{α : Type u} → [self : Inter α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "AddCommMonoid",
   "instHAdd",
   "AddMonoid.toAddSemigroup",
   "AddMonoid",
   "Eq",
   "AddSemigroup.toAdd"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddMonoid : AddMonoid M] → (∀ (a b : M), a + b = b + a) → AddCommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Nat.find",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "HardarNarasimhan.instLatticeInterval",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.μ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HardarNarasimhan.instNontrivialInterval",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HardarNarasimhan.Semistable",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.mk",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] →\n                    [h : HardarNarasimhan.μ_Admissible μ] →\n                      (filtration : ℕ → ℒ) →\n                        Monotone filtration →\n                          filtration 0 = ⊥ →\n                            (fin_len : ∃ n, filtration n = ⊤) →\n                              (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                (∀ (i : ℕ) (h : i < Nat.find fin_len),\n                                    HardarNarasimhan.Semistable\n                                      (HardarNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)) →\n                                  (∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n                                      ¬HardarNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n                                          HardarNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩) →\n                                    HardarNarasimhan.HardarNarasimhanFiltration μ",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.Convex",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              (μ : { p // p.1 < p.2 } → S) →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] → [h : HardarNarasimhan.μ_Admissible μ] → Type",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup.le_sup_left",
   "Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "le_sup_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "True",
   "Eq.trans",
   "of_eq_true",
   "_private.Mathlib.Order.Interval.Set.Defs.0._proof_5",
   "Set",
   "LE.le",
   "Membership.mem",
   "Preorder.toLE",
   "Set.Iic",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "Set.instMembership"],
  "name": "Set.right_mem_Iic",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a : α}, a ∈ Set.Iic a",
  "constCategory": "Theorem"},
 {"references":
  ["contravariant_swap_add_of_contravariant_add",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "AddCommGroup.toAddGroup",
   "Preorder.toLT",
   "HMul.hMul",
   "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
   "GT.gt",
   "AddGroup.toSubtractionMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toNonAssocSemiring",
   "IsCancelAdd.toIsRightCancelAdd",
   "Ring.toAddGroupWithOne",
   "letFun",
   "PartialOrder",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "InvolutiveNeg.toNeg",
   "IsCancelAdd.toIsLeftCancelAdd",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Order.Group.Unbundled.Basic.0._proof_10",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddGroup.existsAddOfLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Ring.toSemiring",
   "id",
   "NegZeroClass.toZero",
   "instHMul",
   "Eq.mpr",
   "mul_pos_of_neg_of_neg",
   "covariant_swap_add_of_covariant_add",
   "AddMonoid.toAddZeroClass",
   "Eq.mp",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "neg_of_neg_pos",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "neg_mul",
   "IsOrderedCancelAddMonoid.toAddLeftReflectLT",
   "Zero.toOfNat0",
   "Eq",
   "Preorder.toLE",
   "IsStrictOrderedRing.toIsOrderedCancelAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Distrib.toMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "LT.lt",
   "Ring.toAddCommGroup",
   "NegZeroClass.toNeg",
   "AddGroupWithOne.toAddGroup",
   "HasDistribNeg.toInvolutiveNeg",
   "SubNegMonoid.toAddMonoid",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "neg_neg_of_pos",
   "IsStrictOrderedRing.toMulPosStrictMono",
   "_private.Init.Core.0._proof_39",
   "Ring"],
  "name": "Linarith.mul_neg",
  "constType":
  "∀ {α : Type u} [inst : Ring α] [inst_1 : PartialOrder α] [IsStrictOrderedRing α] {a b : α}, a < 0 → 0 < b → b * a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddSemigroup.toAdd",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.mk",
   "PosSMulStrictMono",
   "Real",
   "AddCommGroup.add_comm",
   "instHAdd",
   "LinearOrder",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "AddMonoid.toAddSemigroup",
   "LE.le"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.rec",
  "constType":
  "{V : Type} →\n  {motive : HardarNarasimhan.TotallyOrderedRealVectorSpace V → Sort u} →\n    ([toAddCommGroup : AddCommGroup V] →\n        [toModule : _root_.Module ℝ V] →\n          [toLinearOrder : LinearOrder V] →\n            [toPosSMulStrictMono : PosSMulStrictMono ℝ V] →\n              (elim_AddLeftMono : ∀ {y z : V} (x : V), y ≤ z → x + y ≤ x + z) →\n                motive\n                  { toAddCommGroup := toAddCommGroup, toModule := toModule, toLinearOrder := toLinearOrder,\n                    toPosSMulStrictMono := toPosSMulStrictMono, elim_AddLeftMono := elim_AddLeftMono }) →\n      (t : HardarNarasimhan.TotallyOrderedRealVectorSpace V) → motive t",
  "constCategory": "Other"},
 {"references":
  ["le_refl",
   "OrderDual",
   "Preorder",
   "OrderDual.instLT",
   "LE.le",
   "Preorder.toLT",
   "OrderDual.instLE",
   "Preorder.mk",
   "Preorder.toLE",
   "lt_iff_le_not_le",
   "LE.le.trans"],
  "name": "OrderDual.instPreorder",
  "constType": "(α : Type u_5) → [Preorder α] → Preorder αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Nat", "Nat.succ", "Nat.le.refl", "LE.le", "Nat.le.step", "instLENat"],
  "name": "Nat.le_succ",
  "constType": "∀ (n : ℕ), n ≤ n.succ",
  "constCategory": "Theorem"},
 {"references":
  ["absurd", "Not", "False.elim", "False", "Eq", "propext", "Iff.intro"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "And.intro",
   "False.elim",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "not_lt_of_le",
   "Eq.symm",
   "IsTotal.total",
   "HardarNarasimhan.S₁I._proof_1",
   "HardarNarasimhan.S₁I",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "eq_of_ge_of_not_gt",
   "Exists",
   "Exists.choose_spec",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Or.inr",
   "Subtype",
   "lt_of_le_of_ne",
   "Prod.fst",
   "le_rfl",
   "HardarNarasimhan.IsAttained",
   "Subtype.prop",
   "Or.inl",
   "HardarNarasimhan.impl.prop2d6₃I",
   "WellFoundedGT",
   "HardarNarasimhan.S₂I",
   "Preorder.toLE",
   "Eq",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.StI",
   "Exists.choose",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Or.casesOn",
   "IsTotal",
   "ne_of_lt",
   "le_of_lt",
   "HardarNarasimhan.IsComparable",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d8₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.ConvexI I μ →\n    ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n        ∀ (z : ℒ) (hzI : HardarNarasimhan.InIntvl I z) (hz : (↑I).1 ≠ z),\n          HardarNarasimhan.IsAttained μ ⟨((↑I).1, z), ⋯⟩) →\n      ∀ (x : ℒ) (hxSt : x ∈ HardarNarasimhan.StI μ I) (y : ℒ),\n        HardarNarasimhan.InIntvl I y →\n          ∀ (hxy : x < y), HardarNarasimhan.μA μ ⟨((↑I).1, y), ⋯⟩ = HardarNarasimhan.μA μ ⟨(x, y), hxy⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "instOfNat",
   "Int.negOfNat.match_1",
   "Int.negSucc",
   "OfNat.ofNat",
   "Unit",
   "Int"],
  "name": "Int.negOfNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "HardarNarasimhan.impl.instμ_Admissible",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "Exists",
   "Lean.Omega.combo_sat'",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "HardarNarasimhan.impl.HNFil",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "Option.none",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "instHSub",
   "PartialOrder.toPreorder",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Int.instNegInt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "instDecidableEqBool",
   "Nat",
   "Nat.lt_of_not_le",
   "Nontrivial",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.cast",
   "instDecidableAnd",
   "Subtype",
   "HardarNarasimhan.Convex",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HardarNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HardarNarasimhan.Convex μ) (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (n : ℕ)\n  (h₂ : ∃ N ≥ n + 1, HardarNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n  Nat.find h₂ ≤ Nat.find hffin → ¬Nat.find h₂ - 1 ≤ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Covariant M N μ r → CovariantClass M N μ r",
  "constCategory": "Other"},
 {"references":
  ["LT.lt",
   "le_top",
   "PartialOrder.toPreorder",
   "Iff",
   "PartialOrder",
   "Preorder.toLT",
   "Top.top",
   "LE.le.lt_iff_ne",
   "OrderTop",
   "Ne",
   "Preorder.toLE",
   "OrderTop.toTop"],
  "name": "lt_top_iff_ne_top",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, a < ⊤ ↔ a ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub", "Eq.refl", "HSub.hSub", "instHSub", "Eq.ndrec", "Eq", "Int"],
  "name": "Lean.Omega.Int.sub_congr",
  "constType": "∀ {a b c d : ℤ}, a = b → c = d → a - c = b - d",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "IsWellFounded.wf",
   "HardarNarasimhan.impl.ℒₛ",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ) (x : Nat.below n.succ)\n  (hbot : ¬(↑I).1 = ↑x.1),\n  (HardarNarasimhan.impl.ℒₛ μ I x.1 hbot).Nonempty →\n    ∃ a ∈ HardarNarasimhan.impl.ℒₛ μ I x.1 hbot, ∀ x_1 ∈ HardarNarasimhan.impl.ℒₛ μ I x.1 hbot, ¬x_1 > a",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Iff", "Iff.rfl", "GT.gt", "LT"],
  "name": "gt_iff_lt",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, x > y ↔ y < x",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "EmptyCollection.emptyCollection",
   "Set.instEmptyCollection",
   "DFunLike.coe",
   "ClosureOperator.instFunLike",
   "Set.instCompleteAtomicBooleanAlgebra",
   "ClosureOperator.isClosed_closure"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_16",
  "constType": "∀ {α : Type} (T : ClosureOperator (Set α)), T.IsClosed (T ∅)",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "True", "trivial", "Decidable.isTrue"],
  "name": "instDecidableTrue",
  "constType": "Decidable True",
  "constCategory": "Definition"},
 {"references": ["GetElem", "outParam"],
  "name": "GetElem.getElem",
  "constType":
  "{coll : Type u} →\n  {idx : Type v} →\n    {elem : outParam (Type w)} →\n      {valid : outParam (coll → idx → Prop)} →\n        [self : GetElem coll idx elem valid] → (xs : coll) → (i : idx) → valid xs i → elem",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "HardarNarasimhan.ConvexI.convex",
   "Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.ConvexI",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "le_trans",
   "Preorder.toLT",
   "And",
   "Prod.snd",
   "HardarNarasimhan.ConvexI.mk",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "And.intro",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "CompleteLattice",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.Convex_of_Convex_large",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {S : Type} [inst_1 : CompleteLattice S] (I₁ I₂ : { p // p.1 < p.2 }),\n  (↑I₁).1 ≤ (↑I₂).1 ∧ (↑I₂).2 ≤ (↑I₁).2 →\n    ∀ (μ : { p // p.1 < p.2 } → S), HardarNarasimhan.ConvexI I₁ μ → HardarNarasimhan.ConvexI I₂ μ",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.le.refl", "LE.le", "instLENat"],
  "name": "Nat.le_refl",
  "constType": "∀ (n : ℕ), n ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "instOfNatNat",
   "HardarNarasimhan.HardarNarasimhanFiltration.filtration",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Bot.bot",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.first_eq_bot",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HardarNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HardarNarasimhan.Convex μ} {h : HardarNarasimhan.μ_Admissible μ}\n  [self : HardarNarasimhan.HardarNarasimhanFiltration μ], HardarNarasimhan.HardarNarasimhanFiltration.filtration μ 0 = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Bot",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderBot",
   "HardarNarasimhan.μB",
   "Top",
   "BoundedOrder",
   "OrderTop",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "lcProof",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μBstar._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → S",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.fst",
  "constType": "{α : Type u} → {β : Type v} → α × β → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IsEmpty",
  "constType": "Sort u_4 → Prop",
  "constCategory": "Other"},
 {"references":
  ["NeZero",
   "instAddNat",
   "HAdd.hAdd",
   "Nat",
   "Zero.ofOfNat0",
   "instHAdd",
   "instOfNatNat",
   "Nat.succ_ne_zero",
   "NeZero.mk",
   "OfNat.ofNat"],
  "name": "Nat.instNeZeroSucc",
  "constType": "∀ {n : ℕ}, NeZero (n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.Semistable.mk",
   "HardarNarasimhan.Semistable",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.Semistable.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.Semistable μ → Sort u} →\n                ((semistable :\n                      ∀ (x : ℒ) (hx : x ≠ ⊥), ¬HardarNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HardarNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩) →\n                    motive ⋯) →\n                  (t : HardarNarasimhan.Semistable μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.WeakDescendingChainCondition.casesOn",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakDescendingChainCondition.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u →\n                HardarNarasimhan.WeakDescendingChainCondition μ →\n                  HardarNarasimhan.WeakDescendingChainCondition μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Int.instSub",
   "Or.inr",
   "Nat.cast",
   "Eq.trans",
   "Iff.mp",
   "and_true",
   "congrArg",
   "And.intro",
   "Or",
   "Or.inl",
   "letFun",
   "Lean.Omega.Int.ofNat_sub_eq_zero",
   "HSub.hSub",
   "Eq",
   "instNatCastInt",
   "Not",
   "instLTNat",
   "True",
   "And",
   "Nat.decLe",
   "Nat.not_le",
   "OfNat.ofNat",
   "Int",
   "LT.lt",
   "eq_self",
   "Nat",
   "instSubNat",
   "instOfNat",
   "LE.le",
   "id",
   "Int.ofNat_sub",
   "Eq.mpr",
   "instHSub",
   "dite",
   "_private.Init.Core.0._proof_39",
   "instLENat"],
  "name": "Lean.Omega.Int.ofNat_sub_dichotomy",
  "constType": "∀ {a b : ℕ}, b ≤ a ∧ ↑(a - b) = ↑a - ↑b ∨ a < b ∧ ↑(a - b) = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.impl.ℒₛ._proof_2",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "WellFoundedGT",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.ℒₛ._proof_1",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.impl.ℒₛ",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        [WellFoundedGT ℒ] →\n          {S : Type} →\n            [CompleteLattice S] →\n              ({ p // p.1 < p.2 } → S) →\n                (I : { p // p.1 < p.2 }) → (x : { p // HardarNarasimhan.InIntvl I p }) → (↑I).1 ≠ ↑x → Set ℒ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "HardarNarasimhan.InIntvl",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Ne",
   "HardarNarasimhan.S₁I._proof_1",
   "Subtype.mk",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.S₂I",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        {S : Type} →\n          [CompleteLattice S] →\n            ({ p // p.1 < p.2 } → S) →\n              (I : { p // p.1 < p.2 }) → (x : ℒ) → HardarNarasimhan.InIntvl I x → (↑I).1 ≠ x → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommGroupWithZero.zpow_zero'",
   "CommGroupWithZero.mk",
   "LinearOrderedCommGroupWithZero.toDiv",
   "LinearOrderedCommGroupWithZero.zpow_neg'",
   "LinearOrderedCommGroupWithZero.inv_zero",
   "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
   "LinearOrderedCommGroupWithZero.toInv",
   "LinearOrderedCommGroupWithZero.div_eq_mul_inv",
   "CommGroupWithZero",
   "LinearOrderedCommGroupWithZero.zpow_succ'",
   "LinearOrderedCommGroupWithZero.mul_inv_cancel",
   "LinearOrderedCommGroupWithZero",
   "LinearOrderedCommGroupWithZero.zpow",
   "LinearOrderedCommGroupWithZero.toNontrivial",
   "LinearOrderedCommMonoidWithZero.toCommMonoidWithZero"],
  "name": "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommGroupWithZero α] → CommGroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Coe",
   "Preorder.toLT",
   "Subtype.val",
   "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_17",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Coe.mk",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod",
   "LT.lt",
   "lcProof",
   "BoundedOrder.toOrderBot",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top"],
  "name": "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → Coe ℒ (HardarNarasimhan.Interval ⟨(⊥, ⊤), ⋯⟩)",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable.not_imp_symm", "Decidable"],
  "name": "Not.decidable_imp_symm",
  "constType": "∀ {a b : Prop} [Decidable a], (¬a → b) → ¬b → a",
  "constCategory": "Theorem"},
 {"references": ["NatCast.mk", "Nat", "NatCast", "Int.ofNat", "Int"],
  "name": "instNatCastInt",
  "constType": "NatCast ℤ",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "True",
   "Eq.trans",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "OfNat.ofNat",
   "congrArg",
   "Ring.toAddCommGroup",
   "eq_self",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NegZeroClass.toNeg",
   "of_eq_true",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NegZeroClass.toZero",
   "Zero.toOfNat0",
   "neg_zero",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_zero",
  "constType": "∀ {R : Type u_2} [inst : Ring R], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.WeakSlopeLike₂.mk",
   "HardarNarasimhan.WeakSlopeLike₂.rec",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₂.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakSlopeLike₂ μ → Sort u} →\n                (t : HardarNarasimhan.WeakSlopeLike₂ μ) →\n                  ((wsl₂ :\n                        ∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n                          μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.TotIntvl._proof_1",
   "Bot.bot",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "OrderBot.toBot",
   "Subtype.mk",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.TotIntvl",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "True",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "SemilatticeInf",
   "eq_self",
   "of_eq_true",
   "Min.min",
   "inf_of_le_left",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_idem",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] (a : α), a ⊓ a = a",
  "constCategory": "Theorem"},
 {"references":
  ["IsOrderedAddMonoid.mk",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "instHAdd",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "IsOrderedAddMonoid",
   "Int.add_le_add_left",
   "LE.le",
   "id",
   "Int.instAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Eq.mpr",
   "Eq",
   "Preorder.toLE",
   "add_comm",
   "SemilatticeInf.toPartialOrder",
   "instLatticeInt"],
  "name": "Int.instIsOrderedAddMonoid",
  "constType": "IsOrderedAddMonoid ℤ",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Eq.symm",
   "Int.instLEInt",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nat.lt_of_not_le",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Bool",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Option.some",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Int.instAdd",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (i j : ℕ),\n  i < j → j < Nat.find hffin → ¬i + 1 ≤ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references":
  ["Ord",
   "LinearOrder.compare_eq_compareOfLessAndEq._autoParam",
   "PartialOrder.toPreorder",
   "DecidableLE",
   "Ord.compare",
   "ite",
   "DecidableLT",
   "DecidableEq",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.max_def._autoParam",
   "Min",
   "compareOfLessAndEq",
   "Ordering",
   "LinearOrder.min_def._autoParam",
   "Max.max",
   "Or",
   "Min.min",
   "PartialOrder",
   "LE.le",
   "autoParam",
   "Eq",
   "Max",
   "Preorder.toLE"],
  "name": "LinearOrder.mk",
  "constType":
  "{α : Type u_2} →\n  [toPartialOrder : PartialOrder α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (toDecidableLE : DecidableLE α) →\n              (toDecidableEq : DecidableEq α) →\n                (toDecidableLT : DecidableLT α) →\n                  autoParam (∀ (a b : α), a ⊓ b = if a ≤ b then a else b) LinearOrder.min_def._autoParam →\n                    autoParam (∀ (a b : α), a ⊔ b = if a ≤ b then b else a) LinearOrder.max_def._autoParam →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b)\n                          LinearOrder.compare_eq_compareOfLessAndEq._autoParam →\n                        LinearOrder α",
  "constCategory": "Other"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.SlopeLike.slopelike",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HardarNarasimhan.SlopeLike μ] (x y z : ℒ)\n  (h : x < y ∧ y < z),\n  (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n    (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n      (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n        (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration.mk",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Nat.find",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "HardarNarasimhan.instLatticeInterval",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.μ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HardarNarasimhan.instNontrivialInterval",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HardarNarasimhan.Semistable",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "HardarNarasimhan.HardarNarasimhanFiltration.rec",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] →\n                    [h : HardarNarasimhan.μ_Admissible μ] →\n                      {motive : HardarNarasimhan.HardarNarasimhanFiltration μ → Sort u} →\n                        (t : HardarNarasimhan.HardarNarasimhanFiltration μ) →\n                          ((filtration : ℕ → ℒ) →\n                              (monotone : Monotone filtration) →\n                                (first_eq_bot : filtration 0 = ⊥) →\n                                  (fin_len : ∃ n, filtration n = ⊤) →\n                                    (strict_mono :\n                                        ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                      (piecewise_semistable :\n                                          ∀ (i : ℕ) (h : i < Nat.find fin_len),\n                                            HardarNarasimhan.Semistable\n                                              (HardarNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)) →\n                                        (μA_pseudo_strict_anti :\n                                            ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n                                              ¬HardarNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n                                                  HardarNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩) →\n                                          motive\n                                            { filtration := filtration, monotone := monotone,\n                                              first_eq_bot := first_eq_bot, fin_len := fin_len,\n                                              strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n                                              μA_pseudo_strict_anti := μA_pseudo_strict_anti }) →\n                            motive t",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.μA_DescendingChainCondition.rec",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "HardarNarasimhan.μA_DescendingChainCondition.mk",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μA_DescendingChainCondition.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.μA_DescendingChainCondition μ → Sort u} →\n                (t : HardarNarasimhan.μA_DescendingChainCondition μ) →\n                  ((μ_dcc :\n                        ∀ (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n                          (∀ (n : ℕ), f n > f (n + 1)) →\n                            ∃ N, HardarNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(a, f N), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.WeakSlopeLike₁.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₁.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n    HardarNarasimhan.WeakSlopeLike₁ μ",
  "constCategory": "Definition"},
 {"references": ["CompletelyDistribLattice", "CompleteLattice"],
  "name": "CompletelyDistribLattice.toCompleteLattice",
  "constType":
  "{α : Type u} → [self : CompletelyDistribLattice α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["PUnit.unit",
   "Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "OfNat.ofNat",
   "Unit"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq.match_1._cstage1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((k : ℕ) → motive k.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "Subtype.partialOrder",
   "ClosureOperator",
   "Union.union",
   "Subtype.val",
   "DFunLike.coe",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "ClosureOperator.isClosed_closure",
   "Preorder.toLE",
   "Set.instUnion",
   "Eq.rec",
   "Eq",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Set.union_subset",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
   "Set.instMembership",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Subtype.mk"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_4",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B C : T.Closeds),\n  A ≤ C → B ≤ C → ∀ ⦃a : α⦄, a ∈ ↑⟨T (↑A ∪ ↑B), ⋯⟩ → a ∈ ↑C",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "OrderDual",
   "OrderDual.toDual",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "DFunLike.coe",
   "Equiv",
   "OrderDual.ofDual",
   "PartialOrder",
   "Preorder.toLE",
   "Equiv.instFunLike",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "OmegaCompletePartialOrder",
   "OrderDual.instPreorder",
   "Preorder",
   "CompleteAtomicBooleanAlgebra",
   "lcProof",
   "GaloisConnection.closureOperator",
   "Set.instCompleteAtomicBooleanAlgebra",
   "upperBounds",
   "Iff",
   "lowerBounds",
   "LE.le",
   "CompleteLattice"],
  "name": "HardarNarasimhan.DedekindMacNeilleClosureOperator._cstage1",
  "constType": "(α : Type) → [PartialOrder α] → ClosureOperator (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.Convex",
   "Preorder.toLT",
   "HardarNarasimhan.impl.prop2d6₁I",
   "GE.ge",
   "Prod.fst",
   "HardarNarasimhan.IsAttained",
   "And.intro",
   "Or",
   "HardarNarasimhan.impl.prop2d6₃I",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "HardarNarasimhan.impl.prop2d6₂I₁",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.impl.prop2d6₂I₂",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop2d6₀",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.IsComparable",
   "Min.min",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_2_6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (x y z : ℒ) (h : x < y ∧ y < z),\n  HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ ∧\n    (HardarNarasimhan.Convex μ →\n      HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ≥ HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩ ⊓ HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ ∧\n        ((HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≥ HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ →\n              HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ = HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩) ∧\n            (HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩ < HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ →\n              HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∧\n                HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩)) ∧\n          (HardarNarasimhan.IsComparable (HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩) (HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩) ∨\n              HardarNarasimhan.IsAttained μ ⟨(x, z), ⋯⟩ →\n            HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ = HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∨\n              HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∧\n                HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ < HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩))",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "SemilatticeSup.mk",
  "constType":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    (sup : α → α → α) →\n      (∀ (a b : α), a ≤ sup a b) →\n        (∀ (a b : α), b ≤ sup a b) → (∀ (a b c : α), a ≤ c → b ≤ c → sup a b ≤ c) → SemilatticeSup α",
  "constCategory": "Other"},
 {"references": ["Preorder", "LE.le", "le_of_eq", "Preorder.toLE", "Eq"],
  "name": "Eq.le",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Decidable",
   "Eq.trans",
   "WellFounded.has_min",
   "Prod.mk",
   "Subsingleton.elim",
   "Eq.mpr_not",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "eq_true",
   "Membership.mem.out",
   "GT.gt",
   "HardarNarasimhan.impl.prop3d4₀func._proof_7",
   "Subtype.val",
   "HardarNarasimhan.impl.prop3d4₀func._proof_4",
   "False.elim",
   "HardarNarasimhan.impl.prop3d4₀func._proof_8",
   "letFun",
   "forall_congr",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.impl.prop3d4₀func_helper",
   "of_eq_false",
   "Exists",
   "Exists.choose_spec",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat",
   "Eq.refl",
   "eq_false",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "HardarNarasimhan.impl.ℒₛ._proof_2",
   "Subtype",
   "instDecidableTrue",
   "Eq.mp",
   "lt_of_le_of_ne",
   "dite_congr",
   "congrArg",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "IsWellFounded.wf",
   "HardarNarasimhan.impl.ℒₛ",
   "not_true_eq_false",
   "WellFoundedGT",
   "instDecidableFalse",
   "instSubsingletonDecidable",
   "dite_cond_eq_false",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "Set",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Exists.choose",
   "HardarNarasimhan.impl.ℒₛ._proof_1",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "dite_cond_eq_true",
   "of_eq_true",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "_private.Init.Core.0._proof_39",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func_strict_decreasing",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ),\n  (↑I).1 ≠ ↑(HardarNarasimhan.impl.prop3d4₀func μ I i) →\n    ↑(HardarNarasimhan.impl.prop3d4₀func μ I i) > ↑(HardarNarasimhan.impl.prop3d4₀func μ I (i + 1))",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "HardarNarasimhan.μA_DescendingChainCondition.casesOn",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μA_DescendingChainCondition.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u →\n                HardarNarasimhan.μA_DescendingChainCondition μ → HardarNarasimhan.μA_DescendingChainCondition μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Nat.rawCast",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat"],
  "name": "Mathlib.Meta.NormNum.IsNat.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] (n : ℕ), Mathlib.Meta.NormNum.IsNat n.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "HardarNarasimhan.impl.instμ_Admissible",
   "Preorder.toLT",
   "Classical.propDecidable",
   "GT.gt",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Eq.symm",
   "Int.instLEInt",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "List.cons",
   "Bool.true",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Lean.Omega.combo_sat'",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "Prod",
   "instDecidableEqBool",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Lean.Omega.LinearCombo.instAdd",
   "Lean.Omega.Int.sub_congr",
   "Nat.find",
   "Nat.cast",
   "Bool",
   "Subtype",
   "instDecidableAnd",
   "HardarNarasimhan.Convex",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Lean.Omega.Constraint.combine_sat'",
   "Option.some",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Prod.fst",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "HardarNarasimhan.impl.HNFil",
   "Int.instAdd",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "instNatCastInt",
   "of_decide_eq_true",
   "List.nil",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.sub_nonneg_of_le",
   "Int.ofNat_nonneg",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "CompletelyDistribLattice.toCompleteLattice",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Option.none",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "OrderTop.toTop",
   "instLENat"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_9",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HardarNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HardarNarasimhan.Convex μ) (f : ℕ → ℒ),\n  (∃ n, f n = ⊤) →\n    ∀ (n : ℕ) (h₂ : ∃ N ≥ n + 1, HardarNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n      Nat.find h₂ ≥ n + 1 → ¬Nat.find h₂ > 0 → False",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.rawCast",
   "Int",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.IsInt.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : Ring α] (n : ℤ), Mathlib.Meta.NormNum.IsInt n.rawCast n",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LowerAdjoint"],
  "name": "LowerAdjoint.toFun",
  "constType":
  "{α : Type u_1} → {β : Type u_4} → [inst : Preorder α] → [inst_1 : Preorder β] → {u : β → α} → LowerAdjoint u → α → β",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LT"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u_2} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionCommMonoid",
   "DivisionMonoid.inv_eq_of_mul",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.toCancelCommMonoidWithZero._proof_12",
   "CommGroupWithZero.zpow_succ'",
   "CommMonoidWithZero.toCommMonoid",
   "CommGroupWithZero.toDiv",
   "CommGroupWithZero.zpow_neg'",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero",
   "DivisionCommMonoid.mk",
   "DivInvMonoid.mk",
   "CommGroupWithZero.toInv",
   "DivisionMonoid.mul_inv_rev",
   "DivisionMonoid",
   "DivisionMonoid.inv_inv",
   "DivisionMonoid.mk",
   "CommGroupWithZero.div_eq_mul_inv",
   "CommGroupWithZero.zpow_zero'",
   "CommGroupWithZero.toGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GroupWithZero.toDivisionMonoid"],
  "name": "CommGroupWithZero.toDivisionCommMonoid",
  "constType":
  "{G₀ : Type u_3} → [CommGroupWithZero G₀] → DivisionCommMonoid G₀",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.impl.lem2d4₂I",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Preorder.toLT",
   "Iff.mp",
   "sup_le",
   "le_sup_right",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "le_sup_left",
   "Prod",
   "Eq.refl",
   "Iff.mpr",
   "HardarNarasimhan.impl.lem2d4₁",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "Or.inr",
   "SemilatticeInf.toMin",
   "Subtype",
   "not_le_of_lt",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "Prod.fst",
   "congrArg",
   "le_inf",
   "Or.inl",
   "HardarNarasimhan.μmax",
   "Preorder.toLE",
   "Eq",
   "sup_le_iff",
   "propext",
   "inf_lt_left",
   "Not",
   "not_and_or",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Or.casesOn",
   "Max.max",
   "le_of_lt",
   "Min.min",
   "SemilatticeSup.toMax",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop2d8₀I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HardarNarasimhan.InIntvl I y →\n            ∀ (u : ℒ) (h : u < x ∧ u < y) (w : ℒ),\n              HardarNarasimhan.InIntvl I w →\n                ∀ (hw : u ≤ w ∧ w < x ⊔ y),\n                  HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HardarNarasimhan.μmax μ ⟨(w, x ⊔ y), ⋯⟩ ∨\n                    HardarNarasimhan.μA μ ⟨(u, y), ⋯⟩ ≤ HardarNarasimhan.μmax μ ⟨(w, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["_obj", "HardarNarasimhan.μB._rarg", "_neutral"],
  "name": "HardarNarasimhan.μB._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["FunLike",
   "DFunLike.mk",
   "RelEmbedding.toEmbedding",
   "Function.Embedding.toFun",
   "RelEmbedding",
   "RelEmbedding.instFunLike._proof_5"],
  "name": "RelEmbedding.instFunLike",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → FunLike (r ↪r s) α β",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "HardarNarasimhan.Semistable.rec",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.Semistable.mk",
   "HardarNarasimhan.Semistable",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.Semistable.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.Semistable μ → Sort u} →\n                (t : HardarNarasimhan.Semistable μ) →\n                  ((semistable :\n                        ∀ (x : ℒ) (hx : x ≠ ⊥),\n                          ¬HardarNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HardarNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.impl.lem2d4₂I",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "sup_eq_left",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "inf_le_inf_left",
   "sup_le",
   "Subtype.val",
   "And.intro",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "le_sup_left",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Iff.mpr",
   "HardarNarasimhan.impl.lem2d4₁",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "sup_le_sup_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "lt_irrefl",
   "HardarNarasimhan.μmax",
   "Preorder.toLE",
   "Eq",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Max.max",
   "Min.min",
   "LE.le",
   "SemilatticeSup.toMax",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.lem2d4₃I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (w : ℒ),\n          HardarNarasimhan.InIntvl I w →\n            ∀ (hxw : ¬x ≤ w) (u : ℒ) (huxw : u ≤ x ⊓ w),\n              HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(w, x ⊔ w), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["rfl", "funext", "Eq.rec", "Eq"],
  "name": "forall_congr",
  "constType":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references": ["IsEmpty", "isEmptyElim"],
  "name": "IsEmpty.elim",
  "constType": "{α : Sort u} → IsEmpty α → {p : α → Sort u_4} → (a : α) → p a",
  "constCategory": "Definition"},
 {"references": ["Top", "CompleteLattice"],
  "name": "CompleteLattice.toTop",
  "constType": "{α : Type u_8} → [self : CompleteLattice α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "HardarNarasimhan.TotIntvl._proof_1",
   "Subtype.val",
   "And.intro",
   "HardarNarasimhan.NashEquilibrium",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "funext",
   "Eq.symm",
   "HardarNarasimhan.μAstar",
   "HardarNarasimhan.WeakSlopeLike₂.wsl₂",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Iff",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Eq.mp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Iff.intro",
   "Prod.fst",
   "congrArg",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "InfSet.sInf",
   "OrderBot.toBot",
   "bot_ne_top",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "HardarNarasimhan.NashEquilibrium.mk",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.in_TotIntvl",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.WeakDescendingChainCondition.wdcc",
   "HardarNarasimhan.WeakSlopeLike₂",
   "HardarNarasimhan.μA",
   "exists_prop_congr",
   "sInf_le",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "LE.le",
   "HardarNarasimhan.impl.prop4d3₁",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HardarNarasimhan.NashEquilibrium.nash_eq",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.rmk4d10₃",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.WeakDescendingChainCondition μ →\n    HardarNarasimhan.WeakSlopeLike₂ μ →\n      (HardarNarasimhan.NashEquilibrium μ ↔\n        ∀ (y : ℒ) (hy : y ≠ ⊤), HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl ≤ HardarNarasimhan.μmax μ ⟨(y, ⊤), ⋯⟩)",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddSemigroup.toAdd",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "PosSMulStrictMono",
   "Real",
   "AddCommGroup.add_comm",
   "instHAdd",
   "LinearOrder",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "AddMonoid.toAddSemigroup",
   "LE.le"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.mk",
  "constType":
  "{V : Type} →\n  [toAddCommGroup : AddCommGroup V] →\n    [toModule : _root_.Module ℝ V] →\n      [toLinearOrder : LinearOrder V] →\n        [toPosSMulStrictMono : PosSMulStrictMono ℝ V] →\n          (∀ {y z : V} (x : V), y ≤ z → x + y ≤ x + z) → HardarNarasimhan.TotallyOrderedRealVectorSpace V",
  "constCategory": "Other"},
 {"references": ["Not", "False.elim", "Eq.mp", "False", "Eq"],
  "name": "of_eq_false",
  "constType": "∀ {p : Prop}, p = False → ¬p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Real",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "SubNegMonoid.zsmul_succ'._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references": ["Nat", "Int"],
  "name": "Int.negSucc",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references": [],
  "name": "Nonempty",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "LinearOrder.max_def._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubset",
   "Or.inr",
   "HasSubset.Subset",
   "Set",
   "Membership.mem",
   "Set.instUnion",
   "Union.union",
   "Set.instMembership"],
  "name": "Set.subset_union_right",
  "constType": "∀ {α : Type u} {s t : Set α}, t ⊆ s ∪ t",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "SubNegMonoid.toAddMonoid",
   "Real",
   "AddCommGroup.add_comm",
   "Module",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "Real.semiring"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.toModule",
  "constType":
  "{V : Type} → [self : HardarNarasimhan.TotallyOrderedRealVectorSpace V] → _root_.Module ℝ V",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "AddMonoid.nsmul_zero._autoParam",
   "instHAdd",
   "AddMonoid",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "AddSemigroup",
   "Nat",
   "instOfNatNat",
   "Zero.toOfNat0",
   "autoParam",
   "Zero",
   "Eq",
   "AddMonoid.nsmul_succ._autoParam",
   "AddSemigroup.toAdd"],
  "name": "AddMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddSemigroup : AddSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) AddMonoid.nsmul_zero._autoParam →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = nsmul n x + x) AddMonoid.nsmul_succ._autoParam →\n                AddMonoid M",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "HardarNarasimhan.WeakDescendingChainCondition.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.WeakDescendingChainCondition.rec",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakDescendingChainCondition.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakDescendingChainCondition μ → Sort u} →\n                (t : HardarNarasimhan.WeakDescendingChainCondition μ) →\n                  ((wdcc : ∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "AddZeroClass.toZero",
   "AddZeroClass.toAdd",
   "AddZeroClass",
   "instHAdd",
   "Zero.toOfNat0",
   "Eq",
   "OfNat.ofNat",
   "AddZeroClass.zero_add"],
  "name": "zero_add",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder", "LE.le", "le_of_eq", "Eq.symm", "Preorder.toLE", "Eq"],
  "name": "ge_of_eq",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] {a b : α}, a = b → b ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Option",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["HardarNarasimhan.SlopeLike.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HardarNarasimhan.instNontrivialInterval",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "Preorder.toLE",
   "HardarNarasimhan.instBoundedOrderInterval",
   "HardarNarasimhan.Interval",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.instLatticeInterval",
   "HardarNarasimhan.Resμ",
   "Not",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "lt_iff_le_not_le",
   "HardarNarasimhan.SlopeLike.slopelike",
   "LT.lt",
   "Prod",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "CompleteLattice"],
  "name": "HardarNarasimhan.instSlopeLikeIntervalResμ",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hsl : HardarNarasimhan.SlopeLike μ]\n  {z : { p // p.1 < p.2 }}, HardarNarasimhan.SlopeLike (HardarNarasimhan.Resμ z μ)",
  "constCategory": "Theorem"},
 {"references":
  ["ConditionallyCompleteLinearOrderBot", "ConditionallyCompleteLinearOrder"],
  "name":
  "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLinearOrderBot α] → ConditionallyCompleteLinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "Or",
   "LE.le",
   "LinearOrder",
   "Preorder.toLE",
   "LinearOrder.le_total"],
  "name": "le_total",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name":
  "HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references": ["SemilatticeInf", "SemilatticeInf.inf", "Min", "Min.mk"],
  "name": "SemilatticeInf.toMin",
  "constType": "{α : Type u} → [SemilatticeInf α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.Semistable",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.Semistable.semistable",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HardarNarasimhan.Semistable μ] (x : ℒ) (hx : x ≠ ⊥),\n  ¬HardarNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HardarNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.WeakAscendingChainCondition.mk",
   "Preorder.toLT",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakAscendingChainCondition.rec",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HardarNarasimhan.WeakAscendingChainCondition.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakAscendingChainCondition μ → Sort u} →\n                (t : HardarNarasimhan.WeakAscendingChainCondition μ) →\n                  ((wacc : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Decidable"],
  "name": "DecidablePred",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "Or.inl",
   "Or",
   "Subtype.prop",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLinearOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "And.right",
   "HardarNarasimhan.WeakSlopeLike₂.mk",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "HardarNarasimhan.SlopeLike.slopelike",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Or.casesOn",
   "BoundedOrder.toOrderBot",
   "le_of_lt",
   "Eq.refl",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "HardarNarasimhan.impl.instWeakSlopeLike₂OfSlopeLike",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} [hμ : HardarNarasimhan.SlopeLike μ],\n  HardarNarasimhan.WeakSlopeLike₂ μ",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "Bool", "Decidable", "Bool.false", "Decidable.casesOn", "Bool.true"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) → [h : Decidable p] → Bool",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.mp",
   "Iff.mp",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "GT.gt",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "IsEmpty",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.impl.HNFil",
   "IsWellFounded.wf",
   "IsEmpty.elim",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "WellFounded",
   "Not",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "Classical.byContradiction",
   "Top.top",
   "HardarNarasimhan.impl.HNFil_is_strict_mono",
   "False",
   "Ne",
   "Subtype.mk",
   "WellFounded.wellFounded_iff_no_descending_seq",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil_of_fin_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ], ∃ N, HardarNarasimhan.impl.HNFil μ N = ⊤",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Set", "Eq", "setOf"],
  "name": "Set.range",
  "constType": "{α : Type u} → {ι : Sort u_1} → (ι → α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "HardarNarasimhan.Semistable.rec",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.Semistable.mk",
   "HardarNarasimhan.Semistable",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.Semistable.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.Semistable μ → Sort u} →\n                (t : HardarNarasimhan.Semistable μ) →\n                  ((semistable :\n                        ∀ (x : ℒ) (hx : x ≠ ⊥),\n                          ¬HardarNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HardarNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Or.inr",
   "Decidable",
   "Eq.mpr_not",
   "Decidable.em",
   "Eq.mpr_prop",
   "congrArg",
   "Or.casesOn",
   "dif_pos",
   "Or",
   "Or.inl",
   "Eq.refl",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "dif_neg",
   "Eq.rec",
   "Eq",
   "dite"],
  "name": "dite_congr",
  "constType":
  "∀ {b c : Prop} {α : Sort u_1} {x : Decidable b} [inst : Decidable c] {x_1 : b → α} {u : c → α} {y : ¬b → α} {v : ¬c → α}\n  (h₁ : b = c), (∀ (h : c), x_1 ⋯ = u h) → (∀ (h : ¬c), y ⋯ = v h) → dite b x_1 y = dite c u v",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "HardarNarasimhan.ConvexI.rec",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "Prod.snd",
   "HardarNarasimhan.ConvexI.mk",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.ConvexI.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Lattice ℒ] →\n    {S : Type} →\n      [inst_1 : CompleteLattice S] →\n        {I : { p // p.1 < p.2 }} →\n          {μ : { p // p.1 < p.2 } → S} →\n            {motive : HardarNarasimhan.ConvexI I μ → Sort u} →\n              (t : HardarNarasimhan.ConvexI I μ) →\n                ((convex :\n                      ∀ (x y : ℒ),\n                        HardarNarasimhan.InIntvl I x →\n                          HardarNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩) →\n                    motive ⋯) →\n                  motive t",
  "constCategory": "Definition"},
 {"references": ["OrderDual", "Nontrivial"],
  "name": "OrderDual.instNontrivial",
  "constType": "∀ {α : Type u_1} [h : Nontrivial α], Nontrivial αᵒᵈ",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "HardarNarasimhan.μmax",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmin",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop4d14",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_4_14",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      μ ⟨(⊥, x), ⋯⟩ ≤ μ HardarNarasimhan.TotIntvl ∨ ¬μ HardarNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩) →\n    HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl →\n      HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "List", "Int"],
  "name": "Lean.Omega.Coeffs.ofList",
  "constType": "List ℤ → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references":
  ["le_refl",
   "Preorder",
   "LE.le",
   "id",
   "Eq.mpr",
   "Preorder.toLE",
   "Eq",
   "congrArg"],
  "name": "le_of_eq",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.mk",
   "Monoid.one_mul",
   "MulOneClass",
   "Monoid.toOne",
   "Monoid",
   "Monoid.mul_one",
   "Monoid.toSemigroup",
   "Semigroup.toMul"],
  "name": "Monoid.toMulOneClass",
  "constType": "{M : Type u} → [self : Monoid M] → MulOneClass M",
  "constCategory": "Definition"},
 {"references": ["HardarNarasimhan.TotIntvl._rarg", "_obj", "_neutral"],
  "name": "HardarNarasimhan.TotIntvl._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommSemigroup.add_comm",
   "AddCommSemigroup",
   "AddCommMagma.mk",
   "AddSemigroup.toAdd"],
  "name": "AddCommSemigroup.toAddCommMagma",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddCommMagma G",
  "constCategory": "Definition"},
 {"references": ["AddCommMonoidWithOne", "AddMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_2} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Lean.Omega.Constraint",
   "Bool",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Constraint.not_sat_of_isImpossible",
   "Lean.Omega.Constraint.isImpossible",
   "Eq",
   "Lean.Omega.Coeffs.dot",
   "Bool.true",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.not_sat'_of_isImpossible",
  "constType":
  "∀ {c : Omega.Constraint}, c.isImpossible = true → ∀ {x y : Omega.Coeffs}, ¬c.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "BoundedOrder",
   "subsingleton_of_bot_eq_top",
   "Bot.bot",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "not_subsingleton",
   "PartialOrder",
   "Nontrivial",
   "Top.top",
   "Ne",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop"],
  "name": "bot_ne_top",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : BoundedOrder α] [Nontrivial α], ⊥ ≠ ⊤",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "_obj", "Prod.mk", "_neutral"],
  "name": "HardarNarasimhan.Resμ._rarg._cstage2",
  "constType": "_obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Or",
   "Iff",
   "And",
   "Classical.propDecidable",
   "Decidable.not_and_iff_not_or_not"],
  "name": "not_and_or",
  "constType": "∀ {a b : Prop}, ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "Equiv.instFunLike",
   "Iff",
   "LE.le",
   "LE",
   "OrderDual.instLE",
   "Iff.rfl",
   "DFunLike.coe",
   "Equiv",
   "OrderDual.ofDual"],
  "name": "OrderDual.ofDual_le_ofDual",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {a b : αᵒᵈ}, OrderDual.ofDual a ≤ OrderDual.ofDual b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["le_top",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "HardarNarasimhan.TotIntvl",
   "Preorder.toLT",
   "bot_le",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "And.intro",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.in_TotIntvl",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (x : ℒ),\n  HardarNarasimhan.InIntvl HardarNarasimhan.TotIntvl x",
  "constCategory": "Theorem"},
 {"references": ["CompleteAtomicBooleanAlgebra", "CompleteLattice"],
  "name": "CompleteAtomicBooleanAlgebra.toCompleteLattice",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.sub",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Unit",
   "Nat",
   "instSubNat",
   "Nat.sub_le_sub_right.match_1",
   "instOfNatNat",
   "Nat.succ",
   "LE.le",
   "Nat.below",
   "HSub.hSub",
   "Nat.pred_le_pred",
   "instHSub",
   "instLENat"],
  "name": "Nat.sub_le_sub_right",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∀ (k : ℕ), n - k ≤ m - k",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Eq.mp",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.impl.prop2d6₁I",
   "congrArg",
   "Prod.fst",
   "And.intro",
   "inf_top_eq",
   "BoundedOrder.toOrderTop",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "Min.min",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toBoundedOrder",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (z : ℒ),\n          HardarNarasimhan.InIntvl I z →\n            ∀ (h : x < z),\n              HardarNarasimhan.μA μ ⟨(x, z), h⟩ = ⊤ →\n                ∀ (a : ℒ),\n                  HardarNarasimhan.InIntvl I a →\n                    ∀ (hax : a < x), HardarNarasimhan.μA μ ⟨(a, x), hax⟩ ≤ HardarNarasimhan.μA μ ⟨(a, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Exists.intro",
   "Subtype.val",
   "HardarNarasimhan.NashEquilibrium",
   "SupSet.sSup",
   "letFun",
   "HardarNarasimhan.μmin",
   "Eq.symm",
   "HardarNarasimhan.instBoundedOrderInterval",
   "HardarNarasimhan.WeakSlopeLike₁",
   "HardarNarasimhan.impl.prop4d1₁",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Set.ext",
   "Eq.mpr",
   "setOf",
   "Ne.symm",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Prod.fst",
   "congr",
   "InfSet.sInf",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "HardarNarasimhan.instLatticeInterval",
   "HardarNarasimhan.impl.stupid_helper",
   "HardarNarasimhan.μB",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.μA",
   "eq_self",
   "SupSet",
   "Ne",
   "HardarNarasimhan.NashEquilibrium.nash_eq",
   "CompleteLattice.toCompleteSemilatticeInf",
   "bot_lt_top",
   "CompleteLattice",
   "LE.le.not_lt",
   "InfSet",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Membership.mem",
   "Preorder.toLT",
   "Iff.mp",
   "bot_le",
   "HardarNarasimhan.instNontrivialInterval",
   "HardarNarasimhan.WeakSlopeLike₁.wsl₁",
   "HardarNarasimhan.TotIntvl._proof_1",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "HardarNarasimhan.Semistable",
   "funext",
   "forall_congr",
   "HardarNarasimhan.μAstar",
   "HardarNarasimhan.WeakAscendingChainCondition.wacc",
   "Eq.rec",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "Bot.bot",
   "Exists.casesOn",
   "Iff.of_eq",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Iff.intro",
   "congrArg",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "HardarNarasimhan.Semistable.mk",
   "_private.Init.PropLemmas.0._proof_12",
   "OrderBot.toBot",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.Resμ._proof_19",
   "HardarNarasimhan.in_TotIntvl",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "of_eq_true",
   "LE.le",
   "le_sSup",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "OrderTop.toTop",
   "Subtype.coe_ne_coe"],
  "name": "HardarNarasimhan.impl.prop4d20",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥), HardarNarasimhan.WeakAscendingChainCondition (HardarNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n    (∀ (x : ℒ) (hx : x ≠ ⊥), HardarNarasimhan.WeakSlopeLike₁ (HardarNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n      HardarNarasimhan.NashEquilibrium μ → HardarNarasimhan.Semistable μ",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.rec", "Eq"],
  "name": "Eq.mpr_prop",
  "constType": "∀ {p q : Prop}, p = q → q → p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsTotal",
  "constType": "(α : Sort u_1) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["lt_add_of_pos_right",
   "PartialOrder.toPreorder",
   "AddZeroClass",
   "AddZeroClass.toZero",
   "instHAdd",
   "AddLeftStrictMono",
   "Preorder.toLT",
   "zero_lt_one",
   "OfNat.ofNat",
   "ZeroLEOneClass",
   "HAdd.hAdd",
   "LT.lt",
   "NeZero",
   "One.toOfNat1",
   "AddZeroClass.toAdd",
   "PartialOrder",
   "One",
   "Preorder.toLE"],
  "name": "lt_add_one",
  "constType":
  "∀ {α : Type u_1} [inst : One α] [inst_1 : AddZeroClass α] [inst_2 : PartialOrder α] [ZeroLEOneClass α] [NeZero 1]\n  [AddLeftStrictMono α] (a : α), a < a + 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "lcProof",
  "constType": "∀ {α : Prop}, α",
  "constCategory": "Axiom"},
 {"references": ["_obj", "_neutral", "HardarNarasimhan.μmax._rarg"],
  "name": "HardarNarasimhan.μmax._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["True", "Eq.symm", "trivial", "Eq.rec", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "OfNat.mk", "One.one", "One"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "LE.le",
   "And",
   "Iff.mp",
   "Preorder.toLT",
   "Preorder.toLE",
   "lt_iff_le_not_le",
   "And.left"],
  "name": "le_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toAddCommGroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NegZeroClass.toNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Neg.neg",
   "Eq.refl",
   "Eq.symm",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Eq.ndrec",
   "Eq",
   "SubNegZeroMonoid.toNegZeroClass",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_congr",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a a' b : R}, a = a' → -a' = b → -a = b",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeSup.sup", "SemilatticeSup", "Max", "Max.mk"],
  "name": "SemilatticeSup.toMax",
  "constType": "{α : Type u} → [SemilatticeSup α] → Max α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{α : Sort u} → {p : α → Prop} → (val : α) → p val → Subtype p",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "CompleteLattice",
   "HardarNarasimhan.instLatticeInterval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.Resμ._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        (z : { p // p.1 < p.2 }) → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "HardarNarasimhan.impl.cor3d3",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.corollary_3_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Convex μ →\n    (∀ (f : ℕ → ℒ) (h : ∀ (n : ℕ), f n > f (n + 1)), ∃ N, HardarNarasimhan.μA μ ⟨(f (N + 1), f N), ⋯⟩ = ⊤) →\n      HardarNarasimhan.μA_DescendingChainCondition μ",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "PartialOrder.toPreorder",
   "Real",
   "inferInstance",
   "Real.partialOrder"],
  "name": "Real.instPreorder",
  "constType": "Preorder ℝ",
  "constCategory": "Definition"},
 {"references": ["Bot"],
  "name": "Bot.mk",
  "constType": "{α : Type u_1} → α → Bot α",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Max.max",
   "le_sup_right",
   "PartialOrder.toPreorder",
   "LT.lt.trans_le",
   "SemilatticeSup.toMax",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "SemilatticeSup"],
  "name": "lt_sup_of_lt_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c < b → c < a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "HardarNarasimhan.IsAttained",
   "Or.inl",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "CompleteSemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "WellFoundedGT",
   "LE.isTotal",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μ_Admissible.mk",
   "CompletelyDistribLattice.toCompleteLattice",
   "IsTotal",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "HardarNarasimhan.impl.instμ_Admissible",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S}, HardarNarasimhan.μ_Admissible μ",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "And", "Eq", "propext"],
  "name": "_private.Init.SimpLemmas.0._proof_4",
  "constType": "∀ {a b c : Prop}, (a ∧ b → c) = (a → b → c)",
  "constCategory": "Theorem"},
 {"references":
  ["InfSet",
   "PartialOrder.toPreorder",
   "Bot.mk",
   "Membership.mem",
   "Lattice.mk",
   "InfSet.mk",
   "Set.iUnion",
   "Set.iInter",
   "Subtype.val",
   "PartialOrder",
   "Bot",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_12",
   "Set.instUnion",
   "Set.instInter",
   "ClosureOperator.IsClosed",
   "Inter.inter._@.Mathlib.Data.Set.Operations._hyg.7",
   "And",
   "OmegaCompletePartialOrder",
   "Set.instMembership",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Lattice",
   "Top.mk",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_16",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Union.union._@.Mathlib.Data.Set.Operations._hyg.4",
   "SupSet.mk",
   "Subtype.partialOrder",
   "ClosureOperator",
   "EmptyCollection.emptyCollection._@.Mathlib.Data.Set.Operations._hyg.16",
   "Set.instEmptyCollection",
   "DFunLike.coe",
   "ClosureOperator.instFunLike",
   "SemilatticeSup",
   "Preorder.toLE",
   "True",
   "CompleteLattice.mk",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Top",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_9",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
   "Set.univ",
   "lcProof",
   "CompleteAtomicBooleanAlgebra",
   "ClosureOperator.Closeds",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_5",
   "SupSet",
   "LE.le",
   "SemilatticeSup.mk",
   "Subtype.mk",
   "CompleteLattice"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._cstage1",
  "constType":
  "{α : Type} → [PartialOrder α] → (T : ClosureOperator (Set α)) → CompleteLattice T.Closeds",
  "constCategory": "Definition"},
 {"references": ["Set", "Membership.mem", "setOf", "Set.instMembership"],
  "name": "Membership.mem.out",
  "constType": "∀ {α : Type u} {p : α → Prop} {a : α}, a ∈ {x | p x} → p a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup.sup_le",
   "Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "sup_le",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "OrderDual",
   "sup_assoc",
   "Min.min",
   "OrderDual.instSemilatticeSup",
   "Eq"],
  "name": "inf_assoc",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a b c : α), a ⊓ b ⊓ c = a ⊓ (b ⊓ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1",
   "Mathlib.Meta.NormNum.IsInt",
   "AddGroupWithOne.toIntCast",
   "Int.rawCast",
   "Eq",
   "Int.cast",
   "Ring",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
  "constType":
  "∀ {α : Type u} {a : α} {n : ℤ} [inst : Ring α], Mathlib.Meta.NormNum.IsInt a n → a = n.rawCast",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image",
   "Exists",
   "Set",
   "Membership.mem",
   "And",
   "Set.mem_image",
   "Eq",
   "propext",
   "Set.instMembership"],
  "name": "_private.Mathlib.Data.Set.Operations.0._proof_5",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β), (y ∈ f '' s) = ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.mk",
   "AddCommGroup.add_comm",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "SubNegMonoid.toAddMonoid",
   "NonUnitalNonAssocRing.zero_mul",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.left_distrib"],
  "name": "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.μA_DescendingChainCondition.rec",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "HardarNarasimhan.μA_DescendingChainCondition.mk",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μA_DescendingChainCondition.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.μA_DescendingChainCondition μ → Sort u} →\n                (t : HardarNarasimhan.μA_DescendingChainCondition μ) →\n                  ((μ_dcc :\n                        ∀ (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n                          (∀ (n : ℕ), f n > f (n + 1)) →\n                            ∃ N, HardarNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(a, f N), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod",
   "LT.lt",
   "And.intro",
   "Subtype.prop",
   "le_of_lt",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.impl.prop3d4₀func._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }), (↑I).1 ≤ (↑I).1 ∧ (↑I).1 ≤ (↑I).2",
  "constCategory": "Theorem"},
 {"references":
  ["Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup.le_sup_right",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "le_sup_right",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["True", "Iff", "eq_true", "Iff.rfl", "Eq"],
  "name": "iff_self",
  "constType": "∀ (p : Prop), (p ↔ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "HardarNarasimhan.impl.HNFil",
   "instOfNatNat",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "eq_self",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "BoundedOrder.toOrderBot",
   "of_eq_true",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HardarNarasimhan.instInhabitedHardarNarasimhanFiltration._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ], HardarNarasimhan.impl.HNFil μ 0 = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Function.injective_id",
   "CharZero.mk",
   "CharZero",
   "Nat.instAddMonoidWithOne"],
  "name": "Nat.instCharZero",
  "constType": "CharZero ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "HardarNarasimhan.WeakSlopeLike₁.casesOn",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₁.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u → HardarNarasimhan.WeakSlopeLike₁ μ → HardarNarasimhan.WeakSlopeLike₁ μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["FunLike",
   "DFunLike.mk",
   "Function.instFunLikeEmbedding._proof_1",
   "Function.Embedding",
   "Function.Embedding.toFun"],
  "name": "Function.instFunLikeEmbedding",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ↪ β) α β",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₂.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1), μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n    HardarNarasimhan.WeakSlopeLike₂ μ",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "Real.instZero",
   "Real",
   "LE.le",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Real.instLE"],
  "name": "NNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "HardarNarasimhan.instLatticeInterval._rarg", "_neutral"],
  "name": "HardarNarasimhan.instLatticeInterval._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.find",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.InIntvl",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HardarNarasimhan.impl.prop3d4₀func",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "HardarNarasimhan.impl.prop3d4₀func_fin_len",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.impl.prop3d4₀func_len",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              (μ : { p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → HardarNarasimhan.μA_DescendingChainCondition μ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Bot.mk",
   "Preorder.toLT",
   "LE",
   "Subtype.val",
   "BoundedOrder.mk",
   "Prod.fst",
   "PartialOrder",
   "Bot",
   "Preorder.toLE",
   "OrderBot.mk",
   "OrderBot",
   "HardarNarasimhan.Interval",
   "OrderTop.mk",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.instLatticeInterval",
   "Lattice.toSemilatticeInf",
   "Top",
   "And",
   "OrderTop",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "SemilatticeInf",
   "Preorder",
   "lcProof",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.mk",
   "Subtype.mk"],
  "name": "HardarNarasimhan.instBoundedOrderInterval._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → BoundedOrder (HardarNarasimhan.Interval z)",
  "constCategory": "Definition"},
 {"references": ["LE", "BoundedOrder", "OrderBot"],
  "name": "BoundedOrder.toOrderBot",
  "constType":
  "{α : Type u} → {inst : LE α} → [self : BoundedOrder α] → OrderBot α",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro", "Nonempty", "Inhabited", "Inhabited.default"],
  "name": "instNonemptyOfInhabited",
  "constType": "∀ {α : Sort u} [Inhabited α], Nonempty α",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "Preorder",
   "HasSubset.Subset",
   "Set",
   "LE.le",
   "Set.Iic_subset_Iic",
   "Eq",
   "Preorder.toLE",
   "Set.Iic",
   "propext"],
  "name": "_private.Mathlib.Order.Interval.Set.Basic.0._proof_11",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, (Set.Iic a ⊆ Set.Iic b) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Not", "Decidable.byContradiction", "Classical.propDecidable", "False"],
  "name": "Classical.byContradiction",
  "constType": "∀ {p : Prop}, (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references": ["One", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → One R",
  "constCategory": "Definition"},
 {"references":
  ["Nat.lt_of_lt_of_le",
   "instLTNat",
   "Nat.sub",
   "OfNat.ofNat",
   "Nat.pred_lt_of_lt",
   "LT.lt",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "LE.le",
   "HSub.hSub",
   "instHSub",
   "instLENat"],
  "name": "Nat.sub_one_lt_of_le",
  "constType": "∀ {a b : ℕ}, 0 < a → a ≤ b → a - 1 < b",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_4._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.mk",
  "constType": "{α : Type u_1} → α → Top α",
  "constCategory": "Other"},
 {"references":
  ["Nat", "AddMonoidWithOne.toNatCast", "Nat.cast", "AddMonoidWithOne"],
  "name": "Nat.rawCast",
  "constType": "{α : Type u} → [AddMonoidWithOne α] → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder.lt_iff_le_not_le._autoParam",
   "Preorder",
   "Iff",
   "LE.le",
   "And",
   "LE",
   "autoParam",
   "LT"],
  "name": "Preorder.mk",
  "constType":
  "{α : Type u_2} →\n  [toLE : LE α] →\n    [toLT : LT α] →\n      (∀ (a : α), a ≤ a) →\n        (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) →\n          autoParam (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) Preorder.lt_iff_le_not_le._autoParam → Preorder α",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.zero_add",
   "AddMonoid.toZero",
   "AddMonoid.add_zero",
   "AddZeroClass",
   "AddMonoid.toAddSemigroup",
   "AddMonoid",
   "AddZeroClass.mk",
   "AddSemigroup.toAdd"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["Real.instPreorder",
   "Real.instZero",
   "Real",
   "NNReal",
   "Zero",
   "Nonneg.zero"],
  "name": "instNNRealZero",
  "constType": "Zero NNReal",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Prod",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "Subtype",
   "Subtype.prop",
   "Lattice",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HardarNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._proof_11",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (p : { p // p.1 < p.2 }), (↑p).1 < (↑p).2",
  "constCategory": "Theorem"},
 {"references": ["Or.elim.match_1", "Or"],
  "name": "Or.elim",
  "constType": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg",
   "_obj",
   "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.St",
   "Membership.mem",
   "Preorder.toLT",
   "BoundedOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.snd",
   "HardarNarasimhan.impl.rmk3d5",
   "Set.instMembership",
   "Prod.fst",
   "CompletelyDistribLattice.toCompleteLattice",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.remark_3_5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  ∀ x ∈ HardarNarasimhan.St μ, ∀ y ∈ HardarNarasimhan.St μ, x = y",
  "constCategory": "Theorem"},
 {"references":
  ["CompletelyDistribLattice.mk",
   "CompleteLinearOrder.himp_bot",
   "CompleteLinearOrder.top_sdiff",
   "CompleteLinearOrder.toHNot",
   "CompleteLinearOrder.toHImp",
   "CompleteLinearOrder.toCompletelyDistribLattice._proof_28",
   "CompletelyDistribLattice",
   "CompleteLinearOrder.sdiff_le_iff",
   "CompleteLinearOrder.toCompleteLattice",
   "CompleteLinearOrder.toHasCompl",
   "CompleteLinearOrder",
   "CompleteLinearOrder.le_himp_iff",
   "CompleteLinearOrder.toSDiff"],
  "name": "CompleteLinearOrder.toCompletelyDistribLattice",
  "constType":
  "{α : Type u} → [CompleteLinearOrder α] → CompletelyDistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.TotIntvl",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.stableI",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.stable",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references": ["Lean.Omega.LinearCombo", "Lean.Omega.Coeffs", "Int"],
  "name": "Lean.Omega.LinearCombo.mk",
  "constType": "ℤ → Omega.Coeffs → Omega.LinearCombo",
  "constCategory": "Other"},
 {"references":
  ["NatCast.mk",
   "Nat.instAddMonoidWithOne._proof_2",
   "Nat.instAddMonoid",
   "Nat",
   "Nat.instOne",
   "AddMonoidWithOne",
   "AddMonoidWithOne.mk",
   "Nat.instAddMonoidWithOne._proof_1"],
  "name": "Nat.instAddMonoidWithOne",
  "constType": "AddMonoidWithOne ℕ",
  "constCategory": "Definition"},
 {"references": ["Prod", "Prod.mk", "Prod.rec"],
  "name": "Prod.casesOn",
  "constType":
  "{α : Type u} →\n  {β : Type v} → {motive : α × β → Sort u_1} → (t : α × β) → ((fst : α) → (snd : β) → motive (fst, snd)) → motive t",
  "constCategory": "Definition"},
 {"references": ["le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_rfl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a : α}, a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo", "Lean.Omega.LinearCombo.sub", "Sub.mk", "Sub"],
  "name": "Lean.Omega.LinearCombo.instSub",
  "constType": "Sub Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references": ["Not", "Exists", "not_exists", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_15",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) = ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "le_rfl", "LT.lt", "Preorder", "not_le_of_lt", "Preorder.toLT"],
  "name": "lt_irrefl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), ¬a < a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "Set"],
  "name": "InfSet.sInf",
  "constType": "{α : Type u_1} → [self : InfSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references": ["Int.add", "Add", "Add.mk", "Int"],
  "name": "Int.instAdd",
  "constType": "Add ℤ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Bot.mk",
   "Inter.inter",
   "Membership.mem",
   "Lattice.mk",
   "InfSet.mk",
   "Set.iUnion",
   "Union.union",
   "Set.iInter",
   "Subtype.val",
   "PartialOrder",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_10",
   "Set.instUnion",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_12",
   "Set.instInter",
   "ClosureOperator.IsClosed",
   "Set.instMembership",
   "Set.instCompleteAtomicBooleanAlgebra",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_11",
   "Top.mk",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_15",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_16",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SupSet.mk",
   "Subtype.partialOrder",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_8",
   "ClosureOperator",
   "EmptyCollection.emptyCollection",
   "Set.instEmptyCollection",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_3",
   "DFunLike.coe",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_7",
   "ClosureOperator.instFunLike",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_13",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_2",
   "CompleteLattice.mk",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_6",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_9",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
   "Set.univ",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_4",
   "ClosureOperator.Closeds",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_5",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_17",
   "SemilatticeSup.mk",
   "Subtype.mk",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_14",
   "trivial",
   "CompleteLattice"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan",
  "constType":
  "{α : Type} → [PartialOrder α] → (T : ClosureOperator (Set α)) → CompleteLattice T.Closeds",
  "constCategory": "Definition"},
 {"references": ["AddCommMagma", "Add"],
  "name": "AddCommMagma.toAdd",
  "constType": "{G : Type u} → [self : AddCommMagma G] → Add G",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u_2} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references": ["LE.le", "LE", "Bot", "Bot.bot", "OrderBot"],
  "name": "OrderBot.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toBot : Bot α] → (∀ (a : α), ⊥ ≤ a) → OrderBot α",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "OrderDual",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "SemilatticeInf",
   "LT.lt",
   "left_lt_sup",
   "OrderDual.instSemilatticeSup",
   "Min.min",
   "Iff",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_lt_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b < a ↔ ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "le_inf",
   "Min.min",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_12",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b c : HardarNarasimhan.Interval z), ↑a ≤ ↑b → ↑a ≤ ↑c → ↑a ≤ ↑b ⊓ ↑c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "inferInstance",
   "AddMonoid",
   "AddCommMonoid.toAddMonoid",
   "Nat.instAddCommMonoid"],
  "name": "Nat.instAddMonoid",
  "constType": "AddMonoid ℕ",
  "constCategory": "Definition"},
 {"references": ["Function.Embedding", "Function.Injective"],
  "name": "Function.Embedding.mk",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (toFun : α → β) → Function.Injective toFun → α ↪ β",
  "constCategory": "Other"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Set.empty_subset.match_1",
   "Membership.mem",
   "Set.instEmptyCollection",
   "EmptyCollection.emptyCollection",
   "Set.instMembership"],
  "name": "Set.empty_subset",
  "constType": "∀ {α : Type u} (s : Set α), ∅ ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "instHAdd", "Eq.refl", "Int.instAdd", "Eq.ndrec", "Eq", "Int"],
  "name": "Lean.Omega.Int.add_congr",
  "constType": "∀ {a b c d : ℤ}, a = b → c = d → a + c = b + d",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition.noConfusionType",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.WeakDescendingChainCondition.casesOn",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakDescendingChainCondition.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HardarNarasimhan.WeakDescendingChainCondition μ} →\n                  v1 = v2 → HardarNarasimhan.WeakDescendingChainCondition.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Preorder.toLT",
   "sup_le",
   "HardarNarasimhan.impl.prop2d8₀I",
   "Subtype.val",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.prop2d8₁I",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.IsAttained._proof_4",
   "Exists.casesOn",
   "Prod",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "ConditionallyCompleteLattice.toLattice",
   "inf_comm",
   "SemilatticeInf.toMin",
   "Or.inr",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "HardarNarasimhan.IsAttained",
   "Or.inl",
   "HardarNarasimhan.μmax",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.μA",
   "inf_eq_left",
   "LT.lt",
   "Or.casesOn",
   "Max.max",
   "HardarNarasimhan.IsComparable",
   "Min.min",
   "SemilatticeSup.toMax",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "lt_sup_of_lt_left"],
  "name": "HardarNarasimhan.impl.prop2d8₂I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HardarNarasimhan.InIntvl I y →\n            ∀ (u : ℒ),\n              HardarNarasimhan.InIntvl I u →\n                ∀ (h : u < x ∧ u < y),\n                  HardarNarasimhan.IsComparable (HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩)\n                        (HardarNarasimhan.μA μ ⟨(u, y), ⋯⟩) ∨\n                      HardarNarasimhan.IsAttained μ ⟨(u, x ⊔ y), ⋯⟩ →\n                    HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩ ∨\n                      HardarNarasimhan.μA μ ⟨(u, y), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddCommGroup.toAddGroup",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.toAddSemigroup",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddSemigroup.toAdd"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.elim_AddLeftMono",
  "constType":
  "∀ {V : Type} [self : HardarNarasimhan.TotallyOrderedRealVectorSpace V] {y z : V} (x : V), y ≤ z → x + y ≤ x + z",
  "constCategory": "Theorem"},
 {"references":
  ["RelEmbedding.toEmbedding",
   "Iff",
   "Function.Embedding",
   "Function.instFunLikeEmbedding",
   "RelEmbedding",
   "DFunLike.coe"],
  "name": "RelEmbedding.map_rel_iff'",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} {r : α → α → Prop} {s : β → β → Prop} (self : r ↪r s) {a b : α},\n  s (self.toEmbedding a) (self.toEmbedding b) ↔ r a b",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid",
   "SubtractionMonoid.mk",
   "AddCommGroup.add_comm",
   "SubtractionMonoid.neg_eq_of_add",
   "AddCommGroup.toAddGroup",
   "SubtractionCommMonoid",
   "SubtractionCommMonoid.mk",
   "AddCommGroup",
   "SubtractionMonoid.neg_neg",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.neg_add_rev",
   "AddGroup.toSubtractionMonoid"],
  "name": "AddCommGroup.toDivisionAddCommMonoid",
  "constType": "{G : Type u_1} → [AddCommGroup G] → SubtractionCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Preorder.toLE",
   "Eq",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.instLatticeInterval",
   "HardarNarasimhan.Resμ",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.Resμ._proof_19",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.Resμ.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (z : { p // p.1 < p.2 }) {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (p : { p // p.1 < p.2 }),\n  HardarNarasimhan.Resμ z μ p = μ ⟨(↑(↑p).1, ↑(↑p).2), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.DedekindMacNeilleCompletion",
   "HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "PartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan",
   "ClosureOperator",
   "CompleteLattice"],
  "name":
  "HardarNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion._cstage1",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → CompleteLattice (HardarNarasimhan.DedekindMacNeilleCompletion α)",
  "constCategory": "Definition"},
 {"references": ["Nat.decEq", "Nat", "DecidableEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ℕ",
  "constCategory": "Definition"},
 {"references": ["Nat", "Lean.Name"],
  "name": "Lean.Name.num",
  "constType": "Name → ℕ → Name",
  "constCategory": "Other"},
 {"references": ["Subtype.rec", "Subtype", "Subtype.mk"],
  "name": "Subtype.casesOn",
  "constType":
  "{α : Sort u} →\n  {p : α → Prop} →\n    {motive : Subtype p → Sort u_1} →\n      (t : Subtype p) → ((val : α) → (property : p val) → motive ⟨val, property⟩) → motive t",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable", "Decidable.casesOn"],
  "name": "dite",
  "constType":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "constCategory": "Definition"},
 {"references": ["LE.le", "LE", "GE.ge"],
  "name": "LE.le.ge",
  "constType": "∀ {α : Type u_2} [inst : LE α] {x y : α}, x ≤ y → y ≥ x",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Preorder", "le_of_lt", "Preorder.toLT", "lt_of_lt_of_le"],
  "name": "lt_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring.toDistrib",
   "True",
   "Eq.trans",
   "Distrib.toMul",
   "CommSemiring",
   "MulZeroClass.toMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "HMul.hMul",
   "MulZeroClass.zero_mul",
   "OfNat.ofNat",
   "congrArg",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Zero.toOfNat0",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.zero_mul",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 * b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.μB",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Nontrivial",
   "Top.top",
   "OrderBot.toBot",
   "Subtype.mk",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μBstar",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → S",
  "constCategory": "Definition"},
 {"references":
  ["OrderBot.bot_le", "LE.le", "LE", "OrderBot.toBot", "Bot.bot", "OrderBot"],
  "name": "bot_le",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderBot α] {a : α}, ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg",
   "_obj",
   "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Set.instSupSet", "iSup", "Set"],
  "name": "Set.iUnion",
  "constType": "{α : Type u} → {ι : Sort v} → (ι → Set α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "BoundedOrder",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_17",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ], ⊥ < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Nat.cast",
   "instHAdd",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.cast_add",
   "HAdd.hAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.add",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.isNat_add.match_1",
   "Eq.symm",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "AddSemigroup.toAdd"],
  "name": "Mathlib.Meta.NormNum.isNat_add",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {f : α → α → α} {a b : α} {a' b' c : ℕ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsNat a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → a'.add b' = c → Mathlib.Meta.NormNum.IsNat (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SupSet.sSup",
   "Set",
   "CompleteSemilatticeSup.sSup_le",
   "LE.le",
   "Membership.mem",
   "CompleteSemilatticeSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "sSup_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references": ["HSub", "outParam"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "True",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_isNat.match_1",
   "Int.cast",
   "congrArg",
   "Int",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Ring.toAddGroupWithOne",
   "of_eq_true",
   "Mathlib.Meta.NormNum.IsInt",
   "AddGroupWithOne.toIntCast",
   "Int.cast_natCast",
   "Int.ofNat",
   "Eq",
   "Mathlib.Meta.NormNum.IsNat",
   "instNatCastInt",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsInt a (Int.ofNat n) → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references": ["HPow.mk", "HPow", "Pow", "Pow.pow"],
  "name": "instHPow",
  "constType": "{α : Type u_1} → {β : Type u_2} → [Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "sup_le",
   "HardarNarasimhan.impl.prop2d8₀I",
   "Subtype.val",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "inf_le_left",
   "ConditionallyCompleteLattice.toLattice",
   "setOf",
   "inf_le_right",
   "Or.inr",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "lt_of_le_of_ne",
   "Prod.fst",
   "Or.inl",
   "HardarNarasimhan.μmax",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Lattice.toSemilatticeInf",
   "le_sInf_iff",
   "Set",
   "HardarNarasimhan.μA",
   "Or.casesOn",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "Max.max",
   "Min.min",
   "LE.le",
   "SemilatticeSup.toMax",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "lt_sup_of_lt_left"],
  "name": "HardarNarasimhan.impl.prop2d8₁I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HardarNarasimhan.InIntvl I y →\n            ∀ (u : ℒ),\n              HardarNarasimhan.InIntvl I u →\n                ∀ (h : u < x ∧ u < y),\n                  HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ⊓ HardarNarasimhan.μA μ ⟨(u, y), ⋯⟩ ≤\n                    HardarNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toInfSet",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.impl.prop2d6₁I",
   "GE.ge",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq",
   "Eq.rec",
   "Preorder.toLE",
   "le_antisymm",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "inf_eq_right",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop2d6₀",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "Min.min",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop2d6₂I₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HardarNarasimhan.InIntvl I y →\n            ∀ (z : ℒ),\n              HardarNarasimhan.InIntvl I z →\n                ∀ (h : x < y ∧ y < z),\n                  HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≥ HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ →\n                    HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ = HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["exists_prop", "Exists", "And", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_38",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Set",
   "HardarNarasimhan.StI",
   "HardarNarasimhan.TotIntvl",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.St",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Set ℒ",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "HardarNarasimhan.SlopeLike.mk",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.SlopeLike.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.SlopeLike μ → Sort u} →\n                ((slopelike :\n                      ∀ (x y z : ℒ) (h : x < y ∧ y < z),\n                        (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n                          (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n                            (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n                              (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) →\n                    motive ⋯) →\n                  (t : HardarNarasimhan.SlopeLike μ) → motive t",
  "constCategory": "Other"},
 {"references": ["semiOutParam", "CoeOut"],
  "name": "CoeOut.mk",
  "constType":
  "{α : Sort u} → {β : semiOutParam (Sort v)} → (α → β) → CoeOut α β",
  "constCategory": "Other"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["semiOutParam", "Coe"],
  "name": "Coe.mk",
  "constType": "{α : semiOutParam (Sort u)} → {β : Sort v} → (α → β) → Coe α β",
  "constCategory": "Other"},
 {"references":
  ["InfSet",
   "Exists",
   "PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.μA._proof_3",
   "Prod.mk",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "PartialOrder",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μmin._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "WellFounded.has_min",
   "Prod.mk",
   "Membership.mem",
   "Eq.mpr_not",
   "Preorder.toLT",
   "Classical.propDecidable",
   "eq_true",
   "Membership.mem.out",
   "GT.gt",
   "HardarNarasimhan.impl.prop3d4₀func._proof_7",
   "Subtype.val",
   "False.elim",
   "HardarNarasimhan.impl.prop3d4₀func._proof_4",
   "HardarNarasimhan.impl.prop3d4₀func._proof_8",
   "letFun",
   "PartialOrder",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.impl.prop3d4₀func_helper",
   "of_eq_false",
   "Exists",
   "Exists.choose_spec",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat",
   "Eq.refl",
   "eq_false",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "HardarNarasimhan.impl.ℒₛ._proof_2",
   "Subtype",
   "instDecidableTrue",
   "Eq.mp",
   "lt_of_le_of_ne",
   "dite_congr",
   "congrArg",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "IsWellFounded.wf",
   "HardarNarasimhan.impl.ℒₛ",
   "not_true_eq_false",
   "WellFoundedGT",
   "instDecidableFalse",
   "dite_cond_eq_false",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "instHAdd",
   "HardarNarasimhan.impl.prop3d4₀func",
   "HardarNarasimhan.impl.ℒₛ._proof_1",
   "Exists.choose",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func_defprop1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ)\n  (hi : (↑I).1 ≠ ↑(HardarNarasimhan.impl.prop3d4₀func μ I (i + 1))),\n  HardarNarasimhan.μA μ ⟨((↑I).1, ↑(HardarNarasimhan.impl.prop3d4₀func μ I (i + 1))), ⋯⟩ >\n    HardarNarasimhan.μA μ ⟨((↑I).1, ↑(HardarNarasimhan.impl.prop3d4₀func μ I i)), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocCommSemiring", "NonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.μA_DescendingChainCondition",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references": ["Bool", "DecidableEq", "Bool.decEq"],
  "name": "instDecidableEqBool",
  "constType": "DecidableEq Bool",
  "constCategory": "Definition"},
 {"references": ["Or", "Iff", "Or.comm"],
  "name": "or_comm",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ b ∨ a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "Or.resolve_right",
   "LinearOrder",
   "le_total",
   "Preorder.toLE",
   "LE.le.lt_of_not_le"],
  "name": "lt_of_not_le",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrder α] {a b : α}, ¬b ≤ a → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_left"],
  "name": "inf_le_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "WellFounded.has_min",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "bot_le",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "Monotone",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "CompleteLattice.toTop",
   "Eq.rec",
   "Set.mem_range_self",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "eq_of_ge_of_not_gt",
   "Exists",
   "Exists.choose_spec",
   "Real",
   "And.right",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "Set.instMembership",
   "Prod",
   "IsWellOrder",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "CompleteLattice.toBoundedOrder",
   "setOf",
   "Subtype.lt",
   "Subtype",
   "IsWellOrder.toIsWellFounded",
   "Set.range",
   "Prod.fst",
   "Nat.instPreorder",
   "Set.mem_setOf",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "IsWellFounded.wf",
   "Real.instLT",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Real.partialOrder",
   "Not",
   "Set.Nonempty",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Set",
   "instHAdd",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "le_of_lt",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.rmk4d4",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (r : ℒ → ℝ),\n  Monotone r →\n    (IsWellOrder ↑(Set.range r) fun x1 x2 => x1 < x2) →\n      (∀ (z : { p // p.1 < p.2 }), r (↑z).1 = r (↑z).2 → μ z = ⊤) →\n        ∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_le_succ",
   "instAddNat",
   "HAdd.hAdd",
   "Nat",
   "Nat.AtLeastTwo",
   "instOfNatNat",
   "instHAdd",
   "Nat.AtLeastTwo.mk",
   "Nat.zero_le",
   "OfNat.ofNat"],
  "name": "instNatAtLeastTwo",
  "constType": "∀ {n : ℕ}, (n + 2).AtLeastTwo",
  "constCategory": "Theorem"},
 {"references":
  ["List.nil",
   "instAddNat",
   "instHAdd",
   "List.brecOn",
   "List",
   "List.length.match_1",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "List.below",
   "Nat",
   "instOfNatNat",
   "List.cons"],
  "name": "List.length",
  "constType": "{α : Type u_1} → List α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "LE.le",
   "And.right",
   "And",
   "Iff.mp",
   "Preorder.toLT",
   "Preorder.toLE",
   "lt_iff_le_not_le"],
  "name": "not_le_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.toNeg",
   "SubNegZeroMonoid.toSubNegMonoid",
   "NegZeroClass",
   "NegZeroClass.mk",
   "SubNegZeroMonoid",
   "SubNegZeroMonoid.neg_zero"],
  "name": "SubNegZeroMonoid.toNegZeroClass",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → NegZeroClass G",
  "constCategory": "Definition"},
 {"references":
  ["ClosureOperator.instFunLike",
   "Monotone",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "ClosureOperator.toOrderHom",
   "OrderHom.monotone'",
   "ClosureOperator",
   "DFunLike.coe"],
  "name": "ClosureOperator.monotone",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] (c : ClosureOperator α), Monotone ⇑c",
  "constCategory": "Theorem"},
 {"references":
  ["Module",
   "AddCommMonoid.toAddMonoid",
   "MulAction.toSMul",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "instHSMul",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Zero.toOfNat0",
   "Eq",
   "DistribMulAction",
   "Distrib.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddZeroClass.toZero",
   "instHAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "HSMul.hSMul",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "Module.mk",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] →\n      [inst_1 : AddCommMonoid M] →\n        [toDistribMulAction : DistribMulAction R M] →\n          (∀ (r s : R) (x : M), (r + s) • x = r • x + s • x) → (∀ (x : M), 0 • x = 0) → _root_.Module R M",
  "constCategory": "Other"},
 {"references":
  ["Nat", "MulOneClass.toOne", "Nat.instMulOneClass", "One", "inferInstance"],
  "name": "Nat.instOne",
  "constType": "One ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Real", "_private.Mathlib.Data.Real.Basic.0.Real.lt", "LT.mk", "LT"],
  "name": "Real.instLT",
  "constType": "LT ℝ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.Convex",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.filtration",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              (μ : { p // p.1 < p.2 } → S) →\n                {hμ : HardarNarasimhan.μA_DescendingChainCondition μ} →\n                  {hμcvx : HardarNarasimhan.Convex μ} →\n                    {h : HardarNarasimhan.μ_Admissible μ} →\n                      [self : HardarNarasimhan.HardarNarasimhanFiltration μ] → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Lattice.toSemilatticeSup",
   "HardarNarasimhan.impl.lem2d4₂I",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Exists.intro",
   "sup_le",
   "Subtype.val",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "HardarNarasimhan.impl.prop2d6₂I₁",
   "And.right",
   "HardarNarasimhan.impl.prop2d6₂I₂",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop2d6₀",
   "HardarNarasimhan.IsAttained._proof_4",
   "Prod",
   "Exists.casesOn",
   "Classical.or_iff_not_imp_left",
   "Eq.refl",
   "Iff.mpr",
   "HardarNarasimhan.impl.lem2d4₁",
   "Nontrivial",
   "Lattice",
   "setOf",
   "SemilatticeInf.toMin",
   "Or.inr",
   "Subtype",
   "Ne.symm",
   "le_trans",
   "Or.resolve_right",
   "HardarNarasimhan.impl.comparable_iff",
   "lt_of_le_of_ne",
   "Prod.fst",
   "HardarNarasimhan.IsAttained",
   "eq_of_le_of_le",
   "le_inf",
   "Or.inl",
   "HardarNarasimhan.μmax",
   "Preorder.toLE",
   "Eq",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.μA",
   "sInf_le",
   "LT.lt",
   "Or.casesOn",
   "le_of_lt",
   "Min.min",
   "HardarNarasimhan.IsComparable",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop2d6₃I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HardarNarasimhan.InIntvl I y →\n            ∀ (z : ℒ),\n              HardarNarasimhan.InIntvl I z →\n                ∀ (h : x < y ∧ y < z),\n                  HardarNarasimhan.IsComparable (HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩)\n                        (HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩) ∨\n                      HardarNarasimhan.IsAttained μ ⟨(x, z), ⋯⟩ →\n                    HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ = HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∨\n                      HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∧\n                        HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ < HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "MonoidWithZero"],
  "name": "MonoidWithZero.toMonoid",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Monoid M₀",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "IsTotal",
   "PartialOrder.toPreorder",
   "LE.le",
   "LinearOrder",
   "IsTotal.mk",
   "le_total",
   "Preorder.toLE"],
  "name": "LE.isTotal",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α], IsTotal α fun x1 x2 => x1 ≤ x2",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddGroup",
   "Ring.toAddGroupWithOne",
   "Eq.refl",
   "SubNegMonoid.toSub",
   "Eq.symm",
   "HSub.hSub",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "instHSub",
   "Eq",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.sub_congr",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a a' b b' c : R}, a = a' → b = b' → a' - b' = c → a - b = c",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "Decidable.isFalse", "False", "not_false"],
  "name": "instDecidableFalse",
  "constType": "Decidable False",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration.casesOn",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Nat.find",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "HardarNarasimhan.instLatticeInterval",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.μ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HardarNarasimhan.instNontrivialInterval",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HardarNarasimhan.Semistable",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                {hμ : HardarNarasimhan.μA_DescendingChainCondition μ} →\n                  {hμcvx : HardarNarasimhan.Convex μ} →\n                    {h : HardarNarasimhan.μ_Admissible μ} →\n                      Sort u →\n                        HardarNarasimhan.HardarNarasimhanFiltration μ →\n                          HardarNarasimhan.HardarNarasimhanFiltration μ → Sort u",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "AddSemigroup", "instHAdd", "Add", "Eq"],
  "name": "AddSemigroup.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b c : G), a + b + c = a + (b + c)) → AddSemigroup G",
  "constCategory": "Other"},
 {"references": ["Set.Subset", "Set", "LE.mk", "LE"],
  "name": "Set.instLE",
  "constType": "{α : Type u} → LE (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "GetElem",
   "List.get",
   "Fin.mk",
   "List",
   "List.length",
   "GetElem.mk"],
  "name": "List.instGetElemNatLtLength",
  "constType":
  "{α : Type u_1} → GetElem (List α) ℕ α fun as i => i < as.length",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLinearOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "HardarNarasimhan.impl.rmk2d7",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.remark_2_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Convex μ →\n    ∀ (x : ℒ) (h : ⊥ < x ∧ x < ⊤),\n      HardarNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HardarNarasimhan.μA μ HardarNarasimhan.TotIntvl →\n        HardarNarasimhan.μA μ ⟨(x, ⊤), ⋯⟩ = HardarNarasimhan.μA μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "SMul", "Zero"],
  "name": "PosSMulStrictMono",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → [SMul α β] → [Preorder α] → [Preorder β] → [Zero α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeInf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "Lattice",
   "SemilatticeSup.toPartialOrder",
   "Lattice.inf",
   "SemilatticeInf.mk",
   "Lattice.le_inf"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeInf α",
  "constCategory": "Definition"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "∀ {α : Sort u} (a : α), HEq a a",
  "constCategory": "Other"},
 {"references":
  ["LE.le.eq_or_lt",
   "LT.lt",
   "Not",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Or.resolve_right",
   "Preorder.toLT",
   "Eq",
   "Preorder.toLE"],
  "name": "eq_of_le_of_not_lt",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≤ b → ¬a < b → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Bool",
   "Decidable.isFalse",
   "Decidable",
   "Nat.le_of_ble_eq_true",
   "Nat.not_le_of_not_ble_eq_true",
   "instDecidableEqBool",
   "Nat",
   "LE.le",
   "dite",
   "Eq",
   "instLENat",
   "Bool.true",
   "Nat.ble",
   "Decidable.isTrue"],
  "name": "Nat.decLe",
  "constType": "(n m : ℕ) → Decidable (n ≤ m)",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.refl"],
  "name": "Iff.rfl",
  "constType": "∀ {a : Prop}, a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "ClosureOperator",
   "Set.iUnion",
   "DFunLike.coe",
   "Subtype.val",
   "Set.instMembership",
   "ClosureOperator.instFunLike",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "ClosureOperator.isClosed_closure"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_9",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds), T.IsClosed (T (⋃ a ∈ 𝒮, ↑a))",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.WeakSlopeLike₂",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.μA_DescendingChainCondition.μ_dcc",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.impl.prop3d4₀func_helper",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop3d4₀func_defprop1",
   "Exists.casesOn",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Ne.lt_of_le",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "gt_iff_lt",
   "Subtype",
   "Ne.symm",
   "Eq.mp",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "Subtype.prop",
   "instOfNatNat",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "instHAdd",
   "HardarNarasimhan.impl.prop3d4₀func",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "not_le_of_gt",
   "LT.lt",
   "HAdd.hAdd",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "HardarNarasimhan.impl.prop3d4₀func_strict_decreasing"],
  "name": "HardarNarasimhan.impl.prop3d4₀func_fin_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.μA_DescendingChainCondition μ → ∃ i, ↑(HardarNarasimhan.impl.prop3d4₀func μ I i) = (↑I).1",
  "constCategory": "Theorem"},
 {"references": ["Subtype", "Subtype.forall", "Subtype.mk", "Eq", "propext"],
  "name": "_private.Init.Data.Subtype.0._proof_1",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∀ (x : { a // p a }), q x) = ∀ (a : α) (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "exists_prop_congr.match_1",
   "Iff.mpr",
   "Iff",
   "Iff.mp",
   "Exists.intro",
   "exists_prop_congr.match_2",
   "Iff.intro"],
  "name": "exists_prop_congr",
  "constType":
  "∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q ↔ ∃ (h : p'), q' ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.impl.HNFil._proof_3",
   "Prod.mk",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "IsGreatest",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.impl.HNFil",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.StI",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "HardarNarasimhan.impl.HNFil._proof_4",
   "Nat.succ",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil.eq_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ] (n : ℕ),\n  HardarNarasimhan.impl.HNFil μ n.succ =\n    if htop : HardarNarasimhan.impl.HNFil μ n = ⊤ then ⊤\n    else\n      let I' := ⟨(HardarNarasimhan.impl.HNFil μ n, ⊤), ⋯⟩;\n      ⋯.choose",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "instLTNat",
   "Nat",
   "LE.le",
   "Nat.ge_of_not_lt",
   "instLENat"],
  "name": "Nat.le_of_not_lt",
  "constType": "∀ {a b : ℕ}, ¬a < b → b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Neg", "NegZeroClass"],
  "name": "NegZeroClass.toNeg",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Neg G",
  "constCategory": "Definition"},
 {"references": ["Not", "And", "id"],
  "name":
  "HardarNarasimhan.TotallyOrderedRealVectorSpace.lt._inherited_default",
  "constType": "{V : Type} → (V → V → Prop) → V → V → Prop",
  "constCategory": "Definition"},
 {"references": ["Min"],
  "name": "Min.min",
  "constType": "{α : Type u} → [self : Min α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Int.instCommSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Int",
   "Semiring"],
  "name": "Int.instSemiring",
  "constType": "Semiring ℤ",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LE α",
  "constCategory": "Other"},
 {"references":
  ["HardarNarasimhan.NashEquilibrium.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.NashEquilibrium",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.μAstar",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.NashEquilibrium.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  HardarNarasimhan.μAstar μ = HardarNarasimhan.μBstar μ → HardarNarasimhan.NashEquilibrium μ",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeSup.le_sSup",
   "PartialOrder.toPreorder",
   "SupSet.sSup",
   "Set",
   "LE.le",
   "Membership.mem",
   "CompleteSemilatticeSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "le_sSup",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, a ∈ s → a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "add_left_comm",
   "True",
   "Eq.trans",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "of_eq_true",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Eq",
   "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_gt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₂ c : R} (b₁ : R), a + b₂ = c → a + (b₁ + b₂) = b₁ + c",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.mk",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_2",
   "_obj",
   "Set.instCompleteAtomicBooleanAlgebra",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_4",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_1",
   "Lattice.mk",
   "Subtype.partialOrder",
   "SemilatticeSup.mk",
   "_neutral",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_3",
   "CompleteLattice.instOmegaCompletePartialOrder._rarg"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "le_sInf_iff",
   "Set",
   "Membership.mem",
   "CompleteSemilatticeInf",
   "Set.instMembership",
   "CompleteSemilatticeInf.toInfSet",
   "LE.le",
   "CompleteSemilatticeInf.toPartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.CompleteLattice.Defs.0._proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, (a ≤ sInf s) = ∀ b ∈ s, a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.intCast_ofNat",
   "Ring.toSub",
   "AddGroup.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.zsmul_succ'",
   "Ring.toNonUnitalRing._proof_13",
   "AddCommMonoid.toAddMonoid",
   "Ring.intCast_negSucc",
   "Ring.zsmul_zero'",
   "Ring.sub_eq_add_neg",
   "Semiring.toNatCast",
   "AddCommGroup.mk",
   "Ring.toNonAssocRing._proof_18",
   "SubNegMonoid.mk",
   "Semiring.toNonUnitalSemiring",
   "Ring.toNeg",
   "Semiring.toOne",
   "Ring.toNonAssocRing._proof_17",
   "Ring.zsmul",
   "Ring.toNonUnitalRing._proof_14",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocRing",
   "Ring.zsmul_neg'",
   "Ring.neg_add_cancel",
   "NonUnitalNonAssocRing.mk",
   "Ring.toSemiring",
   "Ring.toNonUnitalRing._proof_10",
   "Ring.toNonUnitalRing._proof_12",
   "Ring.toIntCast",
   "Ring.toNonUnitalRing._proof_11",
   "Ring.toNonAssocRing._proof_16",
   "Ring.toNonAssocRing._proof_19",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocRing.mk",
   "Ring"],
  "name": "Ring.toNonAssocRing",
  "constType": "{α : Type u} → [Ring α] → NonAssocRing α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop → Type",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.fst",
   "LT.lt",
   "Nat",
   "BoundedOrder.toOrderTop",
   "Nat.succ",
   "Iff.mpr",
   "Lattice",
   "Nat.below",
   "Top.top",
   "Ne",
   "lt_top_iff_ne_top",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.impl.HNFil._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (n : ℕ) (x : Nat.below n.succ), ¬x.1 = ⊤ → (x.1, ⊤).1 < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "GT.gt",
   "HardarNarasimhan.TotIntvl._proof_1",
   "Subtype.val",
   "not_false_eq_true",
   "forall_congr",
   "funext",
   "HardarNarasimhan.Semistable",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.S₁I._proof_1",
   "Eq.ndrec",
   "HardarNarasimhan.S₁I",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Exists.choose_spec",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "True.intro",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "implies_true",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Iff",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "setOf",
   "Ne.symm",
   "HardarNarasimhan.Semistable.semistable",
   "Subtype",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_36",
   "and_true",
   "Iff.intro",
   "Prod.fst",
   "congrArg",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.Semistable.mk",
   "HardarNarasimhan.S₂I",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "True",
   "HardarNarasimhan.in_TotIntvl",
   "Set",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_3",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.μA",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "HardarNarasimhan.semistableI",
   "False",
   "_private.Init.PropLemmas.0._proof_14",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "_private.Init.Core.0._proof_39",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.semistable_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Semistable μ ↔ HardarNarasimhan.semistableI μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "SubNegMonoid.zsmul_zero'._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.St",
   "HardarNarasimhan.Convex",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop3d4",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.proposition_3_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.μA_DescendingChainCondition μ → HardarNarasimhan.Convex μ → (HardarNarasimhan.St μ).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["sSup_le_iff",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteSemilatticeSup",
   "Membership.mem",
   "CompleteSemilatticeSup.toSupSet",
   "Set.instMembership",
   "SupSet.sSup",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.CompleteLattice.Defs.0._proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, (sSup s ≤ a) = ∀ b ∈ s, b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HardarNarasimhan.impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → Coe ({ p // p.1 < p.2 } → S) ({ p // p.1 < p.2 } → Sᵒᵈ)",
  "constCategory": "Definition"},
 {"references": ["_obj", "_neutral"],
  "name": "HardarNarasimhan.instCoeDedekindMacNeilleCompletion._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["_obj", "_neutral"],
  "name": "HardarNarasimhan.μB._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Iff",
   "PartialOrder",
   "LE.le",
   "top_le_iff",
   "Top.top",
   "OrderTop",
   "Eq",
   "Preorder.toLE",
   "OrderTop.toTop",
   "Iff.symm"],
  "name": "eq_top_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, a = ⊤ ↔ ⊤ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_2._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.mk_le_mk",
   "Subtype",
   "LE.le",
   "LE",
   "Subtype.mk",
   "Eq",
   "Subtype.le",
   "propext"],
  "name": "_private.Mathlib.Order.Basic.0._proof_34",
  "constType":
  "∀ {α : Type u_2} [inst : LE α] {p : α → Prop} {x y : α} {hx : p x} {hy : p y}, (⟨x, hx⟩ ≤ ⟨y, hy⟩) = (x ≤ y)",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.impl.ℒₛ._proof_2",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "GT.gt",
   "HardarNarasimhan.impl.prop3d4₀func._proof_7",
   "Subtype.val",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.ℒₛ",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Exists.choose_spec",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Prod.snd",
   "HardarNarasimhan.impl.ℒₛ._proof_1",
   "Exists.choose",
   "HardarNarasimhan.μA",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func._proof_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ)\n  (hbot : ¬(↑I).1 = ↑(HardarNarasimhan.impl.prop3d4₀func μ I n))\n  (hne : (HardarNarasimhan.impl.ℒₛ μ I (HardarNarasimhan.impl.prop3d4₀func μ I n) hbot).Nonempty),\n  HardarNarasimhan.InIntvl I ⋯.choose",
  "constCategory": "Theorem"},
 {"references": ["forall_apply_eq_imp_iff₂", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_43",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {p : α → Prop} {q : β → Prop},\n  (∀ (b : β) (a : α), p a → f a = b → q b) = ∀ (a : α), p a → q (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint",
   "Bool",
   "Eq.trans",
   "Prod.mk",
   "Lean.Omega.normalize_sat",
   "Lean.Omega.normalizeCoeffs",
   "Lean.Omega.Coeffs",
   "Option.some",
   "Lean.Omega.tidyCoeffs",
   "congrArg",
   "Prod.fst",
   "Lean.Omega.positivize?_eq_some",
   "Lean.Omega.positivizeConstraint",
   "Lean.Omega.positivizeCoeffs",
   "Eq.symm",
   "Eq",
   "Eq.ndrec",
   "Bool.true",
   "Lean.Omega.normalizeConstraint",
   "Lean.Omega.normalize",
   "Lean.Omega.positivize?",
   "Lean.Omega.normalize?",
   "Lean.Omega.positivize_sat",
   "Lean.Omega.tidy?.match_1",
   "True",
   "_private.Init.Omega.Constraint.0.Lean.Omega.tidy?.match_1.splitter",
   "And",
   "Option.getD",
   "Lean.Omega.tidyConstraint",
   "Prod.snd",
   "Unit",
   "Prod",
   "eq_self",
   "Option.none",
   "of_eq_true",
   "Lean.Omega.normalize?_eq_some",
   "Eq.refl",
   "Option",
   "id",
   "And.casesOn",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.tidy_sat",
  "constType":
  "∀ {s : Omega.Constraint} {x v : Omega.Coeffs},\n  s.sat' x v = true → (Omega.tidyConstraint s x).sat' (Omega.tidyCoeffs s x) v = true",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "le_refl",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Eq.mpr_not",
   "Preorder.toLT",
   "Classical.propDecidable",
   "HardarNarasimhan.μ_Admissible",
   "IsGreatest",
   "Monotone",
   "letFun",
   "HardarNarasimhan.impl.HNlen",
   "Eq.symm",
   "Eq.rec",
   "Eq.ndrec",
   "Nat.instLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Nat.instPartialOrder",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Nat.find_spec",
   "lt_of_not_le",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "Subtype",
   "HardarNarasimhan.impl.HNFil._proof_3",
   "instDecidableTrue",
   "HardarNarasimhan.Convex",
   "lt_of_le_of_ne",
   "HardarNarasimhan.impl.HNFil_of_fin_len",
   "dite_congr",
   "congrArg",
   "Prod.fst",
   "Nat.instPreorder",
   "HardarNarasimhan.impl.HNFil",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Not",
   "Nat.le_induction",
   "le_top",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "HardarNarasimhan.StI",
   "Nat.decLe",
   "Exists.choose",
   "HardarNarasimhan.impl.HNFil_is_strict_mono'",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "dite_cond_eq_true",
   "of_eq_true",
   "HardarNarasimhan.impl.HNFil._proof_4",
   "le_of_lt",
   "LE.le",
   "instDecidableEqNat",
   "Subtype.mk",
   "dite",
   "instLENat",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.instInhabitedHardarNarasimhanFiltration._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ], Monotone (HardarNarasimhan.impl.HNFil μ)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Bot.mk",
   "Preorder.toLT",
   "Subtype.val",
   "BoundedOrder.mk",
   "Prod.fst",
   "HardarNarasimhan.instBoundedOrderInterval._proof_15",
   "Preorder.toLE",
   "OrderBot.mk",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.instLatticeInterval",
   "OrderTop.mk",
   "Lattice.toSemilatticeInf",
   "And",
   "HardarNarasimhan.instBoundedOrderInterval._proof_13",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HardarNarasimhan.instBoundedOrderInterval._proof_14",
   "Top.mk",
   "Subtype.mk",
   "HardarNarasimhan.instBoundedOrderInterval._proof_16"],
  "name": "HardarNarasimhan.instBoundedOrderInterval",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → BoundedOrder (HardarNarasimhan.Interval z)",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "Set.instHasSubset",
   "PartialOrder.toPreorder",
   "HasSubset.Subset",
   "Set",
   "LE.le",
   "InfSet.sInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "IsGLB.mono",
   "Preorder.toLE",
   "isGLB_sInf",
   "CompleteSemilatticeInf"],
  "name": "sInf_le_sInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s t : Set α}, s ⊆ t → sInf t ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.WeakSlopeLike₁.noConfusionType",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "HardarNarasimhan.WeakSlopeLike₁.casesOn",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₁.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HardarNarasimhan.WeakSlopeLike₁ μ} →\n                  v1 = v2 → HardarNarasimhan.WeakSlopeLike₁.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Decidable",
   "Eq.trans",
   "Subsingleton.elim",
   "Eq.mpr_not",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "GT.gt",
   "Subtype.val",
   "HardarNarasimhan.impl.prop3d4₀func._proof_7",
   "HardarNarasimhan.impl.prop3d4₀func._proof_4",
   "HardarNarasimhan.impl.prop3d4₀func._proof_8",
   "funext",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Subtype",
   "instDecidableTrue",
   "Eq.mp",
   "dite_congr",
   "Prod.fst",
   "congrArg",
   "instOfNatNat",
   "congr",
   "HardarNarasimhan.impl.ℒₛ",
   "WellFoundedGT",
   "instSubsingletonDecidable",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "Set",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Exists.choose",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "Ne",
   "Subtype.mk",
   "dite",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func_helper",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ),\n  (↑I).1 ≠ ↑(HardarNarasimhan.impl.prop3d4₀func μ I (i + 1)) → (↑I).1 ≠ ↑(HardarNarasimhan.impl.prop3d4₀func μ I i)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.μA_DescendingChainCondition.noConfusionType",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "HardarNarasimhan.μA_DescendingChainCondition.casesOn",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μA_DescendingChainCondition.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HardarNarasimhan.μA_DescendingChainCondition μ} →\n                  v1 = v2 → HardarNarasimhan.μA_DescendingChainCondition.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Nat.lt", "Nat", "LT.mk", "LT"],
  "name": "instLTNat",
  "constType": "LT ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Eq.mpr_not",
   "Preorder.toLT",
   "Classical.propDecidable",
   "HardarNarasimhan.μ_Admissible",
   "IsGreatest",
   "SemilatticeInf.toPartialOrder",
   "Exists.choose_spec",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Eq.refl",
   "Iff.mpr",
   "eq_false",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "Subtype",
   "HardarNarasimhan.impl.HNFil._proof_3",
   "HardarNarasimhan.Convex",
   "dite_congr",
   "Prod.fst",
   "congrArg",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.impl.HNFil",
   "instOfNatNat",
   "WellFoundedGT",
   "instDecidableFalse",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.StI",
   "instHAdd",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "HardarNarasimhan.impl.HNFil._proof_4",
   "False",
   "Ne",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil_prop_of_def",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ] (n : ℕ)\n  (h' : HardarNarasimhan.impl.HNFil μ n ≠ ⊤),\n  IsGreatest (HardarNarasimhan.StI μ ⟨(HardarNarasimhan.impl.HNFil μ n, ⊤), ⋯⟩) (HardarNarasimhan.impl.HNFil μ (n + 1))",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.WeakSlopeLike₂.mk",
   "HardarNarasimhan.WeakSlopeLike₂.rec",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₂.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakSlopeLike₂ μ → Sort u} →\n                (t : HardarNarasimhan.WeakSlopeLike₂ μ) →\n                  ((wsl₂ :\n                        ∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n                          μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["Iff.trans",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "And",
   "and_true",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "SemilatticeInf",
   "le_antisymm_iff",
   "iff_self",
   "of_eq_true",
   "Min.min",
   "congr",
   "Iff",
   "_private.Mathlib.Order.Lattice.0._proof_17",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "_private.Mathlib.Order.Lattice.0._proof_18",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_eq_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.impl.prop2d6₁I",
   "Prod.fst",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq",
   "Eq.rec",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop2d6₀",
   "HardarNarasimhan.μA",
   "inf_eq_left",
   "LT.lt",
   "Prod",
   "le_of_lt",
   "Min.min",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop2d6₂I₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HardarNarasimhan.InIntvl I y →\n            ∀ (z : ℒ),\n              HardarNarasimhan.InIntvl I z →\n                ∀ (h : x < y ∧ y < z),\n                  HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩ < HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ →\n                    HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∧\n                      HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "absurd",
   "LT.lt",
   "Preorder",
   "lt_irrefl",
   "Preorder.toLT",
   "False",
   "Ne",
   "Eq.rec",
   "Eq"],
  "name": "ne_of_gt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, b < a → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "le_trans",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "lt_of_le_of_ne",
   "Membership.mem.out",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "And.intro",
   "HardarNarasimhan.S₂I",
   "HardarNarasimhan.S₁I._proof_1",
   "Eq",
   "Preorder.toLE",
   "HardarNarasimhan.S₁I",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "HardarNarasimhan.StI",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "HardarNarasimhan.μA",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Exists.casesOn",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "HardarNarasimhan.semistableI",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "And.casesOn"],
  "name": "HardarNarasimhan.impl.prop3d7₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (x : ℒ)\n  (hxSt : x ∈ HardarNarasimhan.StI μ I), HardarNarasimhan.semistableI μ ⟨((↑I).1, x), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "Or",
   "HardarNarasimhan.μmax._proof_2",
   "sSup_le",
   "Eq.symm",
   "HardarNarasimhan.μmin",
   "Eq.ndrec",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "HardarNarasimhan.impl.rmk4d10₀",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Classical.not_not",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Or.resolve_right",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Prod.fst",
   "le_rfl",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "sInf_le",
   "LT.lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "OrderTop.toTop",
   "CompleteLattice",
   "And.casesOn"],
  "name": "HardarNarasimhan.impl.prop4d14",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      μ ⟨(⊥, x), ⋯⟩ ≤ μ HardarNarasimhan.TotIntvl ∨ ¬μ HardarNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩) →\n    HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl →\n      HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "funext",
   "forall_congr",
   "Eq.symm",
   "sInf_le_sInf",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "_private.Mathlib.Data.Set.Basic.0._proof_18",
   "Prod.snd",
   "Prod",
   "HasSubset.Subset",
   "Iff.of_eq",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "Subtype",
   "Prod.fst",
   "congrArg",
   "HardarNarasimhan.μmax",
   "congr",
   "_private.Init.PropLemmas.0._proof_12",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.μA",
   "lt_of_lt_of_le",
   "exists_prop_congr",
   "LT.lt",
   "Set.instHasSubset",
   "le_of_lt",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop2d6₀",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (x y z : ℒ) (h : x < y ∧ y < z),\n  HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "Preorder.toLT",
   "Prod.snd",
   "lt_of_le_of_ne",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "PartialOrder",
   "LE.le",
   "Ne",
   "Preorder.toLE"],
  "name": "HardarNarasimhan.IsAttained._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (I : { p // p.1 < p.2 }) (a : ℒ),\n  HardarNarasimhan.InIntvl I a → a ≠ (↑I).2 → (a, (↑I).2).1 < (a, (↑I).2).2",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μA_DescendingChainCondition.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n      (∀ (n : ℕ), f n > f (n + 1)) →\n        ∃ N, HardarNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(a, f N), ⋯⟩) →\n    HardarNarasimhan.μA_DescendingChainCondition μ",
  "constCategory": "Other"},
 {"references":
  ["HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "PartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder"],
  "name": "HardarNarasimhan.DedekindMacNeilleCompletion",
  "constType": "(α : Type) → [PartialOrder α] → Type",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "Preorder",
   "Preorder.toLT",
   "not_lt_of_le",
   "Preorder.toLE",
   "GE.ge"],
  "name": "not_lt_of_ge",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≥ b → ¬a < b",
  "constCategory": "Theorem"},
 {"references": ["True", "eq_true", "Eq", "trivial"],
  "name": "implies_true",
  "constType": "∀ (α : Sort u), (∀ (a : α), True) = True",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.succ", "Nat.rec", "Nat.zero"],
  "name": "Nat.casesOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → motive Nat.zero → ((n : ℕ) → motive n.succ) → motive t",
  "constCategory": "Definition"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["Top"],
  "name": "Top.top",
  "constType": "{α : Type u_1} → [self : Top α] → α",
  "constCategory": "Definition"},
 {"references":
  ["ClosureOperator.isClosed_iff",
   "ClosureOperator.instFunLike",
   "OrderHom.toFun",
   "PartialOrder.toPreorder",
   "ClosureOperator.IsClosed",
   "PartialOrder",
   "Iff.mp",
   "ClosureOperator.toOrderHom",
   "ClosureOperator",
   "Eq",
   "DFunLike.coe"],
  "name": "ClosureOperator.IsClosed.closure_eq",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {c : ClosureOperator α} {x : α}, c.IsClosed x → c x = x",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instCommRing",
   "CommRing.toRing",
   "Nat",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toAddMonoidWithOne",
   "CharZero.mk",
   "CharZero",
   "Int.ofNat.inj",
   "Int"],
  "name": "Int.instCharZero",
  "constType": "CharZero ℤ",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.rec", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references": ["Lean.Syntax"],
  "name": "autoParam",
  "constType": "Sort u → Syntax → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "lt_sup_of_lt_right",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "sup_le",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "IsTotal.total",
   "HardarNarasimhan.S₁I",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "Exists.choose_spec",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Or.inr",
   "Subtype",
   "SemilatticeSup.toPartialOrder",
   "IsTotal.mk",
   "lt_of_le_of_ne",
   "Prod.fst",
   "le_rfl",
   "HardarNarasimhan.IsAttained",
   "Subtype.prop",
   "Or.inl",
   "WellFoundedGT",
   "HardarNarasimhan.S₂I",
   "sup_le_iff",
   "Eq",
   "Preorder.toLE",
   "Subtype.le",
   "Lattice.toSemilatticeInf",
   "eq_of_le_of_not_lt",
   "HardarNarasimhan.StI",
   "Set",
   "Exists.choose",
   "HardarNarasimhan.μA",
   "HardarNarasimhan.impl.prop2d8₂I",
   "le_sup_of_le_left",
   "Or.casesOn",
   "LT.lt",
   "IsTotal",
   "Max.max",
   "ne_of_lt",
   "le_of_lt",
   "HardarNarasimhan.IsComparable",
   "LE.le",
   "SemilatticeSup.toMax",
   "Ne",
   "Subtype.mk",
   "Subtype.casesOn",
   "CompleteLattice.toCompleteSemilatticeInf",
   "lt_sup_of_lt_left",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d8₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.ConvexI I μ →\n    ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n        ∀ (z : ℒ) (hzI : HardarNarasimhan.InIntvl I z) (hz : (↑I).1 ≠ z),\n          HardarNarasimhan.IsAttained μ ⟨((↑I).1, z), ⋯⟩) →\n      IsTotal ↑(HardarNarasimhan.StI μ I) fun x1 x2 => x1 ≤ x2",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Preorder", "Preorder.toLT"],
  "name": "StrictMono",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod",
   "LT.lt",
   "And.intro",
   "Subtype.prop",
   "le_of_lt",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.impl.prop3d4₀func._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }), (↑I).1 ≤ (↑I).2 ∧ (↑I).2 ≤ (↑I).2",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "OrderDual", "Equiv"],
  "name": "OrderDual.toDual",
  "constType": "{α : Type u_1} → α ≃ αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["AddCommMonoid", "Semiring"],
  "name": "Module",
  "constType":
  "(R : Type u) → (M : Type v) → [Semiring R] → [AddCommMonoid M] → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_2",
   "_obj",
   "Subtype.partialOrder",
   "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["PartialOrder", "OmegaCompletePartialOrder"],
  "name": "OmegaCompletePartialOrder.toPartialOrder",
  "constType":
  "{α : Type u_6} → [self : OmegaCompletePartialOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.mp",
   "eq_comm",
   "Preorder.toLT",
   "or_assoc",
   "congrArg",
   "LT.lt",
   "or_self",
   "or_comm",
   "Or",
   "HardarNarasimhan.IsComparable",
   "PartialOrder",
   "LE.le",
   "Eq.symm",
   "Eq",
   "Preorder.toLE",
   "le_iff_eq_or_lt",
   "propext"],
  "name": "HardarNarasimhan.impl.comparable_iff",
  "constType":
  "∀ {L : Type} [inst : PartialOrder L] (x y : L), HardarNarasimhan.IsComparable x y → x < y ∨ y ≤ x",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "Option.some",
  "constType": "{α : Type u} → α → Option α",
  "constCategory": "Other"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "LinearOrder.min_def._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Subsingleton", "Subsingleton.intro", "Subsingleton.elim", "funext"],
  "name": "Pi.instSubsingleton",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} [∀ (a : α), Subsingleton (β a)], Subsingleton ((a : α) → β a)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "OrderTop",
   "LT.lt",
   "PartialOrder",
   "Iff",
   "Top.top",
   "Preorder.toLE",
   "Eq",
   "lt_top_iff_ne_top",
   "Iff.not_left",
   "OrderTop.toTop"],
  "name": "not_lt_top_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, ¬a < ⊤ ↔ a = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["IsStrictOrderedRing",
   "Lattice.toSemilatticeInf",
   "Int.instSemiring",
   "Int.instNontrivial",
   "Int.instIsOrderedAddMonoid",
   "Int.mul_pos",
   "IsStrictOrderedRing.of_mul_pos",
   "Int.instZeroLEOneClass",
   "Int.instRing",
   "instLatticeInt",
   "SemilatticeInf.toPartialOrder",
   "Int"],
  "name": "Int.instIsStrictOrderedRing",
  "constType": "IsStrictOrderedRing ℤ",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "OfNat.ofNat",
   "AddMonoid.mk",
   "HAdd.hAdd",
   "SubNegMonoid.sub'",
   "Nat",
   "Zero.mk",
   "instOfNatNat",
   "id",
   "Add.mk",
   "Zero.toOfNat0",
   "Eq",
   "Neg.mk",
   "AddSemigroup.mk"],
  "name":
  "HardarNarasimhan.TotallyOrderedRealVectorSpace.sub._inherited_default",
  "constType":
  "{V : Type} →\n  (add : V → V → V) →\n    (∀ (a b c : V), a + b + c = a + (b + c)) →\n      (zero : V) →\n        (∀ (a : V), 0 + a = a) →\n          (∀ (a : V), a + 0 = a) →\n            (nsmul : ℕ → V → V) →\n              (∀ (x : V), nsmul 0 x = 0) → (∀ (n : ℕ) (x : V), nsmul (n + 1) x = nsmul n x + x) → (V → V) → V → V → V",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Lattice",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty),\n  Exists.choose h₃ ∈ {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Unique",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references": ["DecidableLE", "ite", "LE.mk", "id"],
  "name":
  "HardarNarasimhan.TotallyOrderedRealVectorSpace.min._inherited_default",
  "constType": "{V : Type} → (le : V → V → Prop) → DecidableLE V → V → V → V",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "HardarNarasimhan.μmax",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.impl.prop4d12",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_4_12",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      ¬μ ⟨(⊥, x), ⋯⟩ ≤ μ HardarNarasimhan.TotIntvl ∨ μ HardarNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩) →\n    HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl →\n      HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Nat", "OfNat", "Nat.cast", "OfNat.mk", "Nat.AtLeastTwo", "NatCast"],
  "name": "instOfNatAtLeastTwo",
  "constType":
  "{R : Type u_1} → {n : ℕ} → [NatCast R] → [n.AtLeastTwo] → OfNat R n",
  "constCategory": "Definition"},
 {"references": ["List.nil", "List.Chain"],
  "name": "List.Chain.nil",
  "constType": "∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "DecidableLE",
   "PartialOrder.toPreorder",
   "Decidable",
   "Decidable.isFalse",
   "DecidableEq",
   "decidableEqOfDecidableLE._proof_4",
   "decidableEqOfDecidableLE._proof_3",
   "decidableLTOfDecidableLE.match_1",
   "PartialOrder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "dite",
   "le_antisymm",
   "Decidable.isTrue"],
  "name": "decidableEqOfDecidableLE",
  "constType":
  "{α : Type u_1} → [inst : PartialOrder α] → [DecidableLE α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "HardarNarasimhan.InIntvl",
   "Preorder.toLT",
   "And",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.impl.ℒₛ._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (x : { p // HardarNarasimhan.InIntvl I p }) (p : ℒ),\n  HardarNarasimhan.InIntvl I p → (↑I).1 ≠ p ∧ p < ↑x → ((↑I).1, p).1 < ((↑I).1, p).2",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "le_of_lt",
   "not_le_of_lt",
   "le_trans",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLT",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "CoeOut.mk",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "CoeOut",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instCoeOutInterval",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → CoeOut (HardarNarasimhan.Interval z) ℒ",
  "constCategory": "Definition"},
 {"references": ["rfl", "True", "eq_true", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.impl.HNFil._proof_1",
   "Preorder.toLT",
   "bot_le",
   "HardarNarasimhan.μ_Admissible",
   "Subtype.val",
   "IsGreatest",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "HardarNarasimhan.impl.prop3d8₁'",
   "Or.inr",
   "Subtype",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.Convex_of_Convex_large",
   "lt_of_le_of_ne",
   "Prod.fst",
   "HardarNarasimhan.IsAttained",
   "Or.inl",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_top",
   "HardarNarasimhan.StI",
   "HardarNarasimhan.TotIntvl",
   "LT.lt",
   "Or.casesOn",
   "IsTotal",
   "Nat.succ",
   "Nat.below",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "HardarNarasimhan.μ_Admissible.μ_adm"],
  "name": "HardarNarasimhan.impl.HNFil._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ] (n : ℕ) (x : Nat.below n.succ)\n  (htop : ¬x.1 = ⊤), ∃ s, IsGreatest (HardarNarasimhan.StI μ ⟨(x.1, ⊤), ⋯⟩) s",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.NashEquilibrium",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.μAstar",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.NashEquilibrium.nash_eq",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HardarNarasimhan.NashEquilibrium μ],\n  HardarNarasimhan.μAstar μ = HardarNarasimhan.μBstar μ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteLattice",
  "constType": "Type u_8 → Type u_8",
  "constCategory": "Other"},
 {"references": ["LT.lt", "Eq.rec", "Eq", "LT"],
  "name": "lt_of_lt_of_eq",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LT α], a < b → b = c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "AddZeroClass.toZero",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "zero_add",
   "AddZeroClass.toAdd",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_pf_zero_add",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 + b = b",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE", "Eq.rec", "Eq"],
  "name": "le_of_le_of_eq",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LE α], a ≤ b → b = c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Inter"],
  "name": "Inter.inter",
  "constType": "{α : Type u} → [self : Inter α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₁.wsl₁",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HardarNarasimhan.WeakSlopeLike₁ μ]\n  (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Or.inr",
   "Or.rec",
   "Or.imp_right",
   "Or.inl",
   "Or",
   "Or.imp_left",
   "Iff",
   "Function.comp",
   "Iff.intro"],
  "name": "or_assoc",
  "constType": "∀ {a b c : Prop}, (a ∨ b) ∨ c ↔ a ∨ b ∨ c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "HardarNarasimhan.InIntvl",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "Subtype.val",
   "HardarNarasimhan.stableI._proof_3",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.stableI._proof_2",
   "HardarNarasimhan.semistableI",
   "Ne",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.stableI",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HardarNarasimhan.SlopeLike",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice",
   "HardarNarasimhan.impl.rmk4d13"],
  "name": "HardarNarasimhan.remark_4_13",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.SlopeLike μ →\n    ∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      ¬μ ⟨(⊥, x), ⋯⟩ ≤ μ HardarNarasimhan.TotIntvl ∨ μ HardarNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Preorder.toLT",
   "Coe.mk",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.natCast_succ",
   "Semiring.mul_one",
   "Semiring.natCast_zero",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "NonAssocSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNonUnitalSemiring",
   "Semiring.one_mul",
   "Semiring"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["add_left_comm",
   "Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "congr",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq.ndrec",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddSemigroup.toAdd",
   "Distrib.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "True",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "AddCommMonoid.toAddCommSemigroup",
   "add_assoc",
   "AddMonoid.toAddSemigroup"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b₁ b₂ c₁ c₂ : R},\n  a₁ + b₁ = c₁ → a₂ + b₂ = c₂ → a₁ + a₂ + (b₁ + b₂) = c₁ + c₂",
  "constCategory": "Theorem"},
 {"references": ["Sub"],
  "name": "Sub.mk",
  "constType": "{α : Type u} → (α → α → α) → Sub α",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "HardarNarasimhan.μA",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Nontrivial",
   "Top.top",
   "OrderBot.toBot",
   "Subtype.mk",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μAstar",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → S",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "AddGroup"],
  "name": "AddGroup.toSubNegMonoid",
  "constType": "{A : Type u} → [self : AddGroup A] → SubNegMonoid A",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompleteLinearOrder",
  "constType": "Type u_8 → Type u_8",
  "constCategory": "Other"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LT α",
  "constCategory": "Other"},
 {"references": ["Nat", "Int"],
  "name": "Int.ofNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["rfl",
   "Set",
   "Membership.mem",
   "Exists.intro",
   "Eq",
   "Set.range",
   "Set.instMembership"],
  "name": "Set.mem_range_self",
  "constType":
  "∀ {α : Type u} {ι : Sort u_1} {f : ι → α} (i : ι), f i ∈ Set.range f",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "WellFounded",
  "constType": "{α : Sort u} → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["HardarNarasimhan.TotallyOrderedRealVectorSpace", "LinearOrder"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
  "constType":
  "{V : Type} → [self : HardarNarasimhan.TotallyOrderedRealVectorSpace V] → LinearOrder V",
  "constCategory": "Definition"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "Preorder.lt_iff_le_not_le._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod",
   "LT.lt",
   "And.intro",
   "Subtype.prop",
   "le_of_lt",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instBoundedOrderInterval._proof_13",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {z : { p // p.1 < p.2 }}, (↑z).1 ≤ (↑z).2 ∧ (↑z).2 ≤ (↑z).2",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring.toDistrib",
   "True",
   "Eq.trans",
   "Distrib.toMul",
   "CommSemiring",
   "MulZeroClass.toMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "OfNat.ofNat",
   "congrArg",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Zero.toOfNat0",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.mul_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["rfl", "Subtype", "Subtype.ext.match_1", "Subtype.mk", "Eq", "Subtype.val"],
  "name": "Subtype.ext",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "Lattice",
   "Top.top",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (z : { p // p.1 < p.2 }),\n  (↑z).2 < ⊤ → ((↑z).1, ⊤).1 < ((↑z).1, ⊤).2",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "instOfNatNat",
   "instHAdd",
   "Nat.lt.base",
   "OfNat.ofNat"],
  "name": "Nat.lt_add_one",
  "constType": "∀ (n : ℕ), n < n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "HardarNarasimhan.HardarNarasimhanFiltration.casesOn",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration.mk",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Nat.find",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "HardarNarasimhan.instLatticeInterval",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.μ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HardarNarasimhan.instNontrivialInterval",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HardarNarasimhan.Semistable",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.ext.match_1",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HardarNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HardarNarasimhan.Convex μ} {h : HardarNarasimhan.μ_Admissible μ}\n  (motive : HardarNarasimhan.HardarNarasimhanFiltration μ → Prop) (h_1 : HardarNarasimhan.HardarNarasimhanFiltration μ),\n  (∀ (filtration : ℕ → ℒ) (monotone : Monotone filtration) (first_eq_bot : filtration 0 = ⊥)\n      (fin_len : ∃ n, filtration n = ⊤)\n      (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j)\n      (piecewise_semistable :\n        ∀ (i : ℕ) (h : i < Nat.find fin_len),\n          HardarNarasimhan.Semistable (HardarNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ))\n      (μA_pseudo_strict_anti :\n        ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n          ¬HardarNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n              HardarNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩),\n      motive\n        { filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot, fin_len := fin_len,\n          strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n          μA_pseudo_strict_anti := μA_pseudo_strict_anti }) →\n    motive h_1",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.rec", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p), (∀ (w : α) (h : p w), motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "Subtype.property",
   "Subtype.ext",
   "Subtype.mk",
   "Eq.rec",
   "Eq",
   "Subtype.val"],
  "name": "Subtype.coe_eq_of_eq_mk",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a : { a // p a }} {b : α} (h : ↑a = b), a = ⟨b, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Real.instPreorder",
   "AddGroup.mk",
   "SubNegMonoid.zsmul_zero'._autoParam",
   "Preorder.toLT",
   "SubNegMonoid.zsmul_neg'._autoParam",
   "HMul.hMul",
   "Min.mk",
   "Semiring.toNonAssocSemiring",
   "AddCommGroup.mk",
   "Or",
   "Sub.mk",
   "HSub.hSub",
   "LT.mk",
   "SubNegMonoid.mk",
   "MulOneClass.toMul",
   "Preorder.lt_iff_le_not_le._autoParam",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.mk",
   "PosSMulStrictMono.mk",
   "SubNegMonoid.zsmul_succ'._autoParam",
   "Real",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "AddCommMonoid.mk",
   "Int.negSucc",
   "LinearOrder.max_def._autoParam",
   "Ordering",
   "Max.mk",
   "AddMonoid.mk",
   "Nat",
   "instOfNat",
   "Zero.mk",
   "Iff",
   "HSMul.hSMul",
   "Add.mk",
   "instHMul",
   "autoParam",
   "Preorder.mk",
   "SubNegMonoid.sub_eq_add_neg._autoParam",
   "AddMonoid.toAddZeroClass",
   "Nat.cast",
   "AddMonoid.nsmul_zero._autoParam",
   "DecidableEq",
   "compareOfLessAndEq",
   "LinearOrder.min_def._autoParam",
   "PartialOrder.mk",
   "Module.mk",
   "instOfNatNat",
   "Ord.mk",
   "MulOneClass.toOne",
   "Monoid.toMulOneClass",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Eq",
   "AddSemigroup.mk",
   "instNatCastInt",
   "Not",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "SMul.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq._autoParam",
   "Distrib.toAdd",
   "DecidableLE",
   "ite",
   "DecidableLT",
   "instHAdd",
   "DistribMulAction.mk",
   "Semiring.toMonoidWithZero",
   "LinearOrder.mk",
   "OfNat.ofNat",
   "Real.semiring",
   "Int",
   "LT.lt",
   "HAdd.hAdd",
   "Real.instZero",
   "AddCommMonoid.toAddCommSemigroup",
   "One.toOfNat1",
   "MulZeroClass.toZero",
   "Nat.succ",
   "LE.mk",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHSub",
   "Neg.mk",
   "MulAction.mk",
   "AddMonoid.nsmul_succ._autoParam"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.mk._flat_ctor",
  "constType":
  "{V : Type} →\n  (add : V → V → V) →\n    (add_assoc : ∀ (a b c : V), a + b + c = a + (b + c)) →\n      (zero : V) →\n        (zero_add : ∀ (a : V), 0 + a = a) →\n          (add_zero : ∀ (a : V), a + 0 = a) →\n            (nsmul : ℕ → V → V) →\n              (nsmul_zero : autoParam (∀ (x : V), nsmul 0 x = 0) AddMonoid.nsmul_zero._autoParam) →\n                (nsmul_succ :\n                    autoParam (∀ (n : ℕ) (x : V), nsmul (n + 1) x = nsmul n x + x) AddMonoid.nsmul_succ._autoParam) →\n                  (neg : V → V) →\n                    (sub : V → V → V) →\n                      autoParam (∀ (a b : V), a - b = a + neg b) SubNegMonoid.sub_eq_add_neg._autoParam →\n                        (zsmul : ℤ → V → V) →\n                          autoParam (∀ (a : V), zsmul 0 a = 0) SubNegMonoid.zsmul_zero'._autoParam →\n                            autoParam (∀ (n : ℕ) (a : V), zsmul (↑n.succ) a = zsmul (↑n) a + a)\n                                SubNegMonoid.zsmul_succ'._autoParam →\n                              autoParam (∀ (n : ℕ) (a : V), zsmul (Int.negSucc n) a = neg (zsmul (↑n.succ) a))\n                                  SubNegMonoid.zsmul_neg'._autoParam →\n                                (∀ (a : V), neg a + a = 0) →\n                                  (add_comm : ∀ (a b : V), a + b = b + a) →\n                                    (smul : ℝ → V → V) →\n                                      (∀ (b : V), 1 • b = b) →\n                                        (∀ (x y : ℝ) (b : V), (x * y) • b = x • y • b) →\n                                          (∀ (a : ℝ), a • 0 = 0) →\n                                            (∀ (a : ℝ) (x y : V), a • (x + y) = a • x + a • y) →\n                                              (∀ (r s : ℝ) (x : V), (r + s) • x = r • x + s • x) →\n                                                (∀ (x : V), 0 • x = 0) →\n                                                  (le lt : V → V → Prop) →\n                                                    (∀ (a : V), le a a) →\n                                                      (∀ (a b c : V), le a b → le b c → le a c) →\n                                                        autoParam (∀ (a b : V), lt a b ↔ le a b ∧ ¬le b a)\n                                                            Preorder.lt_iff_le_not_le._autoParam →\n                                                          (∀ (a b : V), le a b → le b a → a = b) →\n                                                            (min max : V → V → V) →\n                                                              (compare : V → V → Ordering) →\n                                                                (∀ (a b : V), le a b ∨ le b a) →\n                                                                  (toDecidableLE : DecidableLE V) →\n                                                                    (toDecidableEq : DecidableEq V) →\n                                                                      (toDecidableLT : DecidableLT V) →\n                                                                        autoParam\n                                                                            (∀ (a b : V),\n                                                                              min a b = if le a b then a else b)\n                                                                            LinearOrder.min_def._autoParam →\n                                                                          autoParam\n                                                                              (∀ (a b : V),\n                                                                                max a b = if le a b then b else a)\n                                                                              LinearOrder.max_def._autoParam →\n                                                                            autoParam\n                                                                                (∀ (a b : V),\n                                                                                  compare a b = compareOfLessAndEq a b)\n                                                                                LinearOrder.compare_eq_compareOfLessAndEq._autoParam →\n                                                                              (∀ ⦃a : ℝ⦄,\n                                                                                  0 < a →\n                                                                                    ∀ ⦃b₁ b₂ : V⦄,\n                                                                                      lt b₁ b₂ → lt (a • b₁) (a • b₂)) →\n                                                                                (∀ {y z : V} (x : V),\n                                                                                    le y z → le (x + y) (x + z)) →\n                                                                                  HardarNarasimhan.TotallyOrderedRealVectorSpace\n                                                                                    V",
  "constCategory": "Definition"},
 {"references":
  ["not_le",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_le_eq",
  "constType":
  "∀ {β : Type u_2} [inst : LinearOrder β] (a b : β), (¬a ≤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "LE",
   "OrderDual.instOrderBot",
   "OrderTop",
   "BoundedOrder",
   "inferInstanceAs",
   "OrderDual.instLE",
   "BoundedOrder.mk",
   "OrderBot",
   "OrderDual.instOrderTop"],
  "name": "OrderDual.instBoundedOrder",
  "constType":
  "(α : Type u) → [inst : LE α] → [BoundedOrder α] → BoundedOrder αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "SubNegMonoid.sub_eq_add_neg._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.impl.HNFil._proof_3",
   "Prod.mk",
   "HardarNarasimhan.impl.HNFil.match_1",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "IsGreatest",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.impl.HNFil",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.StI",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Bot.bot",
   "Unit",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "BoundedOrder.toOrderBot",
   "HardarNarasimhan.impl.HNFil._proof_4",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil._sunfold",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              (μ : { p // p.1 < p.2 } → S) →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] → [h : HardarNarasimhan.μ_Admissible μ] → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid",
   "DivisionMonoid",
   "DivisionMonoid.toDivInvOneMonoid._proof_15",
   "DivInvOneMonoid",
   "DivInvOneMonoid.mk"],
  "name": "DivisionMonoid.toDivInvOneMonoid",
  "constType": "{α : Type u_1} → [DivisionMonoid α] → DivInvOneMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["instLTNat",
   "Iff.mp",
   "Nat.le_pred_iff_lt",
   "Nat.pred",
   "OfNat.ofNat",
   "LT.lt",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "LE.le",
   "HSub.hSub",
   "instHSub",
   "instLENat"],
  "name": "Nat.lt_of_le_sub_one",
  "constType": "∀ {m n : ℕ}, 0 < m → n ≤ m - 1 → n < m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OrderDual",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableAnd._proof_3",
   "Not",
   "And.intro",
   "instDecidableAnd._proof_2",
   "Decidable.isFalse",
   "Decidable",
   "And",
   "instDecidableAnd.match_1",
   "Decidable.isTrue"],
  "name": "instDecidableAnd",
  "constType":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∧ q)",
  "constCategory": "Definition"},
 {"references": ["Nat", "NatCast.natCast", "NatCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "MulAction.toSMul",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.noConfusionType",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "Eq.ndrec",
   "Eq",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.casesOn",
   "AddSemigroup.toAdd",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "PosSMulStrictMono",
   "HEq.refl",
   "Real",
   "instHAdd",
   "AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "LinearOrder",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "Eq.refl",
   "AddMonoid.toAddSemigroup",
   "LE.le",
   "HEq"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.noConfusion",
  "constType":
  "{V : Type} →\n  {P : Sort u} →\n    {v1 v2 : HardarNarasimhan.TotallyOrderedRealVectorSpace V} →\n      v1 = v2 → HardarNarasimhan.TotallyOrderedRealVectorSpace.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "OrderDual",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.inf",
   "OrderDual.instSemilatticeSup",
   "OrderDual.instLattice._proof_26",
   "Lattice",
   "Lattice.mk",
   "OrderDual.instLattice._proof_27",
   "OrderDual.instLattice._proof_25",
   "OrderDual.instSemilatticeInf"],
  "name": "OrderDual.instLattice",
  "constType": "(α : Type u_1) → [Lattice α] → Lattice αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.ConvexI",
   "HardarNarasimhan.TotIntvl",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.Convex",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "HardarNarasimhan.TotIntvl._proof_1",
   "Subtype.val",
   "And.intro",
   "HardarNarasimhan.μmin",
   "SemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLattice.toInfSet",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "ne_top_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Set.ext",
   "lt_top_iff_ne_top",
   "setOf",
   "Subtype",
   "Prod.fst",
   "congrArg",
   "Iff.intro",
   "BoundedOrder.toOrderTop",
   "InfSet.sInf",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.in_TotIntvl",
   "HardarNarasimhan.TotIntvl",
   "LT.lt",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop4d1_helper",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  sInf {x | ∃ x_1, ∃ (hx : x_1 < ⊤), μ ⟨(x_1, ⊤), hx⟩ = x} = HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub",
   "instOfNat",
   "Eq.refl",
   "Int.sub_self",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "instHSub",
   "Eq",
   "OfNat.ofNat",
   "congrArg",
   "Int"],
  "name": "Int.sub_eq_zero_of_eq",
  "constType": "∀ {a b : ℤ}, a = b → a - b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["le_refl", "Preorder", "True", "LE.le", "eq_true", "Eq", "Preorder.toLE"],
  "name": "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Neg.neg",
   "instHAdd",
   "AddMonoid.toAddSemigroup",
   "Neg",
   "AddMonoid",
   "AddSemigroup.toAdd"],
  "name": "SubNegMonoid.sub'",
  "constType": "{G : Type u} → [AddMonoid G] → [Neg G] → G → G → G",
  "constCategory": "Definition"},
 {"references":
  ["Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Preorder.toLE",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.casesOn",
   "AddSemigroup.toAdd",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "PosSMulStrictMono",
   "Real",
   "instHAdd",
   "AddCommGroup.add_comm",
   "LinearOrder",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "AddMonoid.toAddSemigroup",
   "LE.le",
   "HEq"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.noConfusionType",
  "constType":
  "{V : Type} →\n  Sort u → HardarNarasimhan.TotallyOrderedRealVectorSpace V → HardarNarasimhan.TotallyOrderedRealVectorSpace V → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "HardarNarasimhan.μ_Admissible.mk",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.IsAttained",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.μ_Admissible.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                {motive : HardarNarasimhan.μ_Admissible μ → Sort u} →\n                  ((μ_adm :\n                        (IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n                          ∀ (I : { p // p.1 < p.2 }), HardarNarasimhan.IsAttained μ I) →\n                      motive ⋯) →\n                    (t : HardarNarasimhan.μ_Admissible μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "True",
   "Eq.trans",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "add_assoc",
   "AddMonoid.toAddSemigroup",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddSemigroup.toAdd"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_lt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₂ b c : R} (a₁ : R), a₂ + b = c → a₁ + a₂ + b = a₁ + c",
  "constCategory": "Theorem"},
 {"references": ["WellFounded", "IsWellFounded"],
  "name": "IsWellFounded.wf",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [self : IsWellFounded α r], WellFounded r",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "Not",
   "rfl",
   "Subsingleton",
   "Decidable.isFalse",
   "Decidable",
   "Subsingleton.intro",
   "Eq",
   "instSubsingletonDecidable.match_1",
   "Decidable.isTrue"],
  "name": "instSubsingletonDecidable",
  "constType": "∀ (p : Prop), Subsingleton (Decidable p)",
  "constCategory": "Theorem"},
 {"references": ["Subtype", "LE.le", "LE.mk", "LE", "Subtype.val"],
  "name": "Subtype.le",
  "constType": "{α : Type u_2} → [LE α] → {p : α → Prop} → LE (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Subtype.partialOrder",
   "ClosureOperator",
   "Union.union",
   "DFunLike.coe",
   "Subtype.val",
   "congrArg",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "Eq.symm",
   "ClosureOperator.isClosed_closure",
   "Preorder.toLE",
   "Set.instUnion",
   "Eq.rec",
   "Eq",
   "Set.subset_union_left",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
   "Subtype.coe_eq_of_eq_mk",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "Subtype.mk"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_2",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds), A ≤ ⟨T (↑A ∪ ↑B), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.nil",
  "constType": "{α : Type u} → List α",
  "constCategory": "Other"},
 {"references":
  ["Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "Unit.unit",
   "OfNat.ofNat",
   "Unit"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((k : ℕ) → motive k.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Subtype.lt",
   "Subtype.mk_lt_mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.GCongr.coe_lt_coe",
   "Subtype.prop",
   "Subtype.property",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.instLatticeInterval",
   "Not",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "lt_iff_le_not_le",
   "LT.lt",
   "Prod",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk"],
  "name": "HardarNarasimhan.Resμ._proof_19",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (z : { p // p.1 < p.2 })\n  (p : { p // p.1 < p.2 }), ↑(↑p).1 < ↑(↑p).2",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "OrderEmbedding.le_iff_le",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "OrderEmbedding",
   "DFunLike.coe",
   "RelEmbedding.instFunLike",
   "propext"],
  "name": "_private.Mathlib.Order.Hom.Basic.0._proof_50",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α ↪o β) {a b : α}, (f a ≤ f b) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "CompleteLattice",
   "HardarNarasimhan.Resμ",
   "HardarNarasimhan.instLatticeInterval",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HardarNarasimhan.instCoeForallSubtypeProdLtFstSndForallIntervalOfCompleteLattice._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {z : { p // p.1 < p.2 }} →\n          {S : Type} → [CompleteLattice S] → Coe ({ p // p.1 < p.2 } → S) ({ p // p.1 < p.2 } → S)",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.WeakAscendingChainCondition.mk",
   "Preorder.toLT",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakAscendingChainCondition.rec",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HardarNarasimhan.WeakAscendingChainCondition.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakAscendingChainCondition μ → Sort u} →\n                (t : HardarNarasimhan.WeakAscendingChainCondition μ) →\n                  ((wacc : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references": ["Add.add", "HAdd.mk", "HAdd", "Add"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Prod",
   "Prod.mk",
   "Prod.mk.eta.match_1",
   "Prod.snd",
   "Eq",
   "Prod.fst"],
  "name": "Prod.mk.eta",
  "constType": "∀ {α : Type u_1} {β : Type u_2} {p : α × β}, (p.1, p.2) = p",
  "constCategory": "Theorem"},
 {"references":
  ["le_top",
   "True",
   "LE.le",
   "Top.top",
   "LE",
   "eq_true",
   "OrderTop",
   "Eq",
   "OrderTop.toTop"],
  "name": "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_3",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, (a ≤ ⊤) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "True",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "Mathlib.Tactic.Ring.cast_pos.match_1",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.cast_pos",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = n.rawCast + 0",
  "constCategory": "Theorem"},
 {"references": ["WellFounded", "IsWellFounded"],
  "name": "IsWellFounded.mk",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop}, WellFounded r → IsWellFounded α r",
  "constCategory": "Other"},
 {"references": ["Not", "Exists", "Classical.not_forall", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_forall_eq",
  "constType": "∀ {α : Sort u_1} (s : α → Prop), (¬∀ (x : α), s x) = ∃ x, ¬s x",
  "constCategory": "Theorem"},
 {"references":
  ["contravariant_swap_add_of_contravariant_add",
   "PartialOrder.toPreorder",
   "le_of_add_le_add_left",
   "instHAdd",
   "IsCancelAdd",
   "le_of_add_le_add_right",
   "AddCommMonoid.toAddMonoid",
   "Eq.ge",
   "HAdd.hAdd",
   "AddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "AddZeroClass.toAdd",
   "PartialOrder",
   "IsCancelAdd.mk",
   "LE.le",
   "IsOrderedCancelAddMonoid.toAddLeftReflectLE",
   "LE.le.antisymm",
   "IsLeftCancelAdd.mk",
   "Preorder.toLE",
   "Eq",
   "Eq.le",
   "IsRightCancelAdd.mk",
   "IsOrderedCancelAddMonoid",
   "AddMonoid.toAddZeroClass"],
  "name": "IsOrderedCancelAddMonoid.toIsCancelAdd",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : PartialOrder α] [IsOrderedCancelAddMonoid α], IsCancelAdd α",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instCommSemiring",
   "Real",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring"],
  "name": "Real.semiring",
  "constType": "Semiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "HardarNarasimhan.impl.semistable_iff",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "SupSet.sSup",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Subtype.coe_eta",
   "Eq.symm",
   "HardarNarasimhan.instBoundedOrderInterval",
   "Eq.ndrec",
   "rfl",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "BoundedOrder",
   "Prod.snd",
   "Set.setOf_app_iff",
   "Set.instMembership",
   "Prod",
   "Iff",
   "Eq.refl",
   "Lattice",
   "Set.ext",
   "Eq.mpr",
   "setOf",
   "Prod.fst",
   "le_rfl",
   "congr",
   "InfSet.sInf",
   "HardarNarasimhan.S₂I",
   "Eq",
   "Preorder.toLE",
   "propext",
   "HardarNarasimhan.instLatticeInterval",
   "HardarNarasimhan.impl.stupid_helper",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "lt_of_eq_of_lt",
   "HardarNarasimhan.μA",
   "SupSet",
   "HardarNarasimhan.semistableI",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "And.casesOn",
   "InfSet",
   "PartialOrder.toPreorder",
   "lt_of_lt_of_eq",
   "Set.mem_def",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Iff.mp",
   "HardarNarasimhan.instNontrivialInterval",
   "GT.gt",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "PartialOrder",
   "HardarNarasimhan.Semistable",
   "forall_congr",
   "funext",
   "HardarNarasimhan.S₁I._proof_1",
   "Eq.rec",
   "HardarNarasimhan.S₁I",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.Resμ",
   "And.left",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "Exists.casesOn",
   "Subtype.coe_eq_of_eq_mk",
   "Iff.of_eq",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Iff.intro",
   "congrArg",
   "Subtype.prop",
   "HardarNarasimhan.μmax",
   "Not",
   "HardarNarasimhan.Resμ._proof_19",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.StI",
   "HardarNarasimhan.in_TotIntvl",
   "Prod.mk.eta",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "ne_of_lt",
   "le_of_lt",
   "LE.le",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39",
   "Subtype.coe_ne_coe"],
  "name": "HardarNarasimhan.impl.semistableI_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.semistableI μ I ↔ HardarNarasimhan.Semistable (HardarNarasimhan.Resμ I μ)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.sInf_le",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Membership.mem",
   "Preorder.toLE",
   "Set.instMembership",
   "CompleteSemilatticeInf"],
  "name": "sInf_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, a ∈ s → sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._rarg",
   "_neutral"],
  "name": "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Or",
   "HardarNarasimhan.IsComparable",
   "Eq.refl",
   "PartialOrder",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "HardarNarasimhan.IsComparable.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (x y : ℒ), HardarNarasimhan.IsComparable x y = (x ≤ y ∨ y ≤ x)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.IsAttained",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.μ_Admissible.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨ ∀ (I : { p // p.1 < p.2 }), HardarNarasimhan.IsAttained μ I) →\n    HardarNarasimhan.μ_Admissible μ",
  "constCategory": "Other"},
 {"references":
  ["Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "Unit.unit",
   "OfNat.ofNat",
   "Unit"],
  "name": "HardarNarasimhan.impl.prop3d4₀func.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["One.toOfNat1",
   "AddZeroClass.toZero",
   "AddZeroClass.toAdd",
   "AddZeroClass",
   "zero_le",
   "ZeroLEOneClass.mk",
   "One",
   "LE",
   "CanonicallyOrderedAdd",
   "OfNat.ofNat",
   "ZeroLEOneClass"],
  "name": "CanonicallyOrderedAdd.toZeroLeOneClass",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α] [CanonicallyOrderedAdd α] [inst_3 : One α], ZeroLEOneClass α",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Membership.mem",
   "CompleteSemilatticeInf.le_sInf",
   "Preorder.toLE",
   "Set.instMembership",
   "CompleteSemilatticeInf"],
  "name": "le_sInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "instHAdd",
   "Lean.Omega.LinearCombo.coeffs",
   "Lean.Omega.LinearCombo",
   "Int.instAdd",
   "Lean.Omega.Coeffs",
   "Lean.Omega.LinearCombo.const",
   "Lean.Omega.Coeffs.dot",
   "Int"],
  "name": "Lean.Omega.LinearCombo.eval",
  "constType": "Omega.LinearCombo → Omega.Coeffs → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Preorder",
   "False.elim",
   "lt_irrefl",
   "Iff",
   "Preorder.toLT",
   "False",
   "Iff.intro"],
  "name": "lt_self_iff_false",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] (x : α), x < x ↔ False",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "Eq.trans",
   "Membership.mem",
   "Subtype.val",
   "Set.Elem",
   "funext",
   "forall_congr",
   "Classical.indefiniteDescription",
   "Eq.ndrec",
   "Set.mem_range_self",
   "And.left",
   "WellFounded",
   "Exists",
   "Exists.choose_spec",
   "IsEmpty.mk",
   "And.right",
   "And",
   "Nonempty",
   "Set.instMembership",
   "Exists.casesOn",
   "Nat",
   "instNonemptyOfInhabited",
   "Nat.rec",
   "Iff",
   "Eq.refl",
   "id",
   "Eq.mpr",
   "instInhabitedNat",
   "Mathlib.Tactic.PushNeg.not_implies_eq",
   "Subtype",
   "WellFounded.wellFounded_iff_no_descending_seq.match_1",
   "Set.range",
   "Iff.intro",
   "congrArg",
   "IsEmpty",
   "Nonempty.intro",
   "WellFounded.wellFounded_iff_has_min",
   "instOfNatNat",
   "Subtype.property",
   "Eq",
   "propext",
   "Not",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "Set.Nonempty",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "instHAdd",
   "Set",
   "Mathlib.Tactic.PushNeg.not_and_eq",
   "Mathlib.Tactic.PushNeg.not_forall_eq",
   "Function.comp",
   "Exists.choose",
   "OfNat.ofNat",
   "Mathlib.Tactic.Contrapose.mtr",
   "HAdd.hAdd",
   "not_isEmpty_iff",
   "Set.range_nonempty",
   "False",
   "Subtype.mk",
   "And.casesOn"],
  "name": "WellFounded.wellFounded_iff_no_descending_seq",
  "constType":
  "∀ {α : Type u_1} {r : α → α → Prop}, WellFounded r ↔ IsEmpty { f // ∀ (n : ℕ), r (f (n + 1)) (f n) }",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "PartialOrder",
   "InfSet.sInf",
   "HardarNarasimhan.μmin",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "CompleteSemilatticeInf.toInfSet",
   "Eq.refl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μmin.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.μmin μ I = sInf {x | ∃ u, ∃ (h : HardarNarasimhan.InIntvl I u ∧ u ≠ (↑I).2), μ ⟨(u, (↑I).2), ⋯⟩ = x}",
  "constCategory": "Theorem"},
 {"references": ["Sub.mk", "Sub", "Int.sub", "Int"],
  "name": "Int.instSub",
  "constType": "Sub ℤ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Prod",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "Subtype",
   "Lattice",
   "Preorder.toLT",
   "Prod.snd",
   "CompleteLattice",
   "Prod.fst",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.ConvexI",
  "constType":
  "{ℒ : Type} →\n  [inst : Lattice ℒ] → {S : Type} → [CompleteLattice S] → { p // p.1 < p.2 } → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "HardarNarasimhan.μ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Int.negOfNat",
   "Top.top",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "AddMonoid.toAddZeroClass",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "congr",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "instNatCastInt",
   "lt_of_not_ge",
   "Distrib.toAdd",
   "Nat.instAddMonoid",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.instAddCommMonoid",
   "GE.ge",
   "Mathlib.Meta.NormNum.isNat_add",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Ring.toAddGroupWithOne",
   "HardarNarasimhan.HardarNarasimhanFiltration.fin_len",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Nat.instPartialOrder",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat.instCanonicallyOrderedAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Decidable.byContradiction",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "Subtype",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "HardarNarasimhan.HardarNarasimhanFiltration.strict_mono",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "HardarNarasimhan.HardarNarasimhanFiltration.filtration",
   "Nat.instIsOrderedCancelAddMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "LT.lt",
   "lt_add_one",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.μA_pseudo_strict_anti",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HardarNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HardarNarasimhan.Convex μ} {h : HardarNarasimhan.μ_Admissible μ}\n  [self : HardarNarasimhan.HardarNarasimhanFiltration μ] (i : ℕ) (hi : i + 1 < Nat.find ⋯),\n  ¬HardarNarasimhan.μA μ\n        ⟨(HardarNarasimhan.HardarNarasimhanFiltration.filtration μ i,\n            HardarNarasimhan.HardarNarasimhanFiltration.filtration μ (i + 1)),\n          ⋯⟩ ≤\n      HardarNarasimhan.μA μ\n        ⟨(HardarNarasimhan.HardarNarasimhanFiltration.filtration μ (i + 1),\n            HardarNarasimhan.HardarNarasimhanFiltration.filtration μ (i + 2)),\n          ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "List.rec",
   "List.getLastD",
   "List.getLastD_mem_cons",
   "_private.Batteries.Data.List.Lemmas.0._proof_13",
   "List.Mem.head",
   "Eq.trans",
   "Eq.mp",
   "Iff.mp",
   "eq_true",
   "List",
   "and_true",
   "List.getLast?",
   "List.tfae_of_cycle._proof_4",
   "Iff.intro",
   "congrArg",
   "_private.Batteries.Data.List.Lemmas.0._proof_12",
   "And.intro",
   "List.Chain",
   "letFun",
   "congr",
   "forall_congr",
   "List.TFAE",
   "List.tfae_of_cycle._proof_5",
   "Eq",
   "List.getLastD_cons",
   "List.cons",
   "List.getLastD_eq_getLast?",
   "List.nil",
   "_private.Mathlib.Data.List.TFAE.0._proof_1",
   "True",
   "And.right",
   "And",
   "Option.getD",
   "Function.comp",
   "List.tfae_of_cycle._proof_3",
   "implies_true",
   "and_self",
   "of_eq_true",
   "Iff",
   "Eq.refl",
   "id",
   "Eq.mpr",
   "implies_congr_ctx",
   "And.casesOn"],
  "name": "List.tfae_of_cycle",
  "constType":
  "∀ {a b : Prop} {l : List Prop}, List.Chain (fun x1 x2 => x1 → x2) a (b :: l) → (l.getLastD b → a) → (a :: b :: l).TFAE",
  "constCategory": "Theorem"},
 {"references":
  ["le_rfl",
   "SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "inf_le_inf",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_le_inf_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a : α) {b c : α}, b ≤ c → a ⊓ b ≤ a ⊓ c",
  "constCategory": "Theorem"},
 {"references": ["Set", "iInf", "Set.instInfSet"],
  "name": "Set.iInter",
  "constType": "{α : Type u} → {ι : Sort v} → (ι → Set α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.μ_Admissible",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → [WellFoundedGT ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references": ["Subtype", "Set", "Membership.mem", "Set.instMembership"],
  "name": "Set.Elem",
  "constType": "{α : Type u} → Set α → Type u",
  "constCategory": "Definition"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_4._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Inhabited"],
  "name": "Inhabited.default",
  "constType": "{α : Sort u} → [self : Inhabited α] → α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instIsTransLt",
   "instHAdd",
   "Preorder.toLT",
   "OfNat.ofNat",
   "Nat.instPreorder",
   "LT.lt",
   "HAdd.hAdd",
   "Preorder",
   "Nat",
   "instOfNatNat",
   "Nat.rel_of_forall_rel_succ_of_lt",
   "StrictMono"],
  "name": "strictMono_nat_of_lt_succ",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α}, (∀ (n : ℕ), f n < f (n + 1)) → StrictMono f",
  "constCategory": "Theorem"},
 {"references":
  ["upperBounds", "Set", "Membership.mem", "And", "LE", "Set.instMembership"],
  "name": "IsGreatest",
  "constType": "{α : Type u_1} → [LE α] → Set α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references": ["Set", "SupSet"],
  "name": "SupSet.sSup",
  "constType": "{α : Type u_1} → [self : SupSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_trans", "Nat", "Nat.le_succ", "Nat.succ", "LE.le", "instLENat"],
  "name": "Nat.le_succ_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n ≤ m.succ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "letFun",
  "constType":
  "{α : Sort u} → {β : α → Sort v} → (v : α) → ((x : α) → β x) → β v",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Subtype",
   "Prod.mk",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.μmax._proof_2",
   "PartialOrder",
   "SupSet",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μmax._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₁.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n    HardarNarasimhan.WeakSlopeLike₁ μ",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "not_le_of_lt",
   "imp_not_comm",
   "LE.le",
   "Preorder.toLT",
   "Iff.mp",
   "Preorder.toLE"],
  "name": "not_lt_of_le",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.μmax._proof_2",
   "SupSet.sSup",
   "PartialOrder",
   "HardarNarasimhan.μmin",
   "Preorder.toLE",
   "Eq",
   "HardarNarasimhan.μB",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Eq.refl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μB.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.μB μ I =\n    sSup {x | ∃ a, ∃ (ha : HardarNarasimhan.InIntvl I a ∧ (↑I).1 ≠ a), HardarNarasimhan.μmin μ ⟨((↑I).1, a), ⋯⟩ = x}",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "CommSemiring",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "instOfNatNat",
   "congr",
   "MonoidWithZero.toMonoid",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHPow",
   "Distrib.toAdd",
   "True",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.mul_zero",
   "HPow.hPow",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "of_eq_true",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "Nat.cast_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero._proof_1",
   "Distrib.leftDistribClass",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b : R} (x : R) (e : ℕ),\n  Mathlib.Meta.NormNum.IsNat (a + b) 0 → Mathlib.Meta.NormNum.IsNat (x ^ e * a + x ^ e * b) 0",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "LE.le",
   "not_le_of_lt",
   "Preorder.toLT",
   "Preorder.toLE"],
  "name": "LT.lt.not_le",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "Set.iInter",
   "Subtype.val",
   "DFunLike.coe",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "forall_congr",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "_private.Init.Data.Subtype.0._proof_1",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "_private.Mathlib.Order.SetNotation.0._proof_4",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "Subtype.mk"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_12",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds), T.IsClosed (⋂ a ∈ 𝒮, ↑a)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Iff.trans",
   "PartialOrder.toPreorder",
   "or_comm",
   "Or",
   "Iff",
   "PartialOrder",
   "LE.le",
   "Preorder.toLT",
   "Eq",
   "Preorder.toLE",
   "le_iff_lt_or_eq"],
  "name": "le_iff_eq_or_lt",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≤ b ↔ a = b ∨ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.WeakSlopeLike₁",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references": ["PUnit.unit", "Unit"],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Exists.intro",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "Subtype.prop",
   "HardarNarasimhan.μmax",
   "HardarNarasimhan.μmin",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "sInf_le",
   "LT.lt",
   "Prod",
   "ne_of_lt",
   "le_of_lt",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "le_sSup",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.impl.rmk4d10₀",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.μmin μ I ≤ μ I ∧ μ I ≤ HardarNarasimhan.μmax μ I",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.Embedding",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Nat",
   "instHAdd",
   "instOfNatNat",
   "Nat.rec",
   "OfNat.ofNat"],
  "name": "Nat.recAux",
  "constType":
  "{motive : ℕ → Sort u} → motive 0 → ((n : ℕ) → motive n → motive (n + 1)) → (t : ℕ) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["PUnit.unit",
   "PUnit",
   "Nat",
   "Nat.succ",
   "Nat.rec",
   "Nat.below",
   "PProd",
   "Nat.zero",
   "PProd.mk"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.impl.prop3d4₀func._proof_3",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "GT.gt",
   "HardarNarasimhan.impl.prop3d4₀func._proof_7",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.impl.prop3d4₀func._proof_4",
   "HardarNarasimhan.impl.prop3d4₀func._proof_8",
   "HardarNarasimhan.impl.ℒₛ",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "Unit",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.impl.prop3d4₀func.match_1",
   "Nat",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "dite",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func._sunfold",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        [h : WellFoundedGT ℒ] →\n          {S : Type} →\n            [CompleteLattice S] →\n              ({ p // p.1 < p.2 } → S) → (I : { p // p.1 < p.2 }) → ℕ → { p // HardarNarasimhan.InIntvl I p }",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "Iff",
   "LE.le",
   "And",
   "Preorder.toLT",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "lt_iff_le_not_le",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.rfl", "setOf"],
  "name": "Set.setOf_app_iff",
  "constType": "∀ {α : Type u} {p : α → Prop} {x : α}, {x | p x} x ↔ p x",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Lattice.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "LE",
   "Subtype.val",
   "Prod.fst",
   "PartialOrder.mk",
   "PartialOrder",
   "SemilatticeSup",
   "LT.mk",
   "Eq",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Preorder",
   "lcProof",
   "Min.min",
   "Iff",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.mk",
   "LE.le",
   "Lattice.toSemilatticeInf._elambda_1",
   "SemilatticeSup.mk",
   "Subtype.mk",
   "Preorder.mk",
   "LT"],
  "name": "HardarNarasimhan.instLatticeInterval._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → Lattice (HardarNarasimhan.Interval z)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "LT.lt",
   "instLTNat",
   "Nat.find",
   "Nat",
   "Exists",
   "Subtype.property",
   "And",
   "Nat.findX",
   "DecidablePred",
   "Subtype.val",
   "And.left"],
  "name": "Nat.find_spec",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n), p (Nat.find H)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "LE.le", "Membership.mem", "LE", "Set.instMembership", "setOf"],
  "name": "lowerBounds",
  "constType": "{α : Type u_1} → [LE α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "SemilatticeSup.toPartialOrder",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "le_sup_left",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Max.max",
   "SemilatticeSup.toMax",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HardarNarasimhan.Interval z), ↑a ≤ ↑a ⊔ ↑b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HEq",
  "constType": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "Iff",
   "funext",
   "Membership.mem",
   "Eq",
   "propext",
   "Set.instMembership"],
  "name": "Set.ext",
  "constType":
  "∀ {α : Type u} {a b : Set α}, (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And.right",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instBoundedOrderInterval._proof_14",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a : HardarNarasimhan.Interval z), ↑a ≤ (↑z).2",
  "constCategory": "Theorem"},
 {"references": ["Set"],
  "name": "setOf",
  "constType": "{α : Type u} → (α → Prop) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Preorder.toLT",
   "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "AddMonoidWithOne.toAddMonoid",
   "Semiring.toNonAssocSemiring",
   "IsCancelAdd.toIsRightCancelAdd",
   "PartialOrder",
   "Zero.toOfNat0",
   "add_lt_of_neg_of_le",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Preorder.toLE",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "IsStrictOrderedRing.toIsOrderedCancelAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "IsStrictOrderedRing.toIsOrderedRing",
   "instHAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsOrderedAddMonoid.toAddLeftMono",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "AddCommMonoid.toAddCommSemigroup",
   "AddZeroClass.toAdd",
   "MulZeroClass.toZero",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "covariant_swap_add_of_covariant_add",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Linarith.add_lt_of_neg_of_le",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [inst_1 : PartialOrder α] [IsStrictOrderedRing α] {a b c : α},\n  a < 0 → b ≤ c → a + b < c",
  "constCategory": "Theorem"},
 {"references":
  ["le_rfl",
   "Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "sup_le_sup",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "sup_le_sup_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → ∀ (c : α), a ⊔ c ≤ b ⊔ c",
  "constCategory": "Theorem"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.WeakAscendingChainCondition.mk",
   "Preorder.toLT",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HardarNarasimhan.WeakAscendingChainCondition.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n    HardarNarasimhan.WeakAscendingChainCondition μ",
  "constCategory": "Definition"},
 {"references": ["Eq.symm", "Ne", "Eq"],
  "name": "Ne.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "BoundedOrder",
   "Bot.bot",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "eq_false",
   "Nontrivial",
   "Top.top",
   "False",
   "OrderBot.toBot",
   "bot_ne_top",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop"],
  "name": "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_36",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : BoundedOrder α] [Nontrivial α], (⊥ = ⊤) = False",
  "constCategory": "Theorem"},
 {"references": ["Preorder"],
  "name": "ClosureOperator",
  "constType": "(α : Type u_1) → [Preorder α] → Type u_1",
  "constCategory": "Other"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Subtype.partialOrder",
   "ClosureOperator",
   "Union.union",
   "DFunLike.coe",
   "Subtype.val",
   "congrArg",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "Eq.symm",
   "ClosureOperator.isClosed_closure",
   "Preorder.toLE",
   "Set.instUnion",
   "Eq.rec",
   "Eq",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Set.subset_union_right",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
   "Subtype.coe_eq_of_eq_mk",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "Subtype.mk"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_3",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds), B ≤ ⟨T (↑A ∪ ↑B), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "HardarNarasimhan.TotIntvl._proof_1",
   "Subtype.val",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "SupSet.sSup",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Set.ext",
   "setOf",
   "Ne.symm",
   "Subtype",
   "Prod.fst",
   "congrArg",
   "Iff.intro",
   "HardarNarasimhan.μmax",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.in_TotIntvl",
   "HardarNarasimhan.TotIntvl",
   "LT.lt",
   "ne_of_lt",
   "Ne",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop4d3_helper",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  sSup {x | ∃ y, ∃ (hy : ⊥ < y), μ ⟨(⊥, y), hy⟩ = x} = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Set.inter_subset_right",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Inter.inter",
   "ClosureOperator",
   "Subtype.val",
   "DFunLike.coe",
   "Set.inter_subset_left",
   "ClosureOperator.monotone",
   "And.intro",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "Preorder.toLE",
   "Eq.rec",
   "Eq",
   "Set.instInter",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "And.right",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_5",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "ClosureOperator.IsClosed.closure_eq",
   "Subtype.mk"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_7",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds) ⦃a : α⦄, a ∈ ↑⟨↑A ∩ ↑B, ⋯⟩ → a ∈ ↑B",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "add_add_add_comm",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "instOfNatNat",
   "Mathlib.Meta.NormNum.IsNat.out",
   "Zero.toOfNat0",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq.ndrec",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "Eq.refl",
   "Nat.cast_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "id",
   "Eq.mpr",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b₁ b₂ c : R},\n  Mathlib.Meta.NormNum.IsNat (a₁ + b₁) 0 → a₂ + b₂ = c → a₁ + a₂ + (b₁ + b₂) = c",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Bool.false",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "HardarNarasimhan.impl.HNFil_prop_of_def",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "Ring.toSemiring",
   "Linarith.mul_neg",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Top.top",
   "Int.negOfNat",
   "Int.instCharZero",
   "HardarNarasimhan.impl.HNFil_is_strict_mono",
   "lt_top_iff_ne_top",
   "Nat.find",
   "Mathlib.Tactic.Ring.add_mul",
   "HardarNarasimhan.Convex_of_Convex_large",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "HardarNarasimhan.impl.HNFil",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "HardarNarasimhan.impl.prop3d7₂",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Preorder.toLT",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_zero",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "HardarNarasimhan.impl.HNFil_of_fin_len",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "le_top",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "le_of_lt",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.μ_Admissible",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Bool",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "WellFoundedGT",
   "Mathlib.Tactic.Ring.mul_add",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "Nat.find_min",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Mathlib.Tactic.Ring.zero_mul",
   "lt_trans",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "bot_le",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "And.intro",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "upperBounds",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.StI",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HardarNarasimhan.impl.HNFil_μA_pseudo_strict_anti",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ] (i : ℕ) (hi : i + 1 < Nat.find ⋯),\n  ¬HardarNarasimhan.μA μ ⟨(HardarNarasimhan.impl.HNFil μ i, HardarNarasimhan.impl.HNFil μ (i + 1)), ⋯⟩ ≤\n      HardarNarasimhan.μA μ ⟨(HardarNarasimhan.impl.HNFil μ (i + 1), HardarNarasimhan.impl.HNFil μ (i + 2)), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "Set.iInter",
   "Subtype.val",
   "DFunLike.coe",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.prop",
   "forall_congr",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_12",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "_private.Init.Data.Subtype.0._proof_1",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "_private.Mathlib.Order.SetNotation.0._proof_4",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "Subtype.mk"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_13",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds), ∀ A ∈ 𝒮, ∀ ⦃x : α⦄, x ∈ ↑⟨⋂ a ∈ 𝒮, ↑a, ⋯⟩ → x ∈ ↑A",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub",
   "AddGroup.mk",
   "Nat.cast",
   "Zero.ofOfNat0",
   "Int.zero_add",
   "HMul.hMul",
   "Int.add_zero",
   "Int.instAddCommGroup._proof_4",
   "Int.instMul",
   "Int.zero_mul",
   "AddCommGroup.mk",
   "Int.instAdd",
   "Int.sub_eq_add_neg",
   "SubNegMonoid.mk",
   "AddSemigroup.mk",
   "instNatCastInt",
   "Int.add_assoc",
   "Int.instAddCommGroup._proof_3",
   "AddCommGroup",
   "Int.instNegInt",
   "AddMonoid.mk",
   "Int",
   "Nat",
   "instOfNat",
   "Int.add_left_neg",
   "Int.add_comm",
   "instHMul"],
  "name": "Int.instAddCommGroup",
  "constType": "AddCommGroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Min.min",
   "SemilatticeInf.le_inf",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "le_inf",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.impl.rmk4d10₀",
   "OmegaCompletePartialOrder.toPartialOrder",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.μmax",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.μmin",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.μmin_lt_μ_lt_μmax",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.μmin μ I ≤ μ I ∧ μ I ≤ HardarNarasimhan.μmax μ I",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "not_lt",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "_private.Mathlib.Order.Defs.LinearOrder.0._proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.NashEquilibrium.casesOn",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.NashEquilibrium",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.μAstar",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.NashEquilibrium.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u → HardarNarasimhan.NashEquilibrium μ → HardarNarasimhan.NashEquilibrium μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "CompleteLattice.le_sInf",
   "PartialOrder.toPreorder",
   "OrderDual.instCompleteLattice._proof_29",
   "OrderDual.instLattice",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "OrderDual.instCompleteLattice._proof_30",
   "OrderDual.supSet",
   "BoundedOrder.toOrderTop",
   "OrderDual.infSet",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.sSup_le",
   "OrderDual.instLE",
   "OrderBot.toBot",
   "Preorder.toLE",
   "CompleteLattice.sInf_le",
   "CompleteLattice.le_sSup",
   "CompleteLattice.mk",
   "CompleteLattice.toLattice",
   "BoundedOrder",
   "CompleteSemilatticeInf.toInfSet",
   "BoundedOrder.toOrderBot",
   "OrderDual.instBoundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toBoundedOrder",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "OrderDual.instCompleteLattice",
  "constType": "{α : Type u_1} → [CompleteLattice α] → CompleteLattice αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_8",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "Set.Elem",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_10",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_2",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_3",
   "Nat.lt_add_one",
   "Unit",
   "Set.instMembership",
   "Prod",
   "HardarNarasimhan.impl.prop4d1₁_seq",
   "Nat",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "StrictMono",
   "setOf",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_9",
   "Subtype",
   "Nat.instPreorder",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_1",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_4",
   "Not",
   "Set.Nonempty",
   "HardarNarasimhan.impl.prop4d1₁_seq.match_1",
   "le_top",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._sunfold",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [inst_1 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_2 : CompleteLattice S] →\n            (μ : { p // p.1 < p.2 } → S) →\n              (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                    μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                  {YA |\n                        ∃ (h : YA < ⊤),\n                          ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty →\n                    ℕ → ↑{YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Definition"},
 {"references":
  ["ConditionallyCompleteLinearOrder.compare_eq_compareOfLessAndEq",
   "ConditionallyCompleteLinearOrder.toLinearOrder._proof_3",
   "Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "ConditionallyCompleteLinearOrder.toLinearOrder._proof_4",
   "Lattice.toSemilatticeInf",
   "ConditionallyCompleteLinearOrder.toDecidableLE",
   "ConditionallyCompleteLinearOrder",
   "LinearOrder",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder.mk",
   "ConditionallyCompleteLinearOrder.le_total",
   "ConditionallyCompleteLinearOrder.toDecidableEq",
   "ConditionallyCompleteLinearOrder.toDecidableLT",
   "ConditionallyCompleteLinearOrder.toOrd",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "SemilatticeSup.toMax",
   "ConditionallyCompleteLattice.toLattice"],
  "name": "ConditionallyCompleteLinearOrder.toLinearOrder",
  "constType":
  "{α : Type u_1} → [ConditionallyCompleteLinearOrder α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "CommSemiring",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "Eq.ndrec",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddZeroClass.toZero",
   "instHAdd",
   "mul_add",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Distrib.leftDistribClass",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.mul_add",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₁ b₂ c₁ c₂ d : R},\n  a * b₁ = c₁ → a * b₂ = c₂ → c₁ + 0 + c₂ = d → a * (b₁ + b₂) = d",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.Semistable",
   "HardarNarasimhan.Semistable.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.Semistable.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℒ) (hx : x ≠ ⊥), ¬HardarNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HardarNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩) →\n    HardarNarasimhan.Semistable μ",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "CompleteLattice.le_sInf",
   "Set.Nonempty",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "CompleteLattice.toInfSet",
   "Set",
   "CompleteLattice.toLattice",
   "Membership.mem",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "BddBelow",
   "BddAbove",
   "Set.instMembership",
   "upperBounds",
   "ConditionallyCompleteLattice",
   "lowerBounds",
   "CompleteLattice.sSup_le",
   "Preorder.toLE",
   "CompleteLattice",
   "ConditionallyCompleteLattice.mk",
   "CompleteLattice.sInf_le"],
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_1} → [CompleteLattice α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "HardarNarasimhan.μA_DescendingChainCondition.mk",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μA_DescendingChainCondition.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.μA_DescendingChainCondition μ → Sort u} →\n                ((μ_dcc :\n                      ∀ (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n                        (∀ (n : ℕ), f n > f (n + 1)) →\n                          ∃ N, HardarNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(a, f N), ⋯⟩) →\n                    motive ⋯) →\n                  (t : HardarNarasimhan.μA_DescendingChainCondition μ) → motive t",
  "constCategory": "Other"},
 {"references": [],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace",
  "constType": "Type → Type",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.toDual",
   "OrderDual",
   "Exists",
   "Equiv.instFunLike",
   "OrderDual.exists",
   "Eq",
   "DFunLike.coe",
   "Equiv",
   "propext"],
  "name": "_private.Mathlib.Order.Synonym.0._proof_6",
  "constType":
  "∀ {α : Type u_1} {p : αᵒᵈ → Prop}, (∃ a, p a) = ∃ a, p (OrderDual.toDual a)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "Membership.mem",
   "isGLB_sInf",
   "CompleteSemilatticeInf",
   "Set.instMembership",
   "CompleteSemilatticeInf.toInfSet",
   "Iff",
   "CompleteSemilatticeInf.toPartialOrder",
   "InfSet.sInf",
   "LE.le",
   "le_isGLB_iff",
   "Preorder.toLE"],
  "name": "le_sInf_iff",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, a ≤ sInf s ↔ ∀ b ∈ s, a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "HardarNarasimhan.impl.instμ_Admissible",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "Exists",
   "Lean.Omega.combo_sat'",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "HardarNarasimhan.impl.HNFil",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "instHSub",
   "PartialOrder.toPreorder",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Int.instNegInt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "instDecidableEqBool",
   "Nat",
   "Nat.lt_of_not_le",
   "Nontrivial",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.cast",
   "instDecidableAnd",
   "Subtype",
   "HardarNarasimhan.Convex",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HardarNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HardarNarasimhan.Convex μ) (f : ℕ → ℒ),\n  (∃ n, f n = ⊤) →\n    ∀ (n : ℕ) (h₂ : ∃ N ≥ n + 1, HardarNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n      Nat.find h₂ ≥ n + 1 → ¬n ≤ Nat.find h₂ - 1 → False",
  "constCategory": "Theorem"},
 {"references":
  ["IsStrictOrderedRing.toPosMulStrictMono",
   "PartialOrder.toPreorder",
   "IsStrictOrderedRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "mul_le_mul_of_nonneg_left",
   "IsOrderedRing.mk",
   "MulPosStrictMono.toMulPosMono",
   "IsOrderedRing",
   "Semiring.toNonAssocSemiring",
   "mul_le_mul_of_nonneg_right",
   "MulZeroClass.toZero",
   "PartialOrder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsOrderedCancelAddMonoid.toIsOrderedAddMonoid",
   "PosMulStrictMono.toPosMulMono",
   "IsStrictOrderedRing.toMulPosStrictMono",
   "Semiring",
   "IsStrictOrderedRing.toIsOrderedCancelAddMonoid",
   "IsStrictOrderedRing.toZeroLEOneClass"],
  "name": "IsStrictOrderedRing.toIsOrderedRing",
  "constType":
  "∀ {R : Type u} [inst : Semiring R] [inst_1 : PartialOrder R] [IsStrictOrderedRing R], IsOrderedRing R",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_imp", "And", "Eq", "propext"],
  "name": "_private.Init.Classical.0._proof_13",
  "constType": "∀ {a b : Prop}, (¬(a → b)) = (a ∧ ¬b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Inhabited",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["LE.le", "LE", "RelEmbedding"],
  "name": "OrderEmbedding",
  "constType":
  "(α : Type u_6) → (β : Type u_7) → [LE α] → [LE β] → Type (max u_6 u_7)",
  "constCategory": "Definition"},
 {"references": ["_obj", "HardarNarasimhan.μAstar._rarg", "_neutral"],
  "name": "HardarNarasimhan.μAstar._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Preorder",
   "LE.le",
   "not_le_of_lt",
   "Preorder.toLT",
   "Preorder.toLE",
   "GT.gt"],
  "name": "not_le_of_gt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a > b → ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Max"],
  "name": "Max.max",
  "constType": "{α : Type u} → [self : Max α] → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "GaloisConnection.lowerAdjoint",
   "OrderDual",
   "OrderDual.toDual",
   "PartialOrder.toPreorder",
   "Subtype",
   "LowerAdjoint.toFun",
   "OmegaCompletePartialOrder.toPartialOrder",
   "DFunLike.coe",
   "Equiv",
   "OrderDual.ofDual",
   "HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "HardarNarasimhan.DedekindMacNeilleConnection",
   "PartialOrder",
   "Subtype.le",
   "Eq",
   "Preorder.toLE",
   "Set.instLE",
   "Function.Embedding.mk",
   "RelEmbedding.mk",
   "Equiv.instFunLike",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "Function.Embedding",
   "OrderEmbedding",
   "Set.Iic",
   "HardarNarasimhan.DedekindMacNeilleCompletion",
   "OrderDual.instPreorder",
   "lcProof",
   "upperBounds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff",
   "LE.le",
   "lowerBounds",
   "Subtype.mk"],
  "name": "HardarNarasimhan.coe'._cstage1",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → α ↪o HardarNarasimhan.DedekindMacNeilleCompletion α",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.zsmul_succ'",
   "AddGroupWithOne.sub_eq_add_neg",
   "AddGroupWithOne.zsmul",
   "AddGroup.mk",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroupWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toSub",
   "AddGroupWithOne.zsmul_neg'",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne.neg_add_cancel",
   "AddGroup",
   "AddGroupWithOne.zsmul_zero'",
   "SubNegMonoid.mk"],
  "name": "AddGroupWithOne.toAddGroup",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddGroup R",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "Nat.cast",
   "Iff.mpr",
   "Int.instLTInt",
   "Int.ofNat_lt",
   "instNatCastInt",
   "Int"],
  "name": "Lean.Omega.Int.ofNat_lt_of_lt",
  "constType": "∀ {x y : ℕ}, x < y → ↑x < ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["Set.inter_subset_right",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Inter.inter",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "ClosureOperator",
   "Subtype.val",
   "DFunLike.coe",
   "Set.inter_subset_left",
   "And.intro",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "Preorder.toLE",
   "Eq.rec",
   "Eq",
   "Set.instInter",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "ClosureOperator.IsClosed.closure_eq"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_5",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds), T.IsClosed (↑A ∩ ↑B)",
  "constCategory": "Theorem"},
 {"references": ["MulZeroClass", "Zero"],
  "name": "MulZeroClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SupSet",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MulZeroClass.mk",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → MulZeroClass α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{α : Sort u} → [i : α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.trans",
   "Not",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "SemilatticeSup.toPartialOrder",
   "LE.le.lt_iff_ne",
   "right_eq_sup",
   "LT.lt",
   "Max.max",
   "le_sup_right",
   "Iff",
   "not_congr",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Ne",
   "Eq",
   "Preorder.toLE"],
  "name": "right_lt_sup",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b < a ⊔ b ↔ ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "instLTNat",
   "Nat.find",
   "Nat",
   "Exists",
   "Subtype.property",
   "And.right",
   "And",
   "Nat.findX",
   "DecidablePred",
   "Subtype.val"],
  "name": "Nat.find_min",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n) {m : ℕ}, m < Nat.find H → ¬p m",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Preorder.toLT",
   "BoundedOrder",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Iff.mpr",
   "Nontrivial",
   "Top.top",
   "Ne",
   "OrderBot.toBot",
   "bot_ne_top",
   "lt_top_iff_ne_top",
   "Preorder.toLE",
   "OrderTop.toTop"],
  "name": "bot_lt_top",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : BoundedOrder α] [Nontrivial α], ⊥ < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "HardarNarasimhan.μBstar",
   "le_trans",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HardarNarasimhan.WeakSlopeLike₁.wsl₁",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "HardarNarasimhan.WeakSlopeLike₂.wsl₂",
   "HardarNarasimhan.WeakAscendingChainCondition.wacc",
   "OrderBot.toBot",
   "Eq",
   "Eq.rec",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "HardarNarasimhan.impl.prop4d1₁",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.impl.rmk4d10₀",
   "HardarNarasimhan.TotIntvl",
   "And.right",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakDescendingChainCondition.wdcc",
   "Bot.bot",
   "HardarNarasimhan.WeakSlopeLike₂",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HardarNarasimhan.impl.prop4d3₁",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop4d11₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.WeakAscendingChainCondition μ →\n    HardarNarasimhan.WeakSlopeLike₁ μ →\n      HardarNarasimhan.WeakDescendingChainCondition μ →\n        HardarNarasimhan.WeakSlopeLike₂ μ →\n          HardarNarasimhan.μBstar μ ≤ HardarNarasimhan.μAstar μ →\n            HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instMonoid",
   "Int.mul_add",
   "NonUnitalNonAssocSemiring.mk",
   "AddCommGroup.toAddGroup",
   "Int.instCommRing._proof_3",
   "Int.instCommRing._proof_10",
   "Int.one_mul",
   "Int.instCommRing._proof_12",
   "SubNegMonoid.toSub",
   "AddGroup.toSubNegMonoid",
   "CommSemigroup",
   "instHPow",
   "CommRing.mk",
   "SubNegMonoid.zsmul",
   "AddCommMonoid.mk",
   "Int.instCommRing._proof_4",
   "Int.mul_zero",
   "NatCast.mk",
   "Nat",
   "Int.instCommRing._proof_8",
   "Int.mul_one",
   "Nat.cast",
   "Int.instCommSemigroup",
   "Semigroup.toMul",
   "Int.zero_mul",
   "Int.instAddCommGroup",
   "MulOneClass.toOne",
   "Monoid.toMulOneClass",
   "Int.instCommRing._proof_5",
   "Int.instCommRing._proof_6",
   "Ring.mk",
   "instNatCastInt",
   "NonUnitalSemiring.mk",
   "AddCommGroup.add_comm",
   "SubNegMonoid.toNeg",
   "Int.instCommRing._proof_7",
   "Int.instCommRing._proof_9",
   "Int.instCommRing._proof_1",
   "Semiring.mk",
   "AddCommGroup",
   "Int.instCommRing._proof_2",
   "CommRing",
   "HPow.hPow",
   "Int",
   "Int.add_mul",
   "CommSemigroup.mul_comm",
   "Int.instCommRing._proof_11",
   "SubNegMonoid.toAddMonoid",
   "Monoid.toNatPow",
   "CommSemigroup.toSemigroup",
   "IntCast.mk"],
  "name": "Int.instCommRing",
  "constType": "CommRing ℤ",
  "constCategory": "Definition"},
 {"references": ["Lattice", "SemilatticeSup"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeSup α",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1",
   "Nat.rawCast",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
  "constType":
  "∀ {α : Type u} {a : α} {n : ℕ} [inst : AddMonoidWithOne α], Mathlib.Meta.NormNum.IsNat a n → a = n.rawCast",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "instHAdd",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddGroup",
   "Zero.toOfNat0",
   "Eq",
   "AddSemigroup.toAdd"],
  "name": "AddGroup.mk",
  "constType":
  "{A : Type u} → [toSubNegMonoid : SubNegMonoid A] → (∀ (a : A), -a + a = 0) → AddGroup A",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "Eq.trans",
   "Eq.mpr_not",
   "Classical.propDecidable",
   "eq_true",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "HardarNarasimhan.impl.prop3d4₀func._proof_4",
   "False.elim",
   "HardarNarasimhan.impl.prop3d4₀func._proof_8",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.ndrec",
   "LT.lt.not_le",
   "HardarNarasimhan.impl.prop3d4₀func_helper",
   "Exists",
   "Exists.choose_spec",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "eq_false",
   "Eq.refl",
   "Lattice",
   "Classical.byContradiction",
   "Eq.mpr",
   "HardarNarasimhan.impl.ℒₛ._proof_2",
   "instDecidableTrue",
   "Prod.fst",
   "instOfNatNat",
   "congr",
   "HardarNarasimhan.impl.ℒₛ",
   "WellFoundedGT",
   "not_true_eq_false",
   "Eq",
   "Preorder.toLE",
   "Set",
   "HardarNarasimhan.impl.ℒₛ._proof_1",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "dite_cond_eq_true",
   "Ne",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le.ge",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "WellFounded.has_min",
   "_private.Init.Core.0._proof_38",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "HardarNarasimhan.impl.prop3d4₀func._proof_7",
   "And.intro",
   "PartialOrder",
   "funext",
   "forall_congr",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "of_eq_false",
   "HardarNarasimhan.InIntvl",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "Nat",
   "Nontrivial",
   "id",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "congrArg",
   "dite_congr",
   "Subtype.prop",
   "IsWellFounded.wf",
   "instDecidableFalse",
   "dite_cond_eq_false",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "HardarNarasimhan.impl.prop3d4₀func",
   "gt_of_ge_of_gt",
   "Exists.choose",
   "Eq.mpr_prop",
   "LT.lt",
   "ne_of_lt",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39"],
  "name": "HardarNarasimhan.impl.prop3d4₀func_defprop2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ)\n  (hi : (↑I).1 ≠ ↑(HardarNarasimhan.impl.prop3d4₀func μ I (i + 1))) (z : ℒ)\n  (hz : ↑(HardarNarasimhan.impl.prop3d4₀func μ I (i + 1)) < z ∧ z ≤ ↑(HardarNarasimhan.impl.prop3d4₀func μ I i)),\n  ¬HardarNarasimhan.μA μ ⟨((↑I).1, z), ⋯⟩ ≥\n      HardarNarasimhan.μA μ ⟨((↑I).1, ↑(HardarNarasimhan.impl.prop3d4₀func μ I (i + 1))), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Subtype.lt", "Subtype", "Iff", "Subtype.mk", "Iff.rfl", "LT"],
  "name": "Subtype.mk_lt_mk",
  "constType":
  "∀ {α : Type u_2} [inst : LT α] {p : α → Prop} {x y : α} {hx : p x} {hy : p y}, ⟨x, hx⟩ < ⟨y, hy⟩ ↔ x < y",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "_private.Init.Classical.0._proof_9",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "False.elim",
   "Or",
   "letFun",
   "forall_congr",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Exists.choose_spec",
   "Or.resolve_left",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_3",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Nat",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Lattice",
   "Classical.byContradiction",
   "Top.top",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_6",
   "setOf",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_5",
   "_private.Init.Classical.0._proof_7",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "Prod.fst",
   "congrArg",
   "_private.Init.PropLemmas.0._proof_15",
   "not_lt_top_iff",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "not_true_eq_false",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "_private.Init.Classical.0._proof_13",
   "Exists.choose",
   "exists_prop_congr",
   "LT.lt",
   "Nat.succ",
   "LE.le",
   "Nat.below",
   "False",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "And.casesOn"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._proof_7",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S),\n  (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n    ∀ (k : ℕ) (x : Nat.below k.succ),\n      ⋯.choose ∈ {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZero",
   "Real",
   "PartialOrder",
   "NNReal",
   "LE.le",
   "Subtype.partialOrder",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Real.partialOrder",
   "Real.instLE"],
  "name": "instNNRealPartialOrder",
  "constType": "PartialOrder NNReal",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "Nat.add_sub_of_le",
   "Nat.add_comm",
   "congrArg",
   "HAdd.hAdd",
   "Nat",
   "instSubNat",
   "Eq.refl",
   "LE.le",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "Eq",
   "instHSub",
   "instLENat"],
  "name": "Nat.sub_add_cancel",
  "constType": "∀ {n m : ℕ}, m ≤ n → n - m + m = n",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "PosSMulStrictMono",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "Real",
   "AddCommGroup.add_comm",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "Real.semiring",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.toModule",
   "LinearOrder.toPartialOrder",
   "MulAction.toSMul",
   "Module.toDistribMulAction",
   "Real.instZero",
   "SubNegMonoid.toAddMonoid",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.toPosSMulStrictMono",
  "constType":
  "∀ {V : Type} [self : HardarNarasimhan.TotallyOrderedRealVectorSpace V], PosSMulStrictMono ℝ V",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.sound", "letFun", "Quot.liftOn", "Eq", "Quot.mk", "Quot", "congrArg"],
  "name": "funext",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.Semistable",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["HAdd",
   "Int.add_assoc",
   "Eq.trans",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Coeffs",
   "congrArg",
   "Int",
   "Lean.Omega.LinearCombo.mk",
   "HAdd.hAdd",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "Eq.refl",
   "congr",
   "Lean.Omega.IntList.instAdd",
   "Int.instAdd",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Eq.mpr",
   "Eq.rec",
   "Int.add_left_comm",
   "Lean.Omega.LinearCombo.casesOn",
   "Eq",
   "Lean.Omega.LinearCombo.instAdd",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.add_eval",
  "constType":
  "∀ (l₁ l₂ : Omega.LinearCombo) (v : Omega.Coeffs), (l₁ + l₂).eval v = l₁.eval v + l₂.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["IsOrderedAddMonoid.mk",
   "PartialOrder.toPreorder",
   "Nat.instPartialOrder",
   "instHAdd",
   "Nat.add_le_add_left",
   "Nat.instAddCommMonoid",
   "congrArg",
   "HAdd.hAdd",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "IsOrderedAddMonoid",
   "LE.le",
   "id",
   "Eq.mpr",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Eq",
   "Preorder.toLE",
   "add_comm"],
  "name": "Nat.instIsOrderedAddMonoid",
  "constType": "IsOrderedAddMonoid ℕ",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocRing", "NonAssocRing"],
  "name": "NonAssocRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.ConvexI.convex",
  "constType":
  "∀ {ℒ : Type} {inst : Lattice ℒ} {S : Type} {inst_1 : CompleteLattice S} {I : { p // p.1 < p.2 }}\n  {μ : { p // p.1 < p.2 } → S} [self : HardarNarasimhan.ConvexI I μ] (x y : ℒ),\n  HardarNarasimhan.InIntvl I x → HardarNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Or.inl",
   "Set",
   "Membership.mem",
   "Set.instUnion",
   "Union.union",
   "Set.instMembership"],
  "name": "Set.subset_union_left",
  "constType": "∀ {α : Type u} {s t : Set α}, s ⊆ s ∪ t",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring.right_distrib",
   "NonUnitalNonAssocSemiring.toMul",
   "AddMonoid.toAddSemigroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Distrib",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.left_distrib",
   "Distrib.mk",
   "NonUnitalNonAssocSemiring",
   "AddSemigroup.toAdd"],
  "name": "NonUnitalNonAssocSemiring.toDistrib",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Distrib α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instAddNat",
   "HAdd.hAdd",
   "instLTNat",
   "Nat",
   "instOfNatNat",
   "instHAdd",
   "Iff",
   "LE.le",
   "Iff.rfl",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Nat.add_one_le_iff",
  "constType": "∀ {n m : ℕ}, n + 1 ≤ m ↔ n < m",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddCommMonoid.toAddMonoid",
   "IsOrderedAddMonoid.add_le_add_left",
   "HAdd.hAdd",
   "AddCommMonoid",
   "AddZeroClass.toAdd",
   "PartialOrder",
   "IsOrderedAddMonoid",
   "LE.le",
   "CovariantClass.mk",
   "Preorder.toLE",
   "AddMonoid.toAddZeroClass"],
  "name": "IsOrderedAddMonoid.toAddLeftMono",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : PartialOrder α] [IsOrderedAddMonoid α], AddLeftMono α",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "instLTNat", "Nat", "Decidable", "Nat.succ", "Nat.decLe"],
  "name": "Nat.decLt",
  "constType": "(n m : ℕ) → Decidable (n < m)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IsWellOrder",
  "constType": "(α : Type u) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["HardarNarasimhan.impl.ℒₛ._proof_2",
   "HardarNarasimhan.impl.prop3d4₀func._proof_5",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.ℒₛ",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Exists.choose_spec",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.ℒₛ._proof_1",
   "Exists.choose",
   "HardarNarasimhan.μA",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ) (x : Nat.below n.succ)\n  (hbot : ¬(↑I).1 = ↑x.1) (hne : (HardarNarasimhan.impl.ℒₛ μ I x.1 hbot).Nonempty), HardarNarasimhan.InIntvl I ⋯.choose",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSMul"],
  "name": "HSMul.hSMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "sInf_le_sInf",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "setOf",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "Prod.fst",
   "le_rfl",
   "HardarNarasimhan.μmax",
   "Preorder.toLE",
   "Eq",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.μA",
   "sInf_le",
   "LT.lt",
   "ne_of_lt",
   "Min.min",
   "le_of_lt",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.lem2d4₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (x w : ℒ) (hxw : ¬x ≤ w) (u : ℒ) (huxw : u ≤ x ⊓ w),\n  HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HardarNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["mem_upperBounds",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "GT.gt",
   "HardarNarasimhan.impl.prop3d4",
   "Subtype.val",
   "Set.Elem",
   "IsGreatest",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "IsTotal.total",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "eq_of_ge_of_not_gt",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "upperBounds",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.impl.prop3d8₁",
   "Or.inr",
   "Subtype",
   "lt_of_le_of_ne",
   "Prod.fst",
   "HardarNarasimhan.IsAttained",
   "Or.inl",
   "IsWellFounded.wf",
   "le_of_eq",
   "WellFoundedGT",
   "Eq",
   "Subtype.le",
   "Preorder.toLE",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.StI",
   "LT.lt",
   "Or.casesOn",
   "IsTotal",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d8₁'",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.μA_DescendingChainCondition μ →\n    ∀ (I : { p // p.1 < p.2 }),\n      HardarNarasimhan.ConvexI I μ →\n        ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n            ∀ (z : ℒ) (hzI : HardarNarasimhan.InIntvl I z) (hz : (↑I).1 ≠ z),\n              HardarNarasimhan.IsAttained μ ⟨((↑I).1, z), ⋯⟩) →\n          ∃ s, IsGreatest (HardarNarasimhan.StI μ I) s",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HardarNarasimhan.WeakDescendingChainCondition.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakDescendingChainCondition.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    HardarNarasimhan.WeakDescendingChainCondition μ",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat"],
  "name": "Mathlib.Meta.NormNum.isNat_ofNat",
  "constType":
  "∀ (α : Type u) [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, ↑n = a → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "HardarNarasimhan.impl.HNFil",
   "instOfNatNat",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ], HardarNarasimhan.impl.HNFil μ 0 = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "_neutral",
   "GaloisConnection.closureOperator._at.HardarNarasimhan.DedekindMacNeilleClosureOperator._spec_1"],
  "name": "HardarNarasimhan.DedekindMacNeilleClosureOperator._cstage2",
  "constType": "_neutral → _obj → _neutral",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_5",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "Prod.fst",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nat.below",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (k : ℕ) (x : Nat.below k.succ),\n  ∃ xB, ∃ (hAB : ↑x.1 < xB), ¬μ ⟨(↑x.1, xB), hAB⟩ ≤ μ ⟨(↑x.1, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "AddMonoid.nsmul_zero._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "_private.Init.PropLemmas.0._proof_25",
   "GT.gt",
   "Subtype.val",
   "_private.Mathlib.Data.Set.Operations.0._proof_5",
   "And.intro",
   "letFun",
   "funext",
   "Set.Nonempty.image",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "WellFounded",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "lt_iff_le_not_le",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Set.image",
   "Iff.of_eq",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Subtype",
   "Eq.mp",
   "Prod.fst",
   "congrArg",
   "_private.Init.PropLemmas.0._proof_23",
   "WellFounded.wellFounded_iff_has_min",
   "_private.Init.Data.Subtype.0._proof_2",
   "IsWellFounded.wf",
   "WellFoundedGT",
   "Set.mem_image_of_mem",
   "Preorder.toLE",
   "Eq",
   "propext",
   "HardarNarasimhan.instLatticeInterval",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Set",
   "IsWellFounded.mk",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "Subtype.mk"],
  "name": "HardarNarasimhan.instWellFoundedGTInterval",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hw : WellFoundedGT ℒ]\n  {z : { p // p.1 < p.2 }}, WellFoundedGT (HardarNarasimhan.Interval z)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lattice.toSemilatticeInf._rarg",
   "HardarNarasimhan.instLatticeInterval._rarg",
   "_neutral",
   "BoundedOrder.mk"],
  "name": "HardarNarasimhan.instBoundedOrderInterval._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.Convex",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "HardarNarasimhan.μ_Admissible",
   "Nat.instPreorder",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Monotone",
   "HardarNarasimhan.HardarNarasimhanFiltration.filtration",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.monotone",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HardarNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HardarNarasimhan.Convex μ} {h : HardarNarasimhan.μ_Admissible μ}\n  [self : HardarNarasimhan.HardarNarasimhanFiltration μ],\n  Monotone (HardarNarasimhan.HardarNarasimhanFiltration.filtration μ)",
  "constCategory": "Theorem"},
 {"references": ["PartialOrder", "SemilatticeSup"],
  "name": "SemilatticeSup.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.coe_injective",
   "Subtype",
   "PartialOrder",
   "PartialOrder.lift",
   "Subtype.val"],
  "name": "Subtype.partialOrder",
  "constType":
  "{α : Type u_2} → [PartialOrder α] → (p : α → Prop) → PartialOrder (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "CompleteLattice.le_sSup",
   "CompleteLattice.toLattice",
   "CompleteSemilatticeSup",
   "CompleteLattice.sSup_le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "CompleteSemilatticeSup.mk",
   "CompleteLattice"],
  "name": "CompleteLattice.toCompleteSemilatticeSup",
  "constType":
  "{α : Type u_8} → [self : CompleteLattice α] → CompleteSemilatticeSup α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.instNontrivialInterval",
   "Subtype.val",
   "Prod.fst",
   "Iff.intro",
   "Subtype.prop",
   "Preorder.toLE",
   "HardarNarasimhan.instBoundedOrderInterval",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.instLatticeInterval",
   "HardarNarasimhan.Resμ",
   "Not",
   "HardarNarasimhan.ConvexI.convex",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.ConvexI.mk",
   "LT.lt",
   "Prod",
   "Iff",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.ConvexI_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ ↔ HardarNarasimhan.Convex (HardarNarasimhan.Resμ I μ)",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references": ["LT.lt", "OrderDual", "LT.mk", "LT"],
  "name": "OrderDual.instLT",
  "constType": "(α : Type u_5) → [LT α] → LT αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["One", "MulOneClass"],
  "name": "MulOneClass.toOne",
  "constType": "{M : Type u} → [self : MulOneClass M] → One M",
  "constCategory": "Definition"},
 {"references":
  ["IsOrderedAddMonoid.mk",
   "PartialOrder.toPreorder",
   "IsOrderedCancelAddMonoid.mk",
   "Eq.mp",
   "Nat.le_of_add_le_add_left",
   "Nat.instPartialOrder",
   "instHAdd",
   "Nat.add_le_add_left",
   "Nat.instAddCommMonoid",
   "congrArg",
   "HAdd.hAdd",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "LE.le",
   "id",
   "AddCommSemigroup.toAddCommMagma",
   "Eq.mpr",
   "AddCommMagma.toAdd",
   "Eq",
   "Preorder.toLE",
   "add_comm",
   "IsOrderedCancelAddMonoid"],
  "name": "Nat.instIsOrderedCancelAddMonoid",
  "constType": "IsOrderedCancelAddMonoid ℕ",
  "constCategory": "Theorem"},
 {"references": ["SMul", "HSMul", "SMul.smul", "HSMul.mk"],
  "name": "instHSMul",
  "constType": "{α : Type u_1} → {β : Type u_2} → [SMul α β] → HSMul α β β",
  "constCategory": "Definition"},
 {"references": ["OrderDual", "LE.le", "LE.mk", "LE"],
  "name": "OrderDual.instLE",
  "constType": "(α : Type u_5) → [LE α] → LE αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "And.intro",
   "Set.image",
   "Set",
   "Membership.mem",
   "And",
   "Exists.intro",
   "Eq",
   "Set.instMembership"],
  "name": "Set.mem_image_of_mem",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) {x : α} {a : Set α}, x ∈ a → f x ∈ f '' a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.mk",
   "OrderDual.instPreorder",
   "OrderDual",
   "Preorder",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "inferInstanceAs",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "OrderDual.instPartialOrder",
  "constType": "(α : Type u_5) → [PartialOrder α] → PartialOrder αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HardarNarasimhan.WeakDescendingChainCondition.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakDescendingChainCondition.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakDescendingChainCondition μ → Sort u} →\n                ((wdcc : ∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n                    motive ⋯) →\n                  (t : HardarNarasimhan.WeakDescendingChainCondition μ) → motive t",
  "constCategory": "Other"},
 {"references": ["DivisionMonoid", "DivisionCommMonoid"],
  "name": "DivisionCommMonoid.toDivisionMonoid",
  "constType":
  "{G : Type u} → [self : DivisionCommMonoid G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.isInt_mul.match_1",
   "Ring.toNonAssocRing",
   "Int.mul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Distrib.toMul",
   "HMul.hMul",
   "Int.cast",
   "Int.instMul",
   "Int",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "Ring.toAddGroupWithOne",
   "Int.cast_mul",
   "NonAssocRing.toAddCommGroupWithOne",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.symm",
   "AddGroupWithOne.toIntCast",
   "instHMul",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.isInt_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → a'.mul b' = c → Mathlib.Meta.NormNum.IsInt (a * b) c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "CompleteSemilatticeSup",
   "Membership.mem",
   "isLUB_sSup",
   "CompleteSemilatticeSup.toSupSet",
   "Set.instMembership",
   "SupSet.sSup",
   "Iff",
   "isLUB_le_iff",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sSup_le_iff",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, sSup s ≤ a ↔ ∀ b ∈ s, b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "DFunLike.mk",
   "Equiv.instFunLike._proof_2",
   "Equiv.toFun",
   "Equiv"],
  "name": "Equiv.instFunLike",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ≃ β) α β",
  "constCategory": "Definition"},
 {"references": ["Preorder", "Iff", "LE.le", "Preorder.toLE"],
  "name": "GaloisConnection",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → (β → α) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "not_lt",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_lt_eq",
  "constType":
  "∀ {β : Type u_2} [inst : LinearOrder β] (a b : β), (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.inter_subset_right",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Inter.inter",
   "ClosureOperator",
   "Subtype.val",
   "DFunLike.coe",
   "Set.inter_subset_left",
   "ClosureOperator.monotone",
   "And.intro",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "Preorder.toLE",
   "Eq.rec",
   "Eq",
   "Set.instInter",
   "And.left",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_5",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "ClosureOperator.IsClosed.closure_eq",
   "Subtype.mk"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_6",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds) ⦃a : α⦄, a ∈ ↑⟨↑A ∩ ↑B, ⋯⟩ → a ∈ ↑A",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "bot_le",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "Set.Elem",
   "IsGreatest",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.S₁I",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "HardarNarasimhan.St",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "HardarNarasimhan.impl.prop3d8₂",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.impl.prop3d8₁'",
   "HardarNarasimhan.impl.prop3d8₁",
   "Or.inr",
   "Subtype",
   "HardarNarasimhan.Convex",
   "lt_of_le_of_ne",
   "Prod.fst",
   "HardarNarasimhan.IsAttained",
   "Or.inl",
   "HardarNarasimhan.S₂I",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Subtype.le",
   "Eq",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "HardarNarasimhan.StI",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "Exists.choose",
   "HardarNarasimhan.μA",
   "Or.casesOn",
   "LT.lt",
   "IsTotal",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_3_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Convex μ →\n    ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨ ∀ (z : ℒ) (hz : ⊥ ≠ z), HardarNarasimhan.IsAttained μ ⟨(⊥, z), ⋯⟩) →\n      ((IsTotal ↑(HardarNarasimhan.St μ) fun x1 x2 => x1 ≤ x2) ∧\n          (HardarNarasimhan.μA_DescendingChainCondition μ → ∃ s, IsGreatest (HardarNarasimhan.St μ) s)) ∧\n        ∀ (x : ℒ) (hxSt : x ∈ HardarNarasimhan.St μ) (y : ℒ) (hxy : y > x),\n          HardarNarasimhan.μA μ ⟨(⊥, y), ⋯⟩ = HardarNarasimhan.μA μ ⟨(x, y), hxy⟩",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq.rec", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a ⋯ → motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Int.instSub",
   "Eq.mp",
   "instHAdd",
   "Neg.neg",
   "Int.instNegInt",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "Int.add_right_neg",
   "Int.add_le_add_right",
   "HAdd.hAdd",
   "instOfNat",
   "letFun",
   "LE.le",
   "Int.instAdd",
   "Int.instLEInt",
   "HSub.hSub",
   "instHSub"],
  "name": "Int.sub_nonneg_of_le",
  "constType": "∀ {a b : ℤ}, b ≤ a → 0 ≤ a - b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Int.NonNeg.mk",
   "Nat",
   "Nat.cast",
   "instOfNat",
   "instHAdd",
   "LE.le",
   "Int.instLEInt",
   "OfNat.ofNat",
   "instNatCastInt",
   "Int"],
  "name": "Int.ofNat_nonneg",
  "constType": "∀ (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub",
   "True",
   "Eq.trans",
   "instHAdd",
   "Neg.neg",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Coeffs",
   "Int.instNegInt",
   "congrArg",
   "Int",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.LinearCombo.instSub",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.sub_eq_add_neg",
   "Lean.Omega.LinearCombo.instNeg",
   "of_eq_true",
   "Int.instAdd",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.LinearCombo.instAdd",
   "Eq",
   "instHSub"],
  "name": "Lean.Omega.LinearCombo.sub_eval",
  "constType":
  "∀ (l₁ l₂ : Omega.LinearCombo) (v : Omega.Coeffs), (l₁ - l₂).eval v = l₁.eval v - l₂.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommMonoid",
   "AddCommSemigroup.mk",
   "AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "ClosureOperator.IsClosed",
   "PartialOrder",
   "ClosureOperator"],
  "name": "ClosureOperator.Closeds",
  "constType":
  "{α : Type u_1} → [inst : PartialOrder α] → ClosureOperator α → Type (max 0 u_1)",
  "constCategory": "Definition"},
 {"references":
  ["Preorder",
   "Set",
   "LE.le",
   "Membership.mem",
   "Set.mem_Iic",
   "Eq",
   "Preorder.toLE",
   "Set.Iic",
   "propext",
   "Set.instMembership"],
  "name": "_private.Mathlib.Order.Interval.Set.Defs.0._proof_5",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {b x : α}, (x ∈ Set.Iic b) = (x ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection.lowerAdjoint",
   "Preorder",
   "PartialOrder.toPreorder",
   "GaloisConnection",
   "PartialOrder",
   "LowerAdjoint.closureOperator",
   "ClosureOperator"],
  "name": "GaloisConnection.closureOperator",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_4} →\n    [inst : PartialOrder α] →\n      [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisConnection l u → ClosureOperator α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "rfl",
   "Nat",
   "Nat.cast",
   "instHAdd",
   "Int.instAdd",
   "Eq",
   "instNatCastInt",
   "Int"],
  "name": "Int.natCast_add",
  "constType": "∀ (n m : ℕ), ↑(n + m) = ↑n + ↑m",
  "constCategory": "Theorem"},
 {"references": ["PartialOrder", "CompleteSemilatticeSup"],
  "name": "CompleteSemilatticeSup.toPartialOrder",
  "constType":
  "{α : Type u_8} → [self : CompleteSemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.coe'._proof_18",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "letFun",
   "PartialOrder",
   "Preorder.toLE",
   "Subtype.le",
   "HardarNarasimhan.coe'._proof_20",
   "Set.instLE",
   "Function.Embedding.mk",
   "RelEmbedding.mk",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OrderEmbedding",
   "Set.Iic",
   "HardarNarasimhan.DedekindMacNeilleCompletion",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LE.le",
   "Subtype.mk",
   "Function.Injective",
   "HardarNarasimhan.coe'._proof_19"],
  "name": "HardarNarasimhan.coe'",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → α ↪o HardarNarasimhan.DedekindMacNeilleCompletion α",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "True", "exists_true_left", "True.intro", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_14",
  "constType": "∀ {p : True → Prop}, Exists p = p True.intro",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.μmax",
   "PartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "CompleteSemilatticeInf.toInfSet",
   "Eq.refl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μA.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.μA μ I =\n    sInf {x | ∃ a, ∃ (ha : HardarNarasimhan.InIntvl I a ∧ a ≠ (↑I).2), HardarNarasimhan.μmax μ ⟨(a, (↑I).2), ⋯⟩ = x}",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "OrderDual.instLT",
   "OrderDual.instTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instLE",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "OrderDual.instPreorder",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.h₂_dual_of_h₂",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1), μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n      (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) z ≤ (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨((↑z).1, ⊤), ⋯⟩ ∨\n        (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨((↑z).2, ⊤), hz⟩ ≤ (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨((↑z).1, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Inhabited.mk", "True", "True.intro", "Inhabited"],
  "name": "instInhabitedTrue",
  "constType": "Inhabited True",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "CompleteLattice",
   "HardarNarasimhan.Resμ",
   "HardarNarasimhan.instLatticeInterval",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HardarNarasimhan.instCoeForallSubtypeProdLtFstSndForallIntervalOfCompleteLattice",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {z : { p // p.1 < p.2 }} →\n          {S : Type} → [CompleteLattice S] → Coe ({ p // p.1 < p.2 } → S) ({ p // p.1 < p.2 } → S)",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.SlopeLike.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x y z : ℒ) (h : x < y ∧ y < z),\n      (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n        (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n          (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n            (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) →\n    HardarNarasimhan.SlopeLike μ",
  "constCategory": "Other"},
 {"references": ["AddGroup", "AddCommGroup"],
  "name": "AddCommGroup.toAddGroup",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddGroup G",
  "constCategory": "Definition"},
 {"references": ["Unique", "Eq", "Inhabited", "Inhabited.default"],
  "name": "Unique.mk",
  "constType":
  "{α : Sort u} → (toInhabited : Inhabited α) → (∀ (a : α), a = default) → Unique α",
  "constCategory": "Other"},
 {"references":
  ["lt_trans",
   "Lattice.toSemilatticeSup",
   "HardarNarasimhan.impl.lem2d4₂I",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Exists.intro",
   "sup_le",
   "Subtype.val",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Eq.refl",
   "Iff.mpr",
   "HardarNarasimhan.impl.lem2d4₁",
   "Nontrivial",
   "Lattice",
   "inf_le_left",
   "ConditionallyCompleteLattice.toLattice",
   "setOf",
   "inf_le_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "Prod.fst",
   "le_inf",
   "HardarNarasimhan.μmax",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_sInf_iff",
   "Set",
   "HardarNarasimhan.μA",
   "sInf_le",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "le_of_lt",
   "Min.min",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop2d6₁I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HardarNarasimhan.InIntvl I y →\n            ∀ (z : ℒ),\n              HardarNarasimhan.InIntvl I z →\n                ∀ (h : x < y ∧ y < z),\n                  HardarNarasimhan.μA μ ⟨(x, y), ⋯⟩ ⊓ HardarNarasimhan.μA μ ⟨(y, z), ⋯⟩ ≤\n                    HardarNarasimhan.μA μ ⟨(x, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instCommRing",
   "CommRing.toCommSemiring",
   "CommSemiring",
   "inferInstance",
   "Int"],
  "name": "Int.instCommSemiring",
  "constType": "CommSemiring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZero",
   "Real",
   "NNReal",
   "LE.le",
   "Subtype.instLinearOrder",
   "LinearOrder",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "OfNat.ofNat",
   "Real.instLE"],
  "name": "NNReal.instLinearOrder",
  "constType": "LinearOrder NNReal",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "lt_trans",
   "HardarNarasimhan.impl.dualμBstar_eq_μAstar",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "bot_le",
   "HardarNarasimhan.impl.h₁_dual_of_h₁",
   "Subtype.val",
   "Equiv",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.prop4d1₂",
   "HardarNarasimhan.μAstar",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "Exists",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Lattice",
   "OrderDual.instBoundedOrder",
   "OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "HardarNarasimhan.impl.dualμAstar_eq_μBstar",
   "OrderDual.instLattice",
   "DFunLike.coe",
   "Nat.instPreorder",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "instOfNatNat",
   "OrderDual.instLT",
   "OrderDual.instCompleteLattice",
   "OrderBot.toBot",
   "OrderDual.instPartialOrder",
   "Eq",
   "Preorder.toLE",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "instHAdd",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "LE.le",
   "Subtype.mk",
   "HardarNarasimhan.impl.h₂_dual_of_h₂",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop4d3₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n        μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n      HardarNarasimhan.μAstar μ ≤ HardarNarasimhan.μBstar μ",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_refl",
  "constType": "∀ {α : Type u_2} [self : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references": ["OrderDual", "Top", "Bot", "Top.mk", "Bot.bot"],
  "name": "OrderDual.instTop",
  "constType": "(α : Type u) → [Bot α] → Top αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration.mk",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Nat.find",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "HardarNarasimhan.instLatticeInterval",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.μ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HardarNarasimhan.instNontrivialInterval",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HardarNarasimhan.Semistable",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "HardarNarasimhan.HardarNarasimhanFiltration.rec",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] →\n                    [h : HardarNarasimhan.μ_Admissible μ] →\n                      {motive : HardarNarasimhan.HardarNarasimhanFiltration μ → Sort u} →\n                        (t : HardarNarasimhan.HardarNarasimhanFiltration μ) →\n                          ((filtration : ℕ → ℒ) →\n                              (monotone : Monotone filtration) →\n                                (first_eq_bot : filtration 0 = ⊥) →\n                                  (fin_len : ∃ n, filtration n = ⊤) →\n                                    (strict_mono :\n                                        ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                      (piecewise_semistable :\n                                          ∀ (i : ℕ) (h : i < Nat.find fin_len),\n                                            HardarNarasimhan.Semistable\n                                              (HardarNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)) →\n                                        (μA_pseudo_strict_anti :\n                                            ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n                                              ¬HardarNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n                                                  HardarNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩) →\n                                          motive\n                                            { filtration := filtration, monotone := monotone,\n                                              first_eq_bot := first_eq_bot, fin_len := fin_len,\n                                              strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n                                              μA_pseudo_strict_anti := μA_pseudo_strict_anti }) →\n                            motive t",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "Nat.recAux",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "absurd",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "Eq.refl",
   "HSub.hSub",
   "Ne",
   "Eq",
   "instHSub"],
  "name": "Nat.sub_one_add_one",
  "constType": "∀ {a : ℕ}, a ≠ 0 → a - 1 + 1 = a",
  "constCategory": "Theorem"},
 {"references": ["Int.lt", "LT.mk", "LT", "Int"],
  "name": "Int.instLTInt",
  "constType": "LT ℤ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "lt_trans",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "bot_le",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "HardarNarasimhan.impl.prop4d1₁",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Eq.mpr",
   "setOf",
   "StrictMono",
   "Subtype",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Nat.instPreorder",
   "Prod.fst",
   "congrArg",
   "le_rfl",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Lattice.toSemilatticeInf",
   "le_top",
   "instHAdd",
   "HardarNarasimhan.TotIntvl",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "ne_of_lt",
   "LE.le",
   "le_sSup",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop4d1₂",
  "constType":
  "∀ (ℒ : Type) [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n        μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n      HardarNarasimhan.μAstar μ ≤ HardarNarasimhan.μBstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Eq.symm",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not.decidable_imp_symm",
   "Not",
   "instLTNat",
   "Lattice.toSemilatticeInf",
   "eq_of_le_of_not_lt",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Prod.snd",
   "HardarNarasimhan.impl.prop3d4₀func_len",
   "HardarNarasimhan.impl.prop3d4₀func_fin_len",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Nat.find_min",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func_defprop3₀",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 })\n  (hμDCC : HardarNarasimhan.μA_DescendingChainCondition μ),\n  ∀ i < HardarNarasimhan.impl.prop3d4₀func_len μ I hμDCC, (↑I).1 < ↑(HardarNarasimhan.impl.prop3d4₀func μ I i)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image",
   "Set.Nonempty",
   "Set.Nonempty.image.match_1",
   "Set",
   "Membership.mem",
   "Exists.intro",
   "Set.mem_image_of_mem",
   "Set.instMembership"],
  "name": "Set.Nonempty.image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) {s : Set α}, s.Nonempty → (f '' s).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration.mk",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Nat.find",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "HardarNarasimhan.instLatticeInterval",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "HardarNarasimhan.HardarNarasimhanFiltration.ext.match_1",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.μ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "HEq",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HardarNarasimhan.instNontrivialInterval",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HardarNarasimhan.Semistable",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HardarNarasimhan.HardarNarasimhanFiltration.filtration",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "Eq.casesOn",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.ext",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HardarNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HardarNarasimhan.Convex μ} {h : HardarNarasimhan.μ_Admissible μ}\n  {x y : HardarNarasimhan.HardarNarasimhanFiltration μ},\n  HardarNarasimhan.HardarNarasimhanFiltration.filtration μ = HardarNarasimhan.HardarNarasimhanFiltration.filtration μ →\n    x = y",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.impl.prop3d4₀func._proof_3",
   "Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "instOfNatNat",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "Nat",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.impl.prop3d4₀func μ I 0 = ⟨(↑I).2, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_8",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "_private.Init.Classical.0._proof_9",
   "Membership.mem.out",
   "Subtype.val",
   "False.elim",
   "Or",
   "letFun",
   "forall_congr",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Exists.choose_spec",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_2",
   "Or.resolve_left",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_3",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "HardarNarasimhan.impl.prop4d1₁_seq",
   "Nat",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "StrictMono",
   "setOf",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_9",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "_private.Init.Classical.0._proof_7",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "Nat.instPreorder",
   "Prod.fst",
   "_private.Init.PropLemmas.0._proof_15",
   "not_lt_top_iff",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "not_true_eq_false",
   "Eq",
   "Preorder.toLE",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_1",
   "propext",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "Set",
   "_private.Init.Classical.0._proof_13",
   "Exists.choose",
   "OfNat.ofNat",
   "exists_prop_congr",
   "HAdd.hAdd",
   "LT.lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "And.casesOn"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._proof_10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S)\n  (h₁ : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩)\n  (h₂ :\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty) (k : ℕ),\n  ⋯.choose ∈ {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "Eq.trans",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "strictMono_nat_of_lt_succ",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.μmin",
   "Eq.symm",
   "Exists",
   "Exists.choose_spec",
   "HardarNarasimhan.μA._proof_3",
   "ne_top_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "HardarNarasimhan.impl.prop4d1₁_seq",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Classical.byContradiction",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "setOf",
   "StrictMono",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "InfSet.sInf",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "sInf_le_of_le",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "bot_lt_top",
   "CompleteLattice",
   "And.casesOn",
   "lt_trans",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.preorder",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "Or",
   "sSup_le",
   "funext",
   "forall_congr",
   "HardarNarasimhan.μAstar",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "ConditionallyCompleteLattice.toInfSet",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "Bot.bot",
   "Nat.lt_add_one",
   "Exists.casesOn",
   "Nat",
   "Iff.of_eq",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "Subtype",
   "Eq.mp",
   "HardarNarasimhan.impl.prop4d1_helper",
   "lt_of_le_of_ne",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Set.mem_setOf",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "OrderBot.toBot",
   "le_antisymm",
   "Not",
   "Set.Nonempty",
   "le_top",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "HardarNarasimhan.in_TotIntvl",
   "Mathlib.Tactic.PushNeg.not_and_eq",
   "Mathlib.Tactic.PushNeg.not_forall_eq",
   "Exists.choose",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "le_sInf",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.prop4d1₁",
  "constType":
  "∀ (ℒ : Type) [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n        μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n      HardarNarasimhan.μAstar μ = HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Nat",
   "Nat.cast",
   "LE.le",
   "Int.instLEInt",
   "Eq",
   "instLENat",
   "propext",
   "Mathlib.Tactic.Zify.natCast_le",
   "instNatCastInt",
   "Int"],
  "name": "_private.Mathlib.Tactic.Zify.0._proof_2",
  "constType": "∀ (a b : ℕ), (a ≤ b) = (↑a ≤ ↑b)",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "BoundedOrder",
  "constType": "(α : Type u) → [LE α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "HardarNarasimhan.μAstar",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HardarNarasimhan.μAstar.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.μAstar μ = HardarNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.WeakSlopeLike₂.noConfusionType",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.WeakSlopeLike₂.casesOn",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₂.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HardarNarasimhan.WeakSlopeLike₂ μ} →\n                  v1 = v2 → HardarNarasimhan.WeakSlopeLike₂.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["List.nil",
   "Nat",
   "instOfNat",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Coeffs.set",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.mk"],
  "name": "Lean.Omega.LinearCombo.coordinate",
  "constType": "ℕ → Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references": ["Preorder", "Set", "LE.le", "Preorder.toLE", "setOf"],
  "name": "Set.Iic",
  "constType": "{α : Type u_1} → [Preorder α] → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.NashEquilibrium.casesOn",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.NashEquilibrium",
   "HardarNarasimhan.NashEquilibrium.noConfusionType",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.μAstar",
   "Eq.ndrec",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.NashEquilibrium.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HardarNarasimhan.NashEquilibrium μ} →\n                  v1 = v2 → HardarNarasimhan.NashEquilibrium.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._cstage1",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_7",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "Set.Elem",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_2",
   "BoundedOrder",
   "Prod.snd",
   "Nat.brecOn",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_3",
   "Nat.lt_add_one",
   "Unit",
   "Set.instMembership",
   "Prod",
   "Nat",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_6",
   "StrictMono",
   "setOf",
   "Subtype",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_5",
   "Nat.instPreorder",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_1",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_4",
   "Not",
   "Set.Nonempty",
   "HardarNarasimhan.impl.prop4d1₁_seq.match_1",
   "le_top",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.succ",
   "LE.le",
   "Nat.below",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [inst_1 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_2 : CompleteLattice S] →\n            (μ : { p // p.1 < p.2 } → S) →\n              (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                    μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                  {YA |\n                        ∃ (h : YA < ⊤),\n                          ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty →\n                    ℕ → ↑{YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "DFunLike.coe",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "Set.univ",
   "ClosureOperator.instFunLike",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "trivial",
   "Preorder.toLE"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_15",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)), T.IsClosed Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "PartialOrder.mk",
   "DecidableLE",
   "DecidableEq",
   "Iff",
   "LE.mk",
   "id",
   "And",
   "LT.mk",
   "Preorder.mk",
   "decidableEqOfDecidableLE",
   "Eq"],
  "name":
  "HardarNarasimhan.TotallyOrderedRealVectorSpace.toDecidableEq._inherited_default",
  "constType":
  "{V : Type} →\n  (le lt : V → V → Prop) →\n    (∀ (a : V), le a a) →\n      (∀ (a b c : V), le a b → le b c → le a c) →\n        (∀ (a b : V), lt a b ↔ le a b ∧ ¬le b a) →\n          (∀ (a b : V), le a b → le b a → a = b) → DecidableLE V → DecidableEq V",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "instLTNat",
   "Nat",
   "Exists",
   "And",
   "Nat.findX",
   "DecidablePred",
   "Subtype.val"],
  "name": "Nat.find",
  "constType": "{p : ℕ → Prop} → [DecidablePred p] → (∃ n, p n) → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "HardarNarasimhan.InIntvl",
   "Preorder.toLT",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.impl.ℒₛ._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (x : { p // HardarNarasimhan.InIntvl I p }),\n  (↑I).1 ≠ ↑x → ((↑I).1, ↑x).1 < ((↑I).1, ↑x).2",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "HardarNarasimhan.impl.HNFil",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ] (n : ℕ),\n  ¬HardarNarasimhan.impl.HNFil μ n = ⊤ → (HardarNarasimhan.impl.HNFil μ n, ⊤).1 < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "True",
   "Eq.trans",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring",
   "Distrib.toMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "HMul.hMul",
   "add_mul",
   "congrArg",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "instHMul",
   "Eq",
   "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.add_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b c₁ c₂ d : R},\n  a₁ * b = c₁ → a₂ * b = c₂ → c₁ + c₂ = d → (a₁ + a₂) * b = d",
  "constCategory": "Theorem"},
 {"references": ["IsWellOrder", "IsWellFounded"],
  "name": "IsWellOrder.toIsWellFounded",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [self : IsWellOrder α r], IsWellFounded α r",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "List",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "Exists",
   "Prod.mk",
   "HardarNarasimhan.InIntvl",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "HardarNarasimhan.IsAttained._proof_4",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.μmax",
   "PartialOrder",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice"],
  "name": "HardarNarasimhan.IsAttained",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Prop",
  "constCategory": "Definition"},
 {"references": ["Preorder", "PartialOrder", "LE.le", "Eq", "Preorder.toLE"],
  "name": "PartialOrder.mk",
  "constType":
  "{α : Type u_2} → [toPreorder : Preorder α] → (∀ (a b : α), a ≤ b → b ≤ a → a = b) → PartialOrder α",
  "constCategory": "Other"},
 {"references":
  ["NonAssocSemiring.toNatCast",
   "NonAssocSemiring.natCast_zero",
   "Semiring.mk",
   "Nat.instSemiring._proof_8",
   "Nat.instNonUnitalSemiring",
   "Nat.instMonoidWithZero",
   "MonoidWithZero",
   "NonAssocSemiring.one_mul",
   "Nat",
   "Nat.instSemiring._proof_9",
   "NonAssocSemiring.mul_one",
   "Nat.instNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring",
   "NonUnitalSemiring",
   "Monoid.npow",
   "Semiring",
   "NonAssocSemiring.natCast_succ"],
  "name": "Nat.instSemiring",
  "constType": "Semiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Subtype", "Subtype.exists", "Subtype.mk", "Eq", "propext"],
  "name": "_private.Init.Data.Subtype.0._proof_2",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["ConditionallyCompleteLinearOrderBot",
   "CompleteLinearOrder.toDecidableLE",
   "Lattice.toSemilatticeSup",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_5",
   "CompleteLinearOrder.toDecidableEq",
   "CompleteLattice.toBot",
   "PartialOrder.toPreorder",
   "ConditionallyCompleteLinearOrder.mk",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_7",
   "SemilatticeSup.toPartialOrder",
   "CompleteLinearOrder.toDecidableLT",
   "CompleteLinearOrder.compare_eq_compareOfLessAndEq",
   "ConditionallyCompleteLinearOrderBot.mk",
   "CompleteLinearOrder.le_total",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_8",
   "ConditionallyCompleteLattice",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_6",
   "CompleteLinearOrder.toCompleteLattice",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "CompleteLinearOrder.toOrd",
   "OrderBot.mk",
   "CompleteLattice.toConditionallyCompleteLattice"],
  "name": "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
  "constType":
  "{α : Type u_5} → [h : CompleteLinearOrder α] → ConditionallyCompleteLinearOrderBot α",
  "constCategory": "Definition"},
 {"references": ["Subtype", "Subtype.val"],
  "name": "Subtype.property",
  "constType": "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "HardarNarasimhan.impl.instμ_Admissible",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "Exists",
   "Lean.Omega.combo_sat'",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "HardarNarasimhan.impl.HNFil",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "Option.none",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "instHSub",
   "PartialOrder.toPreorder",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GT.gt",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Int.instNegInt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "instDecidableEqBool",
   "Nat",
   "Nontrivial",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "instDecidableAnd",
   "Subtype",
   "Nat.cast",
   "HardarNarasimhan.Convex",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_13",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HardarNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HardarNarasimhan.Convex μ) (f : ℕ → ℒ),\n  (∃ n, f n = ⊤) →\n    ∀ (n : ℕ) (h₂ : ∃ N ≥ n + 1, HardarNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n      Nat.find h₂ > 0 → n + 1 < Nat.find h₂ → ¬n < Nat.find h₂ - 1 → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.S₂I",
   "Preorder.toLE",
   "Eq",
   "HardarNarasimhan.S₁I",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "HardarNarasimhan.StI",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Ne",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.StI.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.StI μ I =\n    {l |\n      ∃ (hlI : HardarNarasimhan.InIntvl I l) (hl : (↑I).1 ≠ l),\n        HardarNarasimhan.S₁I μ I l hlI hl ∧ HardarNarasimhan.S₂I μ I l hlI hl}",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.instLatticeInterval._proof_7",
   "Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Lattice.mk",
   "Subtype.val",
   "HardarNarasimhan.instLatticeInterval._proof_2",
   "Prod.fst",
   "HardarNarasimhan.instLatticeInterval._proof_11",
   "PartialOrder.mk",
   "LT.mk",
   "HardarNarasimhan.instLatticeInterval._proof_10",
   "Preorder.toLE",
   "HardarNarasimhan.instLatticeInterval._proof_1",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.instLatticeInterval._proof_12",
   "Not",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "HardarNarasimhan.instLatticeInterval._proof_8",
   "Prod.snd",
   "HardarNarasimhan.instLatticeInterval._proof_9",
   "HardarNarasimhan.instLatticeInterval._proof_5",
   "LT.lt",
   "Prod",
   "Max.max",
   "HardarNarasimhan.instLatticeInterval._proof_4",
   "HardarNarasimhan.instLatticeInterval._proof_3",
   "Min.min",
   "HardarNarasimhan.instLatticeInterval._proof_6",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.mk",
   "LE.le",
   "SemilatticeSup.mk",
   "Subtype.mk",
   "Preorder.mk"],
  "name": "HardarNarasimhan.instLatticeInterval",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → Lattice (HardarNarasimhan.Interval z)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.NashEquilibrium",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.μAstar",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.NashEquilibrium.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  HardarNarasimhan.μAstar μ = HardarNarasimhan.μBstar μ → HardarNarasimhan.NashEquilibrium μ",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.impl.dualμBstar_eq_μAstar",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "Subtype.val",
   "DFunLike.coe",
   "Equiv",
   "Prod.fst",
   "OrderDual.ofDual",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "OrderDual.instLT",
   "OrderDual.instCompleteLattice",
   "HardarNarasimhan.μAstar",
   "OrderDual.instPartialOrder",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "OrderDual.instBoundedOrder",
   "CompleteLattice"],
  "name": "HardarNarasimhan.dualμBstar_eq_μAstar",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  OrderDual.ofDual\n    ((HardarNarasimhan.μBstar fun p => OrderDual.toDual (μ ⟨((↑p).2, (↑p).1), ⋯⟩)) = HardarNarasimhan.μAstar μ)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "Eq.trans",
   "Eq.mpr_not",
   "Classical.propDecidable",
   "eq_true",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "HardarNarasimhan.impl.prop3d4₀func._proof_4",
   "HardarNarasimhan.impl.prop3d4₀func._proof_8",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.prop3d4₀func_defprop3₀",
   "Nat.sub_one_add_one",
   "Eq.symm",
   "Eq.ndrec",
   "Exists",
   "Exists.choose_spec",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop3d4₀func_len",
   "Set.instMembership",
   "Prod",
   "Nat.find_spec",
   "eq_false",
   "Eq.refl",
   "Lattice",
   "HardarNarasimhan.impl.ℒₛ._proof_2",
   "Prod.fst",
   "instOfNatNat",
   "HardarNarasimhan.impl.prop3d4₀func_len_nonzero",
   "HardarNarasimhan.impl.ℒₛ",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Set",
   "HardarNarasimhan.impl.ℒₛ._proof_1",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "dite_cond_eq_true",
   "Ne",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "WellFounded.has_min",
   "Membership.mem",
   "Nat.sub_one_lt",
   "Preorder.toLT",
   "Iff.mp",
   "GT.gt",
   "HardarNarasimhan.impl.prop3d4₀func._proof_7",
   "And.intro",
   "PartialOrder",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "of_eq_false",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Nontrivial",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "congrArg",
   "dite_congr",
   "Subtype.prop",
   "IsWellFounded.wf",
   "dite_cond_eq_false",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "eq_of_le_of_not_lt",
   "instHAdd",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Exists.choose",
   "HardarNarasimhan.impl.prop3d4₀func_fin_len",
   "Eq.mpr_prop",
   "LT.lt",
   "ne_of_lt",
   "instSubNat",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "lt_self_iff_false",
   "_private.Init.Core.0._proof_39"],
  "name": "HardarNarasimhan.impl.prop3d4₀func_defprop3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 })\n  (hμDCC : HardarNarasimhan.μA_DescendingChainCondition μ) (y : ℒ)\n  (hy :\n    (↑I).1 < y ∧ y ≤ ↑(HardarNarasimhan.impl.prop3d4₀func μ I (HardarNarasimhan.impl.prop3d4₀func_len μ I hμDCC - 1))),\n  ¬HardarNarasimhan.μA μ ⟨((↑I).1, y), ⋯⟩ >\n      HardarNarasimhan.μA μ\n        ⟨((↑I).1, ↑(HardarNarasimhan.impl.prop3d4₀func μ I (HardarNarasimhan.impl.prop3d4₀func_len μ I hμDCC - 1))), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Top",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["LE"],
  "name": "OrderTop",
  "constType": "(α : Type u) → [LE α] → Type u",
  "constCategory": "Other"},
 {"references": ["LT.lt", "Eq.symm", "Eq.rec", "Eq", "LT"],
  "name": "lt_of_eq_of_lt",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LT α], a = b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "HardarNarasimhan.impl.prop2d6₁I",
   "GT.gt",
   "Membership.mem.out",
   "Subtype.val",
   "And.intro",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.S₁I._proof_1",
   "Eq.rec",
   "HardarNarasimhan.S₁I",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "eq_of_ge_of_not_gt",
   "Exists",
   "Exists.choose_spec",
   "HardarNarasimhan.InIntvl",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Iff.of_eq",
   "Iff.mpr",
   "Eq.refl",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "ConditionallyCompleteLattice.toLattice",
   "Mathlib.Tactic.PushNeg.not_implies_eq",
   "SemilatticeInf.toMin",
   "Subtype",
   "Eq.mp",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "le_rfl",
   "Subtype.prop",
   "HardarNarasimhan.S₂I",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Not",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.StI",
   "Set",
   "Mathlib.Tactic.PushNeg.not_forall_eq",
   "Exists.choose",
   "HardarNarasimhan.μA",
   "inf_eq_left",
   "exists_prop_congr",
   "not_le_of_gt",
   "LT.lt",
   "ne_of_lt",
   "le_of_lt",
   "Min.min",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "And.casesOn"],
  "name": "HardarNarasimhan.impl.prop3d7₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ) (hxSt : x ∈ HardarNarasimhan.StI μ I) (y : ℒ),\n      HardarNarasimhan.InIntvl I y →\n        ∀ (hy : y > x), ¬HardarNarasimhan.μA μ ⟨((↑I).1, x), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(x, y), hy⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.μmax",
   "PartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "CompleteSemilatticeInf.toInfSet",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μA",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["Iff.trans",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "And",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "SemilatticeInf",
   "le_antisymm_iff",
   "iff_self",
   "of_eq_true",
   "Min.min",
   "congr",
   "Iff",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "_private.Mathlib.Order.Lattice.0._proof_18",
   "_private.Mathlib.Order.Lattice.0._proof_16",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_eq_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = a ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["True", "Set", "setOf"],
  "name": "Set.univ",
  "constType": "{α : Type u} → Set α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "True",
   "instHAdd",
   "List",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_1",
  "constType":
  "∀ {a0 a1 : ℤ} {t : List ℤ}, (Omega.LinearCombo.coordinate 1).eval (Omega.Coeffs.ofList (a0 :: a1 :: t)) = a1",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommMonoid",
   "Module",
   "MonoidWithZero.toMonoid",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "DistribMulAction",
   "Semiring"],
  "name": "Module.toDistribMulAction",
  "constType":
  "{R : Type u} →\n  {M : Type v} → {inst : Semiring R} → {inst_1 : AddCommMonoid M} → [self : _root_.Module R M] → DistribMulAction R M",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.zero", "Real", "Zero.mk", "Zero"],
  "name": "Real.instZero",
  "constType": "Zero ℝ",
  "constCategory": "Definition"},
 {"references": ["PUnit", "Nat", "Nat.rec", "PProd"],
  "name": "Nat.below",
  "constType": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "HardarNarasimhan.Semistable.casesOn",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.Semistable",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "HardarNarasimhan.Semistable.noConfusionType",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.Semistable.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HardarNarasimhan.Semistable μ} → v1 = v2 → HardarNarasimhan.Semistable.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.StI",
   "Set",
   "Membership.mem",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Set.instMembership",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.semistableI",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Prop",
  "constCategory": "Definition"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "HardarNarasimhan.impl.instμ_Admissible",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "Exists",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "HardarNarasimhan.impl.HNFil",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "Option.none",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "instHSub",
   "PartialOrder.toPreorder",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GT.gt",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Int.instNegInt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "instDecidableEqBool",
   "Nat",
   "Nontrivial",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.cast",
   "instDecidableAnd",
   "Subtype",
   "HardarNarasimhan.Convex",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HardarNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HardarNarasimhan.Convex μ) (f : ℕ → ℒ),\n  (∃ n, f n = ⊤) →\n    ∀ (n : ℕ) (h₂ : ∃ N ≥ n + 1, HardarNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n      Nat.find h₂ > 0 → ¬Nat.find h₂ - 1 < Nat.find h₂ → False",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "PartialOrder.toPreorder",
   "Add",
   "instHAdd",
   "AddLeftStrictMono",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "CovariantClass.elim",
   "HAdd.hAdd",
   "LT.lt",
   "IsLeftCancelAdd",
   "Iff.mpr",
   "PartialOrder",
   "LT.lt.ne",
   "LE.le",
   "add_ne_add_right",
   "Ne",
   "Preorder.toLE",
   "CovariantClass.mk",
   "LT.lt.le"],
  "name": "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [IsLeftCancelAdd N] [inst_2 : PartialOrder N] [AddLeftMono N], AddLeftStrictMono N",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Function.Injective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLT",
   "not_lt_of_le",
   "Preorder.toLE"],
  "name": "LE.le.not_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder", "GaloisConnection", "LowerAdjoint", "LowerAdjoint.mk"],
  "name": "GaloisConnection.lowerAdjoint",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_4} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisConnection l u → LowerAdjoint u",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_trans",
  "constType":
  "∀ {α : Type u_2} [self : Preorder α] (a b c : α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Order.Lattice.0._proof_15",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "_private.Init.Core.0._proof_38",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "inf_assoc",
   "And.intro",
   "le_sup_right",
   "not_false_eq_true",
   "HardarNarasimhan.μmax._proof_2",
   "sSup_le",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.ConvexI.convex",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "mt",
   "eq_false",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "sup_le_sup_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "lt_of_le_of_ne",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Prod.fst",
   "congrArg",
   "le_inf",
   "HardarNarasimhan.μmax",
   "Preorder.toLE",
   "Eq",
   "le_antisymm",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "inf_idem",
   "inf_le_inf_right",
   "right_eq_sup",
   "gt_of_ge_of_gt",
   "LT.lt",
   "Max.max",
   "of_eq_true",
   "Min.min",
   "le_of_lt",
   "SemilatticeSup.toMax",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "le_sSup",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.lem2d4₂I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (w : ℒ),\n          HardarNarasimhan.InIntvl I w →\n            ∀ (hxw : ¬x ≤ w) (t : ℒ) (hxwt : x ⊔ w ≤ t),\n              HardarNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩ ≤ HardarNarasimhan.μmax μ ⟨(w, t), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["not_le",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "_private.Mathlib.Order.Defs.LinearOrder.0._proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (¬a ≤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Iff", "Membership.mem", "Iff.rfl", "Set.instMembership"],
  "name": "Set.mem_def",
  "constType": "∀ {α : Type u} {a : α} {s : Set α}, a ∈ s ↔ s a",
  "constCategory": "Theorem"},
 {"references":
  ["not_imp_not",
   "WellFounded",
   "Not",
   "WellFounded.has_min.match_1",
   "Set.Nonempty",
   "Exists",
   "Set",
   "Membership.mem",
   "Iff.mp",
   "And",
   "Exists.intro",
   "Set.instMembership",
   "Acc",
   "And.intro",
   "letFun",
   "Acc.recOn",
   "WellFounded.apply"],
  "name": "WellFounded.has_min",
  "constType":
  "∀ {α : Type u_4} {r : α → α → Prop}, WellFounded r → ∀ (s : Set α), s.Nonempty → ∃ a ∈ s, ∀ x ∈ s, ¬r x a",
  "constCategory": "Theorem"},
 {"references": ["semiOutParam"],
  "name": "Coe",
  "constType": "semiOutParam (Sort u) → Sort v → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.SlopeLike.casesOn",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.SlopeLike.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} → Sort u → HardarNarasimhan.SlopeLike μ → HardarNarasimhan.SlopeLike μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Coe",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Function.Embedding",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Coe.mk",
   "OrderEmbedding",
   "HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "HardarNarasimhan.DedekindMacNeilleCompletion",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "HardarNarasimhan.coe'",
   "Preorder.toLE",
   "Subtype.le",
   "Set.instLE"],
  "name": "HardarNarasimhan.instCoeDedekindMacNeilleCompletion._cstage1",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → Coe α (HardarNarasimhan.DedekindMacNeilleCompletion α)",
  "constCategory": "Definition"},
 {"references": ["_obj", "_neutral"],
  "name": "HardarNarasimhan.coe'._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "AddCommMonoid",
   "inferInstance",
   "Nat.instAddCancelCommMonoid",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "Nat.instAddCommMonoid",
  "constType": "AddCommMonoid ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "IsWellFounded.wf",
   "HardarNarasimhan.impl.ℒₛ",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Prod.snd",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func._proof_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ)\n  (hbot : ¬(↑I).1 = ↑(HardarNarasimhan.impl.prop3d4₀func μ I n)),\n  (HardarNarasimhan.impl.ℒₛ μ I (HardarNarasimhan.impl.prop3d4₀func μ I n) hbot).Nonempty →\n    ∃ a ∈ HardarNarasimhan.impl.ℒₛ μ I (HardarNarasimhan.impl.prop3d4₀func μ I n) hbot,\n      ∀ x ∈ HardarNarasimhan.impl.ℒₛ μ I (HardarNarasimhan.impl.prop3d4₀func μ I n) hbot, ¬x > a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Nat.cast",
   "Int.ofNat_le",
   "Iff.mpr",
   "LE.le",
   "Int.instLEInt",
   "instLENat",
   "instNatCastInt",
   "Int"],
  "name": "Lean.Omega.Int.ofNat_le_of_le",
  "constType": "∀ {x y : ℕ}, x ≤ y → ↑x ≤ ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "PartialOrder.toPreorder",
   "AddCommGroup.toAddGroup",
   "Preorder.toLT",
   "CommGroupWithZero.toDivisionCommMonoid",
   "SMulZeroClass.toSMul",
   "instNNRealPartialOrder",
   "GT.gt",
   "RelEmbedding.instFunLike",
   "HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "NNReal.instLinearOrder",
   "NNReal.instLinearOrderedCommGroupWithZero",
   "CompleteLattice.toTop",
   "AddGroup.toSubNegMonoid",
   "DistribSMul.toSMulZeroClass",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "InvOneClass.toInv",
   "Real",
   "AddZeroClass.toZero",
   "ClosureOperator.IsClosed",
   "NNReal",
   "DistribMulAction.toDistribSMul",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.toModule",
   "HardarNarasimhan.DedekindMacNeilleCompletion",
   "Prod",
   "LinearOrder.toDecidableLT",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Nontrivial",
   "Lattice",
   "HSMul.hSMul",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "AddMonoid.toAddZeroClass",
   "instNNRealSemiring",
   "instNNRealZero",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "OmegaCompletePartialOrder.toPartialOrder",
   "DFunLike.coe",
   "Prod.fst",
   "instDistribLatticeOfLinearOrder",
   "HardarNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
   "Preorder.toLE",
   "Subtype.le",
   "DivisionCommMonoid.toDivisionMonoid",
   "Set.instLE",
   "Not",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "Inv.inv",
   "Lattice.toSemilatticeInf",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Semiring.toMonoidWithZero",
   "OrderEmbedding",
   "Real.semiring",
   "NNReal.instDistribMulActionOfReal",
   "OfNat.ofNat",
   "LT.lt",
   "Module.toDistribMulAction",
   "DivInvOneMonoid.toInvOneClass",
   "DistribLattice.toLattice",
   "SubNegMonoid.toAddMonoid",
   "LE.le",
   "HardarNarasimhan.coe'",
   "dite"],
  "name": "HardarNarasimhan.μQuotient",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        {V : Type} →\n          [inst_2 : HardarNarasimhan.TotallyOrderedRealVectorSpace V] →\n            ({ p // p.1 < p.2 } → NNReal) →\n              ({ p // p.1 < p.2 } → V) → { p // p.1 < p.2 } → HardarNarasimhan.DedekindMacNeilleCompletion V",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instLTNat",
   "instHAdd",
   "Nat.lt_succ_of_le",
   "OfNat.ofNat",
   "Iff.intro",
   "LT.lt",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "Iff",
   "Nat.le_of_lt_succ",
   "LE.le",
   "instLENat"],
  "name": "Nat.lt_add_one_iff",
  "constType": "∀ {m n : ℕ}, m < n + 1 ↔ m ≤ n",
  "constCategory": "Theorem"},
 {"references": ["SMul", "MulAction", "Monoid"],
  "name": "MulAction.toSMul",
  "constType":
  "{α : Type u_9} → {β : Type u_10} → {inst : Monoid α} → [self : MulAction α β] → SMul α β",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Monotone",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Not", "False.elim", "True", "False", "eq_true", "Eq"],
  "name": "not_false_eq_true",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "Preorder.toLT",
   "And",
   "Prod.snd",
   "lt_of_le_of_ne",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "PartialOrder",
   "LE.le",
   "Ne",
   "Preorder.toLE",
   "And.left"],
  "name": "HardarNarasimhan.μmax._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (I : { p // p.1 < p.2 }) (u : ℒ),\n  HardarNarasimhan.InIntvl I u ∧ (↑I).1 ≠ u → ((↑I).1, u).1 < ((↑I).1, u).2",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Subtype",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "Set.subset_biUnion_of_mem",
   "Set.iUnion",
   "ClosureOperator",
   "DFunLike.coe",
   "Subtype.val",
   "Set.instMembership",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Subtype.property",
   "Eq.symm",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq",
   "Eq.rec"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_10",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds), ∀ A ∈ 𝒮, ∀ x ∈ ↑A, x ∈ T (⋃ x ∈ 𝒮, ↑x)",
  "constCategory": "Theorem"},
 {"references": ["Int.le", "LE.mk", "LE", "Int"],
  "name": "Int.instLEInt",
  "constType": "LE ℤ",
  "constCategory": "Definition"},
 {"references": ["MulAction", "Monoid", "AddMonoid", "DistribMulAction"],
  "name": "DistribMulAction.toMulAction",
  "constType":
  "{M : Type u_12} →\n  {A : Type u_13} → {inst : Monoid M} → {inst_1 : AddMonoid A} → [self : DistribMulAction M A] → MulAction M A",
  "constCategory": "Definition"},
 {"references": ["Iff", "Membership.mem", "List.instMembership", "List"],
  "name": "List.TFAE",
  "constType": "List Prop → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μA_DescendingChainCondition.μ_dcc",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HardarNarasimhan.μA_DescendingChainCondition μ]\n  (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n  (∀ (n : ℕ), f n > f (n + 1)) → ∃ N, HardarNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(a, f N), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a ⋯ → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Preorder.le_refl",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a : HardarNarasimhan.Interval z), ↑a ≤ ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.S₁I._proof_1",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.S₁I",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        {S : Type} →\n          [CompleteLattice S] →\n            ({ p // p.1 < p.2 } → S) →\n              (I : { p // p.1 < p.2 }) → (x : ℒ) → HardarNarasimhan.InIntvl I x → (↑I).1 ≠ x → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.Interval",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → { p // p.1 < p.2 } → Type",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.Resμ._proof_19",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "CompleteLattice",
   "HardarNarasimhan.instLatticeInterval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.Resμ",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        (z : { p // p.1 < p.2 }) → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass", "Zero"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Membership.mem",
   "And",
   "sInf_le_of_le",
   "CompleteSemilatticeInf",
   "Set.instMembership",
   "CompleteSemilatticeInf.toInfSet",
   "sInf_le_sInf_of_forall_exists_le.match_1",
   "LE.le",
   "CompleteSemilatticeInf.toPartialOrder",
   "InfSet.sInf",
   "le_sInf",
   "Preorder.toLE"],
  "name": "sInf_le_sInf_of_forall_exists_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s t : Set α}, (∀ x ∈ s, ∃ y ∈ t, y ≤ x) → sInf t ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "Function.Embedding",
   "RelEmbedding",
   "Function.instFunLikeEmbedding",
   "DFunLike.coe"],
  "name": "RelEmbedding.mk",
  "constType":
  "{α : Type u_5} →\n  {β : Type u_6} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} → (toEmbedding : α ↪ β) → (∀ {a b : α}, s (toEmbedding a) (toEmbedding b) ↔ r a b) → r ↪r s",
  "constCategory": "Other"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "le_of_lt",
   "not_le_of_lt",
   "le_trans",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLT",
   "Preorder.toLE"],
  "name": "lt_of_le_of_lt",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Set.setOf_subset_setOf",
   "Eq",
   "propext",
   "setOf"],
  "name": "_private.Mathlib.Data.Set.Basic.0._proof_18",
  "constType":
  "∀ {α : Type u} {p q : α → Prop}, ({a | p a} ⊆ {a | q a}) = ∀ (a : α), p a → q a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "Top",
   "OrderDual.instTop",
   "LE",
   "OrderTop",
   "bot_le",
   "OrderDual.instLE",
   "OrderBot.toBot",
   "inferInstanceAs",
   "OrderBot",
   "OrderTop.mk"],
  "name": "OrderDual.instOrderTop",
  "constType": "(α : Type u) → [inst : LE α] → [OrderBot α] → OrderTop αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.S₂I",
   "HardarNarasimhan.S₁I._proof_1",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.S₂I.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (x : ℒ)\n  (hxI : HardarNarasimhan.InIntvl I x) (hx : (↑I).1 ≠ x),\n  HardarNarasimhan.S₂I μ I x hxI hx =\n    ∀ (y : ℒ) (hyI : HardarNarasimhan.InIntvl I y) (hy : (↑I).1 ≠ y),\n      HardarNarasimhan.μA μ ⟨((↑I).1, y), ⋯⟩ = HardarNarasimhan.μA μ ⟨((↑I).1, x), ⋯⟩ → y ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "Exists.intro",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "HardarNarasimhan.in_TotIntvl",
   "instHAdd",
   "HardarNarasimhan.TotIntvl",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.prop3d2",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "HardarNarasimhan.μA_DescendingChainCondition.mk",
   "Exists.casesOn",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.cor3d3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Convex μ →\n    (∀ (f : ℕ → ℒ) (h : ∀ (n : ℕ), f n > f (n + 1)), ∃ N, HardarNarasimhan.μA μ ⟨(f (N + 1), f N), ⋯⟩ = ⊤) →\n      HardarNarasimhan.μA_DescendingChainCondition μ",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Nat.exists_eq_add_of_le",
   "Nat",
   "CanonicallyOrderedAdd.mk",
   "ExistsAddOfLE.mk",
   "CanonicallyOrderedAdd",
   "Nat.le_add_right",
   "instLENat"],
  "name": "Nat.instCanonicallyOrderedAdd",
  "constType": "CanonicallyOrderedAdd ℕ",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_1._cstage2",
  "constType": "_obj → _neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast_one",
   "Nat.cast",
   "Eq.trans",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroOneClass.toMulOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Nat.instAddMonoidWithOne",
   "pow_one",
   "Semiring.toNonAssocSemiring",
   "instOfNatNat",
   "congr",
   "MonoidWithZero.toMonoid",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "instHPow",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "mul_one",
   "add_zero",
   "HPow.hPow",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "of_eq_true",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "AddMonoidWithOne.toOne",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.atom_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "le_total",
   "Or.inr",
   "Subtype",
   "not_le_of_lt",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "le_rfl",
   "HardarNarasimhan.IsAttained",
   "Or.inl",
   "BoundedOrder.toOrderTop",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "HardarNarasimhan.impl.prop2d6₃I",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_top",
   "HardarNarasimhan.μA",
   "Or.casesOn",
   "CompletelyDistribLattice.toCompleteLattice",
   "LT.lt",
   "le_of_lt",
   "HardarNarasimhan.IsComparable",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top"],
  "name": "HardarNarasimhan.impl.rmk2d7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI ⟨(⊥, ⊤), ⋯⟩ μ →\n    ∀ (x : ℒ) (h : ⊥ < x ∧ x < ⊤),\n      HardarNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HardarNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩ →\n        HardarNarasimhan.μA μ ⟨(x, ⊤), ⋯⟩ = HardarNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{α : Type u} → (α → α → α) → Add α",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder._proof_17",
   "CompleteSemilatticeSup.toSupSet",
   "OmegaCompletePartialOrder",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "CompleteLattice.instOmegaCompletePartialOrder._proof_16",
   "Nat",
   "iSup",
   "CompleteSemilatticeInf.toPartialOrder",
   "OmegaCompletePartialOrder.Chain.instFunLikeNat",
   "OmegaCompletePartialOrder.Chain",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OmegaCompletePartialOrder.mk",
   "CompleteLattice"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder",
  "constType":
  "{α : Type u_2} → [CompleteLattice α] → OmegaCompletePartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "SemilatticeSup.toPartialOrder",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Max.max",
   "le_sup_right",
   "SemilatticeSup.toMax",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HardarNarasimhan.Interval z), ↑b ≤ ↑a ⊔ ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HardarNarasimhan.WeakAscendingChainCondition.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n    HardarNarasimhan.WeakAscendingChainCondition μ",
  "constCategory": "Other"},
 {"references": ["Set", "SupSet"],
  "name": "SupSet.mk",
  "constType": "{α : Type u_1} → (Set α → α) → SupSet α",
  "constCategory": "Other"},
 {"references": ["Union"],
  "name": "Union.union._@.Mathlib.Data.Set.Operations._hyg.4",
  "constType": "{α : Type u} → [self : Union α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toNonUnitalCommRing._proof_27",
   "AddGroup.mk",
   "Ring.toSub",
   "NonUnitalNonAssocSemiring.toMul",
   "CommRing.toNonUnitalCommRing._proof_33",
   "AddCommMonoid.toAddMonoid",
   "CommRing.toNonUnitalCommRing._proof_32",
   "CommRing.toNonUnitalCommRing._proof_31",
   "NonUnitalCommRing",
   "CommRing.toNonUnitalCommRing._proof_28",
   "AddCommGroup.mk",
   "CommRing.toNonUnitalCommRing._proof_29",
   "CommRing.toNonUnitalCommRing._proof_36",
   "CommRing.toNonUnitalCommRing._proof_34",
   "SubNegMonoid.mk",
   "CommRing.toNonUnitalCommRing._proof_35",
   "Semiring.toNonUnitalSemiring",
   "Ring.toNeg",
   "Ring.zsmul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommRing",
   "NonUnitalNonAssocRing.mk",
   "NonUnitalCommRing.mk",
   "Ring.toSemiring",
   "CommRing.toNonUnitalCommRing._proof_30",
   "CommRing.toRing",
   "NonUnitalRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toNonUnitalCommRing._proof_26",
   "CommRing.mul_comm"],
  "name": "CommRing.toNonUnitalCommRing",
  "constType": "{α : Type u} → [s : CommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HardarNarasimhan.SlopeLike.noConfusionType",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.SlopeLike.casesOn",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.SlopeLike.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HardarNarasimhan.SlopeLike μ} → v1 = v2 → HardarNarasimhan.SlopeLike.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["instDistribLatticeOfLinearOrder._proof_54",
   "LinearOrder",
   "DistribLattice.mk",
   "DistribLattice",
   "LinearOrder.toLattice"],
  "name": "instDistribLatticeOfLinearOrder",
  "constType": "{α : Type u} → [LinearOrder α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references": ["_obj", "_neutral", "HardarNarasimhan.μA._rarg"],
  "name": "HardarNarasimhan.μA._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["LE", "OrderTop", "BoundedOrder"],
  "name": "BoundedOrder.toOrderTop",
  "constType":
  "{α : Type u} → {inst : LE α} → [self : BoundedOrder α] → OrderTop α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.impl.rmk4d15",
   "OrderBot.toBot",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HardarNarasimhan.SlopeLike",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.remark_4_15",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.SlopeLike μ →\n    ∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      μ ⟨(⊥, x), ⋯⟩ ≤ μ HardarNarasimhan.TotIntvl ∨ ¬μ HardarNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["PUnit.unit",
   "Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "OfNat.ofNat",
   "Unit"],
  "name": "HardarNarasimhan.impl.prop3d4₀func.match_1._cstage1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "of_eq_false",
   "Decidable",
   "Eq.trans",
   "True",
   "Eq.mpr_not",
   "dite_congr",
   "Eq.mpr_prop",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "Eq.refl",
   "False",
   "instDecidableFalse",
   "Eq",
   "dite",
   "not_false"],
  "name": "dite_cond_eq_false",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} {t : c → α} {e : ¬c → α} (h : c = False), dite c t e = e ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Subtype",
   "Eq.trans",
   "OmegaCompletePartialOrder.toPartialOrder",
   "congrArg",
   "HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "_private.Mathlib.Order.Basic.0._proof_34",
   "iff_self",
   "PartialOrder",
   "forall_congr",
   "Subtype.le",
   "Preorder.toLE",
   "Set.instLE",
   "True",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "Set.Iic",
   "implies_true",
   "of_eq_true",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff",
   "LE.le",
   "_private.Mathlib.Order.Interval.Set.Basic.0._proof_11",
   "Subtype.mk"],
  "name": "HardarNarasimhan.coe'._proof_20",
  "constType":
  "∀ {α : Type} [inst : PartialOrder α]\n  (inj : ∀ (x : α), (HardarNarasimhan.DedekindMacNeilleClosureOperator α).IsClosed (Set.Iic x)) (a a_1 : α),\n  ⟨Set.Iic a, ⋯⟩ ≤ ⟨Set.Iic a_1, ⋯⟩ ↔ a ≤ a_1",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "Not",
   "Bool",
   "Decidable",
   "Eq",
   "decide_eq_false",
   "of_decide_eq_true.match_1",
   "Bool.true",
   "Decidable.decide",
   "ne_true_of_eq_false"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references": ["Inv"],
  "name": "Inv.inv",
  "constType": "{α : Type u} → [self : Inv α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HardarNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._cstage1",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.le_top", "LE.le", "Top.top", "LE", "OrderTop", "OrderTop.toTop"],
  "name": "le_top",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration.casesOn",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Nat.find",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "HardarNarasimhan.instLatticeInterval",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.μ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HardarNarasimhan.instNontrivialInterval",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HardarNarasimhan.Semistable",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "HardarNarasimhan.HardarNarasimhanFiltration.noConfusionType",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                {hμ : HardarNarasimhan.μA_DescendingChainCondition μ} →\n                  {hμcvx : HardarNarasimhan.Convex μ} →\n                    {h : HardarNarasimhan.μ_Admissible μ} →\n                      {P : Sort u} →\n                        {v1 v2 : HardarNarasimhan.HardarNarasimhanFiltration μ} →\n                          v1 = v2 → HardarNarasimhan.HardarNarasimhanFiltration.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Distrib.toAdd",
   "Semiring.toNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Eq.refl",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Eq.symm",
   "Eq.ndrec",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.add_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' + b' = c → a + b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "Subtype",
   "PartialOrder.toPreorder",
   "le_trans",
   "Preorder.toLT",
   "sup_le",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "Subtype.prop",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "le_sup_left",
   "LT.lt",
   "Prod",
   "Max.max",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HardarNarasimhan.Interval z), (↑z).1 ≤ ↑a ⊔ ↑b ∧ ↑a ⊔ ↑b ≤ (↑z).2",
  "constCategory": "Theorem"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.Convex",
   "Preorder.toLT",
   "BoundedOrder",
   "Nonempty",
   "Prod.snd",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "instNonemptyOfInhabited",
   "Nontrivial",
   "Lattice",
   "inferInstance",
   "WellFoundedGT",
   "HardarNarasimhan.instInhabitedHardarNarasimhanFiltration",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instNonemptyHardarNarasimhanFiltration",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ],\n  Nonempty (HardarNarasimhan.HardarNarasimhanFiltration μ)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "AddZeroClass.toZero",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Eq.ndrec",
   "Eq",
   "add_comm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Neg.neg",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "SubNegMonoid.toNeg",
   "neg_add_rev",
   "HAdd.hAdd",
   "Ring.toAddCommGroup",
   "eq_self",
   "NegZeroClass.toNeg",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "Ring",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.neg_add",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a₁ a₂ b₁ b₂ : R}, -a₁ = b₁ → -a₂ = b₂ → -(a₁ + a₂) = b₁ + b₂",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "lt_trans",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "bot_le",
   "HardarNarasimhan.impl.h₁_dual_of_h₁",
   "Subtype.val",
   "Equiv",
   "Or",
   "SupSet.sSup",
   "letFun",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "HardarNarasimhan.impl.prop4d1₁",
   "SemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLattice.toInfSet",
   "Exists",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Set.ext",
   "Eq.mpr",
   "OrderDual.instBoundedOrder",
   "setOf",
   "OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "Eq.mp",
   "HardarNarasimhan.impl.dualμAstar_eq_μBstar",
   "OrderDual.instLattice",
   "HardarNarasimhan.impl.prop4d1_helper",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "HardarNarasimhan.impl.prop4d3_helper",
   "DFunLike.coe",
   "Iff.intro",
   "congrArg",
   "Nat.instPreorder",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "instOfNatNat",
   "OrderDual.instLT",
   "InfSet.sInf",
   "OrderDual.instCompleteLattice",
   "OrderDual.instPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "propext",
   "CompleteLattice.toConditionallyCompleteLattice",
   "_private.Mathlib.Order.Synonym.0._proof_6",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "Set",
   "instHAdd",
   "HardarNarasimhan.TotIntvl",
   "OfNat.ofNat",
   "exists_prop_congr",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "LE.le",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "HardarNarasimhan.impl.h₂_dual_of_h₂",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop4d3₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n        μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n      HardarNarasimhan.μBstar μ = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "HardarNarasimhan.instLatticeInterval._rarg._lambda_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name":
  "HardarNarasimhan.impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["True", "True.intro"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "le_trans", "Preorder.toLE", "GE.ge"],
  "name": "ge_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≥ b → b ≥ c → a ≥ c",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "Eq", "GT.gt", "LT", "propext"],
  "name": "_private.Init.Core.0._proof_39",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LT",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["SubtractionMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegZeroMonoid.mk",
   "SubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid._proof_16",
   "SubNegZeroMonoid"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid",
  "constType": "{α : Type u_1} → [SubtractionMonoid α] → SubNegZeroMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakDescendingChainCondition.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    HardarNarasimhan.WeakDescendingChainCondition μ",
  "constCategory": "Other"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "HardarNarasimhan.TotIntvl",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "HardarNarasimhan.impl.prop3d2",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_3_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Convex μ →\n    ∀ (x z : ℒ) (h : x < z),\n      HardarNarasimhan.μA μ ⟨(x, z), h⟩ = ⊤ →\n        ∀ (a : ℒ) (hax : a < x), HardarNarasimhan.μA μ ⟨(a, x), hax⟩ ≤ HardarNarasimhan.μA μ ⟨(a, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Iff.mp",
   "Preorder.toLT",
   "eq_true",
   "List.tfae_of_cycle",
   "List.instGetElem?NatLtLength",
   "Nat.instAddCommMonoid",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "And.intro",
   "GetElem?.getElem?",
   "Mathlib.Meta.NormNum.isNat_add",
   "HardarNarasimhan.NashEquilibrium",
   "Nat.instCharZero",
   "letFun",
   "HardarNarasimhan.μmin",
   "List.TFAE",
   "Nat.instIsOrderedAddMonoid",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.SlopeLike",
   "instLTNat",
   "_private.Init.Data.Nat.Basic.0._proof_6",
   "AddZeroClass.toZero",
   "Nat.instPartialOrder",
   "And",
   "HardarNarasimhan.impl.prop4d16₂",
   "BoundedOrder",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Nat.instNontrivial",
   "True.intro",
   "Prod.snd",
   "Nat.instCanonicallyOrderedAdd",
   "Prod",
   "zero_add",
   "Nat",
   "Iff.mpr",
   "Eq.refl",
   "Iff",
   "Option",
   "AddMonoidWithOne.toOne",
   "Nontrivial",
   "Lattice",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddMonoid.toAddZeroClass",
   "List.length",
   "List.getElem?_eq_getElem",
   "_private.Mathlib.Data.Nat.Cast.Order.Ring.0._proof_7",
   "Subtype",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "List",
   "GetElem.getElem",
   "Option.some",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Nat.instAddMonoidWithOne",
   "congrArg",
   "Prod.fst",
   "Nat.instSemiring",
   "HardarNarasimhan.μmax",
   "instOfNatNat",
   "congr",
   "_private.Mathlib.Data.Nat.Cast.Order.Basic.0._proof_15",
   "Zero.toOfNat0",
   "Eq",
   "Preorder.toLE",
   "List.nil",
   "List.instGetElemNatLtLength",
   "Nat.instAddMonoid",
   "Lattice.toSemilatticeInf",
   "List.TFAE.out",
   "IsStrictOrderedRing.toIsOrderedRing",
   "True",
   "List.Chain.cons",
   "instHAdd",
   "HardarNarasimhan.TotIntvl",
   "List.Chain.nil",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "HardarNarasimhan.impl.prop4d16₁",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Nat.instIsStrictOrderedRing",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_4_16",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.SlopeLike μ →\n    [HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl,\n          HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl,\n          HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl].TFAE ∧\n      (HardarNarasimhan.WeakAscendingChainCondition μ →\n        HardarNarasimhan.WeakDescendingChainCondition μ →\n          [HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl,\n              HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl,\n              HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl,\n              HardarNarasimhan.NashEquilibrium μ].TFAE)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "_private.Mathlib.Order.Lattice.0._proof_9",
   "And",
   "SemilatticeSup.toPartialOrder",
   "and_true",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "Max.max",
   "le_antisymm_iff",
   "iff_self",
   "_private.Mathlib.Order.Lattice.0._proof_7",
   "of_eq_true",
   "congr",
   "Iff",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Eq",
   "Preorder.toLE"],
  "name": "sup_eq_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = a ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.impl.dualμAstar_eq_μBstar",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "Subtype.val",
   "DFunLike.coe",
   "Equiv",
   "Prod.fst",
   "OrderDual.ofDual",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "OrderDual.instLT",
   "OrderDual.instCompleteLattice",
   "HardarNarasimhan.μAstar",
   "OrderDual.instPartialOrder",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "OrderDual.instBoundedOrder",
   "CompleteLattice"],
  "name": "HardarNarasimhan.dualμAstar_eq_μBstar",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  OrderDual.ofDual\n    ((HardarNarasimhan.μAstar fun p => OrderDual.toDual (μ ⟨((↑p).2, (↑p).1), ⋯⟩)) = HardarNarasimhan.μBstar μ)",
  "constCategory": "Theorem"},
 {"references": ["Not", "Eq.symm", "Eq.rec", "Eq"],
  "name": "Eq.mpr_not",
  "constType": "∀ {p q : Prop}, p = q → ¬q → ¬p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LE",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "DecidableLE",
   "Decidable",
   "Decidable.isFalse",
   "DecidableLT",
   "Preorder.toLT",
   "decidableLTOfDecidableLE._proof_2",
   "decidableLTOfDecidableLE.match_1",
   "LT.lt",
   "not_le_of_gt",
   "Preorder",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLE",
   "dite",
   "Decidable.isTrue"],
  "name": "decidableLTOfDecidableLE",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → [DecidableLE α] → DecidableLT α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "instHAdd",
   "AddMonoid.toAddSemigroup",
   "AddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "AddSemigroup.toAdd"],
  "name": "AddCommGroup.mk",
  "constType":
  "{G : Type u} → [toAddGroup : AddGroup G] → (∀ (a b : G), a + b = b + a) → AddCommGroup G",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.NashEquilibrium",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "HardarNarasimhan.impl.instμ_Admissible",
   "Classical.propDecidable",
   "Preorder.toLT",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Eq.symm",
   "Int.instLEInt",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "List.cons",
   "Bool.true",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "instDecidableAnd",
   "Nat.cast",
   "Subtype",
   "Bool",
   "HardarNarasimhan.Convex",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Prod.fst",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "HardarNarasimhan.impl.HNFil",
   "Int.instAdd",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "instNatCastInt",
   "of_decide_eq_true",
   "List.nil",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "CompletelyDistribLattice.toCompleteLattice",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Option.none",
   "instSubNat",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "OrderTop.toTop",
   "instLENat"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_12",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HardarNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HardarNarasimhan.Convex μ) (f : ℕ → ℒ),\n  (∃ n, f n = ⊤) → ∀ (n : ℕ), (∃ N ≥ n + 1, HardarNarasimhan.impl.HNFil μ (n + 1) ≤ f N) → ¬n < n + 1 → False",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocSemiring.mk",
   "AddCommGroup.add_comm",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocCommRing",
   "NonUnitalNonAssocCommRing.mul_comm",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.zero_mul",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.left_distrib"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Definition"},
 {"references": ["_obj", "HardarNarasimhan.Resμ._rarg", "_neutral"],
  "name":
  "HardarNarasimhan.instCoeForallSubtypeProdLtFstSndForallIntervalOfCompleteLattice._cstage2",
  "constType":
  "_neutral → _neutral → _obj → _obj → _obj → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.find",
   "Subtype",
   "PartialOrder.toPreorder",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "HardarNarasimhan.impl.HNFil_of_fin_len",
   "Prod.fst",
   "HardarNarasimhan.impl.HNFil",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNlen",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              (μ : { p // p.1 < p.2 } → S) →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] → [h : HardarNarasimhan.μ_Admissible μ] → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instLTNat",
   "instHAdd",
   "Nat.leRec",
   "Nat.leRec._proof_5",
   "Nat.le_refl",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Nat",
   "Nat.le_succ_of_le",
   "instOfNatNat",
   "LE.le",
   "Nat.le_of_succ_le",
   "Nat.lt_succ_self",
   "Nat.decreasingInduction._proof_11",
   "instLENat",
   "Nat.decreasingInduction._proof_10"],
  "name": "Nat.decreasingInduction",
  "constType":
  "{n : ℕ} →\n  {motive : (m : ℕ) → m ≤ n → Sort u_1} →\n    ((k : ℕ) → (h : k < n) → motive (k + 1) h → motive k ⋯) → motive n ⋯ → {m : ℕ} → (mn : m ≤ n) → motive m mn",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.coe'._proof_18",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "PartialOrder",
   "Subtype.le",
   "Preorder.toLE",
   "Eq",
   "HardarNarasimhan.coe'._proof_20",
   "Set.instLE",
   "Function.Embedding.mk",
   "RelEmbedding.mk",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OrderEmbedding",
   "Set.Iic",
   "HardarNarasimhan.DedekindMacNeilleCompletion",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "LE.le",
   "HardarNarasimhan.coe'",
   "Subtype.mk",
   "HardarNarasimhan.coe'._proof_19"],
  "name": "HardarNarasimhan.coe'.eq_1",
  "constType":
  "∀ {α : Type} [inst : PartialOrder α],\n  HardarNarasimhan.coe' = { toFun := fun x => ⟨Set.Iic x, ⋯⟩, inj' := ⋯, map_rel_iff' := ⋯ }",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HardarNarasimhan.impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → Coe ({ p // p.1 < p.2 } → S) ({ p // p.1 < p.2 } → Sᵒᵈ)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "PartialOrder.toPreorder",
   "eq_of_le_of_not_lt",
   "PartialOrder",
   "LE.le",
   "Eq.symm",
   "Preorder.toLT",
   "Eq",
   "Preorder.toLE"],
  "name": "eq_of_ge_of_not_gt",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≤ b → ¬a < b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "True",
   "instOfNatNat",
   "instHAdd",
   "eq_true",
   "Eq",
   "Nat.lt_add_one",
   "OfNat.ofNat"],
  "name": "_private.Init.Data.Nat.Basic.0._proof_6",
  "constType": "∀ (n : ℕ), (n < n + 1) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint",
   "Bool",
   "Lean.Omega.Coeffs.dot_smul_left",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs",
   "HMul.hMul",
   "Lean.Omega.IntList.instHMulInt",
   "Lean.Omega.Coeffs.combo_eq_smul_add_smul",
   "Int.instMul",
   "congrArg",
   "Lean.Omega.Constraint.combo_sat",
   "Lean.Omega.IntList",
   "Lean.Omega.IntList.instAdd",
   "Int.instAdd",
   "Eq",
   "Bool.true",
   "Lean.Omega.Constraint.sat'.eq_1",
   "instHAdd",
   "Lean.Omega.Coeffs.combo",
   "Lean.Omega.Constraint.combo",
   "Int",
   "HAdd.hAdd",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "id",
   "instHMul",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.combo_sat'",
  "constType":
  "∀ (s t : Omega.Constraint) (a : ℤ) (x : Omega.Coeffs) (b : ℤ) (y v : Omega.Coeffs),\n  s.sat' x v = true → t.sat' y v = true → (Omega.Constraint.combo a s b t).sat' (Omega.Coeffs.combo a x b y) v = true",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "HardarNarasimhan.WeakSlopeLike₁.wsl₁",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.prop4d1₂",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "HardarNarasimhan.WeakAscendingChainCondition.wacc",
   "Preorder.toLE",
   "Eq",
   "HardarNarasimhan.WeakSlopeLike₁",
   "HardarNarasimhan.impl.prop4d1₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_4_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.WeakAscendingChainCondition μ →\n    HardarNarasimhan.WeakSlopeLike₁ μ →\n      HardarNarasimhan.μAstar μ = HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl ∧\n        HardarNarasimhan.μAstar μ ≤ HardarNarasimhan.μBstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "OfNat.ofNat",
   "HardarNarasimhan.μA_DescendingChainCondition.mk",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μA_DescendingChainCondition.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n      (∀ (n : ℕ), f n > f (n + 1)) →\n        ∃ N, HardarNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(a, f N), ⋯⟩) →\n    HardarNarasimhan.μA_DescendingChainCondition μ",
  "constCategory": "Definition"},
 {"references":
  ["Decidable",
   "Subsingleton.elim",
   "Classical.propDecidable",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Nat.sub_one_add_one",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "instLTNat",
   "Exists",
   "HardarNarasimhan.impl.HNFil_prop_of_def",
   "ne_of_gt",
   "BoundedOrder",
   "not_lt_of_ge",
   "Top.top",
   "HardarNarasimhan.impl.HNFil_is_strict_mono",
   "Eq.mpr",
   "HardarNarasimhan.impl.theorem3d10._proof_8",
   "lt_top_iff_ne_top",
   "Nat.find",
   "Nat.add_one_pos",
   "Pi.instSubsingleton",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Or.inl",
   "HardarNarasimhan.impl.HNFil",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "HardarNarasimhan.impl.theorem3d10._proof_13",
   "HardarNarasimhan.S₂I",
   "Eq",
   "not_ne_iff",
   "HardarNarasimhan.instLatticeInterval",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.impl.theorem3d10._proof_5",
   "HardarNarasimhan.μA",
   "lt_of_lt_of_le",
   "CompletelyDistribLattice.toCompleteLattice",
   "eq_self",
   "AddZeroClass.toAdd",
   "HardarNarasimhan.semistableI",
   "Ne",
   "HardarNarasimhan.impl.theorem3d10._proof_10",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "_private.Mathlib.Order.Defs.LinearOrder.0._proof_2",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.impl.theorem3d10._proof_9",
   "le_of_le_of_eq",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "Nat.instAddCommMonoid",
   "GE.ge",
   "Nat.lt_add_one_iff",
   "HardarNarasimhan.impl.lem2d4₃I",
   "Or",
   "PartialOrder",
   "HardarNarasimhan.S₁I._proof_1",
   "CompleteLinearOrder",
   "Eq.rec",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.S₁I",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Nat.instPartialOrder",
   "lt_of_le_of_lt",
   "And.right",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "Mathlib.Tactic.PushNeg.not_le_eq",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "SemilatticeInf.toMin",
   "instDecidableAnd",
   "Eq.mp",
   "le_trans",
   "HardarNarasimhan.Convex",
   "DecidablePred",
   "HardarNarasimhan.impl.HNFil_of_fin_len",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "BoundedOrder.toOrderTop",
   "instSubsingletonDecidable",
   "Not",
   "not_and_or",
   "le_top",
   "instHAdd",
   "HardarNarasimhan.in_TotIntvl",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_3",
   "Nat.sub_le_sub_right",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "HardarNarasimhan.impl.semistableI_iff",
   "LT.lt",
   "lt_add_one",
   "of_eq_true",
   "One.toOfNat1",
   "instSubNat",
   "ne_of_lt",
   "le_of_lt",
   "Nat.succ",
   "SemilatticeSup.toMax",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "False",
   "Subtype.mk",
   "OrderTop.toTop",
   "_private.Init.Core.0._proof_39",
   "instAddNat",
   "Eq.trans",
   "HardarNarasimhan.impl.instμ_Admissible",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "False.elim",
   "le_sup_right",
   "HardarNarasimhan.impl.theorem3d10._proof_12",
   "letFun",
   "HardarNarasimhan.impl.HNlen",
   "Nat.le_of_lt_add_one",
   "Eq.ndrec",
   "le_iff_eq_or_lt",
   "rfl",
   "eq_of_ge_of_not_gt",
   "Exists.choose_spec",
   "eq_comm",
   "Nat.recAux",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat.find_spec",
   "BoundedOrder.toOrderBot",
   "Iff.not",
   "Eq.refl",
   "Lattice",
   "Classical.byContradiction",
   "Nat.sub_one_lt_of_le",
   "HardarNarasimhan.impl.theorem3d10._proof_6",
   "AddMonoid.toAddZeroClass",
   "Or.inr",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Nat.instPreorder",
   "le_inf",
   "instOfNatNat",
   "congr",
   "WellFoundedGT",
   "not_true_eq_false",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "Preorder.toLE",
   "sup_le_iff",
   "propext",
   "inf_lt_left",
   "Nat.instAddMonoid",
   "HardarNarasimhan.impl.theorem3d10._proof_7",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Max.max",
   "dite",
   "right_lt_sup",
   "le_of_not_lt",
   "Nat.find_min",
   "le_refl",
   "Lattice.toSemilatticeSup",
   "Prod.mk",
   "_private.Init.Core.0._proof_38",
   "Iff.mp",
   "Nat.sub_one_lt",
   "HardarNarasimhan.instNontrivialInterval",
   "And.intro",
   "Nat.sub_add_cancel",
   "funext",
   "HardarNarasimhan.Semistable",
   "HSub.hSub",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "HardarNarasimhan.impl.theorem3d10._proof_15",
   "HardarNarasimhan.InIntvl",
   "Nat.add_one_le_iff",
   "And",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Nat.decLt",
   "Nat.gt_of_not_le",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "HardarNarasimhan.impl.theorem3d10._proof_11",
   "upperBounds",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "Subtype",
   "not_le_of_lt",
   "SemilatticeSup.toPartialOrder",
   "congrArg",
   "eq_of_le_of_le",
   "Nat.instOne",
   "Nat.instIsOrderedCancelAddMonoid",
   "OrderBot.toBot",
   "Lattice.toSemilatticeInf",
   "eq_of_le_of_not_lt",
   "True",
   "HardarNarasimhan.StI",
   "Nat.decLe",
   "Exists.choose",
   "HardarNarasimhan.impl.HNFil_ne_top_iff_lt_len",
   "Or.casesOn",
   "Min.min",
   "LE.le",
   "instLENat",
   "HardarNarasimhan.impl.theorem3d10._proof_14"],
  "name": "HardarNarasimhan.impl.theorem3d10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HardarNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HardarNarasimhan.Convex μ) (f : ℕ → ℒ),\n  f 0 = ⊥ →\n    ∀ (hffin : ∃ n, f n = ⊤) (hfsi : ∀ (i j : ℕ), i < j → j ≤ Nat.find hffin → f i < f j),\n      (∀ i ≥ Nat.find hffin, f i = ⊤) →\n        (∀ (j : ℕ) (hj : j < Nat.find hffin),\n            HardarNarasimhan.Semistable (HardarNarasimhan.Resμ ⟨(f j, f (j + 1)), ⋯⟩ μ)) →\n          (∀ (i j : ℕ) (hij : i < j) (hj : j < Nat.find hffin),\n              HardarNarasimhan.μA μ ⟨(f i, f (i + 1)), ⋯⟩ > HardarNarasimhan.μA μ ⟨(f j, f (j + 1)), ⋯⟩) →\n            f = HardarNarasimhan.impl.HNFil μ",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Eq.comm", "Eq"],
  "name": "eq_comm",
  "constType": "∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "Preorder.toLT",
   "False",
   "lt_self_iff_false",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.Basic.0._proof_1",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] (x : α), (x < x) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.μmax._proof_2",
   "PartialOrder",
   "HardarNarasimhan.μmin",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "SupSet",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μB._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "Exists",
   "instOfNatNat",
   "Nontrivial",
   "Exists.intro",
   "Ne",
   "Nontrivial.mk",
   "OfNat.ofNat",
   "Nat.zero_ne_one"],
  "name": "Nat.instNontrivial",
  "constType": "Nontrivial ℕ",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.snd",
  "constType": "{α : Type u} → {β : Type v} → α × β → β",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.WeakAscendingChainCondition.mk",
   "Preorder.toLT",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HardarNarasimhan.WeakAscendingChainCondition.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakAscendingChainCondition μ → Sort u} →\n                ((wacc : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                    motive ⋯) →\n                  (t : HardarNarasimhan.WeakAscendingChainCondition μ) → motive t",
  "constCategory": "Other"},
 {"references": ["_obj", "_neutral"],
  "name": "HardarNarasimhan.μmin._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Membership.mk", "Set", "Set.Mem", "Membership"],
  "name": "Set.instMembership",
  "constType": "{α : Type u} → Membership α (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Or.inl", "Or", "or_self.match_1", "Eq", "propext", "Iff.intro"],
  "name": "or_self",
  "constType": "∀ (p : Prop), (p ∨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "DecidableLT",
   "Preorder.toLT",
   "LinearOrder"],
  "name": "LinearOrder.toDecidableLT",
  "constType": "{α : Type u_2} → [self : LinearOrder α] → DecidableLT α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "Iff.intro",
   "HardarNarasimhan.HardarNarasimhanFiltration.filtration",
   "Eq.symm",
   "WellFoundedGT",
   "HardarNarasimhan.HardarNarasimhanFiltration.ext",
   "Eq.ndrec",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Eq.casesOn",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Iff",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "HEq",
   "CompleteLattice"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.ext_iff",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HardarNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HardarNarasimhan.Convex μ} {h : HardarNarasimhan.μ_Admissible μ}\n  {x y : HardarNarasimhan.HardarNarasimhanFiltration μ},\n  x = y ↔\n    HardarNarasimhan.HardarNarasimhanFiltration.filtration μ = HardarNarasimhan.HardarNarasimhanFiltration.filtration μ",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{α : Type u} → α → Zero α",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder",
   "Set.instCompleteAtomicBooleanAlgebra._proof_4",
   "Set.instCompleteAtomicBooleanAlgebra._proof_12",
   "BooleanAlgebra.toHImp",
   "Set.instCompleteAtomicBooleanAlgebra._proof_11",
   "InfSet.sInf",
   "BooleanAlgebra.toTop",
   "Set.instCompleteAtomicBooleanAlgebra._proof_10",
   "Set.instCompleteAtomicBooleanAlgebra._proof_5",
   "Preorder.toLE",
   "Set.instBooleanAlgebra",
   "Set.instSupSet",
   "BooleanAlgebra",
   "CompleteLattice.mk",
   "Set",
   "Set.instCompleteAtomicBooleanAlgebra._proof_9",
   "Set.instCompleteAtomicBooleanAlgebra._proof_14",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra.toSDiff",
   "Set.instMembership",
   "Set.instCompleteAtomicBooleanAlgebra._proof_2",
   "CompleteAtomicBooleanAlgebra.mk",
   "CompleteAtomicBooleanAlgebra",
   "DistribLattice.toLattice",
   "LE.le",
   "Set.instCompleteAtomicBooleanAlgebra._proof_13",
   "Set.instInfSet",
   "Set.instCompleteAtomicBooleanAlgebra._proof_3",
   "BooleanAlgebra.toHasCompl"],
  "name": "Set.instCompleteAtomicBooleanAlgebra",
  "constType": "{α : Type u_1} → CompleteAtomicBooleanAlgebra (Set α)",
  "constCategory": "Definition"},
 {"references": ["Not", "Iff", "not_congr"],
  "name": "Iff.not",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references":
  ["AddCommMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.add_comm",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid"],
  "name": "AddCommGroup.toAddCommMonoid",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Subtype.partialOrder",
   "_private.Init.PropLemmas.0._proof_25",
   "ClosureOperator",
   "Set.iUnion",
   "Subtype.val",
   "DFunLike.coe",
   "congrArg",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "_private.Init.Data.Subtype.0._proof_2",
   "Subtype.property",
   "funext",
   "ClosureOperator.isClosed_closure",
   "Preorder.toLE",
   "Eq.rec",
   "Eq",
   "propext",
   "Exists",
   "Set",
   "_private.Init.PropLemmas.0._proof_38",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "And",
   "_private.Mathlib.Order.SetNotation.0._proof_3",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_9",
   "exists_prop_congr",
   "Set.instMembership",
   "Exists.casesOn",
   "Iff.of_eq",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "Iff.mpr",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Subtype.mk",
   "And.casesOn"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_11",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds) (A : T.Closeds),\n  (∀ b ∈ 𝒮, b ≤ A) → ∀ ⦃x : α⦄, x ∈ ↑⟨T (⋃ a ∈ 𝒮, ↑a), ⋯⟩ → x ∈ ↑A",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "OrderDual",
   "Min.min",
   "OrderDual.instSemilatticeSup",
   "Eq",
   "sup_comm"],
  "name": "inf_comm",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a b : α), a ⊓ b = b ⊓ a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.instLEInt",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nat.lt_of_not_le",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Bool",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Option.some",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Int.instAdd",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (i j : ℕ),\n  j < Nat.find hffin → ¬j + 1 ≤ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "Subtype.val",
   "And.intro",
   "False.elim",
   "HardarNarasimhan.μmax._proof_2",
   "SupSet.sSup",
   "funext",
   "forall_congr",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "_private.Mathlib.Order.Basic.0._proof_1",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Iff",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "Aesop.BuiltinRules.not_intro",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Iff.intro",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "InfSet.sInf",
   "_private.Init.PropLemmas.0._proof_12",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "sSup_le_iff",
   "bot_lt_iff_ne_bot",
   "le_sInf_iff",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "Set",
   "exists_prop_congr",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "ne_of_lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "_private.Mathlib.Order.CompleteLattice.Defs.0._proof_2",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top",
   "And.casesOn"],
  "name": "HardarNarasimhan.impl.rmk4d10₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.μBstar μ ≤ HardarNarasimhan.μAstar μ ↔\n    ∀ (x : ℒ) (hx : x ≠ ⊤) (y : ℒ) (hy : ⊥ < y),\n      HardarNarasimhan.μmin μ ⟨(⊥, y), hy⟩ ≤ HardarNarasimhan.μmax μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["forall_const", "Nonempty", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_17",
  "constType":
  "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (∀ (a : α), b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["And.intro",
   "True",
   "And",
   "Eq",
   "trivial",
   "propext",
   "And.left",
   "Iff.intro"],
  "name": "and_true",
  "constType": "∀ (p : Prop), (p ∧ True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "And.intro",
   "HardarNarasimhan.NashEquilibrium",
   "HardarNarasimhan.μmax",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "OrderBot.toBot",
   "HardarNarasimhan.impl.rmk4d10₃",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And",
   "BoundedOrder",
   "HardarNarasimhan.impl.rmk4d10₂",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Iff",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice",
   "HardarNarasimhan.impl.rmk4d10₁"],
  "name": "HardarNarasimhan.remark_4_10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (HardarNarasimhan.μBstar μ ≤ HardarNarasimhan.μAstar μ ↔\n      ∀ (x : ℒ) (hx : x ≠ ⊤) (y : ℒ) (hy : ⊥ < y),\n        HardarNarasimhan.μmin μ ⟨(⊥, y), hy⟩ ≤ HardarNarasimhan.μmax μ ⟨(x, ⊤), ⋯⟩) ∧\n    (HardarNarasimhan.WeakAscendingChainCondition μ →\n        HardarNarasimhan.WeakSlopeLike₁ μ →\n          (HardarNarasimhan.NashEquilibrium μ ↔\n            ∀ (y : ℒ) (hy : y ≠ ⊥),\n              HardarNarasimhan.μmin μ ⟨(⊥, y), ⋯⟩ ≤ HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl)) ∧\n      (HardarNarasimhan.WeakDescendingChainCondition μ →\n        HardarNarasimhan.WeakSlopeLike₂ μ →\n          (HardarNarasimhan.NashEquilibrium μ ↔\n            ∀ (y : ℒ) (hy : y ≠ ⊤),\n              HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl ≤ HardarNarasimhan.μmax μ ⟨(y, ⊤), ⋯⟩))",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "instOfNat",
   "instHAdd",
   "Iff",
   "Int.instAdd",
   "LE.le",
   "Int.instLTInt",
   "Int.instLEInt",
   "Iff.rfl",
   "OfNat.ofNat",
   "Int"],
  "name": "Int.add_one_le_iff",
  "constType": "∀ {a b : ℤ}, a + 1 ≤ b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "Nat",
   "Preorder",
   "PartialOrder.toPreorder",
   "inferInstance",
   "Nat.instLinearOrder"],
  "name": "Nat.instPreorder",
  "constType": "Preorder ℕ",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.instFunLike",
   "FunLike",
   "ClosureOperator.instFunLike._proof_1",
   "DFunLike.mk",
   "Preorder",
   "OrderHom",
   "ClosureOperator.toOrderHom",
   "ClosureOperator",
   "DFunLike.coe"],
  "name": "ClosureOperator.instFunLike",
  "constType":
  "(α : Type u_1) → [inst : Preorder α] → FunLike (ClosureOperator α) α α",
  "constCategory": "Definition"},
 {"references": ["Nat", "OfNat", "OfNat.mk"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._rarg",
   "_neutral"],
  "name":
  "HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "HardarNarasimhan.NashEquilibrium",
   "HardarNarasimhan.μmax",
   "HardarNarasimhan.Semistable",
   "HardarNarasimhan.μmin",
   "List.TFAE",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "Eq",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "List.nil",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "BoundedOrder",
   "HardarNarasimhan.impl.thm4d21",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Lattice",
   "Nontrivial"],
  "name": "HardarNarasimhan.theorem_4_21",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.SlopeLike μ →\n    HardarNarasimhan.WeakAscendingChainCondition μ →\n      HardarNarasimhan.WeakDescendingChainCondition μ →\n        [HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl,\n            HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl,\n            HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl,\n            HardarNarasimhan.NashEquilibrium μ, HardarNarasimhan.Semistable μ].TFAE",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "instDecidableIff",
   "instDecidableEqOfIff",
   "Bool",
   "True",
   "instDecidableTrue",
   "Decidable.decide",
   "Eq.refl",
   "id",
   "False",
   "instDecidableFalse",
   "Eq",
   "Bool.true",
   "of_decide_eq_true",
   "instDecidableNot"],
  "name": "not_true_eq_false",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemilatticeSup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "sup_le_iff.match_1",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "And",
   "sup_le",
   "le_sup_left",
   "Iff.intro",
   "And.intro",
   "Max.max",
   "le_sup_right",
   "Iff",
   "LE.le",
   "SemilatticeSup.toMax",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "sup_le_iff",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ⊔ b ≤ c ↔ a ≤ c ∧ b ≤ c",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "Preorder", "lt_irrefl", "Preorder.toLT"],
  "name": "Linarith.lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, ¬a < a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "le_of_not_ge",
   "Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "lt_of_le_not_le",
   "Preorder.toLT",
   "LinearOrder",
   "Preorder.toLE",
   "GE.ge"],
  "name": "lt_of_not_ge",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬a ≥ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.rec", "Eq"],
  "name": "HardarNarasimhan.impl.stupid_helper",
  "constType": "∀ {α : Type} {a b c d : α}, a = b → b = c → c = d → a = d",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Nat",
   "Nat.le_succ_of_le",
   "instOfNatNat",
   "instHAdd",
   "Nat.leRec",
   "LE.le",
   "Nat.le_refl",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Nat.le_induction",
  "constType":
  "∀ {m : ℕ} {P : (n : ℕ) → m ≤ n → Prop},\n  P m ⋯ → (∀ (n : ℕ) (hmn : m ≤ n), P n hmn → P (n + 1) ⋯) → ∀ (n : ℕ) (hmn : m ≤ n), P n hmn",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "DecidableRel", "LT"],
  "name": "DecidableLT",
  "constType": "(α : Type u) → [LT α] → Type (max 0 u)",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.ConvexI.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {S : Type} [inst_1 : CompleteLattice S] {I : { p // p.1 < p.2 }}\n  {μ : { p // p.1 < p.2 } → S},\n  (∀ (x y : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        HardarNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩) →\n    HardarNarasimhan.ConvexI I μ",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "le_trans",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Membership.mem",
   "Preorder.toLE",
   "sInf_le",
   "Set.instMembership",
   "CompleteSemilatticeInf"],
  "name": "sInf_le_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a b : α}, b ∈ s → b ≤ a → sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Int",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "_private.Init.SimpLemmas.0._proof_4",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "_private.Mathlib.Order.CompleteLattice.Defs.0._proof_1",
   "_private.Mathlib.Data.Set.Operations.0._proof_5",
   "_private.Mathlib.Order.Basic.0._proof_34",
   "SupSet.sSup",
   "congrFun",
   "letFun",
   "_private.Init.PropLemmas.0._proof_43",
   "Function.instFunLikeEmbedding",
   "Eq.ndrec",
   "rfl",
   "Exists",
   "Exists.choose_spec",
   "ClosureOperator.IsClosed",
   "Function.Embedding",
   "Set.Iic",
   "Set.right_mem_Iic",
   "Set.instMembership",
   "HardarNarasimhan.DedekindMacNeilleCompletion",
   "implies_true",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff",
   "Eq.refl",
   "Classical.byContradiction",
   "lowerBounds",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "setOf",
   "RelEmbedding.toEmbedding",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "ClosureOperator.instFunLike",
   "congr",
   "Subtype.property",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "Function.Embedding.mk",
   "Set",
   "Set.not_subset",
   "OrderEmbedding",
   "RelEmbedding.map_rel_iff'",
   "CompleteLattice",
   "And.casesOn",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Iff.mp",
   "RelEmbedding.instFunLike",
   "HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "And.intro",
   "PartialOrder",
   "sSup_le",
   "forall_congr",
   "funext",
   "Eq.rec",
   "And.left",
   "RelEmbedding.mk",
   "And.right",
   "And",
   "Exists.casesOn",
   "Set.image",
   "HasSubset.Subset",
   "upperBounds",
   "id",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "Subtype.partialOrder",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "_private.Init.Core.0._proof_25",
   "Iff.intro",
   "congrArg",
   "_private.Init.PropLemmas.0._proof_12",
   "Set.mem_image_of_mem",
   "Subtype.le",
   "le_antisymm",
   "Set.instLE",
   "Not",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "_private.Mathlib.Order.Hom.Basic.0._proof_50",
   "True",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Mathlib.Tactic.PushNeg.not_and_eq",
   "Function.comp",
   "Exists.choose",
   "_private.Init.Data.Subtype.0._proof_1",
   "Set.instHasSubset",
   "le_antisymm_iff",
   "of_eq_true",
   "_private.Mathlib.Order.Interval.Set.Defs.0._proof_5",
   "LE.le",
   "HardarNarasimhan.coe'",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet"],
  "name": "HardarNarasimhan.DedekindMacNeilleCompletion_minimality",
  "constType":
  "∀ {α : Type} [inst : PartialOrder α] {β : Type} [inst_1 : CompleteLattice β] (f : α ↪o β),\n  ∃ f', ⇑f = ⇑f' ∘ ⇑HardarNarasimhan.coe'",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Membership.mem",
   "Set.mem_iInter",
   "Eq",
   "Set.iInter",
   "propext",
   "Set.instMembership"],
  "name": "_private.Mathlib.Order.SetNotation.0._proof_4",
  "constType":
  "∀ {α : Type u} {ι : Sort v} {x : α} {s : ι → Set α}, (x ∈ ⋂ i, s i) = ∀ (i : ι), x ∈ s i",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteAtomicBooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder", "Or", "PartialOrder", "LE.le", "Preorder.toLE"],
  "name": "HardarNarasimhan.IsComparable",
  "constType": "{ℒ : Type} → [PartialOrder ℒ] → ℒ → ℒ → Prop",
  "constCategory": "Definition"},
 {"references": ["_obj", "HardarNarasimhan.Resμ._rarg"],
  "name":
  "HardarNarasimhan.instCoeForallSubtypeProdLtFstSndForallIntervalOfCompleteLattice._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "le_refl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "absurd",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Or",
   "le_of_lt",
   "LE.le",
   "Eq.rec",
   "Eq",
   "Preorder.toLE",
   "lt_trichotomy",
   "le_of_not_lt.match_1"],
  "name": "le_of_not_lt",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬b < a → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "Nat.cast",
   "Int.instLTInt",
   "Eq",
   "Mathlib.Tactic.Zify.natCast_lt",
   "propext",
   "instNatCastInt",
   "Int"],
  "name": "_private.Mathlib.Tactic.Zify.0._proof_3",
  "constType": "∀ (a b : ℕ), (a < b) = (↑a < ↑b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "InfSet",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "Equiv",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "SupSet.sSup",
   "funext",
   "Eq.symm",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "ConditionallyCompleteLattice.toInfSet",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Set.ext",
   "Eq.mpr",
   "OrderDual.instBoundedOrder",
   "setOf",
   "OrderDual",
   "OrderDual.toDual",
   "Ne.symm",
   "Subtype",
   "OrderDual.instLattice",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "Iff.intro",
   "congrArg",
   "OrderDual.ofDual",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "HardarNarasimhan.μmax",
   "OrderDual.instLT",
   "BoundedOrder.toOrderTop",
   "congr",
   "OrderDual.instCompleteLattice",
   "InfSet.sInf",
   "OrderDual.instPartialOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Not",
   "_private.Mathlib.Order.Synonym.0._proof_6",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "HardarNarasimhan.in_TotIntvl",
   "Set",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HardarNarasimhan.impl.dualμBstar_eq_μAstar",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  OrderDual.ofDual\n    ((HardarNarasimhan.μBstar fun p => OrderDual.toDual (μ ⟨((↑p).2, (↑p).1), ⋯⟩)) = HardarNarasimhan.μAstar μ)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "sSup_le_sSup_of_forall_exists_le.match_1",
   "CompleteSemilatticeSup",
   "Membership.mem",
   "And",
   "CompleteSemilatticeSup.toSupSet",
   "LE.le.trans",
   "Set.instMembership",
   "le_sSup_iff",
   "upperBounds",
   "SupSet.sSup",
   "sSup_le",
   "Iff.mpr",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sSup_le_sSup_of_forall_exists_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s t : Set α}, (∀ x ∈ s, ∃ y ∈ t, x ≤ y) → sSup s ≤ sSup t",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "True",
   "instHAdd",
   "List",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_3",
  "constType":
  "∀ {a0 a1 a2 a3 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 3).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: t)) = a3",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "SubNegMonoid.zsmul_neg'._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "HSub.hSub",
   "Ne",
   "Nat.pred_lt",
   "instHSub",
   "OfNat.ofNat"],
  "name": "Nat.sub_one_lt",
  "constType": "∀ {n : ℕ}, n ≠ 0 → n - 1 < n",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "Subtype", "Preorder.lift", "Subtype.val"],
  "name": "Subtype.preorder",
  "constType":
  "{α : Type u_2} → [Preorder α] → (p : α → Prop) → Preorder (Subtype p)",
  "constCategory": "Definition"},
 {"references": ["HMul", "outParam"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod.casesOn",
   "And.intro",
   "Preorder.toLE",
   "Nontrivial.mk",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "ne_of_lt",
   "le_of_lt",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Ne",
   "Subtype.casesOn",
   "Subtype.mk",
   "Subtype.coe_ne_coe"],
  "name": "HardarNarasimhan.instNontrivialInterval",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }},\n  Nontrivial (HardarNarasimhan.Interval z)",
  "constCategory": "Theorem"},
 {"references": ["Exists", "exists_and_right", "And", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_25",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, p x ∧ b) = ((∃ x, p x) ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "True",
   "instHAdd",
   "List",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_4",
  "constType":
  "∀ {a0 a1 a2 a3 a4 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 4).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: a4 :: t)) = a4",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "HardarNarasimhan.ConvexI.casesOn",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq",
   "Eq.ndrec",
   "Preorder.toLE",
   "inf_lt_left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "HardarNarasimhan.ConvexI.noConfusionType",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.ConvexI.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Lattice ℒ} →\n    {S : Type} →\n      {inst_1 : CompleteLattice S} →\n        {I : { p // p.1 < p.2 }} →\n          {μ : { p // p.1 < p.2 } → S} →\n            {P : Sort u} →\n              {v1 v2 : HardarNarasimhan.ConvexI I μ} → v1 = v2 → HardarNarasimhan.ConvexI.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Ring.toNonAssocRing",
   "Bool.false",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "Subtype.coe_eta",
   "HardarNarasimhan.impl.prop3d4₀func_defprop3₀",
   "Eq.symm",
   "Nat.sub_one_add_one",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "HardarNarasimhan.impl.prop3d4₀func_helper",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "inf_eq_right",
   "ne_of_gt",
   "BoundedOrder",
   "Ring.toSemiring",
   "Linarith.mul_neg",
   "instOfNat",
   "eq_false",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "Int.instCharZero",
   "Nat.find",
   "Mathlib.Tactic.Ring.add_mul",
   "Nat.le_refl",
   "Nat.one_le_iff_ne_zero",
   "Prod.fst",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "HardarNarasimhan.S₂I",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "HardarNarasimhan.impl.prop3d4₀func_defprop3",
   "Set",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Mathlib.Tactic.Ring.mul_congr",
   "lt_of_lt_of_le",
   "Nat.cast_add",
   "eq_self",
   "Monoid.toNatPow",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "instHSub",
   "CompleteLattice",
   "HardarNarasimhan.impl.prop3d4₀func_strict_decreasing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "not_false_eq_true",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "PartialOrder",
   "forall_congr",
   "Int.instLEInt",
   "HardarNarasimhan.S₁I._proof_1",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Eq.rec",
   "HardarNarasimhan.S₁I",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "And.right",
   "lt_of_le_of_lt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_zero",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "ge_of_eq",
   "Nat.lt_of_le_sub_one",
   "SemilatticeInf.toMin",
   "Nat.cast",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "CommRing.toNonUnitalCommRing",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "Set.Nonempty",
   "instHAdd",
   "Prod.mk.eta",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "ne_of_lt",
   "instSubNat",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_lt",
   "Linarith.zero_lt_one",
   "SemilatticeSup.toMax",
   "False",
   "Subtype.mk",
   "ge_trans",
   "Linarith.natCast_nonneg",
   "_private.Init.Core.0._proof_39",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.ConvexI",
   "Exists.intro",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "letFun",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Nat.decreasingInduction",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Nat.recAux",
   "Prod.snd",
   "HardarNarasimhan.impl.prop3d4₀func_len",
   "Set.instMembership",
   "Prod",
   "instNonemptyOfInhabited",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.add_lt_of_lt_sub",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Bool",
   "_private.Init.PropLemmas.0._proof_17",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Nat.instPreorder",
   "le_rfl",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "HardarNarasimhan.impl.prop3d4₀func_len_nonzero",
   "Int.instAdd",
   "WellFoundedGT",
   "Mathlib.Tactic.Ring.mul_add",
   "sup_le_iff",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Max.max",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "instIsIrreflGt",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nat.le_of_succ_le",
   "neg_neg_of_pos",
   "right_lt_sup",
   "dite",
   "Nat.find_min",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Lattice.toSemilatticeSup",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HardarNarasimhan.impl.prop3d4₀func_defprop2",
   "_private.Init.Core.0._proof_38",
   "Nat.sub_one_lt",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "And.intro",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "Nat.sub_add_cancel",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.zero_lt_of_ne_zero",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "HardarNarasimhan.impl.prop2d8₁I",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "HardarNarasimhan.InIntvl",
   "And",
   "HardarNarasimhan.impl.prop3d4₀func_defprop1",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "ConditionallyCompleteLattice.toLattice",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "SemilatticeSup.toPartialOrder",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "irrefl",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "True",
   "HardarNarasimhan.StI",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "gt_of_ge_of_gt",
   "HardarNarasimhan.impl.prop3d4₀func_fin_len",
   "NegZeroClass.toNeg",
   "Min.min",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "instLENat",
   "Int.instAddMonoid",
   "instInhabitedTrue"],
  "name": "HardarNarasimhan.impl.prop3d4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.μA_DescendingChainCondition μ →\n    ∀ (I : { p // p.1 < p.2 }), HardarNarasimhan.ConvexI I μ → (HardarNarasimhan.StI μ I).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "OrderDual.toDual",
   "OrderDual",
   "PartialOrder.toPreorder",
   "Equiv.instFunLike",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "DFunLike.coe",
   "Equiv",
   "OrderDual.ofDual",
   "OrderDual.instPreorder",
   "HardarNarasimhan.DedekindMacNeilleConnection",
   "upperBounds",
   "GaloisConnection.closureOperator",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "lowerBounds",
   "Preorder.toLE"],
  "name": "HardarNarasimhan.DedekindMacNeilleClosureOperator",
  "constType": "(α : Type) → [PartialOrder α] → ClosureOperator (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Ring.intCast_ofNat",
   "Ring.toNeg",
   "Semiring.natCast_succ",
   "Ring.toSub",
   "Semiring.toOne",
   "Ring.zsmul",
   "AddGroupWithOne.mk",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddGroupWithOne",
   "AddCommMonoid.toAddMonoid",
   "Ring.neg_add_cancel",
   "Ring.zsmul_neg'",
   "AddMonoidWithOne.mk",
   "Ring.intCast_negSucc",
   "Ring.toSemiring",
   "Ring.zsmul_zero'",
   "Ring.sub_eq_add_neg",
   "Ring.toIntCast",
   "Semiring.toNatCast",
   "Semiring.natCast_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNonUnitalSemiring",
   "Ring"],
  "name": "Ring.toAddGroupWithOne",
  "constType": "{R : Type u} → [self : Ring R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Nat.zero_lt_of_ne_zero.match_1",
   "instLTNat",
   "instHAdd",
   "Nat.zero_lt_succ",
   "OfNat.ofNat",
   "LT.lt",
   "absurd",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "Eq.refl",
   "Ne",
   "Eq"],
  "name": "Nat.zero_lt_of_ne_zero",
  "constType": "∀ {a : ℕ}, a ≠ 0 → 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "GT.gt",
   "GE.ge",
   "Eq.symm",
   "Int.instLEInt",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nat.lt_of_not_le",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Bool",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Option.some",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Int.instAdd",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_15",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (n : ℕ),\n  n + 1 > Nat.find hffin → ¬n ≥ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references": ["AddSemigroup", "Add"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Prod",
   "PartialOrder.toPreorder",
   "Subtype",
   "PartialOrder",
   "LE.le",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Preorder.toLE",
   "Subtype.val",
   "Prod.fst"],
  "name": "HardarNarasimhan.InIntvl",
  "constType":
  "{ℒ : Type} → [inst : PartialOrder ℒ] → { p // p.1 < p.2 } → ℒ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._rarg",
   "_obj",
   "_neutral"],
  "name":
  "HardarNarasimhan.impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "HardarNarasimhan.SlopeLike.mk",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.SlopeLike.rec",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.SlopeLike.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.SlopeLike μ → Sort u} →\n                (t : HardarNarasimhan.SlopeLike μ) →\n                  ((slopelike :\n                        ∀ (x y z : ℒ) (h : x < y ∧ y < z),\n                          (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n                            (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n                              (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n                                (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "HardarNarasimhan.instCoeOutInterval._rarg", "_neutral"],
  "name": "HardarNarasimhan.instCoeOutInterval._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "HardarNarasimhan.WeakSlopeLike₁.wsl₁",
   "HardarNarasimhan.TotIntvl._proof_1",
   "Subtype.val",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "HardarNarasimhan.NashEquilibrium",
   "SupSet.sSup",
   "sSup_le",
   "letFun",
   "funext",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "HardarNarasimhan.WeakAscendingChainCondition.wacc",
   "Eq.rec",
   "HardarNarasimhan.WeakSlopeLike₁",
   "HardarNarasimhan.impl.prop4d1₁",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Iff",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Ne.symm",
   "Subtype",
   "Eq.mp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "congrArg",
   "Iff.intro",
   "Prod.fst",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "bot_ne_top",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "HardarNarasimhan.NashEquilibrium.mk",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.in_TotIntvl",
   "HardarNarasimhan.TotIntvl",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "le_sSup",
   "Ne",
   "Subtype.mk",
   "HardarNarasimhan.NashEquilibrium.nash_eq",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.rmk4d10₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.WeakAscendingChainCondition μ →\n    HardarNarasimhan.WeakSlopeLike₁ μ →\n      (HardarNarasimhan.NashEquilibrium μ ↔\n        ∀ (y : ℒ) (hy : y ≠ ⊥), HardarNarasimhan.μmin μ ⟨(⊥, y), ⋯⟩ ≤ HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HardarNarasimhan.SlopeLike.mk",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.SlopeLike.rec",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.SlopeLike.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.SlopeLike μ → Sort u} →\n                (t : HardarNarasimhan.SlopeLike μ) →\n                  ((slopelike :\n                        ∀ (x y z : ℒ) (h : x < y ∧ y < z),\n                          (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n                            (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n                              (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n                                (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Or",
   "Iff",
   "Decidable.or_iff_not_imp_left",
   "Classical.propDecidable"],
  "name": "Classical.or_iff_not_imp_left",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ ¬a → b",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Set",
   "Membership.mem",
   "And",
   "Eq",
   "Set.instMembership",
   "setOf"],
  "name": "Set.image",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Set α → Set β",
  "constCategory": "Definition"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "∀ {a b : Prop}, (a → b) → ¬b → ¬a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "Subtype.ext",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Eq",
   "Preorder.toLE",
   "le_antisymm",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HardarNarasimhan.Interval z), ↑a ≤ ↑b → ↑b ≤ ↑a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Preorder.toLT",
   "Ne",
   "lt_of_le_of_ne",
   "Preorder.toLE",
   "flip"],
  "name": "Ne.lt_of_le",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≠ b → a ≤ b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "LE.le", "Membership.mem", "LE", "Set.instMembership", "setOf"],
  "name": "upperBounds",
  "constType": "{α : Type u_1} → [LE α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "instLTNat",
   "Nat.gt_of_not_le",
   "Nat",
   "LE.le",
   "instLENat"],
  "name": "Nat.lt_of_not_le",
  "constType": "∀ {a b : ℕ}, ¬a ≤ b → b < a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 → Prop",
  "constCategory": "Other"},
 {"references": ["HMul", "HMul.mk", "Mul", "Mul.mul"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_3._cstage2",
  "constType": "_obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Inter.inter",
   "Membership.mem",
   "And.right",
   "Set.instInter",
   "Set.instMembership"],
  "name": "Set.inter_subset_right",
  "constType": "∀ {α : Type u} {s t : Set α}, s ∩ t ⊆ t",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["Lean.Name"],
  "name": "Lean.Name.anonymous",
  "constType": "Name",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_2"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "HMul.hMul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "mul_neg",
   "MonoidWithZero.toMonoid",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "InvolutiveNeg.toNeg",
   "Eq.ndrec",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "instHPow",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "HPow.hPow",
   "Ring.toSemiring",
   "Ring.toAddCommGroup",
   "eq_self",
   "Nat",
   "NegZeroClass.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Monoid.toNatPow",
   "of_eq_true",
   "instHMul",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_mul",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] (a₁ : R) (a₂ : ℕ) {a₃ b : R}, -a₃ = b → -(a₁ ^ a₂ * a₃) = a₁ ^ a₂ * b",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Subtype",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "And",
   "Subtype.partialOrder",
   "ClosureOperator",
   "Subtype.val",
   "Set.instMembership",
   "And.intro",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_8",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B C : T.Closeds), A ≤ B → A ≤ C → ∀ a ∈ ↑A, a ∈ ↑B ∧ a ∈ ↑C",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "HardarNarasimhan.μB",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HardarNarasimhan.μBstar.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.μBstar μ = HardarNarasimhan.μB μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.find",
   "Subtype",
   "PartialOrder.toPreorder",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.HardarNarasimhanFiltration.fin_len",
   "HardarNarasimhan.HardarNarasimhanFiltration.filtration",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "OrderTop.toTop",
   "instLENat",
   "CompleteLattice"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.strict_mono",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HardarNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HardarNarasimhan.Convex μ} {h : HardarNarasimhan.μ_Admissible μ}\n  [self : HardarNarasimhan.HardarNarasimhanFiltration μ] (i j : ℕ),\n  i < j →\n    j ≤ Nat.find ⋯ →\n      HardarNarasimhan.HardarNarasimhanFiltration.filtration μ i <\n        HardarNarasimhan.HardarNarasimhanFiltration.filtration μ j",
  "constCategory": "Theorem"},
 {"references": ["EmptyCollection.mk", "Set", "False", "EmptyCollection"],
  "name": "Set.instEmptyCollection",
  "constType": "{α : Type u} → EmptyCollection (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "HardarNarasimhan.μBstar",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HardarNarasimhan.WeakSlopeLike₁.wsl₁",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "HardarNarasimhan.impl.prop4d3₂",
   "eq_of_le_of_le",
   "HardarNarasimhan.NashEquilibrium",
   "Or.inl",
   "Or",
   "HardarNarasimhan.Semistable",
   "HardarNarasimhan.impl.prop4d1₂",
   "HardarNarasimhan.μAstar",
   "HardarNarasimhan.WeakSlopeLike₂.wsl₂",
   "HardarNarasimhan.WeakAscendingChainCondition.wacc",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.NashEquilibrium.mk",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.impl.prop4d18₁",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakDescendingChainCondition.wdcc",
   "HardarNarasimhan.WeakSlopeLike₂",
   "Or.casesOn",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Eq.refl",
   "LE.le",
   "Lattice",
   "Nontrivial"],
  "name": "HardarNarasimhan.impl.prop4d18₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Semistable μ →\n    HardarNarasimhan.WeakAscendingChainCondition μ ∧ HardarNarasimhan.WeakSlopeLike₁ μ ∨\n        HardarNarasimhan.WeakDescendingChainCondition μ ∧ HardarNarasimhan.WeakSlopeLike₂ μ →\n      HardarNarasimhan.NashEquilibrium μ",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.WeakAscendingChainCondition",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Iff", "Membership.mem", "Iff.rfl", "setOf", "Set.instMembership"],
  "name": "Set.mem_setOf",
  "constType": "∀ {α : Type u} {a : α} {p : α → Prop}, a ∈ {x | p x} ↔ p a",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.WeakSlopeLike₂.casesOn",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₂.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u → HardarNarasimhan.WeakSlopeLike₂ μ → HardarNarasimhan.WeakSlopeLike₂ μ → Sort u",
  "constCategory": "Definition"},
 {"references": ["Subtype", "Subtype.property", "Subtype.val"],
  "name": "Subtype.prop",
  "constType": "∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat", "Nat.instCommSemiring", "CommSemiring", "inferInstance"],
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "HardarNarasimhan.DedekindMacNeilleCompletion",
   "PartialOrder",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan",
   "inferInstance",
   "CompleteLattice"],
  "name": "HardarNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → CompleteLattice (HardarNarasimhan.DedekindMacNeilleCompletion α)",
  "constCategory": "Definition"},
 {"references": ["OfNat", "OfNat.mk", "Zero", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "HardarNarasimhan.μmin",
   "Eq.ndrec",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "HardarNarasimhan.impl.rmk4d10₀",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "Or.resolve_left",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Ne.symm",
   "Subtype",
   "Classical.not_not",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Prod.fst",
   "le_rfl",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "LT.lt",
   "LE.le",
   "le_sSup",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop4d12",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      ¬μ ⟨(⊥, x), ⋯⟩ ≤ μ HardarNarasimhan.TotIntvl ∨ μ HardarNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩) →\n    HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl →\n      HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_2._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Min.min",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "inf_le_left",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HardarNarasimhan.Interval z), ↑a ⊓ ↑b ≤ ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddSemigroup.toAdd",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.mk",
   "PosSMulStrictMono",
   "Real",
   "AddCommGroup.add_comm",
   "instHAdd",
   "LinearOrder",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.rec",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "AddMonoid.toAddSemigroup",
   "LE.le"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.casesOn",
  "constType":
  "{V : Type} →\n  {motive : HardarNarasimhan.TotallyOrderedRealVectorSpace V → Sort u} →\n    (t : HardarNarasimhan.TotallyOrderedRealVectorSpace V) →\n      ([toAddCommGroup : AddCommGroup V] →\n          [toModule : _root_.Module ℝ V] →\n            [toLinearOrder : LinearOrder V] →\n              [toPosSMulStrictMono : PosSMulStrictMono ℝ V] →\n                (elim_AddLeftMono : ∀ {y z : V} (x : V), y ≤ z → x + y ≤ x + z) →\n                  motive\n                    { toAddCommGroup := toAddCommGroup, toModule := toModule, toLinearOrder := toLinearOrder,\n                      toPosSMulStrictMono := toPosSMulStrictMono, elim_AddLeftMono := elim_AddLeftMono }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderBot",
  "constType": "(α : Type u) → [LE α] → Type u",
  "constCategory": "Other"},
 {"references": ["Eq.refl", "Eq.symm", "Eq.ndrec", "Eq"],
  "name": "Mathlib.Tactic.Ring.of_eq",
  "constType": "∀ {α : Sort u_2} {a b c : α}, a = c → b = c → a = b",
  "constCategory": "Theorem"},
 {"references": ["SMul"],
  "name": "SMul.mk",
  "constType": "{M : Type u} → {α : Type v} → (M → α → α) → SMul M α",
  "constCategory": "Other"},
 {"references":
  ["instLTNat",
   "List",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.263",
   "Option.some",
   "List.instGetElem?NatLtLength",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.251",
   "LT.lt",
   "GetElem?.getElem?",
   "Nat",
   "Iff",
   "Option",
   "List.mem_of_getElem?",
   "List.TFAE",
   "autoParam",
   "Eq",
   "List.length"],
  "name": "List.TFAE.out",
  "constType":
  "∀ {l : List Prop},\n  l.TFAE →\n    ∀ (n₁ n₂ : ℕ) {a b : Prop}, autoParam (l[n₁]? = some a) _auto✝ → autoParam (l[n₂]? = some b) _auto✝¹ → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.S₂I",
   "Ne",
   "Preorder.toLE",
   "HardarNarasimhan.S₁I",
   "CompleteLattice",
   "setOf",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.StI",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Set ℒ",
  "constCategory": "Definition"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name": "HardarNarasimhan.TotIntvl._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "GT.gt",
   "HardarNarasimhan.impl.prop3d4₀func._proof_7",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.impl.prop3d4₀func._proof_4",
   "HardarNarasimhan.impl.prop3d4₀func._proof_8",
   "HardarNarasimhan.impl.ℒₛ",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "dite",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func.eq_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ),\n  HardarNarasimhan.impl.prop3d4₀func μ I n.succ =\n    if hbot : (↑I).1 = ↑(HardarNarasimhan.impl.prop3d4₀func μ I n) then ⟨(↑I).1, ⋯⟩\n    else\n      if hne : (HardarNarasimhan.impl.ℒₛ μ I (HardarNarasimhan.impl.prop3d4₀func μ I n) hbot).Nonempty then\n        let res := ⋯;\n        ⟨res.choose, ⋯⟩\n      else ⟨(↑I).1, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "Semiring.mul_one",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "MonoidWithZero",
   "Semiring.one_mul",
   "Semiring.npow_succ",
   "MonoidWithZero.mk",
   "Semigroup.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Monoid.mk",
   "Semiring.npow",
   "Semiring.npow_zero",
   "Semiring.toNonUnitalSemiring",
   "Semiring",
   "NonUnitalSemiring.mul_assoc"],
  "name": "Semiring.toMonoidWithZero",
  "constType": "{α : Type u} → [self : Semiring α] → MonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["le_rfl",
   "SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "inf_le_inf",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_le_inf_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a : α) {b c : α}, b ≤ c → b ⊓ a ≤ c ⊓ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "SemilatticeSup.toPartialOrder",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "sup_le",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Max.max",
   "SemilatticeSup.toMax",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b c : HardarNarasimhan.Interval z), ↑a ≤ ↑c → ↑b ≤ ↑c → ↑a ⊔ ↑b ≤ ↑c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemilatticeInf",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["HasSubset.mk", "Set", "HasSubset", "LE.le", "Set.instLE"],
  "name": "Set.instHasSubset",
  "constType": "{α : Type u} → HasSubset (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Preorder.toLT",
   "Classical.propDecidable",
   "HardarNarasimhan.μ_Admissible",
   "IsGreatest",
   "letFun",
   "HardarNarasimhan.impl.HNlen",
   "Nat.instLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Nat.find_spec",
   "Iff",
   "Nontrivial",
   "Lattice",
   "Classical.byContradiction",
   "Top.top",
   "Subtype",
   "HardarNarasimhan.impl.HNFil._proof_3",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.impl.HNFil_of_fin_len",
   "congrArg",
   "Iff.intro",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.impl.HNFil",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Nat.le_induction",
   "Lattice.toSemilatticeInf",
   "True",
   "HardarNarasimhan.StI",
   "Mathlib.Tactic.PushNeg.not_lt_eq",
   "Exists.choose",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "eq_self",
   "dite_cond_eq_true",
   "of_eq_true",
   "HardarNarasimhan.impl.HNFil._proof_4",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop",
   "instLENat",
   "Nat.find_min",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil_ne_top_iff_lt_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ] (n : ℕ),\n  HardarNarasimhan.impl.HNFil μ n ≠ ⊤ ↔ n < HardarNarasimhan.impl.HNlen μ",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.impl.lem2d4₂I",
   "Lattice.toSemilatticeSup",
   "le_refl",
   "PartialOrder.toPreorder",
   "sup_eq_left",
   "HardarNarasimhan.ConvexI",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "GE.ge",
   "Subtype.val",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "PartialOrder",
   "letFun",
   "sSup_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "forall_congr",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "inf_eq_right",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "SemilatticeInf.toMin",
   "Subtype",
   "Eq.mp",
   "SemilatticeSup.toPartialOrder",
   "lt_of_le_of_ne",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Prod.fst",
   "le_rfl",
   "eq_of_le_of_le",
   "Subtype.prop",
   "HardarNarasimhan.μmax",
   "_private.Init.PropLemmas.0._proof_12",
   "Preorder.toLE",
   "Eq",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "gt_of_ge_of_gt",
   "not_le_of_gt",
   "LT.lt",
   "Max.max",
   "ne_of_lt",
   "Min.min",
   "le_of_lt",
   "SemilatticeSup.toMax",
   "LE.le",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "Ne",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.rmk2d5₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ → HardarNarasimhan.μmax μ I = HardarNarasimhan.μmax (HardarNarasimhan.μmax μ) I",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "PUnit.unit",
  "constType": "PUnit.{u}",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "And",
   "Iff.intro",
   "And.intro",
   "PartialOrder",
   "Iff",
   "LE.le",
   "le_of_eq",
   "Eq.symm",
   "le_antisymm_iff.match_1",
   "Eq",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "le_antisymm_iff",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a = b ↔ a ≤ b ∧ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "sInf_le_sInf",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "Subtype",
   "lt_of_le_of_ne",
   "HardarNarasimhan.Convex_of_Convex_large",
   "Prod.fst",
   "congrArg",
   "le_rfl",
   "eq_of_le_of_le",
   "HardarNarasimhan.μmax",
   "Preorder.toLE",
   "Eq",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.μA",
   "LT.lt",
   "HardarNarasimhan.impl.rmk2d5₂",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.rmk2d5₃",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ → HardarNarasimhan.μA μ I = HardarNarasimhan.μA (HardarNarasimhan.μmax μ) I",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Nat", "LE.mk", "LE", "Nat.le"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Classical.propDecidable",
   "HardarNarasimhan.instNontrivialInterval",
   "HardarNarasimhan.μ_Admissible",
   "Nat.instAddCommMonoid",
   "HardarNarasimhan.HardarNarasimhanFiltration.fin_len",
   "HardarNarasimhan.Semistable",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "Nat.instIsOrderedAddMonoid",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Nat.instPartialOrder",
   "BoundedOrder",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Prod.snd",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Prod",
   "Nat.instCanonicallyOrderedAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "AddMonoid.toAddZeroClass",
   "Nat.find",
   "Subtype",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.HardarNarasimhanFiltration.strict_mono",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Nat.instOne",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "HardarNarasimhan.HardarNarasimhanFiltration.filtration",
   "Nat.instIsOrderedCancelAddMonoid",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "HardarNarasimhan.instLatticeInterval",
   "Nat.instAddMonoid",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "lt_add_one",
   "AddZeroClass.toAdd",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.piecewise_semistable",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HardarNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HardarNarasimhan.Convex μ} {h : HardarNarasimhan.μ_Admissible μ}\n  [self : HardarNarasimhan.HardarNarasimhanFiltration μ] (i : ℕ) (h_1 : i < Nat.find ⋯),\n  HardarNarasimhan.Semistable\n    (HardarNarasimhan.Resμ\n      ⟨(HardarNarasimhan.HardarNarasimhanFiltration.filtration μ i,\n          HardarNarasimhan.HardarNarasimhanFiltration.filtration μ (i + 1)),\n        ⋯⟩\n      μ)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "AddMonoid.nsmul_succ._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype.mk.injEq",
   "PartialOrder.toPreorder",
   "Subtype",
   "Eq.mp",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem.out",
   "Set.Iic",
   "Set.right_mem_Iic",
   "Set.instMembership",
   "HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "LE.le",
   "Eq.symm",
   "Subtype.mk",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "le_antisymm"],
  "name": "HardarNarasimhan.coe'._proof_19",
  "constType":
  "∀ {α : Type} [inst : PartialOrder α]\n  (inj : ∀ (x : α), (HardarNarasimhan.DedekindMacNeilleClosureOperator α).IsClosed (Set.Iic x)) ⦃a b : α⦄,\n  ⟨Set.Iic a, ⋯⟩ = ⟨Set.Iic b, ⋯⟩ → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.TotallyOrderedRealVectorSpace", "AddCommGroup"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
  "constType":
  "{V : Type} → [self : HardarNarasimhan.TotallyOrderedRealVectorSpace V] → AddCommGroup V",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._proof_11",
   "OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HardarNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "Unit.unit",
   "OfNat.ofNat",
   "Unit"],
  "name": "HardarNarasimhan.impl.HNFil.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.instLatticeInterval._rarg._lambda_1",
   "Lattice.toSemilatticeInf._elambda_1._rarg",
   "_obj",
   "LE.mk",
   "Lattice.mk",
   "SemilatticeSup.mk",
   "Preorder.mk",
   "LT.mk",
   "_neutral"],
  "name": "HardarNarasimhan.instLatticeInterval._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "Lattice.mk",
  "constType":
  "{α : Type u} →\n  [toSemilatticeSup : SemilatticeSup α] →\n    (inf : α → α → α) →\n      (∀ (a b : α), inf a b ≤ a) → (∀ (a b : α), inf a b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ inf b c) → Lattice α",
  "constCategory": "Other"},
 {"references": ["True", "Eq", "trivial", "propext", "Iff.intro"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references": ["AddGroupWithOne", "AddMonoidWithOne"],
  "name": "AddGroupWithOne.toAddMonoidWithOne",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references": ["Not", "Exists", "Classical.not_forall", "Eq", "propext"],
  "name": "_private.Init.Classical.0._proof_9",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) = ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "GetElem?.mk",
   "List.instGetElemNatLtLength",
   "instLTNat",
   "Nat",
   "_private.Init.GetElem.0.List.get!Internal",
   "_private.Init.GetElem.0.List.get?Internal",
   "GetElem?",
   "List",
   "Inhabited",
   "List.length"],
  "name": "List.instGetElem?NatLtLength",
  "constType":
  "{α : Type u_1} → GetElem? (List α) ℕ α fun as i => i < as.length",
  "constCategory": "Definition"},
 {"references": ["Option", "outParam", "GetElem?"],
  "name": "GetElem?.getElem?",
  "constType":
  "{coll : Type u} →\n  {idx : Type v} →\n    {elem : outParam (Type w)} →\n      {valid : outParam (coll → idx → Prop)} → [self : GetElem? coll idx elem valid] → coll → idx → Option elem",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "le_top",
   "PartialOrder.toPreorder",
   "Min.min",
   "inf_of_le_left",
   "Top.top",
   "OrderTop",
   "Eq",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_top_eq",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : OrderTop α] (a : α), a ⊓ ⊤ = a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "OrderDual.toDual",
   "OrderDual",
   "PartialOrder.toPreorder",
   "Equiv.instFunLike",
   "GaloisConnection",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "DFunLike.coe",
   "Equiv",
   "Set.instMembership",
   "OrderDual.ofDual",
   "Iff.intro",
   "OrderDual.instPreorder",
   "upperBounds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "lowerBounds",
   "LE.le",
   "Preorder.toLE"],
  "name": "HardarNarasimhan.DedekindMacNeilleConnection",
  "constType":
  "∀ (α : Type) [inst : PartialOrder α],\n  GaloisConnection (fun A => OrderDual.toDual (upperBounds A)) fun A => lowerBounds (OrderDual.ofDual A)",
  "constCategory": "Theorem"},
 {"references": ["PartialOrder", "CompleteSemilatticeInf"],
  "name": "CompleteSemilatticeInf.toPartialOrder",
  "constType":
  "{α : Type u_8} → [self : CompleteSemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["rfl", "Subtype", "Subtype.ext", "Subtype.mk", "Eq", "Subtype.val"],
  "name": "Subtype.coe_eta",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (a : { a // p a }) (h : p ↑a), ⟨↑a, h⟩ = a",
  "constCategory": "Theorem"},
 {"references": ["lt_trans", "Preorder", "Preorder.toLT", "GT.gt"],
  "name": "gt_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a > b → b > c → a > c",
  "constCategory": "Theorem"},
 {"references": ["IsLeftCancelAdd", "Add", "IsCancelAdd"],
  "name": "IsCancelAdd.toIsLeftCancelAdd",
  "constType":
  "∀ {G : Type u} {inst : Add G} [self : IsCancelAdd G], IsLeftCancelAdd G",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Inhabited.mk",
   "HardarNarasimhan.impl.HNFil_piecewise_semistable",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "HardarNarasimhan.impl.HNFil_of_fin_len",
   "Prod.fst",
   "HardarNarasimhan.impl.HNFil_μA_pseudo_strict_anti",
   "HardarNarasimhan.impl.HNFil",
   "HardarNarasimhan.instInhabitedHardarNarasimhanFiltration._proof_2",
   "WellFoundedGT",
   "HardarNarasimhan.instInhabitedHardarNarasimhanFiltration._proof_1",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration.mk",
   "Prod.snd",
   "Inhabited",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "HardarNarasimhan.impl.HNFil_is_strict_mono'",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HardarNarasimhan.instInhabitedHardarNarasimhanFiltration",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] →\n                    [h : HardarNarasimhan.μ_Admissible μ] → Inhabited (HardarNarasimhan.HardarNarasimhanFiltration μ)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.TotIntvl._proof_1",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.TotIntvl.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ],\n  HardarNarasimhan.TotIntvl = ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toNatCast",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring",
   "AddCommMonoid.add_comm",
   "AddCommMonoidWithOne",
   "AddCommMonoid.toAddMonoid",
   "AddMonoidWithOne.mk",
   "NonAssocSemiring.natCast_succ"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "OrderDual.instLT",
   "Lattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (p : { p // p.1 < p.2 }), (↑p).1 < (↑p).2",
  "constCategory": "Theorem"},
 {"references": ["absurd", "Not", "Or.elim", "Or", "id"],
  "name": "Or.resolve_left",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬a → b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "Subtype.val",
   "And.intro",
   "Or",
   "HardarNarasimhan.NashEquilibrium",
   "HardarNarasimhan.WeakSlopeLike₁.mk",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "HardarNarasimhan.impl.prop4d1₂",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "HardarNarasimhan.WeakAscendingChainCondition.wacc",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.SlopeLike",
   "HardarNarasimhan.WeakSlopeLike₂.mk",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "Subtype",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HardarNarasimhan.impl.prop4d11₁",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "Iff.intro",
   "eq_of_le_of_le",
   "Subtype.prop",
   "Or.inl",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "HardarNarasimhan.NashEquilibrium.mk",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.SlopeLike.slopelike",
   "LT.lt",
   "Or.casesOn",
   "le_of_lt",
   "LE.le",
   "Subtype.mk",
   "HardarNarasimhan.NashEquilibrium.nash_eq",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Eq.le",
   "OrderTop.toTop",
   "CompleteLattice",
   "HardarNarasimhan.impl.prop4d11₂"],
  "name": "HardarNarasimhan.impl.prop4d16₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.SlopeLike μ →\n    HardarNarasimhan.WeakAscendingChainCondition μ →\n      HardarNarasimhan.WeakDescendingChainCondition μ →\n        (HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl ↔\n          HardarNarasimhan.NashEquilibrium μ)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Ordering",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": [],
  "name": "OmegaCompletePartialOrder",
  "constType": "Type u_6 → Type u_6",
  "constCategory": "Other"},
 {"references": ["Semiring", "Ring"],
  "name": "Ring.toSemiring",
  "constType": "{R : Type u} → [self : Ring R] → Semiring R",
  "constCategory": "Definition"},
 {"references": ["Nat", "OfNat", "OfNat.mk", "Int.ofNat", "Int"],
  "name": "instOfNat",
  "constType": "{n : ℕ} → OfNat ℤ n",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.S₁I._proof_1",
   "Preorder.toLE",
   "Eq",
   "HardarNarasimhan.S₁I",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.S₁I.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (x : ℒ)\n  (hxI : HardarNarasimhan.InIntvl I x) (hx : (↑I).1 ≠ x),\n  HardarNarasimhan.S₁I μ I x hxI hx =\n    ∀ (y : ℒ) (hyI : HardarNarasimhan.InIntvl I y) (hy : (↑I).1 ≠ y),\n      ¬HardarNarasimhan.μA μ ⟨((↑I).1, y), ⋯⟩ > HardarNarasimhan.μA μ ⟨((↑I).1, x), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Bool",
   "PartialOrder.toPreorder",
   "Nat.cast",
   "Nat.cast_lt",
   "Mathlib.Meta.NormNum.ble_eq_false",
   "Bool.false",
   "Iff.mp",
   "Preorder.toLT",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "Semiring.toNonAssocSemiring",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "CharZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Nat.ble",
   "IsOrderedRing.toZeroLEOneClass",
   "instLTNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Meta.NormNum.isNat_lt_true.match_1",
   "IsOrderedAddMonoid.toAddLeftMono",
   "LT.lt",
   "IsOrderedRing",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.IsNat",
   "Semiring"],
  "name": "Mathlib.Meta.NormNum.isNat_lt_true",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] [CharZero α] {a b : α} {a' b' : ℕ},\n  Mathlib.Meta.NormNum.IsNat a a' → Mathlib.Meta.NormNum.IsNat b b' → b'.ble a' = false → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "HardarNarasimhan.Semistable.casesOn",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.Semistable",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.Semistable.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u → HardarNarasimhan.Semistable μ → HardarNarasimhan.Semistable μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Lean.Omega.Int.add_le_zero_iff_le_neg'",
   "instDecidableAnd",
   "Bool",
   "Bool.decide_and",
   "Decidable",
   "Eq.trans",
   "Eq.mp",
   "Subsingleton.elim",
   "Lean.Omega.Coeffs",
   "Option.some",
   "Decidable.decide",
   "Int.eq_iff_le_and_ge",
   "congrArg",
   "Bool.and",
   "congr",
   "Int.instAdd",
   "Int.instLEInt",
   "Lean.Omega.Constraint.lowerBound",
   "instSubsingletonDecidable",
   "Eq.ndrec",
   "Eq.rec",
   "Eq",
   "Bool.true",
   "propext",
   "decide_eq_true_eq",
   "Lean.Omega.UpperBound.sat",
   "instHAdd",
   "Neg.neg",
   "And",
   "Lean.Omega.LowerBound.sat",
   "Lean.Omega.Int.add_nonnneg_iff_neg_le'",
   "OfNat.ofNat",
   "Int.instNegInt",
   "Int",
   "HAdd.hAdd",
   "instDecidableEqBool",
   "instOfNat",
   "Eq.refl",
   "LE.le",
   "id",
   "Bool.and_eq_true",
   "Lean.Omega.Constraint.mk",
   "Eq.mpr",
   "Int.decLe",
   "Lean.Omega.Coeffs.dot",
   "and_comm",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.addEquality_sat",
  "constType":
  "∀ {c : ℤ} {x y : Omega.Coeffs}, c + x.dot y = 0 → { lowerBound := some (-c), upperBound := some (-c) }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.impl.semistable_iff",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Iff",
   "HardarNarasimhan.Semistable",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.semistableI",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.semistable_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Semistable μ ↔ HardarNarasimhan.semistableI μ HardarNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "lt_of_le_of_ne",
   "HardarNarasimhan.μ_Admissible",
   "Subtype.val",
   "Prod.fst",
   "instOfNatNat",
   "HardarNarasimhan.impl.HNFil",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.impl.HNFil_prop_of_def",
   "HardarNarasimhan.StI",
   "Set",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "Set.instMembership",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "upperBounds",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil_is_strict_mono",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ] (n : ℕ),\n  HardarNarasimhan.impl.HNFil μ n ≠ ⊤ → HardarNarasimhan.impl.HNFil μ n < HardarNarasimhan.impl.HNFil μ (n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "List.rec",
   "GetElem.getElem",
   "List",
   "Option.some",
   "List.instGetElem?NatLtLength",
   "Nat.le.casesOn",
   "GetElem?.getElem?",
   "instOfNatNat",
   "Nat.le.refl",
   "Eq.symm",
   "Eq.ndrec",
   "Eq",
   "List.get._proof_34",
   "List.cons",
   "Nat.le",
   "Nat.casesAuxOn",
   "List.nil",
   "List.instGetElemNatLtLength",
   "instLTNat",
   "HEq.refl",
   "instHAdd",
   "Nat.noConfusion",
   "Nat.le.step",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "Nat.succ",
   "Option",
   "Eq.refl",
   "HEq",
   "List.length"],
  "name": "List.getElem?_eq_getElem",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i : ℕ} (h : i < l.length), l[i]? = some l[i]",
  "constCategory": "Theorem"},
 {"references": ["Function.Embedding", "RelEmbedding"],
  "name": "RelEmbedding.toEmbedding",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → {r : α → α → Prop} → {s : β → β → Prop} → r ↪r s → α ↪ β",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "True",
   "instHAdd",
   "List",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_2",
  "constType":
  "∀ {a0 a1 a2 : ℤ} {t : List ℤ}, (Omega.LinearCombo.coordinate 2).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: t)) = a2",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakAscendingChainCondition.casesOn",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HardarNarasimhan.WeakAscendingChainCondition.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u →\n                HardarNarasimhan.WeakAscendingChainCondition μ → HardarNarasimhan.WeakAscendingChainCondition μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.NashEquilibrium.rec",
   "HardarNarasimhan.NashEquilibrium.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.NashEquilibrium",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.μAstar",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.NashEquilibrium.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.NashEquilibrium μ → Sort u} →\n                (t : HardarNarasimhan.NashEquilibrium μ) →\n                  ((nash_eq : HardarNarasimhan.μAstar μ = HardarNarasimhan.μBstar μ) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "instHAdd",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "OfNat.ofNat"],
  "name": "Nat.add_one_pos",
  "constType": "∀ (n : ℕ), 0 < n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_1",
   "CompleteLattice.instOmegaCompletePartialOrder._rarg"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "HardarNarasimhan.ConvexI.rec",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "Prod.snd",
   "HardarNarasimhan.ConvexI.mk",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.ConvexI.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Lattice ℒ] →\n    {S : Type} →\n      [inst_1 : CompleteLattice S] →\n        {I : { p // p.1 < p.2 }} →\n          {μ : { p // p.1 < p.2 } → S} →\n            {motive : HardarNarasimhan.ConvexI I μ → Sort u} →\n              (t : HardarNarasimhan.ConvexI I μ) →\n                ((convex :\n                      ∀ (x y : ℒ),\n                        HardarNarasimhan.InIntvl I x →\n                          HardarNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩) →\n                    motive ⋯) →\n                  motive t",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection"],
  "name":
  "EmptyCollection.emptyCollection._@.Mathlib.Data.Set.Operations._hyg.16",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "instOfNatNat",
   "Iff",
   "LE.le",
   "Nat.pos_iff_ne_zero",
   "Ne",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Nat.one_le_iff_ne_zero",
  "constType": "∀ {n : ℕ}, 1 ≤ n ↔ n ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["_obj", "Prod.mk", "HardarNarasimhan.μB._rarg", "_neutral"],
  "name": "HardarNarasimhan.μBstar._rarg._cstage2",
  "constType": "_obj → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["DecidableLE", "ite", "LE.mk", "id"],
  "name":
  "HardarNarasimhan.TotallyOrderedRealVectorSpace.max._inherited_default",
  "constType": "{V : Type} → (le : V → V → Prop) → DecidableLE V → V → V → V",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "DFunLike.coe",
   "Subtype.val",
   "Equiv",
   "Prod.fst",
   "OrderDual.ofDual",
   "Subtype.prop",
   "OrderDual.instLT",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "rfl",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.fuck",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [BoundedOrder ℒ] {S : Type} [CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  μ ⟨(OrderDual.ofDual (↑I).2, OrderDual.ofDual (↑I).1), ⋯⟩ = OrderDual.ofDual ((fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) I)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "HardarNarasimhan.μ_Admissible.mk",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.IsAttained",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.μ_Admissible.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨ ∀ (I : { p // p.1 < p.2 }), HardarNarasimhan.IsAttained μ I) →\n    HardarNarasimhan.μ_Admissible μ",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_right",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Min.min",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_11",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HardarNarasimhan.Interval z), ↑a ⊓ ↑b ≤ ↑b",
  "constCategory": "Theorem"},
 {"references": ["Exists", "And", "Eq", "propext", "exists_eq_right"],
  "name": "_private.Init.PropLemmas.0._proof_23",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.impl.HNFil.match_1",
   "HardarNarasimhan.impl.HNFil._proof_1",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "IsGreatest",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.StI",
   "BoundedOrder",
   "Prod.snd",
   "Nat.brecOn",
   "Exists.choose",
   "Bot.bot",
   "OfNat.ofNat",
   "Unit",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nat.succ",
   "HardarNarasimhan.impl.HNFil._proof_2",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "Top.top",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              (μ : { p // p.1 < p.2 } → S) →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] → [h : HardarNarasimhan.μ_Admissible μ] → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "HMul.hMul",
   "Int.rawCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroup.toSubtractionMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "InvolutiveNeg.toNeg",
   "Eq.ndrec",
   "MulOneClass.toMul",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "Int.instNegInt",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoidWithOne.toOne",
   "Int.negOfNat",
   "instHMul",
   "one_mul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "MulZeroOneClass.toMulOneClass",
   "Int.cast",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Int.cast_one",
   "neg_mul",
   "MulOneClass.toOne",
   "Eq",
   "True",
   "Distrib.toMul",
   "OfNat.ofNat",
   "Int.cast_neg",
   "Int",
   "Ring.toAddCommGroup",
   "eq_self",
   "NegZeroClass.toNeg",
   "AddGroupWithOne.toAddGroup",
   "of_eq_true",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HasDistribNeg.toInvolutiveNeg",
   "One.toOfNat1",
   "AddGroupWithOne.toIntCast",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_one_mul",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a b : R}, (Int.negOfNat 1).rawCast * a = b → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "decidableLTOfDecidableLE",
   "DecidableLE",
   "DecidableLT",
   "Iff",
   "LE.mk",
   "id",
   "And",
   "Preorder.mk",
   "LT.mk"],
  "name":
  "HardarNarasimhan.TotallyOrderedRealVectorSpace.toDecidableLT._inherited_default",
  "constType":
  "{V : Type} →\n  (le lt : V → V → Prop) →\n    (∀ (a : V), le a a) →\n      (∀ (a b c : V), le a b → le b c → le a c) →\n        (∀ (a b : V), lt a b ↔ le a b ∧ ¬le b a) → DecidableLE V → DecidableLT V",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_4"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "HardarNarasimhan.semistableI_iff",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "bot_le",
   "HardarNarasimhan.instNontrivialInterval",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "And.intro",
   "HardarNarasimhan.Semistable",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.instBoundedOrderInterval",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.S₁I",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.Resμ",
   "Exists",
   "Exists.choose_spec",
   "HardarNarasimhan.InIntvl",
   "HardarNarasimhan.St",
   "And",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop3d7₁",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Lattice",
   "Subtype",
   "HardarNarasimhan.Convex",
   "lt_of_le_of_ne",
   "Prod.fst",
   "HardarNarasimhan.S₂I",
   "OrderBot.toBot",
   "Preorder.toLE",
   "HardarNarasimhan.instLatticeInterval",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "Set",
   "HardarNarasimhan.StI",
   "HardarNarasimhan.TotIntvl",
   "Exists.choose",
   "HardarNarasimhan.impl.prop3d7₂",
   "HardarNarasimhan.μA",
   "LT.lt",
   "LE.le",
   "HardarNarasimhan.semistableI",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_3_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Convex μ →\n    ∀ (x : ℒ) (hxSt : x ∈ HardarNarasimhan.St μ),\n      HardarNarasimhan.Semistable (HardarNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ) ∧\n        ∀ (y : ℒ) (hy : y > x), ¬HardarNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(x, y), hy⟩",
  "constCategory": "Theorem"},
 {"references":
  ["PUnit.unit",
   "Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "OfNat.ofNat",
   "Unit"],
  "name": "HardarNarasimhan.impl.HNFil.match_1._cstage1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references": ["Not", "Classical.not_not", "Iff", "Ne", "Eq"],
  "name": "not_ne_iff",
  "constType": "∀ {α : Sort u_1} {a b : α}, ¬a ≠ b ↔ a = b",
  "constCategory": "Theorem"},
 {"references": ["Not", "Exists", "not_exists", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_exists_eq",
  "constType": "∀ {α : Sort u_1} (s : α → Prop), (¬∃ x, s x) = ∀ (x : α), ¬s x",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.μmax._proof_2",
   "SupSet.sSup",
   "PartialOrder",
   "HardarNarasimhan.μmin",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μB",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references": ["List.Chain", "List", "List.cons"],
  "name": "List.Chain.cons",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α}, R a b → List.Chain R b l → List.Chain R a (b :: l)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Set",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Set.not_subset._proof_21",
   "Set.not_subset._proof_22",
   "Exists",
   "Eq.trans",
   "True",
   "Set",
   "Membership.mem",
   "And",
   "Set.instMembership",
   "congrArg",
   "Set.instHasSubset",
   "HasSubset.Subset",
   "iff_self",
   "of_eq_true",
   "Iff",
   "funext"],
  "name": "Set.not_subset",
  "constType": "∀ {α : Type u} {s t : Set α}, ¬s ⊆ t ↔ ∃ a ∈ s, a ∉ t",
  "constCategory": "Theorem"},
 {"references": ["_obj", "HardarNarasimhan.μmin._rarg", "_neutral"],
  "name": "HardarNarasimhan.μmin._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toZero",
   "instHAdd",
   "AddMonoid",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "MulAction.toSMul",
   "MulAction",
   "AddMonoid.toAddSemigroup",
   "HSMul.hSMul",
   "Monoid",
   "instHSMul",
   "Zero.toOfNat0",
   "Eq",
   "DistribMulAction",
   "AddSemigroup.toAdd",
   "AddMonoid.toAddZeroClass"],
  "name": "DistribMulAction.mk",
  "constType":
  "{M : Type u_12} →\n  {A : Type u_13} →\n    [inst : Monoid M] →\n      [inst_1 : AddMonoid A] →\n        [toMulAction : MulAction M A] →\n          (∀ (a : M), a • 0 = 0) → (∀ (a : M) (x y : A), a • (x + y) = a • x + a • y) → DistribMulAction M A",
  "constCategory": "Other"},
 {"references":
  ["Iff.trans",
   "Max.max",
   "PartialOrder.toPreorder",
   "Iff",
   "eq_comm",
   "LE.le",
   "SemilatticeSup.toMax",
   "SemilatticeSup.toPartialOrder",
   "sup_eq_right",
   "SemilatticeSup",
   "Preorder.toLE",
   "Eq"],
  "name": "right_eq_sup",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b = a ⊔ b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["HPow", "outParam"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "le_trans",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "le_sup_left",
   "Preorder.toLE"],
  "name": "le_sup_of_le_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c ≤ a → c ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "Prod.fst",
   "And.intro",
   "HardarNarasimhan.impl.prop4d3₂",
   "HardarNarasimhan.μmax",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.μAstar",
   "HardarNarasimhan.WeakSlopeLike₂.wsl₂",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakDescendingChainCondition.wdcc",
   "HardarNarasimhan.WeakSlopeLike₂",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.impl.prop4d3₁",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_4_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.WeakDescendingChainCondition μ →\n    HardarNarasimhan.WeakSlopeLike₂ μ →\n      HardarNarasimhan.μBstar μ = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl ∧\n        HardarNarasimhan.μAstar μ ≤ HardarNarasimhan.μBstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq.refl",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "CommSemiring",
   "Eq.symm",
   "instHMul",
   "HMul.hMul",
   "Eq.ndrec",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.mul_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' * b' = c → a * b = c",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Nat.cast",
   "Eq.trans",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "instOfNatNat",
   "Nat.add_succ",
   "Zero.toOfNat0",
   "Nat.cast_succ",
   "Eq",
   "AddMonoidWithOne",
   "AddSemigroup.toAdd",
   "True",
   "AddZeroClass.toZero",
   "instHAdd",
   "Nat.recAux",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "of_eq_true",
   "Nat.succ",
   "Eq.refl",
   "add_assoc",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_zero",
   "AddMonoidWithOne.toOne",
   "id",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass"],
  "name": "Nat.cast_add",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "List.tfae_of_cycle",
   "Prod.fst",
   "eq_of_le_of_le",
   "HardarNarasimhan.μmax",
   "letFun",
   "HardarNarasimhan.impl.rmk4d15",
   "Eq.symm",
   "HardarNarasimhan.μmin",
   "List.TFAE",
   "HardarNarasimhan.impl.prop4d12",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "List.nil",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "List.Chain.cons",
   "HardarNarasimhan.impl.rmk4d10₀",
   "HardarNarasimhan.TotIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "List.Chain.nil",
   "HardarNarasimhan.impl.prop4d14",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "CompleteLattice",
   "HardarNarasimhan.impl.rmk4d13"],
  "name": "HardarNarasimhan.impl.prop4d16₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.SlopeLike μ →\n    [HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl,\n        HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl,\n        HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl].TFAE",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "Option.none",
  "constType": "{α : Type u} → Option α",
  "constCategory": "Other"},
 {"references": ["Nat", "Pow", "Monoid", "Monoid.npow", "Pow.mk"],
  "name": "Monoid.toNatPow",
  "constType": "{M : Type u_2} → [Monoid M] → Pow M ℕ",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass", "Add"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Decidable",
   "True",
   "Eq.trans",
   "instDecidableTrue",
   "Eq.mpr_not",
   "True.intro",
   "Eq.mpr_prop",
   "congrArg",
   "dite_congr",
   "eq_self",
   "of_eq_true",
   "Eq.refl",
   "Eq",
   "dite"],
  "name": "dite_cond_eq_true",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} {t : c → α} {e : ¬c → α} (h : c = True), dite c t e = t ⋯",
  "constCategory": "Theorem"},
 {"references": ["Lattice"],
  "name": "Lattice.toSemilatticeInf._elambda_1",
  "constType": "(α : Type u) → Lattice α → α → α → α",
  "constCategory": "Axiom"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "CompleteLattice.le_sInf",
   "CompleteSemilatticeInf.mk",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toPartialOrder",
   "CompleteLattice",
   "CompleteSemilatticeInf",
   "CompleteLattice.sInf_le"],
  "name": "CompleteLattice.toCompleteSemilatticeInf",
  "constType":
  "{α : Type u_8} → [self : CompleteLattice α] → CompleteSemilatticeInf α",
  "constCategory": "Definition"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{α : Type u_1} → [Sub α] → HSub α α α",
  "constCategory": "Definition"},
 {"references":
  ["HMul.hMul",
   "OfNat.ofNat",
   "SMul",
   "One.toOfNat1",
   "MulAction",
   "MulOneClass.toOne",
   "HSMul.hSMul",
   "Monoid.toMulOneClass",
   "Monoid",
   "instHSMul",
   "instHMul",
   "Eq",
   "MulOneClass.toMul"],
  "name": "MulAction.mk",
  "constType":
  "{α : Type u_9} →\n  {β : Type u_10} →\n    [inst : Monoid α] →\n      [toSMul : SMul α β] → (∀ (b : β), 1 • b = b) → (∀ (x y : α) (b : β), (x * y) • b = x • y • b) → MulAction α β",
  "constCategory": "Other"},
 {"references":
  ["Preorder",
   "upperBounds",
   "Set",
   "Iff",
   "LE.le",
   "Membership.mem",
   "Iff.rfl",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "mem_upperBounds",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, a ∈ upperBounds s ↔ ∀ x ∈ s, x ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "HardarNarasimhan.μ_Admissible.casesOn",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.IsAttained",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.μ_Admissible.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                Sort u → HardarNarasimhan.μ_Admissible μ → HardarNarasimhan.μ_Admissible μ → Sort u",
  "constCategory": "Definition"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u_2} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → γ → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.WeakSlopeLike₂.mk",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₂.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1), μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n    HardarNarasimhan.WeakSlopeLike₂ μ",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "HardarNarasimhan.μBstar",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HardarNarasimhan.impl.prop4d18₂",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "And.intro",
   "HardarNarasimhan.NashEquilibrium",
   "Or",
   "HardarNarasimhan.Semistable",
   "HardarNarasimhan.μAstar",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.impl.prop4d18₁",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Lattice",
   "Nontrivial",
   "LE.le"],
  "name": "HardarNarasimhan.proposition_4_18",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Semistable μ →\n    HardarNarasimhan.μBstar μ ≤ HardarNarasimhan.μAstar μ ∧\n      (HardarNarasimhan.WeakAscendingChainCondition μ ∧ HardarNarasimhan.WeakSlopeLike₁ μ ∨\n          HardarNarasimhan.WeakDescendingChainCondition μ ∧ HardarNarasimhan.WeakSlopeLike₂ μ →\n        HardarNarasimhan.NashEquilibrium μ)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references": ["LE.le", "LE"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.HardarNarasimhanFiltration.filtration",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.fin_len",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HardarNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HardarNarasimhan.Convex μ} {h : HardarNarasimhan.μ_Admissible μ}\n  [self : HardarNarasimhan.HardarNarasimhanFiltration μ],\n  ∃ n, HardarNarasimhan.HardarNarasimhanFiltration.filtration μ n = ⊤",
  "constCategory": "Theorem"},
 {"references": ["IsTotal", "Or"],
  "name": "IsTotal.total",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop} [self : IsTotal α r] (a b : α), r a b ∨ r b a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bot",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₂.wsl₂",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HardarNarasimhan.WeakSlopeLike₂ μ]\n  (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1), μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩",
  "constCategory": "Theorem"},
 {"references":
  ["InfSet",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.μmax",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "Set",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μA._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HardarNarasimhan.WeakAscendingChainCondition.wacc",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HardarNarasimhan.WeakAscendingChainCondition μ]\n  (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "HardarNarasimhan.InIntvl",
   "Preorder.toLT",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.S₁I._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (y : ℒ),\n  HardarNarasimhan.InIntvl I y → (↑I).1 ≠ y → ((↑I).1, y).1 < ((↑I).1, y).2",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Nontrivial", "Ne"],
  "name": "Nontrivial.mk",
  "constType": "∀ {α : Type u_3}, (∃ x y, x ≠ y) → Nontrivial α",
  "constCategory": "Other"},
 {"references": ["List"],
  "name": "List.cons",
  "constType": "{α : Type u} → α → List α → List α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toZero", "AddZeroClass", "SMulZeroClass", "DistribSMul"],
  "name": "DistribSMul.toSMulZeroClass",
  "constType":
  "{M : Type u_12} → {A : Type u_13} → {inst : AddZeroClass A} → [self : DistribSMul M A] → SMulZeroClass M A",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Bot",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderBot",
   "Top",
   "BoundedOrder",
   "OrderTop",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "lcProof",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μAstar._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → S",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftMono",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.elim_AddLeftMono",
   "HAdd.hAdd",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "AddCommMonoid.toAddCommSemigroup",
   "LE.le",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "CovariantClass.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instAddLeftMono_harderNarasimhan",
  "constType":
  "∀ {V : Type} [inst : HardarNarasimhan.TotallyOrderedRealVectorSpace V], AddLeftMono V",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "SMul",
   "PosSMulStrictMono",
   "HSMul.hSMul",
   "Preorder.toLT",
   "instHSMul",
   "Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat"],
  "name": "PosSMulStrictMono.mk",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : SMul α β] [inst_1 : Preorder α] [inst_2 : Preorder β] [inst_3 : Zero α],\n  (∀ ⦃a : α⦄, 0 < a → ∀ ⦃b₁ b₂ : β⦄, b₁ < b₂ → a • b₁ < a • b₂) → PosSMulStrictMono α β",
  "constCategory": "Other"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "Nat",
   "PartialOrder",
   "inferInstance",
   "Nat.instLinearOrder"],
  "name": "Nat.instPartialOrder",
  "constType": "PartialOrder ℕ",
  "constCategory": "Definition"},
 {"references": ["NonAssocSemiring", "NonUnitalNonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Int.instSub",
   "Eq.trans",
   "Decidable",
   "Subsingleton.elim",
   "Lean.Omega.Coeffs",
   "GE.ge",
   "Int.instLEInt",
   "HSub.hSub",
   "Eq.symm",
   "Eq.rec",
   "Eq.ndrec",
   "Bool.true",
   "decide_eq_true_eq",
   "Neg.neg",
   "Lean.Omega.UpperBound.sat",
   "And",
   "Lean.Omega.LowerBound.sat",
   "Int.instNegInt",
   "instDecidableEqBool",
   "instOfNat",
   "Int.zero_sub",
   "Eq.refl",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Int.decLe",
   "Lean.Omega.Constraint.sat'",
   "Bool",
   "instDecidableAnd",
   "Option.some",
   "and_true",
   "Decidable.decide",
   "congrArg",
   "congr",
   "Int.instAdd",
   "Lean.Omega.Constraint.lowerBound",
   "instSubsingletonDecidable",
   "Eq",
   "True",
   "instHAdd",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Option.none",
   "LE.le",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "Int.sub_left_le_of_le_add"],
  "name": "Lean.Omega.Constraint.addInequality_sat",
  "constType":
  "∀ {c : ℤ} {x y : Omega.Coeffs}, c + x.dot y ≥ 0 → { lowerBound := some (-c), upperBound := none }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "Set.subset_iUnion₂",
   "HasSubset.Subset",
   "Set",
   "Membership.mem",
   "Set.iUnion",
   "Set.instMembership"],
  "name": "Set.subset_biUnion_of_mem",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {u : α → Set β} {x : α}, x ∈ s → u x ⊆ ⋃ x ∈ s, u x",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "Or.rec",
   "Or",
   "HasSubset.Subset",
   "Set",
   "Membership.mem",
   "Set.instUnion",
   "Union.union",
   "Set.instMembership"],
  "name": "Set.union_subset",
  "constType": "∀ {α : Type u} {s t r : Set α}, s ⊆ r → t ⊆ r → s ∪ t ⊆ r",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.μmax._proof_2",
   "HardarNarasimhan.μmax",
   "SupSet.sSup",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Eq.refl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μmax.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.μmax μ I = sSup {x | ∃ u, ∃ (h : HardarNarasimhan.InIntvl I u ∧ (↑I).1 ≠ u), μ ⟨((↑I).1, u), ⋯⟩ = x}",
  "constCategory": "Theorem"},
 {"references": ["Bot"],
  "name": "Bot.bot",
  "constType": "{α : Type u_1} → [self : Bot α] → α",
  "constCategory": "Definition"},
 {"references": ["semiOutParam"],
  "name": "CoeOut",
  "constType": "Sort u → semiOutParam (Sort v) → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references": ["Int.neg", "Neg", "Neg.mk", "Int"],
  "name": "Int.instNegInt",
  "constType": "Neg ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Subtype.val",
   "Prod.fst",
   "eq_of_le_of_le",
   "le_of_not_gt",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "HardarNarasimhan.S₂I",
   "WellFoundedGT",
   "HardarNarasimhan.S₁I._proof_1",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "HardarNarasimhan.S₁I",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "HardarNarasimhan.StI",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Exists.casesOn",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "Nontrivial",
   "Ne",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "And.casesOn"],
  "name": "HardarNarasimhan.impl.rmk3d5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  ∀ x ∈ HardarNarasimhan.StI μ I, ∀ y ∈ HardarNarasimhan.StI μ I, x = y",
  "constCategory": "Theorem"},
 {"references": ["_obj", "HardarNarasimhan.μBstar._rarg", "_neutral"],
  "name": "HardarNarasimhan.μBstar._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.rfl", "Eq.rec", "Eq"],
  "name": "Iff.of_eq",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Ne.symm",
   "Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "HardarNarasimhan.InIntvl",
   "Preorder.toLT",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.stableI._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (x : ℒ),\n  HardarNarasimhan.InIntvl I x → x ≠ (↑I).1 → ((↑I).1, x).1 < ((↑I).1, x).2",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.WeakSlopeLike₁.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₁.rec",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₁.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakSlopeLike₁ μ → Sort u} →\n                (t : HardarNarasimhan.WeakSlopeLike₁ μ) →\n                  ((wsl₁ :\n                        ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                          μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["Add", "Lean.Omega.LinearCombo.add", "Lean.Omega.LinearCombo", "Add.mk"],
  "name": "Lean.Omega.LinearCombo.instAdd",
  "constType": "Add Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instBoundedOrderInterval._proof_16",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a : HardarNarasimhan.Interval z), (↑z).1 ≤ ↑a",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name": "HardarNarasimhan.μmax._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Real",
   "Real.instIsOrderedAddMonoid",
   "NNReal",
   "Real.instZeroLEOneClass",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Real.instAddCommMonoid",
   "Nonneg.semiring",
   "Real.instIsOrderedRing",
   "IsOrderedRing.toPosMulMono",
   "Real.partialOrder",
   "Real.semiring",
   "Semiring"],
  "name": "instNNRealSemiring",
  "constType": "Semiring NNReal",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Subtype", "LT.mk", "Subtype.val", "LT"],
  "name": "Subtype.lt",
  "constType": "{α : Type u_2} → [LT α] → {p : α → Prop} → LT (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "GaloisConnection.lowerAdjoint",
   "OrderDual",
   "OrderDual.toDual",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "LowerAdjoint.toFun",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "DFunLike.coe",
   "_private.Init.Core.0._proof_25",
   "Equiv",
   "congrArg",
   "OrderDual.ofDual",
   "Iff.intro",
   "HardarNarasimhan.DedekindMacNeilleConnection",
   "PartialOrder",
   "forall_congr",
   "funext",
   "Eq",
   "Preorder.toLE",
   "True",
   "Equiv.instFunLike",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Set.Iic",
   "Set.instMembership",
   "implies_true",
   "OrderDual.instPreorder",
   "of_eq_true",
   "_private.Mathlib.Order.Interval.Set.Defs.0._proof_5",
   "Set.instCompleteAtomicBooleanAlgebra",
   "upperBounds",
   "Eq.refl",
   "LE.le",
   "lowerBounds",
   "Set.ext",
   "setOf"],
  "name": "HardarNarasimhan.coe'._proof_18",
  "constType":
  "∀ {α : Type} [inst : PartialOrder α] (x : α),\n  lowerBounds (OrderDual.ofDual (⋯.lowerAdjoint.toFun (Set.Iic x))) = Set.Iic x",
  "constCategory": "Theorem"},
 {"references": ["Not", "False"],
  "name": "Aesop.BuiltinRules.not_intro",
  "constType": "∀ {P : Prop}, (P → False) → ¬P",
  "constCategory": "Theorem"},
 {"references": ["absurd", "Not", "Or.elim", "Or", "id"],
  "name": "Or.resolve_right",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.WeakDescendingChainCondition.mk",
   "Real.instPreorder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Subtype.lt",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "Set.Elem",
   "Set.range",
   "Prod.fst",
   "Monotone",
   "Real.instLT",
   "CompleteLattice.toTop",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Real",
   "Set",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "IsWellOrder",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "HardarNarasimhan.impl.rmk4d4",
   "CompleteLattice"],
  "name": "HardarNarasimhan.remark_4_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (r : ℒ → ℝ),\n  Monotone r →\n    (IsWellOrder ↑(Set.range r) fun x1 x2 => x1 < x2) →\n      (∀ (z : { p // p.1 < p.2 }), r (↑z).1 = r (↑z).2 → μ z = ⊤) → HardarNarasimhan.WeakDescendingChainCondition μ",
  "constCategory": "Theorem"},
 {"references": ["_obj", "HardarNarasimhan.Resμ._rarg", "_neutral"],
  "name": "HardarNarasimhan.Resμ._cstage2",
  "constType":
  "_neutral → _neutral → _obj → _obj → _obj → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "True",
   "List",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_0",
  "constType":
  "∀ {a0 : ℤ} {t : List ℤ}, (Omega.LinearCombo.coordinate 0).eval (Omega.Coeffs.ofList (a0 :: t)) = a0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint",
   "Bool",
   "Lean.Omega.Constraint.sat",
   "And",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Constraint.combine",
   "And.intro",
   "Eq.mpr",
   "Lean.Omega.Constraint.combine_sat",
   "Eq",
   "Bool.true",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.combine_sat'",
  "constType":
  "∀ {s t : Omega.Constraint} {x y : Omega.Coeffs}, s.sat' x y = true → t.sat' x y = true → (s.combine t).sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "mt",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLT",
   "Ne",
   "Eq",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "lt_of_le_of_ne",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["DFunLike", "outParam"],
  "name": "DFunLike.coe",
  "constType":
  "{F : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (α → Sort u_3)} → [self : DFunLike F α β] → F → (a : α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "OrderDual",
   "PartialOrder.toPreorder",
   "Set",
   "GaloisConnection",
   "ClosureOperator",
   "OmegaCompletePartialOrder",
   "Preorder",
   "OrderDual.instPreorder",
   "CompleteAtomicBooleanAlgebra",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "CompleteLattice"],
  "name":
  "GaloisConnection.closureOperator._at.HardarNarasimhan.DedekindMacNeilleClosureOperator._spec_1",
  "constType":
  "(α : Type) →\n  let _x_1 := Set.instCompleteAtomicBooleanAlgebra;\n  let _x_13 := _x_1.1;\n  let _x_14 := CompleteLattice.instOmegaCompletePartialOrder;\n  let _x_18 := _x_14.1;\n  let _x_19 := _x_18.1;\n  let _x_20 := OrderDual.instPreorder (Set α);\n  let _y_3 := _x_18;\n  let _y_4 := _x_20;\n  (l : Set α → (Set α)ᵒᵈ) → (u : (Set α)ᵒᵈ → Set α) → GaloisConnection l u → ClosureOperator (Set α)",
  "constCategory": "Axiom"},
 {"references": ["Not", "Classical.not_not", "Eq", "propext"],
  "name": "_private.Init.Classical.0._proof_7",
  "constType": "∀ {a : Prop}, (¬¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.Semistable",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HardarNarasimhan.Semistable.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℒ) (hx : x ≠ ⊥), ¬HardarNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HardarNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩) →\n    HardarNarasimhan.Semistable μ",
  "constCategory": "Other"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.WeakSlopeLike₁.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₁.rec",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₁.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakSlopeLike₁ μ → Sort u} →\n                (t : HardarNarasimhan.WeakSlopeLike₁ μ) →\n                  ((wsl₁ :\n                        ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                          μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Preorder.toLT",
   "OfNat.ofNat",
   "Nat.lt_add_one",
   "Nat.instPreorder",
   "LT.lt",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "Lattice",
   "StrictMono",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (x : ℕ → ℒ), StrictMono x → ∀ (N : ℕ), x N < x (N + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Real.partialOrder._proof_44",
   "Real.partialOrder._proof_45",
   "Real",
   "Real.partialOrder._proof_43",
   "Real.partialOrder._proof_42",
   "Real.instLE",
   "LT.lt",
   "PartialOrder.mk",
   "PartialOrder",
   "Real.instLT",
   "LE.mk",
   "LE.le",
   "Preorder.mk",
   "LT.mk"],
  "name": "Real.partialOrder",
  "constType": "PartialOrder ℝ",
  "constCategory": "Definition"},
 {"references": ["_obj", "LE.mk", "Preorder.mk", "LT.mk", "_neutral"],
  "name": "HardarNarasimhan.instLatticeInterval._rarg._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Bool.false",
   "Classical.propDecidable",
   "eq_true",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "eq_top_iff",
   "congrFun",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "gt_trans",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instInhabitedHardarNarasimhanFiltration",
   "HardarNarasimhan.HardarNarasimhanFiltration.ext",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "Linarith.mul_neg",
   "Nat.le_succ",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Top.top",
   "Int.negOfNat",
   "Int.instCharZero",
   "Nat.find",
   "Mathlib.Tactic.Ring.add_mul",
   "Nat.le_refl",
   "HardarNarasimhan.HardarNarasimhanFiltration.first_eq_bot",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "HardarNarasimhan.impl.HNFil",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HardarNarasimhan.impl.theorem3d10._proof_5",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "CompletelyDistribLattice.toCompleteLattice",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "CompleteLattice.toCompleteSemilatticeInf",
   "instHSub",
   "_private.Mathlib.Order.Defs.LinearOrder.0._proof_2",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "HardarNarasimhan.HardarNarasimhanFiltration.fin_len",
   "Int.instLEInt",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Eq.rec",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_zero",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "of_eq_true",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.HardarNarasimhanFiltration.μA_pseudo_strict_anti",
   "HardarNarasimhan.impl.instμ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Inhabited.default",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Nat.le_succ_of_le",
   "letFun",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HardarNarasimhan.impl.theorem3d10",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "Nat.find_spec",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "HardarNarasimhan.impl.theorem3d10._proof_6",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "WellFoundedGT",
   "Preorder.toLE",
   "Mathlib.Tactic.Ring.mul_add",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.le_induction",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "HardarNarasimhan.HardarNarasimhanFiltration.monotone",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "HardarNarasimhan.HardarNarasimhanFiltration.strict_mono",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HardarNarasimhan.HardarNarasimhanFiltration.filtration",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "True",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "HardarNarasimhan.HardarNarasimhanFiltration.piecewise_semistable",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HardarNarasimhan.instUniqueHardarNarasimhanFiltration._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] (a : HardarNarasimhan.HardarNarasimhanFiltration μ), a = default",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Set", "Membership.mem", "Set.instMembership"],
  "name": "Set.Nonempty",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "InfSet",
   "PartialOrder.toPreorder",
   "Set",
   "Top",
   "Membership.mem",
   "SemilatticeSup.toPartialOrder",
   "Bot.bot",
   "Set.instMembership",
   "SupSet.sSup",
   "SupSet",
   "Lattice",
   "LE.le",
   "InfSet.sInf",
   "Top.top",
   "Bot",
   "Preorder.toLE",
   "CompleteLattice"],
  "name": "CompleteLattice.mk",
  "constType":
  "{α : Type u_8} →\n  [toLattice : Lattice α] →\n    [toSupSet : SupSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, a ≤ sSup s) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a) →\n          [toInfSet : InfSet α] →\n            (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) →\n                [toTop : Top α] → [toBot : Bot α] → (∀ (x : α), x ≤ ⊤) → (∀ (x : α), ⊥ ≤ x) → CompleteLattice α",
  "constCategory": "Other"},
 {"references":
  ["HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "instHAdd",
   "AddCommGroup.toAddGroup",
   "AddMonoid.toAddSemigroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "AddSemigroup.toAdd"],
  "name": "AddCommGroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommGroup G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "Or.inl",
   "Or",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.WeakSlopeLike₁.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.SlopeLike.slopelike",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Or.casesOn",
   "le_of_lt",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.instWeakSlopeLike₁OfSlopeLike",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} [hμ : HardarNarasimhan.SlopeLike μ],\n  HardarNarasimhan.WeakSlopeLike₁ μ",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Distrib"],
  "name": "Distrib.toMul",
  "constType": "{R : Type u_1} → [self : Distrib R] → Mul R",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.μ_Admissible.noConfusionType",
   "Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "HardarNarasimhan.IsAttained",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "HardarNarasimhan.μ_Admissible.casesOn",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "IsTotal",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.μ_Admissible.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                {P : Sort u} →\n                  {v1 v2 : HardarNarasimhan.μ_Admissible μ} →\n                    v1 = v2 → HardarNarasimhan.μ_Admissible.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.impl.prop3d4₀func._proof_3",
   "HardarNarasimhan.impl.prop3d4₀func._proof_5",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.impl.prop3d4₀func._proof_4",
   "instOfNatNat",
   "HardarNarasimhan.impl.ℒₛ",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Nat.brecOn",
   "Exists.choose",
   "OfNat.ofNat",
   "Set.instMembership",
   "Unit",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.impl.prop3d4₀func.match_1",
   "Nat",
   "HardarNarasimhan.impl.prop3d4₀func._proof_6",
   "Nat.succ",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "Subtype.mk",
   "dite",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        [h : WellFoundedGT ℒ] →\n          {S : Type} →\n            [CompleteLattice S] →\n              ({ p // p.1 < p.2 } → S) → (I : { p // p.1 < p.2 }) → ℕ → { p // HardarNarasimhan.InIntvl I p }",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration.mk",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Nat.find",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "HardarNarasimhan.instLatticeInterval",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.μ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HardarNarasimhan.instNontrivialInterval",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HardarNarasimhan.Semistable",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.mk._flat_ctor",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] →\n                    [h : HardarNarasimhan.μ_Admissible μ] →\n                      (filtration : ℕ → ℒ) →\n                        Monotone filtration →\n                          filtration 0 = ⊥ →\n                            (fin_len : ∃ n, filtration n = ⊤) →\n                              (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                (∀ (i : ℕ) (h : i < Nat.find fin_len),\n                                    HardarNarasimhan.Semistable\n                                      (HardarNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)) →\n                                  (∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n                                      ¬HardarNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n                                          HardarNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩) →\n                                    HardarNarasimhan.HardarNarasimhanFiltration μ",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "le_trans",
   "Iff.mp",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.μ_Admissible",
   "Nat.instPreorder",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.impl.HNFil",
   "instOfNatNat",
   "letFun",
   "HardarNarasimhan.impl.HNlen",
   "WellFoundedGT",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Nat.le_induction",
   "instLTNat",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Nat.add_one_le_iff",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "HardarNarasimhan.impl.HNFil_ne_top_iff_lt_len",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "Nat.le_succ",
   "Nat.succ",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "HardarNarasimhan.impl.HNFil_is_strict_mono",
   "Ne",
   "OrderTop.toTop",
   "instLENat",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil_is_strict_mono'",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ] (i j : ℕ),\n  i < j → j ≤ HardarNarasimhan.impl.HNlen μ → HardarNarasimhan.impl.HNFil μ i < HardarNarasimhan.impl.HNFil μ j",
  "constCategory": "Theorem"},
 {"references":
  ["instNNRealSemiring",
   "Real",
   "NNReal",
   "Semiring.toMonoidWithZero",
   "AddMonoid",
   "Real.semiring",
   "DistribMulAction.compHom",
   "RingHom.toMonoidHom",
   "Semiring.toNonAssocSemiring",
   "NNReal.toRealHom",
   "Real.instMonoid",
   "MonoidWithZero.toMonoid",
   "DistribMulAction"],
  "name": "NNReal.instDistribMulActionOfReal",
  "constType":
  "{M : Type u_1} → [inst : AddMonoid M] → [DistribMulAction ℝ M] → DistribMulAction NNReal M",
  "constCategory": "Definition"},
 {"references": ["Nat", "Sub.mk", "Nat.sub", "Sub"],
  "name": "instSubNat",
  "constType": "Sub ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "absurd",
   "LT.lt",
   "Preorder",
   "lt_irrefl",
   "Preorder.toLT",
   "False",
   "Ne",
   "Eq.rec",
   "Eq"],
  "name": "ne_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Subtype.val",
   "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_17",
   "Prod.fst",
   "And.intro",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top"],
  "name": "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_18",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (a : ℒ),\n  (↑⟨(⊥, ⊤), ⋯⟩).1 ≤ a ∧ a ≤ (↑⟨(⊥, ⊤), ⋯⟩).2",
  "constCategory": "Theorem"},
 {"references":
  ["IsStrictOrderedRing.toCharZero",
   "PartialOrder.toPreorder",
   "IsStrictOrderedRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Preorder.toLT",
   "zero_lt_one",
   "OfNat.ofNat",
   "LT.lt",
   "Semiring.toNonAssocSemiring",
   "One.toOfNat1",
   "MulZeroClass.toZero",
   "PartialOrder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoidWithOne.toOne",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NeZero.charZero_one",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring",
   "IsStrictOrderedRing.toZeroLEOneClass"],
  "name": "Linarith.zero_lt_one",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [inst_1 : PartialOrder α] [IsStrictOrderedRing α], 0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "HardarNarasimhan.ConvexI.casesOn",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.ConvexI.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Lattice ℒ} →\n    {S : Type} →\n      {inst_1 : CompleteLattice S} →\n        {I : { p // p.1 < p.2 }} →\n          {μ : { p // p.1 < p.2 } → S} → Sort u → HardarNarasimhan.ConvexI I μ → HardarNarasimhan.ConvexI I μ → Sort u",
  "constCategory": "Definition"},
 {"references": ["Top", "LE", "OrderTop"],
  "name": "OrderTop.toTop",
  "constType": "{α : Type u} → {inst : LE α} → [self : OrderTop α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "PartialOrder.toPreorder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "Nat.cast_nonneg",
   "IsOrderedRing",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Semiring.toNonAssocSemiring",
   "MulZeroClass.toZero",
   "PartialOrder",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Preorder.toLE",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring"],
  "name": "Linarith.natCast_nonneg",
  "constType":
  "∀ (α : Type u) [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "HardarNarasimhan.μBstar",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HardarNarasimhan.impl.prop4d11₁",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "And.intro",
   "HardarNarasimhan.μmax",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "Preorder.toLE",
   "Eq",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "CompleteLattice",
   "HardarNarasimhan.impl.prop4d11₂"],
  "name": "HardarNarasimhan.proposition_4_11",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl →\n      HardarNarasimhan.μBstar μ ≤ HardarNarasimhan.μAstar μ) ∧\n    (HardarNarasimhan.WeakAscendingChainCondition μ →\n      HardarNarasimhan.WeakSlopeLike₁ μ →\n        HardarNarasimhan.WeakDescendingChainCondition μ →\n          HardarNarasimhan.WeakSlopeLike₂ μ →\n            HardarNarasimhan.μBstar μ ≤ HardarNarasimhan.μAstar μ →\n              HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.IsAttained",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.μ_Admissible.μ_adm",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HardarNarasimhan.μ_Admissible μ],\n  (IsTotal S fun x1 x2 => x1 ≤ x2) ∨ ∀ (I : { p // p.1 < p.2 }), HardarNarasimhan.IsAttained μ I",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.coe_injective",
   "Subtype",
   "Iff",
   "Ne",
   "Function.Injective.ne_iff",
   "Subtype.val"],
  "name": "Subtype.coe_ne_coe",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, ↑a ≠ ↑b ↔ a ≠ b",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.add", "Add", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "SemilatticeSup.toPartialOrder",
   "LT.lt",
   "Max.max",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Preorder.toLE",
   "right_lt_sup",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.Lattice.0._proof_15",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, (b < a ⊔ b) = ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "instHAdd", "Add", "LE.le", "LE", "CovariantClass"],
  "name": "AddLeftMono",
  "constType": "(M : Type u_1) → [Add M] → [LE M] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Eq.propIntro",
   "Subtype",
   "HEq.refl",
   "Subtype.noConfusion",
   "Eq.refl",
   "Eq.symm",
   "HEq",
   "Subtype.mk",
   "Eq.ndrec",
   "Eq",
   "Eq.casesOn"],
  "name": "Subtype.mk.injEq",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} (val : α) (property : p val) (val_1 : α) (property_1 : p val_1),\n  (⟨val, property⟩ = ⟨val_1, property_1⟩) = (val = val_1)",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.NashEquilibrium.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.NashEquilibrium",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.μAstar",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.NashEquilibrium.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.NashEquilibrium μ → Sort u} →\n                ((nash_eq : HardarNarasimhan.μAstar μ = HardarNarasimhan.μBstar μ) → motive ⋯) →\n                  (t : HardarNarasimhan.NashEquilibrium μ) → motive t",
  "constCategory": "Other"},
 {"references": ["Bool"],
  "name": "sorryAx",
  "constType": "(α : Sort u) → Bool → α",
  "constCategory": "Axiom"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "bot_le",
   "HardarNarasimhan.impl.rmk2d5₁",
   "HardarNarasimhan.Convex_of_Convex_large",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.impl.rmk2d5₂",
   "HardarNarasimhan.impl.rmk2d5₃",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "CompleteLattice"],
  "name": "HardarNarasimhan.remark_2_5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Convex μ →\n    HardarNarasimhan.Convex (HardarNarasimhan.μmax μ) ∧\n      ∀ (I : { p // p.1 < p.2 }),\n        HardarNarasimhan.μmax μ I = HardarNarasimhan.μmax (HardarNarasimhan.μmax μ) I ∧\n          HardarNarasimhan.μA μ I = HardarNarasimhan.μA (HardarNarasimhan.μmax μ) I",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "HardarNarasimhan.instNontrivialInterval",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.impl.semistableI_iff",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Iff",
   "HardarNarasimhan.Semistable",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.semistableI",
   "HardarNarasimhan.instBoundedOrderInterval",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "CompleteLattice",
   "HardarNarasimhan.Resμ",
   "HardarNarasimhan.instLatticeInterval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.semistableI_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.semistableI μ I ↔ HardarNarasimhan.Semistable (HardarNarasimhan.Resμ I μ)",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.Name"],
  "name": "Lean.Name.str",
  "constType": "Name → String → Name",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Iff.mp",
   "HardarNarasimhan.instNontrivialInterval",
   "HardarNarasimhan.μ_Admissible",
   "Nat.instAddCommMonoid",
   "HardarNarasimhan.Semistable",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "Nat.instIsOrderedAddMonoid",
   "HardarNarasimhan.Interval",
   "And.left",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "HardarNarasimhan.impl.HNFil_prop_of_def",
   "Nat.instPartialOrder",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop3d7₁",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat.instCanonicallyOrderedAdd",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "upperBounds",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "lt_top_iff_ne_top",
   "AddMonoid.toAddZeroClass",
   "Nat.find",
   "Subtype",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.impl.HNFil_of_fin_len",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Nat.instOne",
   "HardarNarasimhan.impl.HNFil",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Nat.instIsOrderedCancelAddMonoid",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "HardarNarasimhan.instLatticeInterval",
   "Nat.instAddMonoid",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.StI",
   "Set",
   "instHAdd",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "HardarNarasimhan.impl.HNFil_is_strict_mono'",
   "HardarNarasimhan.impl.semistableI_iff",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "lt_add_one",
   "AddZeroClass.toAdd",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "HardarNarasimhan.semistableI",
   "Ne",
   "Subtype.mk",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "OrderTop.toTop",
   "Nat.find_min",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.HNFil_piecewise_semistable",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ] (i : ℕ) (h_1 : i < Nat.find ⋯),\n  HardarNarasimhan.Semistable\n    (HardarNarasimhan.Resμ ⟨(HardarNarasimhan.impl.HNFil μ i, HardarNarasimhan.impl.HNFil μ (i + 1)), ⋯⟩ μ)",
  "constCategory": "Theorem"},
 {"references": ["Union"],
  "name": "Union.union",
  "constType": "{α : Type u} → [self : Union α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["LE", "BoundedOrder", "OrderTop", "OrderBot"],
  "name": "BoundedOrder.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toOrderTop : OrderTop α] → [toOrderBot : OrderBot α] → BoundedOrder α",
  "constCategory": "Other"},
 {"references":
  ["Preorder.le_trans",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b c : HardarNarasimhan.Interval z), ↑a ≤ ↑b → ↑b ≤ ↑c → ↑a ≤ ↑c",
  "constCategory": "Theorem"},
 {"references":
  ["ConditionallyCompleteLattice", "ConditionallyCompleteLinearOrder"],
  "name": "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLinearOrder α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Sub"],
  "name": "SubNegMonoid.toSub",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Sub G",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "Bot",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderBot",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Top",
   "OrderTop",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod",
   "LT.lt",
   "lcProof",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.TotIntvl._cstage1",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "instOfNatNat",
   "instHAdd",
   "Nat.le_of_succ_le_succ",
   "LE.le",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Nat.le_of_lt_add_one",
  "constType": "∀ {n m : ℕ}, n < m + 1 → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "PartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "CompleteSemilatticeInf.toInfSet",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μmin",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references": ["Mul", "MulOneClass"],
  "name": "MulOneClass.toMul",
  "constType": "{M : Type u} → [self : MulOneClass M] → Mul M",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "sub_eq_add_neg",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Eq.ndrec",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Ring.toAddCommGroup",
   "eq_self",
   "NegZeroClass.toNeg",
   "AddGroupWithOne.toAddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "of_eq_true",
   "instHSub",
   "AddMonoid.toAddZeroClass",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.sub_pf",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a b c d : R}, -b = c → a + c = d → a - b = d",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references": ["Union", "Set", "Union.mk", "Set.union"],
  "name": "Set.instUnion",
  "constType": "{α : Type u} → Union (Set α)",
  "constCategory": "Definition"},
 {"references": ["Inter", "Set", "Set.inter", "Inter.mk"],
  "name": "Set.instInter",
  "constType": "{α : Type u} → Inter (Set α)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "HardarNarasimhan.instCoeOutInterval._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.instNontrivialInterval",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "HardarNarasimhan.NashEquilibrium",
   "HardarNarasimhan.Semistable",
   "OrderBot.toBot",
   "HardarNarasimhan.instBoundedOrderInterval",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "HardarNarasimhan.instLatticeInterval",
   "SemilatticeInf.toPartialOrder",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "HardarNarasimhan.impl.prop4d20",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_4_20",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥), HardarNarasimhan.WeakAscendingChainCondition (HardarNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n    (∀ (x : ℒ) (hx : x ≠ ⊥), HardarNarasimhan.WeakSlopeLike₁ (HardarNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n      HardarNarasimhan.NashEquilibrium μ → HardarNarasimhan.Semistable μ",
  "constCategory": "Theorem"},
 {"references": ["Classical.choose_spec", "Exists", "Exists.choose"],
  "name": "Exists.choose_spec",
  "constType": "∀ {α : Sort u_1} {p : α → Prop} (P : ∃ a, p a), p P.choose",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocCommRing.mk",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalNonAssocCommRing"],
  "name": "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
  "constType":
  "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalNonAssocCommRing α",
  "constCategory": "Definition"},
 {"references": ["Preorder", "ClosureOperator"],
  "name": "ClosureOperator.IsClosed",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → ClosureOperator α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "le_top",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "Nat.lt_add_one",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "Lattice",
   "Top.top",
   "OrderTop.toTop",
   "StrictMono"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (x : ℕ → ℒ), StrictMono x → ∀ (N : ℕ), (x N, ⊤).1 < (x N, ⊤).2",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "le_top",
   "LT.lt.trans_le",
   "LT.lt.ne",
   "Top.top",
   "Preorder.toLT",
   "OrderTop",
   "Ne",
   "Preorder.toLE",
   "OrderTop.toTop"],
  "name": "ne_top_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α] {a b : α}, a < b → a ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "sorryAx",
   "Eq.trans",
   "Lean.Name.str",
   "Bool.false",
   "Classical.propDecidable",
   "Exists.intro",
   "eq_true",
   "List.tfae_of_cycle",
   "List.instGetElem?NatLtLength",
   "Subtype.val",
   "GetElem?.getElem?",
   "HardarNarasimhan.NashEquilibrium",
   "Nat.instCharZero",
   "HardarNarasimhan.WeakSlopeLike₁.mk",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "HardarNarasimhan.μmin",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Eq.ndrec",
   "HardarNarasimhan.instBoundedOrderInterval",
   "HardarNarasimhan.WeakSlopeLike₁",
   "instLTNat",
   "HardarNarasimhan.SlopeLike",
   "_private.Init.Data.Nat.Basic.0._proof_6",
   "Exists",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop4d16₂",
   "Nat.instNontrivial",
   "Prod.snd",
   "lt_iff_le_not_le",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "StrictMono",
   "AddMonoid.toAddZeroClass",
   "_private.Mathlib.Data.Nat.Cast.Order.Ring.0._proof_7",
   "List.getElem?_eq_getElem",
   "Or.inr",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "OmegaCompletePartialOrder.toPartialOrder",
   "GetElem.getElem",
   "List",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Nat.instPreorder",
   "Prod.fst",
   "Nat.instAddMonoidWithOne",
   "Prod.casesOn",
   "Nat.instNeZeroSucc",
   "Or.inl",
   "Nat.instSemiring",
   "instOfNatNat",
   "congr",
   "_private.Mathlib.Data.Nat.Cast.Order.Basic.0._proof_15",
   "Preorder.toLE",
   "Eq",
   "HardarNarasimhan.instLatticeInterval",
   "Nat.instAddMonoid",
   "IsStrictOrderedRing.toIsOrderedRing",
   "List.Chain.cons",
   "HardarNarasimhan.TotIntvl",
   "List.Chain.nil",
   "HardarNarasimhan.SlopeLike.slopelike",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "HardarNarasimhan.impl.prop4d16₁",
   "eq_self",
   "AddZeroClass.toAdd",
   "inferInstance",
   "Nat.instIsStrictOrderedRing",
   "Ne",
   "Subtype.casesOn",
   "Lean.Name.num",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "lt_trans",
   "le_refl",
   "PartialOrder.toPreorder",
   "Lean.Name",
   "Prod.mk",
   "_private.Init.Core.0._proof_38",
   "Iff.mp",
   "Preorder.toLT",
   "HardarNarasimhan.WeakSlopeLike₁.wsl₁",
   "HardarNarasimhan.instNontrivialInterval",
   "Nat.instAddCommMonoid",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "And.intro",
   "Mathlib.Meta.NormNum.isNat_add",
   "Or",
   "HardarNarasimhan.Semistable",
   "List.TFAE",
   "HardarNarasimhan.WeakAscendingChainCondition.wacc",
   "CompleteLinearOrder",
   "Nat.instIsOrderedAddMonoid",
   "List.cons",
   "HardarNarasimhan.Interval",
   "And.left",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "AddZeroClass.toZero",
   "Nat.instPartialOrder",
   "And.right",
   "And",
   "IsOrderedAddMonoid.toAddLeftMono",
   "True.intro",
   "Bot.bot",
   "Nat.lt_add_one",
   "Exists.casesOn",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "zero_add",
   "Option",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "List.length",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Lean.Name.anonymous",
   "Subtype",
   "HardarNarasimhan.WeakAscendingChainCondition.mk",
   "le_trans",
   "HardarNarasimhan.impl.prop4d18₂",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "congrArg",
   "Subtype.prop",
   "Nat.instOne",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "Subtype.le",
   "Not",
   "List.nil",
   "List.instGetElemNatLtLength",
   "bot_lt_iff_ne_bot",
   "le_top",
   "List.TFAE.out",
   "Lattice.toSemilatticeInf",
   "True",
   "_private.Mathlib.Order.Basic.0._proof_36",
   "instHAdd",
   "HardarNarasimhan.impl.instWeakSlopeLike₁OfSlopeLike",
   "HardarNarasimhan.WeakSlopeLike₂",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "HardarNarasimhan.impl.prop4d20",
   "Or.casesOn",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.thm4d21",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.SlopeLike μ →\n    HardarNarasimhan.WeakAscendingChainCondition μ →\n      HardarNarasimhan.WeakDescendingChainCondition μ →\n        [HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl,\n            HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = μ HardarNarasimhan.TotIntvl,\n            HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl,\n            HardarNarasimhan.NashEquilibrium μ, HardarNarasimhan.Semistable μ].TFAE",
  "constCategory": "Theorem"},
 {"references":
  ["HardarNarasimhan.impl.lem2d4₂I",
   "Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "Prod.fst",
   "And.intro",
   "HardarNarasimhan.impl.lem2d4₃I",
   "HardarNarasimhan.μmax",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "inf_lt_left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "HardarNarasimhan.TotIntvl",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "gt_of_ge_of_gt",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "HardarNarasimhan.impl.lem2d4₁",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.lemma_2_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Convex μ →\n    ∀ (x w : ℒ) (hxw : ¬x ≤ w) (u t : ℒ) (huxw : u ≤ x ⊓ w) (hxwt : x ⊔ w ≤ t),\n      (HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HardarNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩ ∧\n          HardarNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩ ≤ HardarNarasimhan.μmax μ ⟨(w, t), ⋯⟩) ∧\n        HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(w, x ⊔ w), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["ClosureOperator.isClosed_iff",
   "ClosureOperator.le_closure",
   "PartialOrder.toPreorder",
   "ClosureOperator.IsClosed",
   "ClosureOperator.toOrderHom",
   "ClosureOperator",
   "DFunLike.coe",
   "Iff.intro",
   "ClosureOperator.instFunLike",
   "OrderHom.toFun",
   "Iff",
   "PartialOrder",
   "Iff.mpr",
   "LE.le",
   "LE.le.antisymm",
   "ClosureOperator.IsClosed.closure_eq",
   "Preorder.toLE",
   "Eq",
   "Eq.le"],
  "name": "ClosureOperator.isClosed_iff_closure_le",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {c : ClosureOperator α} {x : α}, c.IsClosed x ↔ c x ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "instLTNat",
   "Nat.succ_add",
   "Nat.add_le_of_le_sub",
   "Eq.mp",
   "instHAdd",
   "Nat.ge_of_not_lt",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.not_lt_zero",
   "Nat",
   "Nat.sub_eq_zero_of_le",
   "instSubNat",
   "Nat.succ",
   "instOfNatNat",
   "letFun",
   "LE.le",
   "HSub.hSub",
   "instHSub",
   "instLENat",
   "Nat.le_of_lt"],
  "name": "Nat.add_lt_of_lt_sub",
  "constType": "∀ {a b c : ℕ}, a < c - b → a + b < c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "CompleteLattice.toBot",
   "BoundedOrder",
   "BoundedOrder.mk",
   "CompleteLattice.le_top",
   "CompleteLattice.bot_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderBot.mk",
   "CompleteLattice",
   "OrderTop.mk"],
  "name": "CompleteLattice.toBoundedOrder",
  "constType": "{α : Type u_1} → [inst : CompleteLattice α] → BoundedOrder α",
  "constCategory": "Definition"},
 {"references": ["Not", "Classical.not_imp", "And", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_implies_eq",
  "constType": "∀ (p q : Prop), (¬(p → q)) = (p ∧ ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
   "Nat.cast",
   "True",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.cast",
   "congrArg",
   "Int",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Ring.toAddGroupWithOne",
   "of_eq_true",
   "Mathlib.Meta.NormNum.IsInt",
   "AddGroupWithOne.toIntCast",
   "Int.cast_natCast",
   "Int.ofNat",
   "Eq",
   "Mathlib.Meta.NormNum.IsNat",
   "instNatCastInt",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsNat a n → Mathlib.Meta.NormNum.IsInt a (Int.ofNat n)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_right"],
  "name": "inf_le_right",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "True",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instOfNatAtLeastTwo",
   "Preorder.toLT",
   "eq_true",
   "OfNat.ofNat",
   "Nat.ofNat_pos",
   "LT.lt",
   "IsOrderedRing",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Semiring.toNonAssocSemiring",
   "Nat.AtLeastTwo",
   "MulZeroClass.toZero",
   "PartialOrder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nontrivial",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring"],
  "name": "_private.Mathlib.Data.Nat.Cast.Order.Ring.0._proof_7",
  "constType":
  "∀ {α : Type u_3} [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] [Nontrivial α] {n : ℕ}\n  [inst_4 : n.AtLeastTwo], (0 < OfNat.ofNat n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.WeakDescendingChainCondition",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "Equiv",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "SupSet.sSup",
   "funext",
   "Eq.symm",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Set.ext",
   "Eq.mpr",
   "OrderDual.instBoundedOrder",
   "setOf",
   "OrderDual",
   "OrderDual.toDual",
   "Ne.symm",
   "Subtype",
   "OrderDual.instLattice",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "Iff.intro",
   "congrArg",
   "OrderDual.ofDual",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "OrderDual.instLT",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.μmax",
   "congr",
   "InfSet.sInf",
   "OrderDual.instCompleteLattice",
   "OrderDual.instPartialOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Not",
   "_private.Mathlib.Order.Synonym.0._proof_6",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "HardarNarasimhan.in_TotIntvl",
   "Set",
   "exists_prop_congr",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "ConditionallyCompleteLattice.toSupSet",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HardarNarasimhan.impl.dualμAstar_eq_μBstar",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  OrderDual.ofDual\n    ((HardarNarasimhan.μAstar fun p => OrderDual.toDual (μ ⟨((↑p).2, (↑p).1), ⋯⟩)) = HardarNarasimhan.μBstar μ)",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.NashEquilibrium.rec",
   "HardarNarasimhan.NashEquilibrium.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.μBstar",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.NashEquilibrium",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.μAstar",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.NashEquilibrium.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.NashEquilibrium μ → Sort u} →\n                (t : HardarNarasimhan.NashEquilibrium μ) →\n                  ((nash_eq : HardarNarasimhan.μAstar μ = HardarNarasimhan.μBstar μ) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.impl.lem2d4₂I",
   "Lattice.toSemilatticeSup",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Preorder.toLT",
   "Prod.fst",
   "le_rfl",
   "HardarNarasimhan.μmax",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.ConvexI.mk",
   "LT.lt",
   "Prod",
   "Max.max",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.rmk2d5₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ → HardarNarasimhan.ConvexI I (HardarNarasimhan.μmax μ)",
  "constCategory": "Theorem"},
 {"references": ["SubtractionMonoid", "SubtractionCommMonoid"],
  "name": "SubtractionCommMonoid.toSubtractionMonoid",
  "constType":
  "{G : Type u} → [self : SubtractionCommMonoid G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.μBstar",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "HardarNarasimhan.TotIntvl._proof_1",
   "Subtype.val",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "SupSet.sSup",
   "letFun",
   "sSup_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "HardarNarasimhan.μmin",
   "HardarNarasimhan.μAstar",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HardarNarasimhan.μA._proof_3",
   "HardarNarasimhan.impl.rmk4d10₀",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Ne.symm",
   "Subtype",
   "le_trans",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Prod.fst",
   "HardarNarasimhan.μmax",
   "BoundedOrder.toOrderTop",
   "InfSet.sInf",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.μB",
   "HardarNarasimhan.in_TotIntvl",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.μA",
   "sInf_le",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "LE.le",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HardarNarasimhan.impl.prop4d11₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.μmin μ HardarNarasimhan.TotIntvl = HardarNarasimhan.μmax μ HardarNarasimhan.TotIntvl →\n    HardarNarasimhan.μBstar μ ≤ HardarNarasimhan.μAstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "Prod.fst",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nat.below",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (k : ℕ) (x : Nat.below k.succ), ↑x.1 < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HardarNarasimhan.SlopeLike.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HardarNarasimhan.SlopeLike",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HardarNarasimhan.SlopeLike.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x y z : ℒ) (h : x < y ∧ y < z),\n      (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n        (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n          (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n            (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) →\n    HardarNarasimhan.SlopeLike μ",
  "constCategory": "Definition"},
 {"references":
  ["Int.instCommRing", "CommRing.toRing", "inferInstance", "Int", "Ring"],
  "name": "Int.instRing",
  "constType": "Ring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Inter.inter",
   "Membership.mem",
   "Set.instInter",
   "Set.instMembership",
   "And.left"],
  "name": "Set.inter_subset_left",
  "constType": "∀ {α : Type u} {s t : Set α}, s ∩ t ⊆ s",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "OrderDual", "Equiv"],
  "name": "OrderDual.ofDual",
  "constType": "{α : Type u_1} → αᵒᵈ ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Eq.symm",
   "Int.instLEInt",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nat.lt_of_not_le",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Bool",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Option.some",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Int.instAdd",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (filtration : ℕ → ℒ) (fin_len : ∃ n, filtration n = ⊤)\n  (i : ℕ), i + 1 < Nat.find fin_len → ¬i + 1 ≤ Nat.find fin_len → False",
  "constCategory": "Theorem"},
 {"references": ["Ord", "Ordering"],
  "name": "Ord.mk",
  "constType": "{α : Type u} → (α → α → Ordering) → Ord α",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Eq.mp",
   "Iff.mp",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Subtype.val",
   "congrArg",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "letFun",
   "Eq.symm",
   "WellFoundedGT",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "HardarNarasimhan.impl.prop3d4₀func",
   "Prod.snd",
   "HardarNarasimhan.impl.prop3d4₀func_len",
   "HardarNarasimhan.impl.prop3d4₀func_fin_len",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat.find_spec",
   "Nat",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "False",
   "Ne",
   "lt_self_iff_false",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.prop3d4₀func_len_nonzero",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 })\n  (hμDCC : HardarNarasimhan.μA_DescendingChainCondition μ), HardarNarasimhan.impl.prop3d4₀func_len μ I hμDCC ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "RelEmbedding.toEmbedding",
   "PartialOrder.toPreorder",
   "Set",
   "Coe",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Coe.mk",
   "Function.Embedding.toFun",
   "HardarNarasimhan.DedekindMacNeilleClosureOperator",
   "HardarNarasimhan.DedekindMacNeilleCompletion",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "LE.le",
   "HardarNarasimhan.coe'",
   "Preorder.toLE",
   "Subtype.le",
   "Set.instLE"],
  "name": "HardarNarasimhan.instCoeDedekindMacNeilleCompletion",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → Coe α (HardarNarasimhan.DedekindMacNeilleCompletion α)",
  "constCategory": "Definition"},
 {"references": ["IsWellFounded", "GT.gt", "LT"],
  "name": "WellFoundedGT",
  "constType": "(α : Type u_1) → [LT α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["ClosureOperator.isClosed_iff",
   "ClosureOperator.instFunLike",
   "OrderHom.toFun",
   "PartialOrder.toPreorder",
   "ClosureOperator.IsClosed",
   "Iff.mpr",
   "PartialOrder",
   "ClosureOperator.toOrderHom",
   "ClosureOperator",
   "Eq",
   "ClosureOperator.idempotent",
   "DFunLike.coe"],
  "name": "ClosureOperator.isClosed_closure",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] (c : ClosureOperator α) (x : α), c.IsClosed (c x)",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "eq_true",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.AtLeastTwo",
   "PartialOrder",
   "Nat.one_lt_ofNat",
   "CharZero",
   "Preorder.toLE",
   "Eq",
   "AddMonoidWithOne",
   "AddSemigroup.toAdd",
   "AddZeroClass.toZero",
   "True",
   "instOfNatAtLeastTwo",
   "OfNat.ofNat",
   "ZeroLEOneClass",
   "LT.lt",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "AddMonoid.toAddSemigroup",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddZeroClass"],
  "name": "_private.Mathlib.Data.Nat.Cast.Order.Basic.0._proof_15",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [AddLeftMono α] [ZeroLEOneClass α] [CharZero α]\n  {n : ℕ} [inst_5 : n.AtLeastTwo], (1 < OfNat.ofNat n) = True",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references": ["Top", "LE.le", "Top.top", "LE", "OrderTop"],
  "name": "OrderTop.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toTop : Top α] → (∀ (a : α), a ≤ ⊤) → OrderTop α",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "Prod.snd",
   "HardarNarasimhan.ConvexI.mk",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.ConvexI.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Lattice ℒ] →\n    {S : Type} →\n      [inst_1 : CompleteLattice S] →\n        {I : { p // p.1 < p.2 }} →\n          {μ : { p // p.1 < p.2 } → S} →\n            {motive : HardarNarasimhan.ConvexI I μ → Sort u} →\n              ((convex :\n                    ∀ (x y : ℒ),\n                      HardarNarasimhan.InIntvl I x →\n                        HardarNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩) →\n                  motive ⋯) →\n                (t : HardarNarasimhan.ConvexI I μ) → motive t",
  "constCategory": "Other"},
 {"references": ["Add", "Distrib"],
  "name": "Distrib.toAdd",
  "constType": "{R : Type u_1} → [self : Distrib R] → Add R",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable", "Decidable.casesOn"],
  "name": "ite",
  "constType": "{α : Sort u} → (c : Prop) → [h : Decidable c] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Coe",
   "Preorder.toLT",
   "Subtype.val",
   "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_17",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Coe.mk",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_18",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top"],
  "name": "HardarNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → Coe ℒ (HardarNarasimhan.Interval ⟨(⊥, ⊤), ⋯⟩)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Ring.toNonAssocRing",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "PartialOrder",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "Zero.toOfNat0",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsOrderedAddMonoid.toAddLeftMono",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "IsOrderedRing",
   "AddGroupWithOne.toAddGroup",
   "AddCommMonoid.toAddCommSemigroup",
   "sub_nonpos_of_le",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "covariant_swap_add_of_covariant_add",
   "instHSub",
   "Ring"],
  "name": "Linarith.sub_nonpos_of_le",
  "constType":
  "∀ {α : Type u} [inst : Ring α] [inst_1 : PartialOrder α] [IsOrderedRing α] {a b : α}, a ≤ b → a - b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "HardarNarasimhan.μ_Admissible.mk",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.IsAttained",
   "IsTotal",
   "HardarNarasimhan.μ_Admissible.rec",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.μ_Admissible.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                {motive : HardarNarasimhan.μ_Admissible μ → Sort u} →\n                  (t : HardarNarasimhan.μ_Admissible μ) →\n                    ((μ_adm :\n                          (IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n                            ∀ (I : { p // p.1 < p.2 }), HardarNarasimhan.IsAttained μ I) →\n                        motive ⋯) →\n                      motive t",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "HardarNarasimhan.instBoundedOrderInterval._rarg", "_neutral"],
  "name": "HardarNarasimhan.instBoundedOrderInterval._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg",
   "_obj",
   "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "le_trans",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "le_inf",
   "Subtype.prop",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Min.min",
   "Lattice",
   "Nontrivial",
   "LE.le"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_9",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HardarNarasimhan.Interval z), (↑z).1 ≤ ↑a ⊓ ↑b ∧ ↑a ⊓ ↑b ≤ (↑z).2",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.WeakSlopeLike₁.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "HardarNarasimhan.WeakSlopeLike₁",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₁.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakSlopeLike₁ μ → Sort u} →\n                ((wsl₁ :\n                      ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                        μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                    motive ⋯) →\n                  (t : HardarNarasimhan.WeakSlopeLike₁ μ) → motive t",
  "constCategory": "Other"},
 {"references": ["Nat", "OfNat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "Union.union",
   "DFunLike.coe",
   "Subtype.val",
   "ClosureOperator.instFunLike",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "ClosureOperator.isClosed_closure",
   "Set.instUnion"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds), T.IsClosed (T (↑A ∪ ↑B))",
  "constCategory": "Theorem"},
 {"references": ["HAdd", "outParam"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["PartialOrder", "LinearOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u_2} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.impl.instμ_Admissible",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "Unique.mk",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "HardarNarasimhan.instInhabitedHardarNarasimhanFiltration",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Unique",
   "HardarNarasimhan.instUniqueHardarNarasimhanFiltration._proof_3",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Lattice",
   "Nontrivial"],
  "name": "HardarNarasimhan.instUniqueHardarNarasimhanFiltration",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLinearOrder S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] → Unique (HardarNarasimhan.HardarNarasimhanFiltration μ)",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_16",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "EmptyCollection.emptyCollection",
   "Set.instEmptyCollection",
   "Subtype.val",
   "DFunLike.coe",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "ClosureOperator.isClosed_closure",
   "Eq.rec",
   "Eq",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Set.empty_subset",
   "Set.instMembership",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Subtype.mk"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_17",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A : T.Closeds) ⦃a : α⦄, a ∈ ↑⟨T ∅, ⋯⟩ → a ∈ ↑A",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "IsIrrefl",
   "Preorder",
   "Preorder.toLT",
   "IsIrrefl.swap",
   "GT.gt",
   "instIsIrreflLt"],
  "name": "instIsIrreflGt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α], IsIrrefl α fun x1 x2 => x1 > x2",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le_trans", "Nat", "Nat.le_succ", "Nat.succ", "LE.le", "instLENat"],
  "name": "Nat.le_of_succ_le",
  "constType": "∀ {n m : ℕ}, n.succ ≤ m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "CoeOut.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "CoeOut",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instCoeOutInterval._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → CoeOut (HardarNarasimhan.Interval z) ℒ",
  "constCategory": "Definition"},
 {"references":
  ["IsStrictOrderedRing.mk",
   "PartialOrder.toPreorder",
   "IsOrderedCancelAddMonoid.mk",
   "Nat.le_of_add_le_add_left",
   "Eq.mp",
   "Exists.intro",
   "Nat.add_le_add_left",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "Nat.mul_lt_mul_of_pos_right",
   "Nat.instSemiring",
   "Nat.ne_of_lt",
   "instOfNatNat",
   "Zero.toOfNat0",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nontrivial.mk",
   "Preorder.toLE",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "add_comm",
   "IsOrderedAddMonoid.mk",
   "IsStrictOrderedRing",
   "Exists",
   "Nat.instPartialOrder",
   "instHAdd",
   "ZeroLEOneClass.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat.zero_lt_succ",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat",
   "Nat.zero_lt_one",
   "One.toOfNat1",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "AddMonoidWithOne.toOne",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "Nat.mul_lt_mul_of_pos_left",
   "id",
   "Ne",
   "Eq.mpr",
   "Nat.le_of_lt"],
  "name": "Nat.instIsStrictOrderedRing",
  "constType": "IsStrictOrderedRing ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Subtype.partialOrder",
   "ClosureOperator",
   "Set.iInter",
   "Subtype.val",
   "DFunLike.coe",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "forall_congr",
   "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_12",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "_private.Init.Data.Subtype.0._proof_1",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "_private.Mathlib.Order.SetNotation.0._proof_4",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "Subtype.mk"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_14",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds) (A : T.Closeds),\n  (∀ b ∈ 𝒮, A ≤ b) → ∀ ⦃x : α⦄, x ∈ ↑A → x ∈ ↑⟨⋂ a ∈ 𝒮, ↑a, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "HardarNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._rarg",
   "_neutral"],
  "name":
  "HardarNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "PartialOrder.toPreorder",
   "AddCommGroup.toAddGroup",
   "Preorder.toLT",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubtractionMonoid",
   "IsOrderedAddMonoid",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddGroup.toSubNegMonoid",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "AddCommGroup",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "neg_neg_iff_pos",
   "LT.lt",
   "NegZeroClass.toNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "IsOrderedAddMonoid.toIsOrderedCancelAddMonoid",
   "Iff.mpr",
   "AddCommGroup.toAddCommMonoid",
   "NegZeroClass.toZero",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "AddMonoid.toAddZeroClass"],
  "name": "neg_neg_of_pos",
  "constType":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : PartialOrder α] [IsOrderedAddMonoid α] {a : α}, 0 < a → -a < 0",
  "constCategory": "Theorem"},
 {"references": ["Neg"],
  "name": "Neg.mk",
  "constType": "{α : Type u} → (α → α) → Neg α",
  "constCategory": "Other"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name":
  "HardarNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references": ["And.intro", "And", "And.rec"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "instOfNatNat",
   "Zero.toOfNat0",
   "Nat.cast_succ",
   "Eq",
   "AddMonoidWithOne",
   "AddSemigroup.toAdd",
   "AddZeroClass.toZero",
   "instHAdd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat",
   "zero_add",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "AddZeroClass.toAdd",
   "Nat.succ",
   "Eq.refl",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_zero",
   "AddMonoidWithOne.toOne",
   "id",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "Preorder.le_refl", "LE.le", "Preorder.toLE"],
  "name": "le_refl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.mk",
  "constType": "{α : Type u} → {β : Type v} → α → β → α × β",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lean.Name",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["LE.le", "LE", "ge_iff_le", "Eq", "GE.ge", "propext"],
  "name": "_private.Init.Core.0._proof_38",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "Set"],
  "name": "InfSet.mk",
  "constType": "{α : Type u_1} → (Set α → α) → InfSet α",
  "constCategory": "Other"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "Int.cast",
   "Int",
   "Ring"],
  "name": "Int.rawCast",
  "constType": "{α : Type u} → [Ring α] → ℤ → α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "bot_le",
   "Subtype.val",
   "Equiv",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instTop",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "Exists",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OrderDual.instOrderTop",
   "Nat.lt_add_one",
   "Prod",
   "Exists.casesOn",
   "Nat",
   "OrderDual.instPreorder",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "StrictMono",
   "OrderDual",
   "Subtype",
   "Eq.mp",
   "DFunLike.coe",
   "congrArg",
   "HardarNarasimhan.impl.fuck",
   "Nat.instPreorder",
   "Prod.fst",
   "OrderDual.ofDual",
   "Subtype.prop",
   "instOfNatNat",
   "OrderDual.instLT",
   "OrderBot.toBot",
   "OrderDual.instLE",
   "Eq",
   "Preorder.toLE",
   "le_top",
   "Lattice.toSemilatticeInf",
   "OrderDual.ofDual_le_ofDual",
   "Equiv.instFunLike",
   "instHAdd",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.h₁_dual_of_h₁",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    ∀ (x : ℕ → ℒᵒᵈ) (smf : StrictMono x),\n      ∃ N, (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨(x N, x (N + 1)), ⋯⟩ ≤ (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨(x N, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "BoundedOrder",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.TotIntvl._proof_1",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ], ⊥ < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat.to_eq.match_1",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "Unit"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_eq",
  "constType":
  "∀ {α : Type u} [inst : AddMonoidWithOne α] {n : ℕ} {a a' : α}, Mathlib.Meta.NormNum.IsNat a n → ↑n = a' → a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Subtype.lt", "Subtype", "Iff.mpr", "Iff.rfl", "Subtype.val", "LT"],
  "name": "Subtype.GCongr.coe_lt_coe",
  "constType":
  "∀ {α : Type u_2} [inst : LT α] {p : α → Prop} {x y : Subtype p}, x < y → ↑x < ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod",
   "LT.lt",
   "And.intro",
   "Subtype.prop",
   "le_of_lt",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instBoundedOrderInterval._proof_15",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {z : { p // p.1 < p.2 }}, (↑z).1 ≤ (↑z).1 ∧ (↑z).1 ≤ (↑z).2",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.lt",
   "Nat.instMax",
   "instMinNat",
   "DecidableEq",
   "Nat.le_refl",
   "PartialOrder.mk",
   "LT.mk",
   "Nat.instLinearOrder._proof_3",
   "Nat.le",
   "Nat.le_trans",
   "DecidableLE",
   "DecidableLT",
   "LinearOrder",
   "Nat.decLe",
   "LinearOrder.mk",
   "instOrdNat",
   "Nat.le_antisymm",
   "Nat.decLt",
   "Nat",
   "Nat.instLinearOrder._proof_2",
   "Nat.instLinearOrder._proof_1",
   "LE.mk",
   "Nat.le_total",
   "inferInstance",
   "instDecidableEqNat",
   "Preorder.mk",
   "Nat.lt_iff_le_not_le"],
  "name": "Nat.instLinearOrder",
  "constType": "LinearOrder ℕ",
  "constCategory": "Definition"},
 {"references": ["Inv", "InvOneClass"],
  "name": "InvOneClass.toInv",
  "constType": "{G : Type u_2} → [self : InvOneClass G] → Inv G",
  "constCategory": "Definition"},
 {"references": ["Neg"],
  "name": "Neg.neg",
  "constType": "{α : Type u} → [self : Neg α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "HardarNarasimhan.impl.semistable_iff",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "SupSet.sSup",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Subtype.coe_eta",
   "HardarNarasimhan.μmin",
   "Eq.symm",
   "Eq.ndrec",
   "Exists",
   "Exists.choose_spec",
   "HardarNarasimhan.impl.rmk4d10₀",
   "HardarNarasimhan.μA._proof_3",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Eq.mpr",
   "setOf",
   "Ne.symm",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "_private.Mathlib.Order.Defs.LinearOrder.0._proof_1",
   "HardarNarasimhan.S₂I",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Set",
   "HardarNarasimhan.TotIntvl",
   "HardarNarasimhan.μA",
   "CompletelyDistribLattice.toCompleteLattice",
   "LinearOrder.toPartialOrder",
   "HardarNarasimhan.semistableI",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "bot_lt_top",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "sSup_le_sSup_of_forall_exists_le",
   "HardarNarasimhan.μBstar",
   "Membership.mem",
   "_private.Init.Core.0._proof_38",
   "Preorder.toLT",
   "Iff.mp",
   "GT.gt",
   "And.intro",
   "HardarNarasimhan.μmax._proof_2",
   "sSup_le",
   "PartialOrder",
   "HardarNarasimhan.Semistable",
   "HardarNarasimhan.μAstar",
   "CompleteLinearOrder",
   "HardarNarasimhan.S₁I._proof_1",
   "Eq.rec",
   "HardarNarasimhan.S₁I",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "sInf_le_sInf_of_forall_exists_le",
   "HardarNarasimhan.InIntvl",
   "And.right",
   "And",
   "Bot.bot",
   "Exists.casesOn",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "HardarNarasimhan.μmax",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "Prod.mk.eta",
   "Exists.choose",
   "LT.lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "_private.Init.Core.0._proof_39",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.prop4d18₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Semistable μ → HardarNarasimhan.μBstar μ ≤ HardarNarasimhan.μAstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["MulAction.toSMul",
   "DistribSMul.mk",
   "AddZeroClass.toZero",
   "SMulZeroClass.mk",
   "DistribMulAction.smul_zero",
   "DistribMulAction.toMulAction",
   "Monoid",
   "AddMonoid",
   "DistribSMul",
   "DistribMulAction",
   "DistribMulAction.smul_add",
   "AddMonoid.toAddZeroClass"],
  "name": "DistribMulAction.toDistribSMul",
  "constType":
  "{M : Type u_1} → {A : Type u_7} → [inst : Monoid M] → [inst_1 : AddMonoid A] → [DistribMulAction M A] → DistribSMul M A",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.WeakSlopeLike₂.mk",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.WeakSlopeLike₂",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakSlopeLike₂.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HardarNarasimhan.WeakSlopeLike₂ μ → Sort u} →\n                ((wsl₂ :\n                      ∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n                        μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n                    motive ⋯) →\n                  (t : HardarNarasimhan.WeakSlopeLike₂ μ) → motive t",
  "constCategory": "Other"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references": ["Max"],
  "name": "Max.mk",
  "constType": "{α : Type u} → (α → α → α) → Max α",
  "constCategory": "Other"},
 {"references":
  ["LT.lt",
   "Prod",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "Subtype",
   "Subtype.prop",
   "Lattice",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.stableI._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }), (↑I).1 < (↑I).2",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "instLTNat",
   "Nat",
   "Nat.lt_or_ge",
   "LE.le",
   "Or.resolve_right",
   "GT.gt",
   "GE.ge",
   "instLENat"],
  "name": "Nat.gt_of_not_le",
  "constType": "∀ {n m : ℕ}, ¬n ≤ m → n > m",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HardarNarasimhan.StI",
   "Set",
   "Membership.mem",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Set.instMembership",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "HardarNarasimhan.semistableI",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.semistableI.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HardarNarasimhan.semistableI μ I = ((↑I).2 ∈ HardarNarasimhan.StI μ I)",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name": "HardarNarasimhan.μA._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Not", "False.elim", "Decidable", "Decidable.byCases", "id", "False"],
  "name": "Decidable.byContradiction",
  "constType": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μ_Admissible",
   "Prod.fst",
   "HardarNarasimhan.μ_Admissible.mk",
   "Prod",
   "LT.lt",
   "HardarNarasimhan.IsAttained",
   "IsTotal",
   "HardarNarasimhan.μ_Admissible.rec",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.μ_Admissible.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                {motive : HardarNarasimhan.μ_Admissible μ → Sort u} →\n                  (t : HardarNarasimhan.μ_Admissible μ) →\n                    ((μ_adm :\n                          (IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n                            ∀ (I : { p // p.1 < p.2 }), HardarNarasimhan.IsAttained μ I) →\n                        motive ⋯) →\n                      motive t",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakAscendingChainCondition.noConfusionType",
   "HardarNarasimhan.WeakAscendingChainCondition.casesOn",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.WeakAscendingChainCondition",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HardarNarasimhan.WeakAscendingChainCondition.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HardarNarasimhan.WeakAscendingChainCondition μ} →\n                  v1 = v2 → HardarNarasimhan.WeakAscendingChainCondition.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "HardarNarasimhan.impl.instμ_Admissible",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "Exists",
   "Lean.Omega.combo_sat'",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "HardarNarasimhan.impl.HNFil",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "Option.none",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "instHSub",
   "PartialOrder.toPreorder",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GT.gt",
   "GE.ge",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Int.instNegInt",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "instDecidableEqBool",
   "Nat",
   "Nontrivial",
   "Nat.lt_of_not_le",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.cast",
   "instDecidableAnd",
   "Subtype",
   "HardarNarasimhan.Convex",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_11",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HardarNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HardarNarasimhan.Convex μ) (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (n : ℕ)\n  (h₂ : ∃ N ≥ n + 1, HardarNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n  Nat.find h₂ > 0 → Nat.find h₂ - 1 < Nat.find hffin → ¬Nat.find h₂ ≤ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "AddGroupWithOne.toAddMonoidWithOne",
   "inferInstance",
   "AddMonoidWithOne",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne",
  "constType": "{α : Type u} → [Ring α] → AddMonoidWithOne α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references": ["ConditionallyCompleteLattice", "Lattice"],
  "name": "ConditionallyCompleteLattice.toLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["HardarNarasimhan.impl.lem2d4₂I",
   "Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "And.intro",
   "HardarNarasimhan.impl.lem2d4₃I",
   "HardarNarasimhan.μmax",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "inf_lt_left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "gt_of_ge_of_gt",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "HardarNarasimhan.impl.lem2d4₁",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.lem2d4I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        ∀ (w : ℒ),\n          HardarNarasimhan.InIntvl I w →\n            ∀ (hxw : ¬x ≤ w) (u t : ℒ) (huxw : u ≤ x ⊓ w) (hxwt : x ⊔ w ≤ t),\n              HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HardarNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩ ∧\n                HardarNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩ ≤ HardarNarasimhan.μmax μ ⟨(w, t), ⋯⟩ ∧\n                  HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HardarNarasimhan.μA μ ⟨(w, x ⊔ w), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "not_le_of_lt",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "And.intro",
   "Or.inl",
   "Or",
   "BoundedOrder.toOrderTop",
   "letFun",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HardarNarasimhan.SlopeLike",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.SlopeLike.slopelike",
   "Bot.bot",
   "Or.casesOn",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.rmk4d13",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.SlopeLike μ →\n    ∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      ¬μ ⟨(⊥, x), ⋯⟩ ≤ μ HardarNarasimhan.TotIntvl ∨ μ HardarNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_8",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Prod.fst",
   "Nat.instPreorder",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_1",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "instHAdd",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_2",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "HardarNarasimhan.impl.prop4d1₁_seq._proof_3",
   "OfNat.ofNat",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HardarNarasimhan.impl.prop4d1₁_seq",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf",
   "StrictMono"],
  "name": "HardarNarasimhan.impl.prop4d1₁_seq._proof_9",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S)\n  (h₁ : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩)\n  (h₂ :\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty) (k : ℕ),\n  ∃ xB,\n    ∃ (hAB : ↑(HardarNarasimhan.impl.prop4d1₁_seq μ h₁ h₂ h₃ k) < xB),\n      ¬μ ⟨(↑(HardarNarasimhan.impl.prop4d1₁_seq μ h₁ h₂ h₃ k), xB), hAB⟩ ≤\n          μ ⟨(↑(HardarNarasimhan.impl.prop4d1₁_seq μ h₁ h₂ h₃ k), ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableLT",
   "DecidableEq",
   "id",
   "LT.mk",
   "compareOfLessAndEq",
   "Ordering"],
  "name":
  "HardarNarasimhan.TotallyOrderedRealVectorSpace.compare._inherited_default",
  "constType":
  "{V : Type} → (lt : V → V → Prop) → DecidableEq V → DecidableLT V → V → V → Ordering",
  "constCategory": "Definition"},
 {"references": ["Not", "Iff", "Classical.propDecidable", "Decidable.not_not"],
  "name": "Classical.not_not",
  "constType": "∀ {a : Prop}, ¬¬a ↔ a",
  "constCategory": "Theorem"},
 {"references": ["Function.Embedding"],
  "name": "Function.Embedding.toFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → (α ↪ β) → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Int.cast_add",
   "Int.add",
   "Distrib.toAdd",
   "Ring.toNonAssocRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "instHAdd",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "Int.cast",
   "Int",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.instAdd",
   "Eq.symm",
   "AddGroupWithOne.toIntCast",
   "Mathlib.Meta.NormNum.isInt_add.match_1",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.isInt_add",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → a'.add b' = c → Mathlib.Meta.NormNum.IsInt (f a b) c",
  "constCategory": "Theorem"},
 {"references": ["IsTotal", "Or"],
  "name": "IsTotal.mk",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop}, (∀ (a b : α), r a b ∨ r b a) → IsTotal α r",
  "constCategory": "Other"},
 {"references": ["SupSet", "CompleteSemilatticeSup"],
  "name": "CompleteSemilatticeSup.toSupSet",
  "constType": "{α : Type u_8} → [self : CompleteSemilatticeSup α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Ordering.gt",
   "Decidable",
   "ite",
   "DecidableEq",
   "Ordering.eq",
   "Ordering.lt",
   "Eq",
   "Ordering",
   "LT"],
  "name": "compareOfLessAndEq",
  "constType":
  "{α : Type u_1} → (x y : α) → [inst : LT α] → [Decidable (x < y)] → [DecidableEq α] → Ordering",
  "constCategory": "Definition"},
 {"references": ["True", "imp_self", "Eq", "propext"],
  "name": "_private.Init.Core.0._proof_25",
  "constType": "∀ {a : Prop}, (a → a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HardarNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.InIntvl",
   "Prod.snd",
   "HardarNarasimhan.ConvexI.mk",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.ConvexI.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {S : Type} [inst_1 : CompleteLattice S] {I : { p // p.1 < p.2 }}\n  {μ : { p // p.1 < p.2 } → S},\n  (∀ (x y : ℒ),\n      HardarNarasimhan.InIntvl I x →\n        HardarNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩) →\n    HardarNarasimhan.ConvexI I μ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "eq_of_le_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["Not", "IsIrrefl", "IsIrrefl.irrefl"],
  "name": "irrefl",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop} [IsIrrefl α r] (a : α), ¬r a a",
  "constCategory": "Theorem"},
 {"references":
  ["WellFounded",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Set",
   "WellFounded.has_min",
   "Membership.mem",
   "And",
   "Exists.intro",
   "Iff.intro",
   "Set.instMembership",
   "Exists.casesOn",
   "Acc",
   "WellFounded.intro",
   "Iff",
   "Classical.byContradiction",
   "Acc.intro",
   "False",
   "And.casesOn",
   "setOf"],
  "name": "WellFounded.wellFounded_iff_has_min",
  "constType":
  "∀ {α : Type u_1} {r : α → α → Prop}, WellFounded r ↔ ∀ (s : Set α), s.Nonempty → ∃ m ∈ s, ∀ x ∈ s, ¬r x m",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "HardarNarasimhan.μmax._proof_2",
   "SupSet.sSup",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HardarNarasimhan.μmax",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "not_le_of_lt",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "And.intro",
   "Or.inl",
   "Or",
   "BoundedOrder.toOrderTop",
   "letFun",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HardarNarasimhan.SlopeLike",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.TotIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.SlopeLike.slopelike",
   "Bot.bot",
   "Or.casesOn",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HardarNarasimhan.impl.rmk4d15",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.SlopeLike μ →\n    ∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      μ ⟨(⊥, x), ⋯⟩ ≤ μ HardarNarasimhan.TotIntvl ∨ ¬μ HardarNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Exists.intro", "Eq", "forall_exists_index", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_12",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (∃ x, p x) → Prop}, (∀ (h : ∃ x, p x), q h) = ∀ (x : α) (h : p x), q ⋯",
  "constCategory": "Theorem"},
 {"references": ["LE", "Bot", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{α : Type u} → {inst : LE α} → [self : OrderBot α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "True",
   "AddZeroClass.toZero",
   "Eq.trans",
   "CommSemiring",
   "CommSemiring.toSemiring",
   "Mathlib.Tactic.Ring.cast_zero.match_1",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "OfNat.ofNat",
   "congrArg",
   "eq_self",
   "AddMonoidWithOne.toNatCast",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "MulZeroClass.toZero",
   "Nat.cast_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.cast_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R}, Mathlib.Meta.NormNum.IsNat a 0 → a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "PartialOrder.le_antisymm"],
  "name": "le_antisymm",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddSemigroup.toAdd",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.mk",
   "PosSMulStrictMono",
   "Real",
   "AddCommGroup.add_comm",
   "instHAdd",
   "LinearOrder",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "HardarNarasimhan.TotallyOrderedRealVectorSpace.rec",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "AddMonoid.toAddSemigroup",
   "LE.le"],
  "name": "HardarNarasimhan.TotallyOrderedRealVectorSpace.recOn",
  "constType":
  "{V : Type} →\n  {motive : HardarNarasimhan.TotallyOrderedRealVectorSpace V → Sort u} →\n    (t : HardarNarasimhan.TotallyOrderedRealVectorSpace V) →\n      ([toAddCommGroup : AddCommGroup V] →\n          [toModule : _root_.Module ℝ V] →\n            [toLinearOrder : LinearOrder V] →\n              [toPosSMulStrictMono : PosSMulStrictMono ℝ V] →\n                (elim_AddLeftMono : ∀ {y z : V} (x : V), y ≤ z → x + y ≤ x + z) →\n                  motive\n                    { toAddCommGroup := toAddCommGroup, toModule := toModule, toLinearOrder := toLinearOrder,\n                      toPosSMulStrictMono := toPosSMulStrictMono, elim_AddLeftMono := elim_AddLeftMono }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": ["_obj", "Prod.mk", "_neutral", "HardarNarasimhan.μA._rarg"],
  "name": "HardarNarasimhan.μAstar._rarg._cstage2",
  "constType": "_obj → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["_obj", "Set.instCompleteAtomicBooleanAlgebra", "_neutral"],
  "name":
  "HardarNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Not", "Classical.not_not", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_not_eq",
  "constType": "∀ (p : Prop), (¬¬p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "ne_comm",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LE.le.lt_iff_ne",
   "bot_le",
   "Bot.bot",
   "LT.lt",
   "Iff",
   "PartialOrder",
   "Ne",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderBot"],
  "name": "bot_lt_iff_ne_bot",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, ⊥ < a ↔ a ≠ ⊥",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "DecidableRel", "LE"],
  "name": "DecidableLE",
  "constType": "(α : Type u) → [LE α] → Type (max 0 u)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "LE.le",
   "LE",
   "Subtype.coe_le_coe",
   "Eq",
   "Subtype.le",
   "Subtype.val",
   "propext"],
  "name": "_private.Mathlib.Order.Basic.0._proof_36",
  "constType":
  "∀ {α : Type u_2} [inst : LE α] {p : α → Prop} {x y : Subtype p}, (↑x ≤ ↑y) = (x ≤ y)",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_and", "And", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_and_eq",
  "constType": "∀ (p q : Prop), (¬(p ∧ q)) = (p → ¬q)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Omega.LinearCombo",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["CommSemiring", "Semiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Set.mem_iUnion",
   "Exists",
   "Set",
   "Membership.mem",
   "Set.iUnion",
   "Eq",
   "propext",
   "Set.instMembership"],
  "name": "_private.Mathlib.Order.SetNotation.0._proof_3",
  "constType":
  "∀ {α : Type u} {ι : Sort v} {x : α} {s : ι → Set α}, (x ∈ ⋃ i, s i) = ∃ i, x ∈ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "Preorder.toLT",
   "GT.gt",
   "Preorder.toLE",
   "GE.ge",
   "lt_of_lt_of_le"],
  "name": "gt_of_ge_of_gt",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≥ b → b > c → a > c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.decLt",
   "LT.lt",
   "Lean.Omega.Constraint",
   "Bool",
   "Lean.Omega.Constraint.isImpossible.match_1",
   "Bool.false",
   "Int.instLTInt",
   "Decidable.decide",
   "Int"],
  "name": "Lean.Omega.Constraint.isImpossible",
  "constType": "Omega.Constraint → Bool",
  "constCategory": "Definition"},
 {"references": ["Exists", "Classical.choose"],
  "name": "Exists.choose",
  "constType": "{α : Sort u_1} → {p : α → Prop} → (∃ a, p a) → α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "HardarNarasimhan.WeakDescendingChainCondition",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HardarNarasimhan.WeakDescendingChainCondition.wdcc",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HardarNarasimhan.WeakDescendingChainCondition μ]\n  (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "CompleteSemilatticeInf"],
  "name": "CompleteSemilatticeInf.toInfSet",
  "constType": "{α : Type u_8} → [self : CompleteSemilatticeInf α] → InfSet α",
  "constCategory": "Definition"},
 {"references": ["Or.rec", "Or.inr", "Or.inl", "Or"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b), (∀ (h : a), motive ⋯) → (∀ (h : b), motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Preorder", "Preorder.toLT"],
  "name": "StrictAnti",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["DivInvMonoid.toInv",
   "DivInvOneMonoid.toDivInvMonoid",
   "InvOneClass",
   "DivInvOneMonoid.inv_one",
   "DivInvMonoid.toMonoid",
   "Monoid.toOne",
   "DivInvOneMonoid",
   "InvOneClass.mk"],
  "name": "DivInvOneMonoid.toInvOneClass",
  "constType": "{G : Type u_2} → [self : DivInvOneMonoid G] → InvOneClass G",
  "constCategory": "Definition"},
 {"references": ["Lattice", "DistribLattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{α : Type u_1} → [self : DistribLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HardarNarasimhan.Convex",
   "GE.ge",
   "Prod.fst",
   "HardarNarasimhan.IsAttained",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HardarNarasimhan.impl.prop2d8₁I",
   "Lattice.toSemilatticeInf",
   "HardarNarasimhan.in_TotIntvl",
   "HardarNarasimhan.TotIntvl",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HardarNarasimhan.μA",
   "HardarNarasimhan.impl.prop2d8₂I",
   "LT.lt",
   "Prod",
   "Max.max",
   "HardarNarasimhan.IsComparable",
   "Min.min",
   "Lattice",
   "Nontrivial",
   "SemilatticeSup.toMax",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "lt_sup_of_lt_left",
   "CompleteLattice"],
  "name": "HardarNarasimhan.proposition_2_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HardarNarasimhan.Convex μ →\n    ∀ (x y u : ℒ) (h : u < x ∧ u < y),\n      HardarNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩ ≥ HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ⊓ HardarNarasimhan.μA μ ⟨(u, y), ⋯⟩ ∧\n        (HardarNarasimhan.IsComparable (HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩) (HardarNarasimhan.μA μ ⟨(u, y), ⋯⟩) ∨\n            HardarNarasimhan.IsAttained μ ⟨(u, x ⊔ y), ⋯⟩ →\n          HardarNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩ ≥ HardarNarasimhan.μA μ ⟨(u, x), ⋯⟩ ∨\n            HardarNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩ ≥ HardarNarasimhan.μA μ ⟨(u, y), ⋯⟩)",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "AddMonoid"],
  "name": "SubNegMonoid.toAddMonoid",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → AddMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "HardarNarasimhan.μ_Admissible",
   "Subtype.val",
   "IsGreatest",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "HardarNarasimhan.InIntvl",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "HardarNarasimhan.impl.prop3d8₁'",
   "Or.inr",
   "Subtype",
   "HardarNarasimhan.impl.HNFil._proof_3",
   "HardarNarasimhan.Convex",
   "HardarNarasimhan.Convex_of_Convex_large",
   "lt_of_le_of_ne",
   "Prod.fst",
   "HardarNarasimhan.IsAttained",
   "Or.inl",
   "BoundedOrder.toOrderTop",
   "HardarNarasimhan.impl.HNFil",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_top",
   "HardarNarasimhan.StI",
   "HardarNarasimhan.TotIntvl",
   "LT.lt",
   "Or.casesOn",
   "IsTotal",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "HardarNarasimhan.μ_Admissible.μ_adm"],
  "name": "HardarNarasimhan.impl.HNFil._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HardarNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HardarNarasimhan.Convex μ] [h : HardarNarasimhan.μ_Admissible μ] (n : ℕ)\n  (htop : ¬HardarNarasimhan.impl.HNFil μ n = ⊤),\n  ∃ s, IsGreatest (HardarNarasimhan.StI μ ⟨(HardarNarasimhan.impl.HNFil μ n, ⊤), ⋯⟩) s",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HardarNarasimhan.instBoundedOrderInterval",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HardarNarasimhan.HardarNarasimhanFiltration.mk",
   "HardarNarasimhan.HardarNarasimhanFiltration",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Nat.find",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "HardarNarasimhan.instLatticeInterval",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "HardarNarasimhan.μA",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "HardarNarasimhan.Interval",
   "HardarNarasimhan.Resμ",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "HardarNarasimhan.Convex",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "HardarNarasimhan.μ_Admissible",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "HardarNarasimhan.HardarNarasimhanFiltration._proof_1",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "HardarNarasimhan.instNontrivialInterval",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HardarNarasimhan.Semistable",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HardarNarasimhan.μA_DescendingChainCondition",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HardarNarasimhan.HardarNarasimhanFiltration.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HardarNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HardarNarasimhan.Convex μ] →\n                    [h : HardarNarasimhan.μ_Admissible μ] →\n                      {motive : HardarNarasimhan.HardarNarasimhanFiltration μ → Sort u} →\n                        ((filtration : ℕ → ℒ) →\n                            (monotone : Monotone filtration) →\n                              (first_eq_bot : filtration 0 = ⊥) →\n                                (fin_len : ∃ n, filtration n = ⊤) →\n                                  (strict_mono :\n                                      ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                    (piecewise_semistable :\n                                        ∀ (i : ℕ) (h : i < Nat.find fin_len),\n                                          HardarNarasimhan.Semistable\n                                            (HardarNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)) →\n                                      (μA_pseudo_strict_anti :\n                                          ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n                                            ¬HardarNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n                                                HardarNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩) →\n                                        motive\n                                          { filtration := filtration, monotone := monotone,\n                                            first_eq_bot := first_eq_bot, fin_len := fin_len,\n                                            strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n                                            μA_pseudo_strict_anti := μA_pseudo_strict_anti }) →\n                          (t : HardarNarasimhan.HardarNarasimhanFiltration μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Iff.rfl",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Iff",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "HardarNarasimhan.Interval",
   "SemilatticeInf.toPartialOrder"],
  "name": "HardarNarasimhan.instLatticeInterval._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HardarNarasimhan.Interval z), ↑a ≤ ↑b ∧ ¬↑b ≤ ↑a ↔ ↑a ≤ ↑b ∧ ¬↑b ≤ ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint", "Lean.Omega.UpperBound", "Lean.Omega.LowerBound"],
  "name": "Lean.Omega.Constraint.mk",
  "constType": "Omega.LowerBound → Omega.UpperBound → Omega.Constraint",
  "constCategory": "Other"},
 {"references": ["SupSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toSupSet",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["Int.instAddCommGroup",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "inferInstance",
   "AddMonoid",
   "AddGroup.toSubNegMonoid",
   "Int"],
  "name": "Int.instAddMonoid",
  "constType": "AddMonoid ℤ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Max.max",
   "PartialOrder.toPreorder",
   "LT.lt.trans_le",
   "SemilatticeSup.toMax",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "SemilatticeSup",
   "le_sup_left"],
  "name": "lt_sup_of_lt_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c < a → c < a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "GT.gt",
   "GE.ge",
   "Eq.symm",
   "Int.instLEInt",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nat.lt_of_not_le",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Bool",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Option.some",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Int.instAdd",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HardarNarasimhan.impl.theorem3d10._proof_14",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (n : ℕ),\n  n + 1 > Nat.find hffin → ¬n + 1 ≥ Nat.find hffin → False",
  "constCategory": "Theorem"}]