[{"references": ["SMul", "SMulZeroClass", "Zero"],
  "name": "SMulZeroClass.toSMul",
  "constType":
  "{M : Type u_12} → {A : Type u_13} → {inst : Zero A} → [self : SMulZeroClass M A] → SMul M A",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "EmptyCollection.emptyCollection",
   "Set.instEmptyCollection",
   "Set.instHasSubset",
   "sdiff_eq_bot_iff",
   "HasSubset.Subset",
   "Iff",
   "SDiff.sdiff",
   "Eq",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Set.instBooleanAlgebra",
   "Set.instSDiff"],
  "name": "Set.diff_eq_empty",
  "constType": "∀ {α : Type u} {s t : Set α}, s \\ t = ∅ ↔ s ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.μmin",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.μmax._proof_2",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "SupSet",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μB._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references": ["Or.inr", "True", "Or", "eq_true", "Eq", "trivial"],
  "name": "or_true",
  "constType": "∀ (p : Prop), (p ∨ True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.S₁I._proof_1",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Ne",
   "Subtype.mk",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.S₂I",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        {S : Type} →\n          [CompleteLattice S] →\n            ({ p // p.1 < p.2 } → S) →\n              (I : { p // p.1 < p.2 }) → (x : ℒ) → HarderNarasimhan.InIntvl I x → (↑I).1 ≠ x → Prop",
  "constCategory": "Definition"},
 {"references": ["Min"],
  "name": "Min.mk",
  "constType": "{α : Type u} → (α → α → α) → Min α",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Nat",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (n : ℕ),\n  ¬HarderNarasimhan.impl.HNFil μ n = ⊤ → (HarderNarasimhan.impl.HNFil μ n, ⊤).1 < ⊤",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Real.instIsStrictOrderedRing",
   "Real",
   "Nonneg.linearOrderedCommGroupWithZero",
   "NNReal",
   "Real.field",
   "Real.linearOrder",
   "LinearOrderedCommGroupWithZero"],
  "name": "NNReal.instLinearOrderedCommGroupWithZero",
  "constType": "LinearOrderedCommGroupWithZero NNReal",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "congrFun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "SupSet.sSup",
   "Set",
   "CompleteLattice.toLattice",
   "LE.le",
   "Membership.mem",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteLattice",
   "Set.instMembership"],
  "name": "CompleteLattice.sSup_le",
  "constType":
  "∀ {α : Type u_8} [self : CompleteLattice α] (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "instOfNat",
   "instHAdd",
   "Int.instAdd",
   "LE.le",
   "Int.instLEInt",
   "Int.instLTInt",
   "OfNat.ofNat",
   "Int"],
  "name": "Int.add_one_le_of_lt",
  "constType": "∀ {a b : ℤ}, a < b → a + 1 ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "Nat.cast",
   "SubNegMonoid.zsmul_zero'._autoParam",
   "SubNegMonoid.zsmul_neg'._autoParam",
   "HSub.hSub",
   "Zero.toOfNat0",
   "Eq",
   "AddSemigroup.toAdd",
   "instNatCastInt",
   "SubNegMonoid.zsmul_succ'._autoParam",
   "Neg.neg",
   "instHAdd",
   "Int.negSucc",
   "Sub",
   "Neg",
   "AddMonoid",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "Nat",
   "instOfNat",
   "Nat.succ",
   "SubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "autoParam",
   "instHSub",
   "SubNegMonoid.sub_eq_add_neg._autoParam"],
  "name": "SubNegMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toAddMonoid : AddMonoid G] →\n    [toNeg : Neg G] →\n      [toSub : Sub G] →\n        autoParam (∀ (a b : G), a - b = a + -b) SubNegMonoid.sub_eq_add_neg._autoParam →\n          (zsmul : ℤ → G → G) →\n            autoParam (∀ (a : G), zsmul 0 a = 0) SubNegMonoid.zsmul_zero'._autoParam →\n              autoParam (∀ (n : ℕ) (a : G), zsmul (↑n.succ) a = zsmul (↑n) a + a) SubNegMonoid.zsmul_succ'._autoParam →\n                autoParam (∀ (n : ℕ) (a : G), zsmul (Int.negSucc n) a = -zsmul (↑n.succ) a)\n                    SubNegMonoid.zsmul_neg'._autoParam →\n                  SubNegMonoid G",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "OmegaCompletePartialOrder.toPartialOrder",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.μmin",
   "HarderNarasimhan.impl.rmk4d10₀",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.μmin_lt_μ_lt_μmax",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.μmin μ I ≤ μ I ∧ μ I ≤ HarderNarasimhan.μmax μ I",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "Lattice",
   "inferInstance",
   "Int.instLinearOrder",
   "Int"],
  "name": "instLatticeInt",
  "constType": "Lattice ℤ",
  "constCategory": "Definition"},
 {"references": ["CommMonoidWithZero", "LinearOrderedCommMonoidWithZero"],
  "name": "LinearOrderedCommMonoidWithZero.toCommMonoidWithZero",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommMonoidWithZero α] → CommMonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMonoid",
   "SetLike.instMembership",
   "Subtype",
   "Submodule.setLike",
   "Module",
   "Subtype.property",
   "Membership.mem",
   "Subtype.val",
   "Submodule",
   "Semiring"],
  "name": "Submodule.coe_mem",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  {p : Submodule R M} (x : ↥p), ↑x ∈ p",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.hasQuotient",
   "Submodule.Quotient.mk",
   "HasQuotient.Quotient",
   "IsScalarTower",
   "Module",
   "AddCommGroup.toAddGroup",
   "SMulZeroClass.toSMul",
   "Submodule",
   "SMul",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "DistribSMul.toSMulZeroClass",
   "rfl",
   "AddZeroClass.toZero",
   "DistribMulAction.toDistribSMul",
   "Submodule.Quotient.instSMul'",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Ring.toSemiring",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "HSMul.hSMul",
   "AddCommGroup.toAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "Ring"],
  "name": "Submodule.Quotient.mk_smul",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M) {S : Type u_3} [inst_3 : SMul S R] [inst_4 : SMul S M] [inst_5 : IsScalarTower S R M] (r : S)\n  (x : M), Submodule.Quotient.mk (r • x) = r • Submodule.Quotient.mk x",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Int.instLTInt",
   "HarderNarasimhan.JordanHolderFiltration",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "SizeOf",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Int.negOfNat",
   "Top.top",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "HarderNarasimhan.JordanHolderFiltration.rec",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "SizeOf.sizeOf",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "instSizeOfDefault",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration._sizeOf_1",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLinearOrder S} →\n              {μ : { p // p.1 < p.2 } → S} → [SizeOf ℒ] → [SizeOf S] → HarderNarasimhan.JordanHolderFiltration μ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup.le_sup_left",
   "Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "le_sup_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "True",
   "Eq.trans",
   "of_eq_true",
   "_private.Mathlib.Order.Interval.Set.Defs.0._proof_5",
   "Set",
   "LE.le",
   "Membership.mem",
   "Preorder.toLE",
   "Set.Iic",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "Set.instMembership"],
  "name": "Set.right_mem_Iic",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a : α}, a ∈ Set.Iic a",
  "constCategory": "Theorem"},
 {"references":
  ["contravariant_swap_add_of_contravariant_add",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "AddCommGroup.toAddGroup",
   "Preorder.toLT",
   "HMul.hMul",
   "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
   "GT.gt",
   "AddGroup.toSubtractionMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toNonAssocSemiring",
   "IsCancelAdd.toIsRightCancelAdd",
   "Ring.toAddGroupWithOne",
   "letFun",
   "PartialOrder",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "InvolutiveNeg.toNeg",
   "IsCancelAdd.toIsLeftCancelAdd",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Order.Group.Unbundled.Basic.0._proof_10",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddGroup.existsAddOfLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Ring.toSemiring",
   "id",
   "NegZeroClass.toZero",
   "instHMul",
   "Eq.mpr",
   "mul_pos_of_neg_of_neg",
   "covariant_swap_add_of_covariant_add",
   "AddMonoid.toAddZeroClass",
   "Eq.mp",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "neg_of_neg_pos",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "neg_mul",
   "IsOrderedCancelAddMonoid.toAddLeftReflectLT",
   "Zero.toOfNat0",
   "Eq",
   "Preorder.toLE",
   "IsStrictOrderedRing.toIsOrderedCancelAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Distrib.toMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "LT.lt",
   "Ring.toAddCommGroup",
   "NegZeroClass.toNeg",
   "AddGroupWithOne.toAddGroup",
   "HasDistribNeg.toInvolutiveNeg",
   "SubNegMonoid.toAddMonoid",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "neg_neg_of_pos",
   "IsStrictOrderedRing.toMulPosStrictMono",
   "_private.Init.Core.0._proof_39",
   "Ring"],
  "name": "Linarith.mul_neg",
  "constType":
  "∀ {α : Type u} [inst : Ring α] [inst_1 : PartialOrder α] [IsStrictOrderedRing α] {a b : α}, a < 0 → 0 < b → b * a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["le_refl",
   "OrderDual",
   "Preorder",
   "OrderDual.instLT",
   "LE.le",
   "Preorder.toLT",
   "OrderDual.instLE",
   "Preorder.mk",
   "Preorder.toLE",
   "lt_iff_le_not_le",
   "LE.le.trans"],
  "name": "OrderDual.instPreorder",
  "constType": "(α : Type u_5) → [Preorder α] → Preorder αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "Nat.succ",
   "Nat.le_of_succ_le_succ",
   "LE.le",
   "instLENat"],
  "name": "Nat.le_of_lt_succ",
  "constType": "∀ {m n : ℕ}, m < n.succ → m ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "instOfNat",
   "Int.negOfNat.match_1",
   "Int.negSucc",
   "OfNat.ofNat",
   "Unit",
   "Int"],
  "name": "Int.negOfNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Int.instSub", "Eq.refl", "HSub.hSub", "instHSub", "Eq.ndrec", "Eq", "Int"],
  "name": "Lean.Omega.Int.sub_congr",
  "constType": "∀ {a b c d : ℤ}, a = b → c = d → a - c = b - d",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "le_top",
   "PartialOrder.toPreorder",
   "Iff",
   "PartialOrder",
   "Preorder.toLT",
   "Top.top",
   "LE.le.lt_iff_ne",
   "OrderTop",
   "Ne",
   "Preorder.toLE",
   "OrderTop.toTop"],
  "name": "lt_top_iff_ne_top",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, a < ⊤ ↔ a ≠ ⊤",
  "constCategory": "Theorem"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Covariant M N μ r → CovariantClass M N μ r",
  "constCategory": "Other"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "_private.Init.SimpLemmas.0._proof_4",
   "Exists.intro",
   "Membership.mem.out",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Subtype.val",
   "_private.Mathlib.Order.CompleteLattice.Defs.0._proof_1",
   "_private.Mathlib.Data.Set.Operations.0._proof_5",
   "_private.Mathlib.Order.Basic.0._proof_34",
   "SupSet.sSup",
   "congrFun",
   "letFun",
   "_private.Init.PropLemmas.0._proof_43",
   "Function.instFunLikeEmbedding",
   "Eq.ndrec",
   "rfl",
   "Exists",
   "Exists.choose_spec",
   "ClosureOperator.IsClosed",
   "Function.Embedding",
   "Set.Iic",
   "Set.right_mem_Iic",
   "Set.instMembership",
   "implies_true",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff",
   "Eq.refl",
   "Classical.byContradiction",
   "lowerBounds",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "setOf",
   "RelEmbedding.toEmbedding",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "ClosureOperator",
   "ClosureOperator.instFunLike",
   "congr",
   "Subtype.property",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "Function.Embedding.mk",
   "Set",
   "Set.not_subset",
   "OrderEmbedding",
   "RelEmbedding.map_rel_iff'",
   "CompleteLattice",
   "And.casesOn",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Iff.mp",
   "RelEmbedding.instFunLike",
   "And.intro",
   "PartialOrder",
   "sSup_le",
   "forall_congr",
   "funext",
   "Eq.rec",
   "And.left",
   "RelEmbedding.mk",
   "And.right",
   "And",
   "Exists.casesOn",
   "Set.image",
   "HasSubset.Subset",
   "upperBounds",
   "id",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "Subtype.partialOrder",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "_private.Init.Core.0._proof_25",
   "Iff.intro",
   "congrArg",
   "_private.Init.PropLemmas.0._proof_12",
   "Set.mem_image_of_mem",
   "Subtype.le",
   "le_antisymm",
   "Set.instLE",
   "Not",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "_private.Mathlib.Order.Hom.Basic.0._proof_50",
   "True",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Mathlib.Tactic.PushNeg.not_and_eq",
   "Function.comp",
   "Exists.choose",
   "_private.Init.Data.Subtype.0._proof_1",
   "Set.instHasSubset",
   "le_antisymm_iff",
   "of_eq_true",
   "_private.Mathlib.Order.Interval.Set.Defs.0._proof_5",
   "LE.le",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet"],
  "name": "HarderNarasimhan.DedekindMacNeilleCompletion_minimality",
  "constType":
  "∀ {α : Type} [inst : PartialOrder α] {β : Type} [inst_1 : CompleteLattice β] (f : α ↪o β),\n  ∃ f', ⇑f = ⇑f' ∘ ⇑HarderNarasimhan.coe'",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Iff", "Iff.rfl", "GT.gt", "LT"],
  "name": "gt_iff_lt",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, x > y ↔ y < x",
  "constCategory": "Theorem"},
 {"references":
  ["PUnit.unit",
   "Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "OfNat.ofNat",
   "Unit"],
  "name": "HarderNarasimhan.impl.prop3d4₀func.match_1._cstage1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references": ["Decidable", "True", "trivial", "Decidable.isTrue"],
  "name": "instDecidableTrue",
  "constType": "Decidable True",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Rat.instLattice",
   "Ring.toNonAssocRing",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Preorder.toLT",
   "Rat.addGroup",
   "_private.Mathlib.Data.Real.Basic.0._proof_49",
   "HMul.hMul",
   "Real.instNontrivial",
   "Real.mk",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "IsStrictOrderedRing.of_mul_pos",
   "abs",
   "Rat.linearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Real",
   "Real.instIsOrderedAddMonoid",
   "CauSeq.Pos",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat",
   "id",
   "instHMul",
   "Eq.mpr",
   "Rat.instDivisionRing",
   "CauSeq.mul_pos",
   "_private.Mathlib.Data.Real.Basic.0._proof_38",
   "Real.instRing",
   "Real.ind_mk",
   "congrArg",
   "Rat.instIsStrictOrderedRing",
   "Real.instLT",
   "Zero.toOfNat0",
   "Eq",
   "Real.partialOrder",
   "Rat.instField",
   "Real.instMul",
   "IsStrictOrderedRing",
   "Distrib.toMul",
   "DivisionRing.toRing",
   "Real.instZeroLEOneClass",
   "Real.semiring",
   "OfNat.ofNat",
   "LT.lt",
   "Real.instZero",
   "MulZeroClass.toZero",
   "CauSeq.instMul",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "CauSeq"],
  "name": "Real.instIsStrictOrderedRing",
  "constType": "IsStrictOrderedRing ℝ",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "Eq.trans",
   "HarderNarasimhan.impl.prop4d20",
   "eq_true",
   "List.tfae_of_cycle",
   "List.instGetElem?NatLtLength",
   "Subtype.val",
   "GetElem?.getElem?",
   "HarderNarasimhan.NashEquilibrium",
   "Nat.instCharZero",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "instLTNat",
   "_private.Init.Data.Nat.Basic.0._proof_6",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Nat.instNontrivial",
   "Prod.snd",
   "lt_iff_le_not_le",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Eq.mpr",
   "HarderNarasimhan.Semistable",
   "AddMonoid.toAddZeroClass",
   "_private.Mathlib.Data.Nat.Cast.Order.Ring.0._proof_7",
   "List.getElem?_eq_getElem",
   "Or.inr",
   "HarderNarasimhan.WeakSlopeLike₁.mk",
   "HarderNarasimhan.impl.prop4d16₂",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "List",
   "GetElem.getElem",
   "Option.some",
   "HarderNarasimhan.impl.prop4d18₂",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instAddMonoidWithOne",
   "Prod.casesOn",
   "Or.inl",
   "Nat.instSemiring",
   "instOfNatNat",
   "congr",
   "HarderNarasimhan.WeakSlopeLike₁",
   "_private.Mathlib.Data.Nat.Cast.Order.Basic.0._proof_15",
   "Preorder.toLE",
   "Eq",
   "Nat.instAddMonoid",
   "IsStrictOrderedRing.toIsOrderedRing",
   "List.Chain.cons",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "List.Chain.nil",
   "HarderNarasimhan.instBoundedOrderInterval",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "OfNat.ofNat",
   "HarderNarasimhan.impl.prop4d16₁",
   "CompletelyDistribLattice.toCompleteLattice",
   "HAdd.hAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "Ne",
   "Nat.instIsStrictOrderedRing",
   "Subtype.casesOn",
   "CompleteLattice.toCompleteSemilatticeInf",
   "lt_trans",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Iff.mp",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Nat.instAddCommMonoid",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "And.intro",
   "Mathlib.Meta.NormNum.isNat_add",
   "Or",
   "List.TFAE",
   "CompleteLinearOrder",
   "Nat.instIsOrderedAddMonoid",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "AddZeroClass.toZero",
   "Nat.instPartialOrder",
   "And.right",
   "And",
   "IsOrderedAddMonoid.toAddLeftMono",
   "HarderNarasimhan.TotIntvl",
   "True.intro",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "zero_add",
   "Iff.mpr",
   "Option",
   "Nontrivial",
   "id",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "List.length",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "congrArg",
   "Subtype.prop",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Interval",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "Subtype.le",
   "Not",
   "List.nil",
   "List.instGetElemNatLtLength",
   "bot_lt_iff_ne_bot",
   "List.TFAE.out",
   "Lattice.toSemilatticeInf",
   "True",
   "_private.Mathlib.Order.Basic.0._proof_36",
   "instHAdd",
   "Or.casesOn",
   "LT.lt",
   "HarderNarasimhan.instNontrivialInterval",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "HarderNarasimhan.SlopeLike.slopelike"],
  "name": "HarderNarasimhan.impl.thm4d21",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ →\n    HarderNarasimhan.WeakAscendingChainCondition μ →\n      HarderNarasimhan.WeakDescendingChainCondition μ →\n        [HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl,\n              HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl,\n              HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl,\n              HarderNarasimhan.NashEquilibrium μ].TFAE ∧\n          (HarderNarasimhan.Semistable μ → HarderNarasimhan.NashEquilibrium μ) ∧\n            ((∀ (x : ℒ) (hx : x ≠ ⊥),\n                HarderNarasimhan.WeakAscendingChainCondition (HarderNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n              HarderNarasimhan.NashEquilibrium μ → HarderNarasimhan.Semistable μ)",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.le.refl", "LE.le", "instLENat"],
  "name": "Nat.le_refl",
  "constType": "∀ (n : ℕ), n ≤ n",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.fst",
  "constType": "{α : Type u} → {β : Type v} → α × β → α",
  "constCategory": "Definition"},
 {"references":
  ["Preorder",
   "Subtype",
   "DecidableLE",
   "Subtype.le",
   "Preorder.toLE",
   "Subtype.val"],
  "name": "Subtype.decidableLE",
  "constType":
  "{α : Type u_2} → [inst : Preorder α] → [h : DecidableLE α] → {p : α → Prop} → DecidableLE (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["NeZero",
   "instAddNat",
   "HAdd.hAdd",
   "Nat",
   "Zero.ofOfNat0",
   "instHAdd",
   "instOfNatNat",
   "Nat.succ_ne_zero",
   "NeZero.mk",
   "OfNat.ofNat"],
  "name": "Nat.instNeZeroSucc",
  "constType": "∀ {n : ℕ}, NeZero (n + 1)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsEmpty",
  "constType": "Sort u_4 → Prop",
  "constCategory": "Other"},
 {"references": ["Set", "Add", "AddSubsemigroup"],
  "name": "AddSubsemigroup.carrier",
  "constType": "{M : Type u_3} → [inst : Add M] → AddSubsemigroup M → Set M",
  "constCategory": "Definition"},
 {"references":
  ["Preorder",
   "Iff",
   "RelEmbedding.map_rel_iff",
   "LE.le",
   "Preorder.toLE",
   "OrderEmbedding",
   "DFunLike.coe",
   "RelEmbedding.instFunLike"],
  "name": "OrderEmbedding.le_iff_le",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α ↪o β) {a b : α}, f a ≤ f b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub",
   "Or.inr",
   "Nat.cast",
   "Eq.trans",
   "Iff.mp",
   "and_true",
   "congrArg",
   "And.intro",
   "Or",
   "Or.inl",
   "letFun",
   "Lean.Omega.Int.ofNat_sub_eq_zero",
   "HSub.hSub",
   "Eq",
   "instNatCastInt",
   "Not",
   "instLTNat",
   "True",
   "And",
   "Nat.decLe",
   "Nat.not_le",
   "OfNat.ofNat",
   "Int",
   "LT.lt",
   "eq_self",
   "Nat",
   "instSubNat",
   "instOfNat",
   "LE.le",
   "id",
   "Int.ofNat_sub",
   "Eq.mpr",
   "instHSub",
   "dite",
   "_private.Init.Core.0._proof_39",
   "instLENat"],
  "name": "Lean.Omega.Int.ofNat_sub_dichotomy",
  "constType": "∀ {a b : ℕ}, b ≤ a ∧ ↑(a - b) = ↑a - ↑b ∨ a < b ∧ ↑(a - b) = 0",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg",
   "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Module",
   "LinearMap.toAddHom",
   "LinearEquiv.toLinearMap",
   "LinearEquiv.instEquivLike._proof_6",
   "LinearEquiv",
   "LinearEquiv.invFun",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "EquivLike.mk",
   "AddHom.toFun",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "LinearEquiv.right_inv",
   "RingHomInvPair",
   "EquivLike",
   "LinearEquiv.left_inv",
   "Semiring"],
  "name": "LinearEquiv.instEquivLike",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_5} →\n    {M : Type u_6} →\n      {M₂ : Type u_8} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring S] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                [inst_4 : _root_.Module R M] →\n                  [inst_5 : _root_.Module S M₂] →\n                    {σ : R →+* S} →\n                      {σ' : S →+* R} →\n                        [inst_6 : RingHomInvPair σ σ'] → [inst_7 : RingHomInvPair σ' σ] → EquivLike (M ≃ₛₗ[σ] M₂) M M₂",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.SlopeLike",
   "Or.inr",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.WeakSlopeLike₁.mk",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "Or.inl",
   "Or",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Or.casesOn",
   "le_of_lt",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "HarderNarasimhan.SlopeLike.slopelike"],
  "name": "HarderNarasimhan.impl.instWeakSlopeLike₁OfSlopeLike",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.SlopeLike μ],\n  HarderNarasimhan.WeakSlopeLike₁ μ",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA_DescendingChainCondition",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "SizeOf",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.HarderNarasimhanFiltration._sizeOf_1",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "SizeOf.mk",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration._sizeOf_inst",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              (μ : { p // p.1 < p.2 } → S) →\n                {hμ : HarderNarasimhan.μA_DescendingChainCondition μ} →\n                  {hμcvx : HarderNarasimhan.Convex μ} →\n                    {h : HarderNarasimhan.μ_Admissible μ} →\n                      [SizeOf ℒ] → [SizeOf S] → SizeOf (HarderNarasimhan.HarderNarasimhanFiltration μ)",
  "constCategory": "Definition"},
 {"references": ["NatCast.mk", "Nat", "NatCast", "Int.ofNat", "Int"],
  "name": "instNatCastInt",
  "constType": "NatCast ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "HarderNarasimhan.Affine.rec",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.Affine.mk",
   "HarderNarasimhan.Affine",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HarderNarasimhan.Affine.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.Affine μ → Sort u} →\n                (t : HarderNarasimhan.Affine μ) →\n                  ((affine : ∀ (a b : ℒ) (h : ¬a ≤ b), μ ⟨(a ⊓ b, a), ⋯⟩ = μ ⟨(b, a ⊔ b), ⋯⟩) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "True",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "SemilatticeInf",
   "eq_self",
   "of_eq_true",
   "Min.min",
   "inf_of_le_left",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_idem",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] (a : α), a ⊓ a = a",
  "constCategory": "Theorem"},
 {"references":
  ["IsOrderedAddMonoid.mk",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "instHAdd",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "IsOrderedAddMonoid",
   "Int.add_le_add_left",
   "LE.le",
   "id",
   "Int.instAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Eq.mpr",
   "Eq",
   "Preorder.toLE",
   "add_comm",
   "SemilatticeInf.toPartialOrder",
   "instLatticeInt"],
  "name": "Int.instIsOrderedAddMonoid",
  "constType": "IsOrderedAddMonoid ℤ",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.univ",
   "Finset.map",
   "Finset",
   "Subtype",
   "Set",
   "Membership.mem",
   "Function.Embedding.subtype",
   "Fintype",
   "Set.Elem",
   "Set.instMembership"],
  "name": "Set.toFinset",
  "constType": "{α : Type u_1} → (s : Set α) → [Fintype ↑s] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.μ_Admissible.μ_adm",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.μ_Admissible μ],\n  (IsTotal S fun x1 x2 => x1 ≤ x2) ∨ ∀ (I : { p // p.1 < p.2 }), HarderNarasimhan.IsAttained μ I",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace", "AddCommGroup"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
  "constType":
  "{V : Type} → [self : HarderNarasimhan.TotallyOrderedRealVectorSpace V] → AddCommGroup V",
  "constCategory": "Definition"},
 {"references": ["CompletelyDistribLattice", "CompleteLattice"],
  "name": "CompletelyDistribLattice.toCompleteLattice",
  "constType":
  "{α : Type u} → [self : CompletelyDistribLattice α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "LinearOrder.toOrd",
   "LinearOrder.toDecidableEq",
   "LinearOrder.toDecidableLT",
   "PartialOrder.toPreorder",
   "Ord.compare",
   "Preorder.toLT",
   "LinearOrder",
   "compareOfLessAndEq",
   "Ordering",
   "Eq"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrder α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "HarderNarasimhan.impl.prop2d6₁I",
   "Preorder.toLT",
   "GE.ge",
   "HarderNarasimhan.impl.prop2d6₀",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq",
   "Eq.rec",
   "Preorder.toLE",
   "le_antisymm",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "inf_eq_right",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Min.min",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.μA",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop2d6₂I₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HarderNarasimhan.InIntvl I y →\n            ∀ (z : ℒ),\n              HarderNarasimhan.InIntvl I z →\n                ∀ (h : x < y ∧ y < z),\n                  HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≥ HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ →\n                    HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ = HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "SetLike.instMembership",
   "ZeroMemClass.coe_eq_zero",
   "Membership.mem",
   "Subtype.val",
   "OfNat.ofNat",
   "ZeroMemClass",
   "SetLike",
   "Zero.toOfNat0",
   "ZeroMemClass.zero",
   "Zero",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Algebra.Group.Submonoid.Defs.0._proof_47",
  "constType":
  "∀ {A : Type u_3} {M₁ : Type u_4} [inst : SetLike A M₁] [inst_1 : Zero M₁] [hA : ZeroMemClass A M₁] {S' : A} {x : ↥S'},\n  (↑x = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "EmbeddingLike.apply_eq_iff_eq",
   "EmbeddingLike",
   "Eq",
   "DFunLike.coe",
   "propext"],
  "name": "_private.Mathlib.Data.FunLike.Embedding.0._proof_1",
  "constType":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [inst : FunLike F α β] [i : EmbeddingLike F α β] (f : F) {x y : α},\n  (f x = f y) = (x = y)",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.mk''",
   "AddSubgroup",
   "HasQuotient.Quotient",
   "QuotientAddGroup.instHasQuotientAddSubgroup",
   "QuotientAddGroup.leftRel",
   "AddGroup"],
  "name": "QuotientAddGroup.mk",
  "constType":
  "{α : Type u_1} → [inst : AddGroup α] → {s : AddSubgroup α} → α → α ⧸ s",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "SemilatticeSup.mk",
  "constType":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    (sup : α → α → α) →\n      (∀ (a b : α), a ≤ sup a b) →\n        (∀ (a b : α), b ≤ sup a b) → (∀ (a b c : α), a ≤ c → b ≤ c → sup a b ≤ c) → SemilatticeSup α",
  "constCategory": "Other"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "PosSMulStrictMono",
   "Real",
   "AddCommGroup.add_comm",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "Real.semiring",
   "LinearOrder.toPartialOrder",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toModule",
   "MulAction.toSMul",
   "Module.toDistribMulAction",
   "Real.instZero",
   "SubNegMonoid.toAddMonoid",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.toPosSMulStrictMono",
  "constType":
  "∀ {V : Type} [self : HarderNarasimhan.TotallyOrderedRealVectorSpace V], PosSMulStrictMono ℝ V",
  "constCategory": "Theorem"},
 {"references": ["Lattice", "GeneralizedHeytingAlgebra"],
  "name": "GeneralizedHeytingAlgebra.toLattice",
  "constType":
  "{α : Type u_4} → [self : GeneralizedHeytingAlgebra α] → Lattice α",
  "constCategory": "Definition"},
 {"references": ["BEq.mk", "BEq", "DecidableEq", "Eq", "Decidable.decide"],
  "name": "instBEqOfDecidableEq",
  "constType": "{α : Type u_1} → [DecidableEq α] → BEq α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.Affine.mk",
   "HarderNarasimhan.Affine",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HarderNarasimhan.Affine.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.Affine μ → Sort u} →\n                ((affine : ∀ (a b : ℒ) (h : ¬a ≤ b), μ ⟨(a ⊓ b, a), ⋯⟩ = μ ⟨(b, a ⊔ b), ⋯⟩) → motive ⋯) →\n                  (t : HarderNarasimhan.Affine μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "CommRing.toCommSemiring",
   "IsNoetherianRing",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.instLinearOrderS₀",
   "CommSemiring.toSemiring",
   "LE",
   "HarderNarasimhan.S₀",
   "Preorder.toLE",
   "CommRing"],
  "name": "HarderNarasimhan.instLES₀",
  "constType":
  "{R : Type} → [inst : CommRing R] → [inst_1 : IsNoetherianRing R] → LE (HarderNarasimhan.S₀ R)",
  "constCategory": "Definition"},
 {"references": ["eq_false", "And", "False", "Eq", "And.left"],
  "name": "false_and",
  "constType": "∀ (p : Prop), (False ∧ p) = False",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.μBstar",
   "Nontrivial",
   "Lattice",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.NashEquilibrium.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  HarderNarasimhan.μAstar μ = HarderNarasimhan.μBstar μ → HarderNarasimhan.NashEquilibrium μ",
  "constCategory": "Other"},
 {"references":
  ["LT.lt",
   "Prod",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "Subtype",
   "Lattice",
   "Preorder.toLT",
   "Prod.snd",
   "CompleteLattice",
   "Prod.fst",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.ConvexI",
  "constType":
  "{ℒ : Type} →\n  [inst : Lattice ℒ] → {S : Type} → [CompleteLattice S] → { p // p.1 < p.2 } → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toZero",
   "neg_eq_zero_sub",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "OfNat.ofNat",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid",
   "SubNegMonoid.toSub",
   "Eq.symm",
   "HSub.hSub",
   "Zero.toOfNat0",
   "Eq",
   "instHSub",
   "AddMonoid.toAddZeroClass"],
  "name": "zero_sub",
  "constType": "∀ {G : Type u_1} [inst : SubNegMonoid G] (a : G), 0 - a = -a",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LowerAdjoint"],
  "name": "LowerAdjoint.toFun",
  "constType":
  "{α : Type u_1} → {β : Type u_4} → [inst : Preorder α] → [inst_1 : Preorder β] → {u : β → α} → LowerAdjoint u → α → β",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LT"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u_2} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHom.mk",
   "RingHom",
   "CommSemiring",
   "Mul.toSMul",
   "MulZeroOneClass.toMulOneClass",
   "SMul",
   "Semiring.toNonAssocSemiring",
   "Algebra.id._proof_30",
   "RingHom.id",
   "MulOneClass.toOne",
   "Algebra.id._proof_28",
   "NonAssocSemiring.toMulZeroOneClass",
   "Algebra.id._proof_26",
   "NonUnitalNonAssocSemiring.toDistrib",
   "CommSemiring.toSemiring",
   "Algebra.id._proof_29",
   "Distrib.toMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Algebra.algebraMap",
   "Algebra",
   "OneHom.mk",
   "RingHom.mk",
   "Algebra.id._proof_27",
   "Algebra.mk",
   "Algebra.id._proof_31",
   "RingHom.toAlgebra"],
  "name": "Algebra.id",
  "constType": "(R : Type u) → [inst : CommSemiring R] → Algebra R R",
  "constCategory": "Definition"},
 {"references":
  ["contravariant_le_iff_contravariant_lt_and_eq",
   "ContravariantClass.mk",
   "PartialOrder.toPreorder",
   "Add",
   "instHAdd",
   "And",
   "Preorder.toLT",
   "Contravariant",
   "ContravariantClass.elim",
   "Function.swap",
   "AddRightReflectLT",
   "LT.lt",
   "HAdd.hAdd",
   "And.intro",
   "add_right_cancel",
   "PartialOrder",
   "Iff.mpr",
   "IsRightCancelAdd",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "AddRightReflectLE"],
  "name": "IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [IsRightCancelAdd N] [inst_2 : PartialOrder N] [AddRightReflectLT N],\n  AddRightReflectLE N",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "OrderEmbedding.le_iff_le",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "OrderEmbedding",
   "DFunLike.coe",
   "RelEmbedding.instFunLike",
   "propext"],
  "name": "HarderNarasimhan.impl.noname._proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α ↪o β) {a b : α}, (f a ≤ f b) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["PrimeSpectrum",
   "CommRing.toCommSemiring",
   "Ideal.IsPrime",
   "CommSemiring.toSemiring",
   "PrimeSpectrum.asIdeal",
   "CommRing",
   "PrimeSpectrum.isPrime"],
  "name": "Module.support._proof_1",
  "constType":
  "∀ (R : Type u_1) [inst : CommRing R] (p : PrimeSpectrum R), p.asIdeal.IsPrime",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "IsNoetherian",
   "AddCommMonoid",
   "PartialOrder.toPreorder",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "IsNoetherian.wellFoundedGT",
   "Submodule.completeLattice",
   "Preorder.toLT",
   "WellFoundedGT",
   "Submodule",
   "Semiring"],
  "name": "wellFoundedGT",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  [h : IsNoetherian R M], WellFoundedGT (Submodule R M)",
  "constCategory": "Theorem"},
 {"references": ["IsEmpty", "isEmptyElim"],
  "name": "IsEmpty.elim",
  "constType": "{α : Sort u} → IsEmpty α → {p : α → Sort u_4} → (a : α) → p a",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "CommSemiring",
   "CommSemiring.toSemiring",
   "OmegaCompletePartialOrder.toPartialOrder",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum",
   "Semiring.toNonAssocSemiring",
   "Ideal",
   "PartialOrder",
   "PrimeSpectrum.ext",
   "Submodule.completeLattice",
   "PrimeSpectrum.asIdeal",
   "PartialOrder.lift",
   "Semiring.toModule"],
  "name": "PrimeSpectrum.instPartialOrder",
  "constType":
  "{R : Type u} → [inst : CommSemiring R] → PartialOrder (PrimeSpectrum R)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toModule._proof_8",
   "Module",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "DistribMulAction.mk",
   "Semiring.toMonoidWithZero",
   "MonoidWithZero.toMulZeroOneClass",
   "AddCommMonoid.toAddMonoid",
   "Semiring.toModule._proof_7",
   "MonoidWithZero.toMulActionWithZero",
   "Module.mk",
   "Semiring.toNonAssocSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toZero",
   "MonoidWithZero.toMonoid",
   "Semiring.toModule._proof_6",
   "Semiring.toModule._proof_9",
   "Semiring",
   "MulActionWithZero.toMulAction"],
  "name": "Semiring.toModule",
  "constType": "{R : Type u_1} → [inst : Semiring R] → _root_.Module R R",
  "constCategory": "Definition"},
 {"references":
  ["PUnit.unit",
   "Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "OfNat.ofNat",
   "Unit"],
  "name": "HarderNarasimhan.impl.HNFil.match_1._cstage1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "CommRing.toCommSemiring",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "Nat.instPreorder",
   "IsNoetherianRing",
   "Nat",
   "Monotone",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.CoprimaryFiltration",
   "Nontrivial",
   "Submodule.completeLattice",
   "AddCommGroup.toAddCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.monotone",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (self : HarderNarasimhan.CoprimaryFiltration R M), Monotone self.filtration",
  "constCategory": "Theorem"},
 {"references":
  ["le_rfl",
   "Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "sup_le_sup",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "sup_le_sup_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → ∀ (c : α), c ⊔ a ≤ c ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "LE.le",
   "Lattice",
   "SemilatticeSup.toPartialOrder",
   "Lattice.inf",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_right",
  "constType":
  "∀ {α : Type u} [self : Lattice α] (a b : α), Lattice.inf a b ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Add",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": ["Nat", "Int"],
  "name": "Int.negSucc",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "LinearOrder.max_def._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nonempty",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["implies_congr",
   "instAddNat",
   "HarderNarasimhan.impl.prop3d4₀func._proof_8",
   "PartialOrder.toPreorder",
   "Decidable",
   "Eq.trans",
   "WellFounded.has_min",
   "Prod.mk",
   "Subsingleton.elim",
   "Eq.mpr_not",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "eq_true",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "False.elim",
   "letFun",
   "forall_congr",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop3d4₀func._proof_4",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HarderNarasimhan.impl.ℒₛ._proof_1",
   "of_eq_false",
   "Exists",
   "Exists.choose_spec",
   "HarderNarasimhan.impl.ℒₛ",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.impl.prop3d4₀func_helper",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "eq_false",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "Subtype",
   "instDecidableTrue",
   "Eq.mp",
   "lt_of_le_of_ne",
   "dite_congr",
   "congrArg",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "IsWellFounded.wf",
   "not_true_eq_false",
   "WellFoundedGT",
   "instDecidableFalse",
   "instSubsingletonDecidable",
   "dite_cond_eq_false",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "Set",
   "HarderNarasimhan.impl.prop3d4₀func",
   "Exists.choose",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "dite_cond_eq_true",
   "of_eq_true",
   "HarderNarasimhan.μA",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "_private.Init.Core.0._proof_39",
   "HarderNarasimhan.impl.ℒₛ._proof_2",
   "CompleteLattice",
   "HarderNarasimhan.impl.prop3d4₀func._proof_7"],
  "name": "HarderNarasimhan.impl.prop3d4₀func_strict_decreasing",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ),\n  (↑I).1 ≠ ↑(HarderNarasimhan.impl.prop3d4₀func μ I i) →\n    ↑(HarderNarasimhan.impl.prop3d4₀func μ I i) > ↑(HarderNarasimhan.impl.prop3d4₀func μ I (i + 1))",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA_DescendingChainCondition",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              (μ : { p // p.1 < p.2 } → S) →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] → [h : HarderNarasimhan.μ_Admissible μ] → Type",
  "constCategory": "Other"},
 {"references":
  ["Set.instHasSubset",
   "Or.inr",
   "HasSubset.Subset",
   "Set",
   "Membership.mem",
   "Set.instUnion",
   "Union.union",
   "Set.instMembership"],
  "name": "Set.subset_union_right",
  "constType": "∀ {α : Type u} {s t : Set α}, t ⊆ s ∪ t",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "AddMonoid.nsmul_zero._autoParam",
   "instHAdd",
   "AddMonoid",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "AddSemigroup",
   "Nat",
   "instOfNatNat",
   "Zero.toOfNat0",
   "autoParam",
   "Zero",
   "Eq",
   "AddMonoid.nsmul_succ._autoParam",
   "AddSemigroup.toAdd"],
  "name": "AddMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddSemigroup : AddSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) AddMonoid.nsmul_zero._autoParam →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = nsmul n x + x) AddMonoid.nsmul_succ._autoParam →\n                AddMonoid M",
  "constCategory": "Other"},
 {"references": ["AddGroup"],
  "name": "AddSubgroup",
  "constType": "(G : Type u_3) → [AddGroup G] → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Iff.trans",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "_private.Mathlib.Order.Lattice.0._proof_9",
   "SemilatticeSup.toPartialOrder",
   "And",
   "and_true",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "Max.max",
   "le_antisymm_iff",
   "iff_self",
   "_private.Mathlib.Order.Lattice.0._proof_7",
   "of_eq_true",
   "congr",
   "Iff",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Eq",
   "Preorder.toLE"],
  "name": "sup_of_le_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a → a ⊔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "WellFounded.has_min",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "bot_le",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "Monotone",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "CompleteLattice.toTop",
   "Eq.rec",
   "Set.mem_range_self",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "eq_of_ge_of_not_gt",
   "Exists",
   "Exists.choose_spec",
   "Real",
   "And.right",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "Set.instMembership",
   "Prod",
   "IsWellOrder",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "CompleteLattice.toBoundedOrder",
   "setOf",
   "Subtype.lt",
   "Subtype",
   "IsWellOrder.toIsWellFounded",
   "Set.range",
   "Prod.fst",
   "Nat.instPreorder",
   "Set.mem_setOf",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "IsWellFounded.wf",
   "Real.instLT",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Real.partialOrder",
   "Not",
   "Set.Nonempty",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Set",
   "instHAdd",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "le_of_lt",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.rmk4d4",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (r : ℒ → ℝ),\n  Monotone r →\n    (IsWellOrder ↑(Set.range r) fun x1 x2 => x1 < x2) →\n      (∀ (z : { p // p.1 < p.2 }), r (↑z).1 = r (↑z).2 → μ z = ⊤) →\n        ∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder", "LE.le", "le_of_eq", "Eq.symm", "Preorder.toLE", "Eq"],
  "name": "ge_of_eq",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] {a b : α}, a = b → b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "HarderNarasimhan.impl.JHFil._proof_2",
   "CompleteLattice.toTop",
   "CompleteLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "HarderNarasimhan.Semistable",
   "setOf",
   "Subtype",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "IsWellFounded.wf",
   "WellFoundedGT",
   "OrderBot.toBot",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Set",
   "instHAdd",
   "OfNat.ofNat",
   "LT.lt",
   "CompletelyDistribLattice.toCompleteLattice",
   "HAdd.hAdd",
   "StrictAnti",
   "HarderNarasimhan.impl.JHFil",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.JHFil._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hacc : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤)\n  (hμsl : HarderNarasimhan.SlopeLike μ) (hst : HarderNarasimhan.Semistable μ)\n  (hdc : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) (n : ℕ),\n  {p | ∃ (h : ⊥ < p), p < HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc n ∧ μ ⟨(⊥, p), h⟩ = μ ⟨(⊥, ⊤), ⋯⟩}.Nonempty →\n    ∃ a ∈ {p | ∃ (h : ⊥ < p), p < HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc n ∧ μ ⟨(⊥, p), h⟩ = μ ⟨(⊥, ⊤), ⋯⟩},\n      ∀ x ∈ {p | ∃ (h : ⊥ < p), p < HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc n ∧ μ ⟨(⊥, p), h⟩ = μ ⟨(⊥, ⊤), ⋯⟩},\n        ¬x > a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeSup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "SemilatticeSup.le_sup_right",
  "constType":
  "∀ {α : Type u} [self : SemilatticeSup α] (a b : α), b ≤ SemilatticeSup.sup a b",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toRing",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "instHMul",
   "HMul.hMul",
   "Eq",
   "CommRing",
   "Semiring.toNonUnitalSemiring",
   "Ring.toSemiring"],
  "name": "CommRing.mul_comm",
  "constType": "∀ {α : Type u} [self : CommRing α] (a b : α), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "instLTNat",
   "Decidable.byContradiction",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "Nat.lt_of_lt_pred._proof_9",
   "HSub.hSub",
   "instHSub",
   "OfNat.ofNat",
   "Nat.decLt"],
  "name": "Nat.lt_of_lt_pred",
  "constType": "∀ {m n : ℕ}, m < n - 1 → m < n",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.SlopeLike",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.SlopeLike.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x y z : ℒ) (h : x < y ∧ y < z),\n      (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n        (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n          (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n            (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) →\n    HarderNarasimhan.SlopeLike μ",
  "constCategory": "Other"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "Or",
   "LE.le",
   "LinearOrder",
   "Preorder.toLE",
   "LinearOrder.le_total"],
  "name": "le_total",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["ConditionallyCompleteLinearOrderBot", "ConditionallyCompleteLinearOrder"],
  "name":
  "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLinearOrderBot α] → ConditionallyCompleteLinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Set",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.S₂I",
   "Subtype.val",
   "HarderNarasimhan.S₁I",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.InIntvl",
   "Nontrivial",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "CompleteLattice",
   "setOf",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.StI",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Set ℒ",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "Bot.bot",
   "OfNat.ofNat",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "Submodule.instBot",
   "Submodule.mem_bot",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "_private.Mathlib.Algebra.Module.Submodule.Lattice.0._proof_4",
  "constType":
  "∀ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  (x ∈ ⊥) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "LE.le",
   "Lattice",
   "SemilatticeSup.toPartialOrder",
   "Lattice.inf",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_left",
  "constType":
  "∀ {α : Type u} [self : Lattice α] (a b : α), Lattice.inf a b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["SMulMemClass",
   "Submodule.toSubMulAction",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "Submodule",
   "SMulMemClass.mk",
   "Module.toDistribMulAction",
   "AddCommMonoid",
   "SubMulAction.smul_mem'",
   "Submodule.setLike",
   "MonoidWithZero.toMonoid",
   "Semiring",
   "AddMonoid.toAddZeroClass",
   "DistribSMul.toSMulZeroClass"],
  "name": "Submodule.smulMemClass",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M],\n  SMulMemClass (Submodule R M) R M",
  "constCategory": "Theorem"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toPartialOrder",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_33",
   "Lattice.inf",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "GeneralizedHeytingAlgebra.toHImp",
   "instDistribLatticeOfLinearOrder",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Preorder.toLE",
   "SemilatticeInf.mk",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_34",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Lattice.toSemilatticeInf",
   "LinearOrder",
   "DistribLattice.toLattice",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_35",
   "Min.min",
   "Iff",
   "LE.le",
   "HImp.himp",
   "CompleteLattice.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_42",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b c : HarderNarasimhan.DedekindMacNeilleCompletion α), a ≤ b ⇨ c ↔ min a b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "instAddNat",
   "Real.instPreorder",
   "AddGroup.mk",
   "SubNegMonoid.zsmul_zero'._autoParam",
   "Preorder.toLT",
   "SubNegMonoid.zsmul_neg'._autoParam",
   "HMul.hMul",
   "Min.mk",
   "Semiring.toNonAssocSemiring",
   "AddCommGroup.mk",
   "Or",
   "Sub.mk",
   "HSub.hSub",
   "LT.mk",
   "SubNegMonoid.mk",
   "MulOneClass.toMul",
   "Preorder.lt_iff_le_not_le._autoParam",
   "PosSMulStrictMono.mk",
   "SubNegMonoid.zsmul_succ'._autoParam",
   "Real",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "AddCommMonoid.mk",
   "Int.negSucc",
   "LinearOrder.max_def._autoParam",
   "Ordering",
   "Max.mk",
   "AddMonoid.mk",
   "Nat",
   "instOfNat",
   "Zero.mk",
   "Iff",
   "HSMul.hSMul",
   "Add.mk",
   "instHMul",
   "autoParam",
   "Preorder.mk",
   "SubNegMonoid.sub_eq_add_neg._autoParam",
   "AddMonoid.toAddZeroClass",
   "Nat.cast",
   "AddMonoid.nsmul_zero._autoParam",
   "DecidableEq",
   "compareOfLessAndEq",
   "LinearOrder.min_def._autoParam",
   "PartialOrder.mk",
   "Module.mk",
   "instOfNatNat",
   "Ord.mk",
   "MulOneClass.toOne",
   "Monoid.toMulOneClass",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Eq",
   "AddSemigroup.mk",
   "instNatCastInt",
   "Not",
   "SMul.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq._autoParam",
   "Distrib.toAdd",
   "DecidableLE",
   "ite",
   "DecidableLT",
   "instHAdd",
   "DistribMulAction.mk",
   "Semiring.toMonoidWithZero",
   "LinearOrder.mk",
   "OfNat.ofNat",
   "Real.semiring",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.mk",
   "Int",
   "LT.lt",
   "HAdd.hAdd",
   "Real.instZero",
   "AddCommMonoid.toAddCommSemigroup",
   "One.toOfNat1",
   "MulZeroClass.toZero",
   "Nat.succ",
   "LE.mk",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHSub",
   "Neg.mk",
   "MulAction.mk",
   "AddMonoid.nsmul_succ._autoParam"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.mk._flat_ctor",
  "constType":
  "{V : Type} →\n  (add : V → V → V) →\n    (add_assoc : ∀ (a b c : V), a + b + c = a + (b + c)) →\n      (zero : V) →\n        (zero_add : ∀ (a : V), 0 + a = a) →\n          (add_zero : ∀ (a : V), a + 0 = a) →\n            (nsmul : ℕ → V → V) →\n              (nsmul_zero : autoParam (∀ (x : V), nsmul 0 x = 0) AddMonoid.nsmul_zero._autoParam) →\n                (nsmul_succ :\n                    autoParam (∀ (n : ℕ) (x : V), nsmul (n + 1) x = nsmul n x + x) AddMonoid.nsmul_succ._autoParam) →\n                  (neg : V → V) →\n                    (sub : V → V → V) →\n                      autoParam (∀ (a b : V), a - b = a + neg b) SubNegMonoid.sub_eq_add_neg._autoParam →\n                        (zsmul : ℤ → V → V) →\n                          autoParam (∀ (a : V), zsmul 0 a = 0) SubNegMonoid.zsmul_zero'._autoParam →\n                            autoParam (∀ (n : ℕ) (a : V), zsmul (↑n.succ) a = zsmul (↑n) a + a)\n                                SubNegMonoid.zsmul_succ'._autoParam →\n                              autoParam (∀ (n : ℕ) (a : V), zsmul (Int.negSucc n) a = neg (zsmul (↑n.succ) a))\n                                  SubNegMonoid.zsmul_neg'._autoParam →\n                                (∀ (a : V), neg a + a = 0) →\n                                  (add_comm : ∀ (a b : V), a + b = b + a) →\n                                    (smul : ℝ → V → V) →\n                                      (∀ (b : V), 1 • b = b) →\n                                        (∀ (x y : ℝ) (b : V), (x * y) • b = x • y • b) →\n                                          (∀ (a : ℝ), a • 0 = 0) →\n                                            (∀ (a : ℝ) (x y : V), a • (x + y) = a • x + a • y) →\n                                              (∀ (r s : ℝ) (x : V), (r + s) • x = r • x + s • x) →\n                                                (∀ (x : V), 0 • x = 0) →\n                                                  (le lt : V → V → Prop) →\n                                                    (∀ (a : V), le a a) →\n                                                      (∀ (a b c : V), le a b → le b c → le a c) →\n                                                        autoParam (∀ (a b : V), lt a b ↔ le a b ∧ ¬le b a)\n                                                            Preorder.lt_iff_le_not_le._autoParam →\n                                                          (∀ (a b : V), le a b → le b a → a = b) →\n                                                            (min max : V → V → V) →\n                                                              (compare : V → V → Ordering) →\n                                                                (∀ (a b : V), le a b ∨ le b a) →\n                                                                  (toDecidableLE : DecidableLE V) →\n                                                                    (toDecidableEq : DecidableEq V) →\n                                                                      (toDecidableLT : DecidableLT V) →\n                                                                        autoParam\n                                                                            (∀ (a b : V),\n                                                                              min a b = if le a b then a else b)\n                                                                            LinearOrder.min_def._autoParam →\n                                                                          autoParam\n                                                                              (∀ (a b : V),\n                                                                                max a b = if le a b then b else a)\n                                                                              LinearOrder.max_def._autoParam →\n                                                                            autoParam\n                                                                                (∀ (a b : V),\n                                                                                  compare a b = compareOfLessAndEq a b)\n                                                                                LinearOrder.compare_eq_compareOfLessAndEq._autoParam →\n                                                                              (∀ ⦃a : ℝ⦄,\n                                                                                  0 < a →\n                                                                                    ∀ ⦃b₁ b₂ : V⦄,\n                                                                                      lt b₁ b₂ → lt (a • b₁) (a • b₂)) →\n                                                                                (∀ {y z : V} (x : V),\n                                                                                    le y z → le (x + y) (x + z)) →\n                                                                                  HarderNarasimhan.TotallyOrderedRealVectorSpace\n                                                                                    V",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "PartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "CompleteSemilatticeInf.toInfSet",
   "HarderNarasimhan.InIntvl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μmin",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.hasQuotient",
   "Submodule.Quotient.mk",
   "HasQuotient.Quotient",
   "IsScalarTower",
   "Module",
   "AddCommGroup.toAddGroup",
   "SMulZeroClass.toSMul",
   "Submodule",
   "SMul",
   "MonoidWithZero.toMonoid",
   "Eq.symm",
   "instHSMul",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "DistribSMul.toSMulZeroClass",
   "AddZeroClass.toZero",
   "DistribMulAction.toDistribSMul",
   "Submodule.Quotient.mk_smul",
   "Submodule.Quotient.instSMul'",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Ring.toSemiring",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "HSMul.hSMul",
   "AddCommGroup.toAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "Ring"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_33",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M) {S : Type u_3} [inst_3 : SMul S R] [inst_4 : SMul S M] [inst_5 : IsScalarTower S R M] (r : S)\n  (x : M), r • Submodule.Quotient.mk x = Submodule.Quotient.mk (r • x)",
  "constCategory": "Theorem"},
 {"references":
  ["IsCancelAdd",
   "AddRightCancelSemigroup.add_right_cancel",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddCancelMonoid",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddZeroClass.toAdd",
   "IsCancelAdd.mk",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "IsLeftCancelAdd.mk",
   "AddRightCancelMonoid.toAddMonoid",
   "IsRightCancelAdd.mk",
   "AddMonoid.toAddZeroClass"],
  "name": "AddCancelMonoid.toIsCancelAdd",
  "constType": "∀ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Theorem"},
 {"references":
  ["le_refl",
   "Preorder",
   "LE.le",
   "id",
   "Eq.mpr",
   "Preorder.toLE",
   "Eq",
   "congrArg"],
  "name": "le_of_eq",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "CoeOut.mk",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "CoeOut",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instCoeOutInterval",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → CoeOut (HarderNarasimhan.Interval z) ℒ",
  "constCategory": "Definition"},
 {"references": ["AddCommMonoidWithOne", "AddMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_2} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Lean.Omega.Constraint",
   "Bool",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Constraint.not_sat_of_isImpossible",
   "Lean.Omega.Constraint.isImpossible",
   "Eq",
   "Lean.Omega.Coeffs.dot",
   "Bool.true",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.not_sat'_of_isImpossible",
  "constType":
  "∀ {c : Omega.Constraint}, c.isImpossible = true → ∀ {x y : Omega.Coeffs}, ¬c.sat' x y = true",
  "constCategory": "Theorem"},
 {"references": ["Nat", "SizeOf"],
  "name": "SizeOf.mk",
  "constType": "{α : Sort u} → (α → ℕ) → SizeOf α",
  "constCategory": "Other"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁.wsl₁",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "le_trans",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "HarderNarasimhan.WeakDescendingChainCondition.wdcc",
   "eq_of_le_of_le",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.WeakAscendingChainCondition.wacc",
   "HarderNarasimhan.impl.rmk4d10₀",
   "HarderNarasimhan.μBstar",
   "HarderNarasimhan.WeakSlopeLike₂.wsl₂",
   "HarderNarasimhan.WeakSlopeLike₁",
   "OrderBot.toBot",
   "HarderNarasimhan.impl.prop4d1₁",
   "Eq",
   "Eq.rec",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop4d3₁",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "And.right",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop4d11₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.WeakAscendingChainCondition μ →\n    HarderNarasimhan.WeakSlopeLike₁ μ →\n      HarderNarasimhan.WeakDescendingChainCondition μ →\n        HarderNarasimhan.WeakSlopeLike₂ μ →\n          HarderNarasimhan.μBstar μ ≤ HarderNarasimhan.μAstar μ →\n            HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Or",
   "Iff",
   "And",
   "Classical.propDecidable",
   "Decidable.not_and_iff_not_or_not"],
  "name": "not_and_or",
  "constType": "∀ {a b : Prop}, ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "LinearEquiv.injective",
   "associatedPrimes",
   "CommRing.toCommSemiring",
   "Module",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CommSemiring.toSemiring",
   "LinearEquiv.toLinearMap",
   "AddCommGroup",
   "associatedPrimes.subset_of_injective",
   "CommRing",
   "LinearEquiv",
   "LinearEquiv.symm",
   "Semiring.toNonAssocSemiring",
   "Ideal",
   "Set.instCompleteAtomicBooleanAlgebra",
   "RingHom.id",
   "AddCommGroup.toAddCommMonoid",
   "RingHomInvPair.ids",
   "Eq",
   "le_antisymm"],
  "name": "LinearEquiv.AssociatedPrimes.eq",
  "constType":
  "∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  {M' : Type u_3} [inst_3 : AddCommGroup M'] [inst_4 : _root_.Module R M'] (l : M ≃ₗ[R] M'),\n  associatedPrimes R M = associatedPrimes R M'",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "MulZeroClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MonoidWithZero.toMulZeroOneClass",
   "Subtype.val",
   "PosMulMono",
   "MulOneClass.toOne",
   "MonoidWithZero.toMonoid",
   "Pow",
   "Zero.toOfNat0",
   "Preorder.toLE",
   "instHPow",
   "Nonneg.pow._proof_21",
   "HPow.hPow",
   "MonoidWithZero",
   "OfNat.ofNat",
   "ZeroLEOneClass",
   "Preorder",
   "Nat",
   "MulZeroOneClass.toMulZeroClass",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "LE.le",
   "Subtype.mk",
   "Pow.mk"],
  "name": "Nonneg.pow",
  "constType":
  "{α : Type u_1} →\n  [inst : MonoidWithZero α] → [inst_1 : Preorder α] → [ZeroLEOneClass α] → [PosMulMono α] → Pow { x // 0 ≤ x } ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toPartialOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "GeneralizedHeytingAlgebra.toHImp",
   "instDistribLatticeOfLinearOrder",
   "HasCompl.compl",
   "OrderBot.toBot",
   "HeytingAlgebra.toOrderBot",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Lattice.toSemilatticeInf",
   "LinearOrder",
   "Bot.bot",
   "DistribLattice.toLattice",
   "HeytingAlgebra.himp_bot",
   "HImp.himp",
   "HeytingAlgebra.toHasCompl",
   "CompleteLattice.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_43",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a : HarderNarasimhan.DedekindMacNeilleCompletion α), a ⇨ ⊥ = aᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "Equiv.instFunLike",
   "Iff",
   "LE.le",
   "LE",
   "OrderDual.instLE",
   "Iff.rfl",
   "DFunLike.coe",
   "Equiv",
   "OrderDual.ofDual"],
  "name": "OrderDual.ofDual_le_ofDual",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {a b : αᵒᵈ}, OrderDual.ofDual a ≤ OrderDual.ofDual b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "LinearMap.instFunLike",
   "SemilinearMapClass",
   "Module",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup",
   "LinearMap",
   "CommRing",
   "LinearMap.semilinearMapClass",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "AddCommGroup.toAddCommMonoid",
   "Semiring.toModule"],
  "name": "IsAssociatedPrime._proof_1",
  "constType":
  "∀ {R : Type u_2} [inst : CommRing R] (M : Type u_1) [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M],\n  SemilinearMapClass (R →ₗ[R] M) (RingHom.id R) R M",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Set.singleton", "Set", "Singleton.mk", "Singleton"],
  "name": "Set.instSingletonSet",
  "constType": "{α : Type u} → Singleton α (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Equiv.left_inv",
   "LinearEquiv.toEquiv",
   "LinearMap.inverse",
   "LinearMap.instFunLike",
   "Module",
   "LinearMap.mk",
   "AddHom.mk",
   "LinearEquiv",
   "DFunLike.coe",
   "Equiv",
   "LinearEquiv.invFun",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Equiv.right_inv",
   "LinearEquiv.symm._proof_8",
   "Equiv.symm",
   "LinearEquiv.mk",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "LinearEquiv.symm._proof_7",
   "LinearEquiv.left_inv",
   "LinearEquiv.toLinearMap",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "Equiv.invFun",
   "LinearEquiv.right_inv",
   "RingHomInvPair",
   "Semiring"],
  "name": "LinearEquiv.symm",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_5} →\n    {M : Type u_6} →\n      {M₂ : Type u_8} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring S] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                {module_M : _root_.Module R M} →\n                  {module_S_M₂ : _root_.Module S M₂} →\n                    {σ : R →+* S} →\n                      {σ' : S →+* R} →\n                        {re₁ : RingHomInvPair σ σ'} → {re₂ : RingHomInvPair σ' σ} → (M ≃ₛₗ[σ] M₂) → M₂ ≃ₛₗ[σ'] M",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "Or.inl",
   "Or",
   "Subtype.prop",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLinearOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Or.casesOn",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakSlopeLike₂.mk",
   "le_of_lt",
   "Eq.refl",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.SlopeLike.slopelike"],
  "name": "HarderNarasimhan.impl.instWeakSlopeLike₂OfSlopeLike",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.SlopeLike μ],\n  HarderNarasimhan.WeakSlopeLike₂ μ",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instMembership",
   "instHAdd",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "Submodule",
   "HAdd.hAdd",
   "AddCommMonoid",
   "AddSubmonoidClass.toAddMemClass",
   "AddCommMonoid.toAddCommSemigroup",
   "Submodule.setLike",
   "AddMemClass.add_mem",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Submodule.addSubmonoidClass",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.add_mem",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x y : M}, x ∈ p → y ∈ p → x + y ∈ p",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μA_DescendingChainCondition.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n      (∀ (n : ℕ), f n > f (n + 1)) →\n        ∃ N, HarderNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(a, f N), ⋯⟩) →\n    HarderNarasimhan.μA_DescendingChainCondition μ",
  "constCategory": "Other"},
 {"references":
  ["Set.instHasSubset",
   "Preorder",
   "upperBounds_mono_mem",
   "HasSubset.Subset",
   "upperBounds",
   "Set",
   "Membership.mem",
   "LE.le",
   "Preorder.toLE",
   "upperBounds_mono_set",
   "Set.instMembership"],
  "name": "upperBounds_mono",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] ⦃s t : Set α⦄, s ⊆ t → ∀ ⦃a b : α⦄, a ≤ b → a ∈ upperBounds t → b ∈ upperBounds s",
  "constCategory": "Theorem"},
 {"references":
  ["lt_add_of_pos_right",
   "PartialOrder.toPreorder",
   "AddZeroClass",
   "AddZeroClass.toZero",
   "instHAdd",
   "AddLeftStrictMono",
   "Preorder.toLT",
   "zero_lt_one",
   "OfNat.ofNat",
   "ZeroLEOneClass",
   "HAdd.hAdd",
   "LT.lt",
   "NeZero",
   "One.toOfNat1",
   "AddZeroClass.toAdd",
   "PartialOrder",
   "One",
   "Preorder.toLE"],
  "name": "lt_add_one",
  "constType":
  "∀ {α : Type u_1} [inst : One α] [inst_1 : AddZeroClass α] [inst_2 : PartialOrder α] [ZeroLEOneClass α] [NeZero 1]\n  [AddLeftStrictMono α] (a : α), a < a + 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsTotal",
  "constType": "(α : Sort u_1) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "lcProof",
  "constType": "∀ {α : Prop}, α",
  "constCategory": "Axiom"},
 {"references": ["True", "Eq.symm", "trivial", "Eq.rec", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "HarderNarasimhan.ConvexI.convex",
   "Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.ConvexI",
   "And.right",
   "le_trans",
   "Preorder.toLT",
   "And",
   "HarderNarasimhan.ConvexI.mk",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "And.intro",
   "HarderNarasimhan.InIntvl",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "CompleteLattice",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.Convex_of_Convex_large",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {S : Type} [inst_1 : CompleteLattice S] (I₁ I₂ : { p // p.1 < p.2 }),\n  (↑I₁).1 ≤ (↑I₂).1 ∧ (↑I₂).2 ≤ (↑I₁).2 →\n    ∀ (μ : { p // p.1 < p.2 } → S), HarderNarasimhan.ConvexI I₁ μ → HarderNarasimhan.ConvexI I₂ μ",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeSup.sup", "SemilatticeSup", "Max", "Max.mk"],
  "name": "SemilatticeSup.toMax",
  "constType": "{α : Type u} → [SemilatticeSup α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_2",
   "_obj"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "BoundedOrder",
   "Prod.snd",
   "Nat.instPreorder",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nat",
   "Antitone",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.JordanHolderFiltration.antitone",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} (self : HarderNarasimhan.JordanHolderFiltration μ),\n  Antitone self.filtration",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "LinearMap.instFunLike",
   "SemilinearMapClass",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Submodule",
   "LinearMap.semilinearMapClass",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "Prod.snd",
   "LinearMap",
   "CommRing",
   "LT.lt",
   "Prod",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_8",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  SemilinearMapClass (↥(↑I).2 →ₗ[R] M) (RingHom.id R) (↥(↑I).2) M",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "Lattice",
   "Top.top",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (z : { p // p.1 < p.2 }),\n  (↑z).2 < ⊤ → ((↑z).1, ⊤).1 < ((↑z).1, ⊤).2",
  "constCategory": "Theorem"},
 {"references":
  ["Max.max",
   "PartialOrder.toPreorder",
   "sup_eq_left",
   "LE.le",
   "SemilatticeSup.toMax",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.Lattice.0._proof_10",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, (a ⊔ b = a) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["associatedPrimes",
   "CommRing.toCommSemiring",
   "Module",
   "Set",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "AddCommGroup",
   "CommRing",
   "HarderNarasimhan.Coprimary.mk",
   "Set.instMembership",
   "HarderNarasimhan.Coprimary.rec",
   "IsNoetherianRing",
   "HarderNarasimhan.Coprimary",
   "Ideal",
   "AddCommGroup.toAddCommMonoid",
   "ExistsUnique"],
  "name": "HarderNarasimhan.Coprimary.casesOn",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : AddCommGroup M] →\n          [inst_3 : _root_.Module R M] →\n            {motive : HarderNarasimhan.Coprimary R M → Sort u} →\n              (t : HarderNarasimhan.Coprimary R M) →\n                ((coprimary : ∃! p, p ∈ associatedPrimes R M) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Preorder",
   "PartialOrder.toPreorder",
   "Real",
   "inferInstance",
   "Real.partialOrder"],
  "name": "Real.instPreorder",
  "constType": "Preorder ℝ",
  "constCategory": "Definition"},
 {"references": ["Mul", "NonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "RingHomSurjective",
   "SemilinearMapClass",
   "Module",
   "Submodule.map",
   "Membership.mem",
   "DFunLike.coe",
   "Submodule",
   "AddCommMonoid",
   "SetLike.coe",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Set.mem_image_of_mem",
   "Semiring"],
  "name": "Submodule.mem_map_of_mem",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} [inst_6 : RingHomSurjective σ₁₂] {F : Type u_9} [inst_7 : FunLike F M M₂]\n  [inst_8 : SemilinearMapClass F σ₁₂ M M₂] {f : F} {p : Submodule R M} {r : M}, r ∈ p → f r ∈ Submodule.map f p",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "instHAdd",
   "Nat.add_comm",
   "Eq",
   "Eq.rec",
   "Nat.add_lt_add_left"],
  "name": "Nat.add_lt_add_right",
  "constType": "∀ {n m : ℕ}, n < m → ∀ (k : ℕ), n + k < m + k",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Max.max",
   "le_sup_right",
   "PartialOrder.toPreorder",
   "LT.lt.trans_le",
   "SemilatticeSup.toMax",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "SemilatticeSup"],
  "name": "lt_sup_of_lt_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c < b → c < a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.CoprimaryFiltration.noConfusion",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Submodule.instBot",
   "Nontrivial",
   "HarderNarasimhan.CoprimaryFiltration.mk",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "HarderNarasimhan.CoprimaryFiltration",
   "instOfNatNat",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Submodule.instTop",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.mk.inj",
  "constType":
  "∀ {R : Type} {inst : CommRing R} {inst_1 : IsNoetherianRing R} {M : Type} {inst_2 : Nontrivial M}\n  {inst_3 : AddCommGroup M} {inst_4 : _root_.Module R M} {inst_5 : Module.Finite R M}\n  {filtration : ℕ → HarderNarasimhan.ℒ R M} {monotone : Monotone filtration} {first_eq_bot : filtration 0 = ⊥}\n  {fin_len : ∃ n, filtration n = ⊤}\n  {strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j}\n  {piecewise_coprimary :\n    ∀ n < Nat.find fin_len,\n      HarderNarasimhan.Coprimary R (↥(filtration (n + 1)) ⧸ Submodule.submoduleOf (filtration n) (filtration (n + 1)))}\n  {strict_mono_associated_prime :\n    ∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len),\n      { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }}\n  {filtration_1 : ℕ → HarderNarasimhan.ℒ R M} {monotone_1 : Monotone filtration_1} {first_eq_bot_1 : filtration_1 0 = ⊥}\n  {fin_len_1 : ∃ n, filtration_1 n = ⊤}\n  {strict_mono_1 : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len_1 → filtration_1 i < filtration_1 j}\n  {piecewise_coprimary_1 :\n    ∀ n < Nat.find fin_len_1,\n      HarderNarasimhan.Coprimary R\n        (↥(filtration_1 (n + 1)) ⧸ Submodule.submoduleOf (filtration_1 n) (filtration_1 (n + 1)))}\n  {strict_mono_associated_prime_1 :\n    ∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len_1),\n      { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }},\n  { filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot, fin_len := fin_len,\n        strict_mono := strict_mono, piecewise_coprimary := piecewise_coprimary,\n        strict_mono_associated_prime := strict_mono_associated_prime } =\n      { filtration := filtration_1, monotone := monotone_1, first_eq_bot := first_eq_bot_1, fin_len := fin_len_1,\n        strict_mono := strict_mono_1, piecewise_coprimary := piecewise_coprimary_1,\n        strict_mono_associated_prime := strict_mono_associated_prime_1 } →\n    filtration = filtration_1",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.toAddGroup",
   "CanonicallyOrderedAdd",
   "eq_true",
   "MonoidWithZero.toMulZeroOneClass",
   "SMulZeroClass.toSMul",
   "or_true",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "NNReal.instLinearOrder",
   "NNReal.instLinearOrderedCommGroupWithZero",
   "NNReal.instCanonicallyOrderedAdd",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion",
   "Eq.symm",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "pos_iff_ne_zero",
   "CoheytingAlgebra.toOrderTop",
   "Exists",
   "GroupWithZero.toNoZeroSMulDivisors",
   "BoundedOrder",
   "DivisionSemiring.toSemiring",
   "HarderNarasimhan.impl.μQuotient_helper",
   "Right.inv_pos",
   "MulZeroOneClass.toMulZeroClass",
   "eq_false",
   "Top.top",
   "Eq.mpr",
   "covariant_swap_add_of_covariant_add",
   "OmegaCompletePartialOrder.toPartialOrder",
   "AddCommMonoid.toAddMonoid",
   "Prod.fst",
   "add_lt_add_iff_left",
   "Or.inl",
   "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
   "Eq",
   "MulActionWithZero.toSMulWithZero",
   "PosSMulMono.toPosSMulReflectLT",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Iff.symm",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "eq_sub_of_add_eq",
   "eq_self",
   "and_self",
   "Module.toDistribMulAction",
   "dite_cond_eq_true",
   "AddZeroClass.toAdd",
   "_private.Mathlib.Data.FunLike.Embedding.0._proof_1",
   "Ne",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toPosSMulStrictMono",
   "add_smul",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "CommGroupWithZero.toDivisionCommMonoid",
   "GT.gt",
   "RelEmbedding.instFunLike",
   "not_false_eq_true",
   "Semiring.toNonAssocSemiring",
   "IsCancelAdd.toIsRightCancelAdd",
   "Or",
   "PartialOrder",
   "DistribMulAction.toMulAction",
   "CompleteLattice.toTop",
   "AddGroup.toSubNegMonoid",
   "Semifield.toDivisionSemiring",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "DistribSMul.toSMulZeroClass",
   "AddZeroClass.toZero",
   "Real",
   "And.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "_private.Mathlib.Order.Hom.Basic.0._proof_51",
   "Exists.casesOn",
   "zero_add",
   "Real.instMonoid",
   "MulPosReflectLE.toMulPosReflectLT",
   "DivisionMonoid.toDivInvOneMonoid",
   "GroupWithZero.toDivisionMonoid",
   "instNNRealSemiring",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype.lt",
   "instDecidableAnd",
   "Eq.mp",
   "DFunLike.coe",
   "smul_right_injective",
   "not_top_lt",
   "instDistribLatticeOfLinearOrder",
   "not_or",
   "AddCancelMonoid.toIsCancelAdd",
   "GroupWithZero.toMonoidWithZero",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "dite_cond_eq_false",
   "Subtype.le",
   "smul_lt_smul_iff_of_pos_left",
   "NNReal.instPosSMulStrictMono",
   "Not",
   "not_and_or",
   "Inv.inv",
   "le_top",
   "instHAdd",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "NNReal.instSemifield",
   "NNReal.instDistribMulActionOfReal",
   "Real.semiring",
   "LT.lt",
   "lt_add_of_pos_left",
   "of_eq_true",
   "ne_of_lt",
   "False",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "HarderNarasimhan.SlopeLike",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "add_eq_zero",
   "False.elim",
   "letFun",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "SubNegMonoid.toSub",
   "sub_lt_iff_lt_add",
   "le_iff_eq_or_lt",
   "lt_add_of_pos_right",
   "lt_sub_iff_add_lt",
   "AddGroup.toAddCancelMonoid",
   "_private.Mathlib.Algebra.Order.Monoid.Canonical.Defs.0._proof_10",
   "ClosureOperator.IsClosed",
   "NNReal",
   "_private.Mathlib.Order.Basic.0._proof_1",
   "Prod.snd",
   "DivisionSemiring.toGroupWithZero",
   "Prod",
   "LinearOrder.toDecidableLT",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "Lattice",
   "AddCommGroup.toAddCommMonoid",
   "LinearOrderedCommGroupWithZero.toMulPosReflectLE",
   "AddMonoid.toAddZeroClass",
   "instNNRealZero",
   "Or.inr",
   "Ne.symm",
   "HarderNarasimhan.coe'",
   "Order.Coframe.toCoheytingAlgebra",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "contravariant_lt_of_covariant_le",
   "_private.Mathlib.Order.Defs.LinearOrder.0._proof_1",
   "congr",
   "AddCommMagma.toAdd",
   "Preorder.toLE",
   "propext",
   "Distrib.toAdd",
   "HarderNarasimhan.instAddLeftMono_harderNarasimhan",
   "HarderNarasimhan.impl.prop4d6",
   "OrderEmbedding",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "LinearOrder.toDecidableEq",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "eq_zero_or_pos",
   "dite",
   "And.casesOn",
   "lt_trans",
   "Prod.mk",
   "Iff.mp",
   "Subtype.preorder",
   "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
   "instNNRealPartialOrder",
   "AddMonoidWithOne.toAddMonoid",
   "And.intro",
   "HarderNarasimhan.impl.not_top_of_Nontrivial_TotallyOrderedRealVectorSpace",
   "NNReal.instModuleOfReal",
   "HSub.hSub",
   "Unique.instSubsingleton",
   "InvOneClass.toInv",
   "NonUnitalNonAssocSemiring.toDistrib",
   "And",
   "DistribMulAction.toDistribSMul",
   "add_zero",
   "Iff.mpr",
   "lt_of_not_le",
   "Nontrivial",
   "HSMul.hSMul",
   "NegZeroClass.toZero",
   "id",
   "CompleteDistribLattice.toCoframe",
   "Subtype",
   "Subtype.partialOrder",
   "SubNegZeroMonoid.toSubNegMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "PosSMulStrictMono.toPosSMulMono",
   "congrArg",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "RelEmbedding.instEmbeddingLike",
   "DivisionCommMonoid.toDivisionMonoid",
   "Set.instLE",
   "AddUnits",
   "Lattice.toSemilatticeInf",
   "AddZeroClass",
   "True",
   "Semiring.toMonoidWithZero",
   "_private.Mathlib.Algebra.Group.Defs.0._proof_2",
   "Module.toMulActionWithZero",
   "HarderNarasimhan.μQuotient",
   "Or.casesOn",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toModule",
   "DistribLattice.toLattice",
   "DivInvOneMonoid.toInvOneClass",
   "AddCommMonoid.toAddCommSemigroup",
   "SubNegMonoid.toAddMonoid",
   "LE.le",
   "CanonicallyOrderedAddCommMonoid.toUniqueAddUnits"],
  "name": "HarderNarasimhan.impl.prop4d8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {V : Type}\n  [inst_3 : HarderNarasimhan.TotallyOrderedRealVectorSpace V] [Nontrivial V] (r : { p // p.1 < p.2 } → NNReal)\n  (d : { p // p.1 < p.2 } → V),\n  (∀ (x y z : ℒ) (h : x < y ∧ y < z),\n      d ⟨(x, z), ⋯⟩ = d ⟨(x, y), ⋯⟩ + d ⟨(y, z), ⋯⟩ ∧ r ⟨(x, z), ⋯⟩ = r ⟨(x, y), ⋯⟩ + r ⟨(y, z), ⋯⟩) →\n    (∀ (x y : ℒ) (h : x < y), r ⟨(x, y), h⟩ = 0 → d ⟨(x, y), h⟩ > 0) →\n      HarderNarasimhan.SlopeLike (HarderNarasimhan.μQuotient r d)",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "And", "Eq", "propext"],
  "name": "_private.Init.SimpLemmas.0._proof_4",
  "constType": "∀ {a b c : Prop}, (a ∧ b → c) = (a → b → c)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "PartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "CompleteSemilatticeInf.toInfSet",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μA.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.μA μ I =\n    sInf {x | ∃ a, ∃ (ha : HarderNarasimhan.InIntvl I a ∧ a ≠ (↑I).2), HarderNarasimhan.μmax μ ⟨(a, (↑I).2), ⋯⟩ = x}",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "CompleteLattice.toInfSet",
   "Set",
   "CompleteLattice.toLattice",
   "Membership.mem",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Set.instMembership",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "CompleteLattice.sInf_le",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_38",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (s : Set (HarderNarasimhan.DedekindMacNeilleCompletion α)), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "Lean.Omega.combo_sat'",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "HarderNarasimhan.impl.instμ_Admissible",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "instHSub",
   "PartialOrder.toPreorder",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "Nat.lt_of_not_le",
   "Nontrivial",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.cast",
   "instDecidableAnd",
   "Subtype",
   "HarderNarasimhan.impl.HNFil",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HarderNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HarderNarasimhan.Convex μ) (f : ℕ → ℒ),\n  (∃ n, f n = ⊤) →\n    ∀ (n : ℕ) (h₂ : ∃ N ≥ n + 1, HarderNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n      Nat.find h₂ ≥ n + 1 → ¬n ≤ Nat.find h₂ - 1 → False",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Membership.mem",
   "Preorder.toLT",
   "Submodule.subtype",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "letFun",
   "not_lt_of_le",
   "Eq.symm",
   "Eq.rec",
   "SetLike.instMembership",
   "Submodule.addCommGroup",
   "LinearMap",
   "Ring.toSemiring",
   "Iff.mpr",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "lt_top_iff_ne_top",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "Eq.mp",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.mem_top",
   "Submodule",
   "Preorder.toLE",
   "Eq",
   "Submodule.instOrderTop",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "Submodule.submoduleOf._proof_14",
   "LT.lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "Submodule.Quotient.nontrivial_of_lt_top",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "HarderNarasimhan.impl.quot_ntl._proof_17",
   "Submodule.completeLattice",
   "False",
   "Ne",
   "Subtype.mk",
   "Submodule.addCommMonoid",
   "OrderTop.toTop",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.quot_ntl",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] {N₁ N₂ : HarderNarasimhan.ℒ R M},\n  N₁ < N₂ → Nontrivial (↥N₂ ⧸ Submodule.submoduleOf N₁ N₂)",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name": "HarderNarasimhan.coe'._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup.sup_le",
   "Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "sup_le",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image",
   "Exists",
   "Set",
   "Membership.mem",
   "And",
   "Set.mem_image",
   "Eq",
   "propext",
   "Set.instMembership"],
  "name": "_private.Mathlib.Data.Set.Operations.0._proof_5",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β), (y ∈ f '' s) = ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "And", "LE"],
  "name": "Minimal",
  "constType": "{α : Type u_1} → [LE α] → (α → Prop) → α → Prop",
  "constCategory": "Definition"},
 {"references": ["True", "Iff", "eq_true", "Iff.rfl", "Eq"],
  "name": "iff_self",
  "constType": "∀ (p : Prop), (p ↔ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_17",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top"],
  "name": "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_18",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (a : ℒ),\n  (↑⟨(⊥, ⊤), ⋯⟩).1 ≤ a ∧ a ≤ (↑⟨(⊥, ⊤), ⋯⟩).2",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "_private.Init.Classical.0._proof_9",
   "Membership.mem.out",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_8",
   "Subtype.val",
   "False.elim",
   "Or",
   "letFun",
   "forall_congr",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_1",
   "Exists.choose_spec",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_2",
   "Or.resolve_left",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Nat",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_9",
   "StrictMono",
   "setOf",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "_private.Init.Classical.0._proof_7",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "Nat.instPreorder",
   "Prod.fst",
   "_private.Init.PropLemmas.0._proof_15",
   "not_lt_top_iff",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "not_true_eq_false",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "Set",
   "_private.Init.Classical.0._proof_13",
   "HarderNarasimhan.impl.prop4d1₁_seq",
   "Exists.choose",
   "OfNat.ofNat",
   "exists_prop_congr",
   "HAdd.hAdd",
   "LT.lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_3",
   "And.casesOn"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._proof_10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S)\n  (h₁ : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩)\n  (h₂ :\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty) (k : ℕ),\n  ⋯.choose ∈ {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype.mk.injEq",
   "PartialOrder.toPreorder",
   "Subtype",
   "Eq.mp",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem.out",
   "Set.Iic",
   "Set.right_mem_Iic",
   "Set.instMembership",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "LE.le",
   "Eq.symm",
   "Subtype.mk",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "le_antisymm"],
  "name": "HarderNarasimhan.coe'._proof_49",
  "constType":
  "∀ {α : Type} [inst : PartialOrder α]\n  (inj : ∀ (x : α), (HarderNarasimhan.DedekindMacNeilleClosureOperator α).IsClosed (Set.Iic x)) ⦃a b : α⦄,\n  ⟨Set.Iic a, ⋯⟩ = ⟨Set.Iic b, ⋯⟩ → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.mp",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "HarderNarasimhan.impl.prop2d6₁I",
   "Preorder.toLT",
   "congrArg",
   "Prod.fst",
   "And.intro",
   "inf_top_eq",
   "BoundedOrder.toOrderTop",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Min.min",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toBoundedOrder",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (z : ℒ),\n          HarderNarasimhan.InIntvl I z →\n            ∀ (h : x < z),\n              HarderNarasimhan.μA μ ⟨(x, z), h⟩ = ⊤ →\n                ∀ (a : ℒ),\n                  HarderNarasimhan.InIntvl I a →\n                    ∀ (hax : a < x), HarderNarasimhan.μA μ ⟨(a, x), hax⟩ ≤ HarderNarasimhan.μA μ ⟨(a, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "OrderDual",
   "PartialOrder.toPreorder",
   "Set",
   "GaloisConnection",
   "ClosureOperator",
   "OmegaCompletePartialOrder",
   "Preorder",
   "OrderDual.instPreorder",
   "CompleteAtomicBooleanAlgebra",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "CompleteLattice"],
  "name":
  "GaloisConnection.closureOperator._at.HarderNarasimhan.DedekindMacNeilleClosureOperator._spec_1",
  "constType":
  "(α : Type) →\n  let _x_1 := Set.instCompleteAtomicBooleanAlgebra;\n  let _x_13 := _x_1.1;\n  let _x_14 := CompleteLattice.instOmegaCompletePartialOrder;\n  let _x_18 := _x_14.1;\n  let _x_19 := _x_18.1;\n  let _x_20 := OrderDual.instPreorder (Set α);\n  let _y_3 := _x_18;\n  let _y_4 := _x_20;\n  (l : Set α → (Set α)ᵒᵈ) → (u : (Set α)ᵒᵈ → Set α) → GaloisConnection l u → ClosureOperator (Set α)",
  "constCategory": "Axiom"},
 {"references": [],
  "name": "SizeOf",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["LE", "BoundedOrder", "OrderBot"],
  "name": "BoundedOrder.toOrderBot",
  "constType":
  "{α : Type u} → {inst : LE α} → [self : BoundedOrder α] → OrderBot α",
  "constCategory": "Definition"},
 {"references":
  ["Or.inr", "Or", "False", "Eq", "false_or.match_1", "propext", "Iff.intro"],
  "name": "false_or",
  "constType": "∀ (p : Prop), (False ∨ p) = p",
  "constCategory": "Theorem"},
 {"references": ["One", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → One R",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubset",
   "Preorder",
   "HasSubset.Subset",
   "Set",
   "LE.le",
   "Set.Iic_subset_Iic",
   "Eq",
   "Preorder.toLE",
   "Set.Iic",
   "propext"],
  "name": "_private.Mathlib.Order.Interval.Set.Basic.0._proof_11",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, (Set.Iic a ⊆ Set.Iic b) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.FiniteTotalPayoff.mk",
   "BoundedOrder.toOrderTop",
   "CompleteLattice.toTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.FiniteTotalPayoff.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.FiniteTotalPayoff μ → Sort u} →\n                ((fin_tot_payoff : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤) → motive ⋯) →\n                  (t : HarderNarasimhan.FiniteTotalPayoff μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Nat.lt_of_lt_of_le",
   "instLTNat",
   "Nat.sub",
   "OfNat.ofNat",
   "Nat.pred_lt_of_lt",
   "LT.lt",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "LE.le",
   "HSub.hSub",
   "instHSub",
   "instLENat"],
  "name": "Nat.sub_one_lt_of_le",
  "constType": "∀ {a b : ℕ}, 0 < a → a ≤ b → a - 1 < b",
  "constCategory": "Theorem"},
 {"references": ["Top"],
  "name": "Top.mk",
  "constType": "{α : Type u_1} → α → Top α",
  "constCategory": "Other"},
 {"references":
  ["CommRing.toCommSemiring",
   "Subtype",
   "SetLike.instMembership",
   "Module",
   "Submodule.module",
   "CommSemiring.toSemiring",
   "CommSemiring",
   "Membership.mem",
   "AddCommGroup",
   "CommRing",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.addCommMonoid",
   "Semiring"],
  "name": "Submodule.submoduleOf._at.HarderNarasimhan.impl.lift_quot._spec_4",
  "constType":
  "(R : Type) →\n  (inst : CommRing R) →\n    (M : Type) →\n      (inst_1 : AddCommGroup M) →\n        (inst_2 : _root_.Module R M) →\n          let _x_3 := CommRing.toCommSemiring;\n          let _x_6 := _x_3.1;\n          let _x_9 := AddCommGroup.toAddCommMonoid;\n          let _y_3 := _x_6;\n          let _y_4 := _x_9;\n          let _y_5 := inst_2;\n          Submodule R M →\n            (q : Submodule R M) →\n              let _x_1 := q.addCommMonoid;\n              let _x_2 := q.module;\n              Submodule R ↥q",
  "constCategory": "Axiom"},
 {"references":
  ["RingHom",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Module",
   "inferInstance",
   "LinearEquiv.instEquivLike",
   "LinearEquiv",
   "RingHomInvPair",
   "EquivLike",
   "Semiring"],
  "name": "DFinsupp.instEquivLikeLinearEquiv",
  "constType":
  "{R : Type u_6} →\n  {S : Type u_7} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        (σ : R →+* S) →\n          {σ' : S →+* R} →\n            [inst_2 : RingHomInvPair σ σ'] →\n              [inst_3 : RingHomInvPair σ' σ] →\n                (M : Type u_8) →\n                  (M₂ : Type u_9) →\n                    [inst_4 : AddCommMonoid M] →\n                      [inst_5 : AddCommMonoid M₂] →\n                        [inst_6 : _root_.Module R M] → [inst_7 : _root_.Module S M₂] → EquivLike (M ≃ₛₗ[σ] M₂) M M₂",
  "constCategory": "Definition"},
 {"references":
  ["Real.instPreorder",
   "Real.instZero",
   "Real",
   "NNReal",
   "Zero",
   "Nonneg.zero"],
  "name": "instNNRealZero",
  "constType": "Zero NNReal",
  "constCategory": "Definition"},
 {"references": ["Not", "And", "id"],
  "name":
  "HarderNarasimhan.TotallyOrderedRealVectorSpace.lt._inherited_default",
  "constType": "{V : Type} → (V → V → Prop) → V → V → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Finset.univ",
   "Finset",
   "Set",
   "Membership.mem",
   "Finset.toSet",
   "Fintype",
   "Finset.card_le_card_of_injOn",
   "Set.instMembership",
   "Fintype.card",
   "Nat",
   "LE.le",
   "Finset.instMembership",
   "Finset.mem_univ",
   "Eq",
   "instLENat",
   "Function.Injective"],
  "name": "Fintype.card_le_of_injective",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Fintype α] [inst_1 : Fintype β] (f : α → β),\n  Function.Injective f → Fintype.card α ≤ Fintype.card β",
  "constCategory": "Theorem"},
 {"references":
  ["CompletelyDistribLattice.mk",
   "CompleteLinearOrder.himp_bot",
   "CompleteLinearOrder.top_sdiff",
   "CompleteLinearOrder.toHNot",
   "CompleteLinearOrder.toHImp",
   "CompleteLinearOrder.toCompletelyDistribLattice._proof_28",
   "CompletelyDistribLattice",
   "CompleteLinearOrder.sdiff_le_iff",
   "CompleteLinearOrder.toCompleteLattice",
   "CompleteLinearOrder.toHasCompl",
   "CompleteLinearOrder",
   "CompleteLinearOrder.le_himp_iff",
   "CompleteLinearOrder.toSDiff"],
  "name": "CompleteLinearOrder.toCompletelyDistribLattice",
  "constType":
  "{α : Type u} → [CompleteLinearOrder α] → CompletelyDistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "Module",
   "Submodule.module",
   "LinearMap.mk",
   "Membership.mem",
   "AddHom.mk",
   "LinearEquiv",
   "Subtype.val",
   "Submodule.mem_top",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.topEquiv._proof_16",
   "RingHom.id",
   "LinearEquiv.mk",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "SetLike.instMembership",
   "Submodule.instTop",
   "Submodule.topEquiv._proof_13",
   "AddCommMonoid.toAddCommSemigroup",
   "Submodule.setLike",
   "Submodule.topEquiv._proof_17",
   "Top.top",
   "RingHomInvPair.ids",
   "Subtype.mk",
   "Submodule.addCommMonoid",
   "Submodule.topEquiv._proof_14",
   "Semiring"],
  "name": "Submodule.topEquiv",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → ↥⊤ ≃ₗ[R] M",
  "constCategory": "Definition"},
 {"references":
  ["NatCast.mk",
   "Nat.instAddMonoidWithOne._proof_2",
   "Nat.instAddMonoid",
   "Nat",
   "Nat.instOne",
   "AddMonoidWithOne",
   "AddMonoidWithOne.mk",
   "Nat.instAddMonoidWithOne._proof_1"],
  "name": "Nat.instAddMonoidWithOne",
  "constType": "AddMonoidWithOne ℕ",
  "constCategory": "Definition"},
 {"references": ["le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_rfl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a : α}, a ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Prod", "Prod.mk", "Prod.rec"],
  "name": "Prod.casesOn",
  "constType":
  "{α : Type u} →\n  {β : Type v} → {motive : α × β → Sort u_1} → (t : α × β) → ((fst : α) → (snd : β) → motive (fst, snd)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Int.instLTInt",
   "HarderNarasimhan.JordanHolderFiltration",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Int.negOfNat",
   "Top.top",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "HarderNarasimhan.JordanHolderFiltration.noConfusionType",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "HarderNarasimhan.JordanHolderFiltration.casesOn",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLinearOrder S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                {P : Sort u} →\n                  {v1 v2 : HarderNarasimhan.JordanHolderFiltration μ} →\n                    v1 = v2 → HarderNarasimhan.JordanHolderFiltration.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Not", "le_rfl", "LT.lt", "Preorder", "not_le_of_lt", "Preorder.toLT"],
  "name": "lt_irrefl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), ¬a < a",
  "constCategory": "Theorem"},
 {"references": ["Int.add", "Add", "Add.mk", "Int"],
  "name": "Int.instAdd",
  "constType": "Add ℤ",
  "constCategory": "Definition"},
 {"references": ["InfSet", "Set"],
  "name": "InfSet.sInf",
  "constType": "{α : Type u_1} → [self : InfSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "instOfNatNat",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.impl.prop3d4₀func",
   "BoundedOrder",
   "HarderNarasimhan.impl.prop3d4₀func._proof_3",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d4₀func.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.impl.prop3d4₀func μ I 0 = ⟨(↑I).2, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.S₀_order",
   "Finset",
   "Singleton.singleton",
   "Set.toFinset_subset_toFinset",
   "Exists.intro",
   "Subtype.val",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "IsGreatest",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion",
   "Eq.symm",
   "HarderNarasimhan.S",
   "Exists",
   "ClosureOperator.IsClosed",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "Iff",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "CompleteLattice.toBoundedOrder",
   "setOf",
   "RelEmbedding.toEmbedding",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "Prod.fst",
   "le_rfl",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "LinearExtension",
   "Set",
   "Set.toFinset",
   "AddCommGroup",
   "HarderNarasimhan.impl.assinc",
   "PrimeSpectrum",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "Submodule.completeLattice",
   "Ne",
   "HarderNarasimhan.S₀",
   "Module.Finite",
   "mem_upperBounds",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.instLES₀",
   "Prod.mk",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.preorder",
   "HarderNarasimhan.μmax",
   "And.intro",
   "HarderNarasimhan.impl.noname._proof_1",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "IsGreatest.csSup_eq",
   "Exists.casesOn",
   "Finset.instSingleton",
   "HasSubset.Subset",
   "upperBounds",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Submodule.instNontrivial",
   "Function.Embedding.toFun",
   "lt_of_le_of_ne",
   "Submodule",
   "congrArg",
   "instDistribLatticeOfLinearOrder",
   "Subtype.prop",
   "HarderNarasimhan.instLinearOrderS₀",
   "Subtype.le",
   "Set.instLE",
   "Not",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "CommSemiring.toSemiring",
   "Finset.instHasSubset",
   "HarderNarasimhan.μmax._proof_2",
   "CommRing",
   "Set.instHasSubset",
   "LT.lt",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "ne_of_lt",
   "le_of_lt",
   "LE.le",
   "Subtype.mk",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.impl.noname",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  HarderNarasimhan.μmax (HarderNarasimhan.μ R M) I = HarderNarasimhan.μ R M I",
  "constCategory": "Theorem"},
 {"references": ["AddCommMagma", "Add"],
  "name": "AddCommMagma.toAdd",
  "constType": "{G : Type u} → [self : AddCommMagma G] → Add G",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u_2} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references": ["LE.le", "LE", "Bot", "Bot.bot", "OrderBot"],
  "name": "OrderBot.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toBot : Bot α] → (∀ (a : α), ⊥ ≤ a) → OrderBot α",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "OrderDual",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "SemilatticeInf",
   "LT.lt",
   "left_lt_sup",
   "OrderDual.instSemilatticeSup",
   "Min.min",
   "Iff",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_lt_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b < a ↔ ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "And.right",
   "Or.resolve_left",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Ne.symm",
   "Subtype",
   "Classical.not_not",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Prod.fst",
   "le_rfl",
   "eq_of_le_of_le",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.impl.rmk4d10₀",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.μmax._proof_2",
   "LT.lt",
   "LE.le",
   "le_sSup",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop4d12",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      ¬μ ⟨(⊥, x), ⋯⟩ ≤ μ HarderNarasimhan.TotIntvl ∨ μ HarderNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩) →\n    HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl →\n      HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["MulAction.toSMul",
   "MulAction.mul_smul",
   "MulAction",
   "IsScalarTower",
   "Monoid",
   "Monoid.toMulAction",
   "IsScalarTower.mk"],
  "name": "IsScalarTower.left",
  "constType":
  "∀ (M : Type u_1) {α : Type u_5} [inst : Monoid M] [inst_1 : MulAction M α], IsScalarTower M M α",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.instTop._proof_10",
   "AddSubmonoid.instTop",
   "Set",
   "Module",
   "Top",
   "Membership.mem",
   "AddSubmonoid.mk",
   "AddCommMonoid.toAddMonoid",
   "Set.instMembership",
   "Submodule",
   "Set.univ",
   "AddSubsemigroup.mk",
   "AddCommMonoid",
   "AddZeroClass.toAdd",
   "AddSubmonoid",
   "Submodule.mk",
   "Top.top",
   "Top.mk",
   "trivial",
   "Submodule.instTop._proof_11",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.instTop",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → Top (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "SemilatticeSup.toPartialOrder",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "le_sup_left",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Max.max",
   "SemilatticeSup.toMax",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HarderNarasimhan.Interval z), ↑a ≤ ↑a ⊔ ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype", "Iff", "LE.le", "LE", "Iff.rfl", "Subtype.le", "Subtype.val"],
  "name": "Subtype.coe_le_coe",
  "constType":
  "∀ {α : Type u_2} [inst : LE α] {p : α → Prop} {x y : Subtype p}, ↑x ≤ ↑y ↔ x ≤ y",
  "constCategory": "Theorem"},
 {"references":
  ["RelEmbedding.toEmbedding",
   "Iff",
   "Function.Embedding",
   "Function.instFunLikeEmbedding",
   "RelEmbedding",
   "DFunLike.coe"],
  "name": "RelEmbedding.map_rel_iff'",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} {r : α → α → Prop} {s : β → β → Prop} (self : r ↪r s) {a b : α},\n  s (self.toEmbedding a) (self.toEmbedding b) ↔ r a b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.find",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
   "Inhabited.mk",
   "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration",
   "Module",
   "HarderNarasimhan.μ",
   "Classical.propDecidable",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_18",
   "Inhabited.default",
   "HarderNarasimhan.CoprimaryFiltration",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_19",
   "letFun",
   "Eq",
   "HarderNarasimhan.S",
   "HarderNarasimhan.impl.prop3d11",
   "CompleteLattice.toConditionallyCompleteLattice",
   "instLTNat",
   "CommRing.toCommSemiring",
   "Submodule.instTop",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "HarderNarasimhan.impl.prop3d13₂",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_21",
   "Inhabited",
   "CommRing",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.impl.piecewise_coprimary",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "HarderNarasimhan.impl.prop3d13₁",
   "LT.lt",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_26",
   "Nat",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Nontrivial",
   "Top.top",
   "HarderNarasimhan.CoprimaryFiltration.mk",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "inferInstance",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_20",
   "ConditionallyCompleteLattice.toLattice",
   "HarderNarasimhan.S₀",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] → Inhabited (HarderNarasimhan.CoprimaryFiltration R M)",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "And.intro",
   "HarderNarasimhan.μmin",
   "HarderNarasimhan.μBstar",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.impl.prop4d11₂",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "HarderNarasimhan.impl.prop4d11₁",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_4_11",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl →\n      HarderNarasimhan.μBstar μ ≤ HarderNarasimhan.μAstar μ) ∧\n    (HarderNarasimhan.WeakAscendingChainCondition μ →\n      HarderNarasimhan.WeakSlopeLike₁ μ →\n        HarderNarasimhan.WeakDescendingChainCondition μ →\n          HarderNarasimhan.WeakSlopeLike₂ μ →\n            HarderNarasimhan.μBstar μ ≤ HarderNarasimhan.μAstar μ →\n              HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl)",
  "constCategory": "Theorem"},
 {"references": ["Nat.decEq", "Nat", "DecidableEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.StI",
   "Preorder.toLT",
   "HarderNarasimhan.S₂I",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.S₁I",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Ne",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.StI.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.StI μ I =\n    {l |\n      ∃ (hlI : HarderNarasimhan.InIntvl I l) (hl : (↑I).1 ≠ l),\n        HarderNarasimhan.S₁I μ I l hlI hl ∧ HarderNarasimhan.S₂I μ I l hlI hl}",
  "constCategory": "Theorem"},
 {"references": ["Subtype.rec", "Subtype", "Subtype.mk"],
  "name": "Subtype.casesOn",
  "constType":
  "{α : Sort u} →\n  {p : α → Prop} →\n    {motive : Subtype p → Sort u_1} →\n      (t : Subtype p) → ((val : α) → (property : p val) → motive ⟨val, property⟩) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "MulZeroClass.toMul",
   "HMul.hMul",
   "Subtype.val",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "IsStrictOrderedRing",
   "Nonneg.coe_mul",
   "IsStrictOrderedRing.toIsOrderedRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toSemiring",
   "Nonneg.semifield._proof_12",
   "OfNat.ofNat",
   "Nonneg.mul",
   "DistribLattice.toLattice",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "instHMul",
   "Semifield",
   "IsOrderedRing.toPosMulMono"],
  "name": "Nonneg.semifield._proof_17",
  "constType":
  "∀ {α : Type u_1} [inst : Semifield α] [inst_1 : LinearOrder α] [inst_2 : IsStrictOrderedRing α] (a b : { x // 0 ≤ x }),\n  ↑(a * b) = ↑a * ↑b",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE", "GE.ge"],
  "name": "LE.le.ge",
  "constType": "∀ {α : Type u_2} [inst : LE α] {x y : α}, x ≤ y → y ≥ x",
  "constCategory": "Theorem"},
 {"references":
  ["Semifield.toCommSemiring",
   "Semiring.mul_one",
   "AddMonoid.toZero",
   "CommGroupWithZero.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.zero_mul",
   "Semifield.mul_inv_cancel",
   "Semifield.div_eq_mul_inv",
   "AddCommMonoid.toAddMonoid",
   "Semifield.inv_zero",
   "CommGroupWithZero",
   "Semigroup.mk",
   "CommSemiring.mul_comm",
   "Semiring.npow_zero",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalSemiring.mul_assoc",
   "Semifield.zpow_neg'",
   "Semiring.toOne",
   "NonUnitalNonAssocSemiring.mul_zero",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Semifield.toDiv",
   "CommMonoidWithZero.mk",
   "Semifield.toInv",
   "Semiring.one_mul",
   "Semiring.npow_succ",
   "Semifield.zpow_zero'",
   "Semifield.zpow",
   "CommMonoid.mk",
   "Semifield.toNontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Monoid.mk",
   "Semifield",
   "Semiring.npow",
   "Semifield.zpow_succ'"],
  "name": "Semifield.toCommGroupWithZero",
  "constType": "{K : Type u_2} → [self : Semifield K] → CommGroupWithZero K",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Preorder", "le_of_lt", "Preorder.toLT", "lt_of_lt_of_le"],
  "name": "lt_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring.toDistrib",
   "True",
   "Eq.trans",
   "Distrib.toMul",
   "CommSemiring",
   "MulZeroClass.toMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "HMul.hMul",
   "MulZeroClass.zero_mul",
   "OfNat.ofNat",
   "congrArg",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Zero.toOfNat0",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.zero_mul",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 * b = 0",
  "constCategory": "Theorem"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name":
  "HarderNarasimhan.impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "Nat.succ_lt_succ",
   "Nat.succ",
   "Iff",
   "Nat.lt_of_succ_lt_succ",
   "Iff.intro"],
  "name": "Nat.succ_lt_succ_iff",
  "constType": "∀ {a b : ℕ}, a.succ < b.succ ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Finset",
   "Submodule.toAddSubmonoid",
   "Eq.trans",
   "Submodule.Quotient.module",
   "Singleton.singleton",
   "WithTop",
   "Exists.intro",
   "Set.diff_eq_empty",
   "Membership.mem.out",
   "Subtype.val",
   "Set.inter_compl_self",
   "Finset.min'",
   "RingHom.id",
   "letFun",
   "Set.instInter",
   "Finset.min'_le",
   "Set.instSDiff",
   "LinearMap.ker",
   "Exists",
   "LocalizedModule",
   "Submodule.addCommGroup",
   "Prod.snd",
   "LinearMap",
   "HarderNarasimhan.impl.associated_primes_quot_koqcl._proof_11",
   "Set.instMembership",
   "Set.instHasCompl",
   "Prod",
   "Submonoid",
   "SetLike.coe",
   "LocalizedModule.isModule'",
   "Eq.refl",
   "Iff",
   "Top.top",
   "Finset.instMembership",
   "AddCommGroup.toAddCommMonoid",
   "RingHomInvPair.ids",
   "Set.ext",
   "Eq.mpr",
   "AddSubmonoid.toAddSubsemigroup",
   "setOf",
   "AddMonoid.toAddZeroClass",
   "Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "LocalizedModule.instAddCommMonoid",
   "MulZeroOneClass.toMulOneClass",
   "AddCommMonoid.toAddMonoid",
   "HarderNarasimhan.impl.μ_nonempty",
   "EmptyCollection.emptyCollection",
   "LocalizedModule.mkLinearMap",
   "Prod.fst",
   "AddSubsemigroup.carrier",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "Eq",
   "LinearExtension",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "toLinearExtension",
   "Set.toFinset",
   "AddCommGroup",
   "PrimeSpectrum",
   "eq_self",
   "CommRing.toRing",
   "HarderNarasimhan.ℒ",
   "AddZeroClass.toAdd",
   "HarderNarasimhan.impl.bourbaki_elements_math_alg_comm_chIV_sec1_no2_prop6",
   "HarderNarasimhan._μ._proof_2",
   "Submodule.completeLattice",
   "SDiff.sdiff",
   "Ne",
   "Module.Finite",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.impl.f1",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Membership.mem",
   "Inter.inter",
   "Iff.mp",
   "Preorder.toLT",
   "PrimeSpectrum.isPrime",
   "Finset.inf",
   "LinearMap.semilinearMapClass",
   "And.intro",
   "Semiring.toNonAssocSemiring",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "Eq.rec",
   "Semiring.toModule",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization",
   "NonAssocSemiring.toMulZeroOneClass",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "SetLike.instMembership",
   "Submonoid.instSetLike",
   "PrimeSpectrum.mk",
   "And.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "iff_true",
   "Exists.casesOn",
   "HasSubset.Subset",
   "WithTop.semilatticeInf",
   "Finset.inf'._proof_13",
   "Nontrivial",
   "id",
   "Submodule.submoduleOf",
   "WithTop.untop.match_1",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Subtype",
   "Eq.mp",
   "Submodule.module",
   "WithTop.some",
   "Set.instEmptyCollection",
   "LinearEquiv",
   "Iff.intro",
   "Submodule",
   "congrArg",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "WithTop.orderTop",
   "eq_of_le_of_le",
   "WithTop.top",
   "Ideal",
   "HasCompl.compl",
   "HarderNarasimhan.impl.koqcl_iso",
   "Ideal.primeCompl",
   "OrderHom.monotone'",
   "PrimeSpectrum.asIdeal",
   "Finset.min'_mem",
   "LinearEquiv.AssociatedPrimes.eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "True",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "Function.comp",
   "IsAssociatedPrime",
   "CommRing",
   "Set.instSingletonSet",
   "Set.instHasSubset",
   "LT.lt",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "of_eq_true",
   "Submodule.setLike",
   "LE.le",
   "HarderNarasimhan.impl.associated_primes_quot_koqcl._proof_12",
   "Submodule.addCommMonoid"],
  "name": "HarderNarasimhan.impl.associated_primes_quot_koqcl",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  associatedPrimes R (↥(↑I).2 ⧸ Submodule.submoduleOf (HarderNarasimhan.impl.ker_of_quot_comp_localization I) (↑I).2) =\n    {((HarderNarasimhan._μ R M I).toFinset.min' ⋯).asIdeal}",
  "constCategory": "Theorem"},
 {"references":
  ["OrderBot.bot_le", "LE.le", "LE", "OrderBot.toBot", "Bot.bot", "OrderBot"],
  "name": "bot_le",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderBot α] {a : α}, ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "DivInvMonoid.toZPow",
   "GroupWithZero.toDivInvMonoid",
   "Subtype.val",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "instHPow",
   "Lattice.toSemilatticeInf",
   "IsStrictOrderedRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toGroupWithZero",
   "DivisionSemiring.toSemiring",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nonneg.zpow",
   "DistribLattice.toLattice",
   "MulZeroClass.toZero",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semifield"],
  "name": "Nonneg.coe_zpow",
  "constType":
  "∀ {α : Type u_1} [inst : Semifield α] [inst_1 : LinearOrder α] [inst_2 : IsStrictOrderedRing α] (a : { x // 0 ≤ x })\n  (n : ℤ), ↑(a ^ n) = ↑a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.StI",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil",
   "Prod.fst",
   "IsGreatest",
   "HarderNarasimhan.impl.HNFil._proof_3",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "HarderNarasimhan.impl.HNFil.match_1",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HarderNarasimhan.impl.HNFil._proof_4",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Bot.bot",
   "Unit",
   "LT.lt",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil._sunfold",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              (μ : { p // p.1 < p.2 } → S) →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] → [h : HarderNarasimhan.μ_Admissible μ] → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Nat.cast",
   "instHAdd",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.cast_add",
   "HAdd.hAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.add",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.isNat_add.match_1",
   "Eq.symm",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "AddSemigroup.toAdd"],
  "name": "Mathlib.Meta.NormNum.isNat_add",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {f : α → α → α} {a b : α} {a' b' c : ℕ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsNat a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → a'.add b' = c → Mathlib.Meta.NormNum.IsNat (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.Affine",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HarderNarasimhan.Affine.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (a b : ℒ) (h : ¬a ≤ b), μ ⟨(a ⊓ b, a), ⋯⟩ = μ ⟨(b, a ⊔ b), ⋯⟩) → HarderNarasimhan.Affine μ",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "SupSet.sSup",
   "Set",
   "CompleteSemilatticeSup.sSup_le",
   "LE.le",
   "Membership.mem",
   "CompleteSemilatticeSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "sSup_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod",
   "LT.lt",
   "And.intro",
   "Subtype.prop",
   "le_of_lt",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.prop3d4₀func._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }), (↑I).1 ≤ (↑I).1 ∧ (↑I).1 ≤ (↑I).2",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "True",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_isNat.match_1",
   "Int.cast",
   "congrArg",
   "Int",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Ring.toAddGroupWithOne",
   "of_eq_true",
   "Mathlib.Meta.NormNum.IsInt",
   "AddGroupWithOne.toIntCast",
   "Int.cast_natCast",
   "Int.ofNat",
   "Eq",
   "Mathlib.Meta.NormNum.IsNat",
   "instNatCastInt",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsInt a (Int.ofNat n) → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Submodule.instBot",
   "Nontrivial",
   "HarderNarasimhan.CoprimaryFiltration.mk",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "HarderNarasimhan.CoprimaryFiltration.casesOn",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.ext.match_1",
  "constType":
  "∀ {R : Type} {inst : CommRing R} {inst_1 : IsNoetherianRing R} {M : Type} {inst_2 : Nontrivial M}\n  {inst_3 : AddCommGroup M} {inst_4 : _root_.Module R M} {inst_5 : Module.Finite R M}\n  (motive : HarderNarasimhan.CoprimaryFiltration R M → Prop) (h : HarderNarasimhan.CoprimaryFiltration R M),\n  (∀ (filtration : ℕ → HarderNarasimhan.ℒ R M) (monotone : Monotone filtration) (first_eq_bot : filtration 0 = ⊥)\n      (fin_len : ∃ n, filtration n = ⊤)\n      (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j)\n      (piecewise_coprimary :\n        ∀ n < Nat.find fin_len,\n          HarderNarasimhan.Coprimary R\n            (↥(filtration (n + 1)) ⧸ Submodule.submoduleOf (filtration n) (filtration (n + 1))))\n      (strict_mono_associated_prime :\n        ∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len),\n          { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }),\n      motive\n        { filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot, fin_len := fin_len,\n          strict_mono := strict_mono, piecewise_coprimary := piecewise_coprimary,\n          strict_mono_associated_prime := strict_mono_associated_prime }) →\n    motive h",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Bot",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderBot",
   "Top",
   "BoundedOrder",
   "OrderTop",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "lcProof",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μAstar._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → S",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "CommRing.toCommSemiring",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.CoprimaryFiltration",
   "Module",
   "Nontrivial",
   "CommSemiring.toSemiring",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "CommRing",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.filtration",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] → HarderNarasimhan.CoprimaryFiltration R M → ℕ → HarderNarasimhan.ℒ R M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["semiOutParam", "Coe"],
  "name": "Coe.mk",
  "constType": "{α : semiOutParam (Sort u)} → {β : Sort v} → (α → β) → Coe α β",
  "constCategory": "Other"},
 {"references": ["Exists", "And", "Eq", "propext", "exists_eq_right"],
  "name": "HarderNarasimhan.impl.lift_quot_middle._proof_21",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.Quotient.module",
   "Submodule.module",
   "Membership.mem",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "NonAssocSemiring",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "CommSemiring.toSemiring",
   "Submodule.addCommGroup",
   "AddCommGroup",
   "LinearMap",
   "CommRing",
   "Ring.toSemiring",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.addCommMonoid",
   "Semiring",
   "Ring"],
  "name": "Submodule.mkQ._at.HarderNarasimhan.impl.lift_quot._spec_10",
  "constType":
  "(R : Type) →\n  (inst : CommRing R) →\n    (M : Type) →\n      (inst_1 : AddCommGroup M) →\n        (inst_2 : _root_.Module R M) →\n          (N₂ : Submodule R M) →\n            (_x_1 : Ring R) →\n              (_x_6 : Semiring R) →\n                let _x_7 := N₂.addCommGroup;\n                (_x_9 : AddCommMonoid M) →\n                  let _x_10 := N₂.module;\n                  let _y_3 := _x_1;\n                  let _y_4 := _x_7;\n                  let _y_5 := _x_10;\n                  (p : Submodule R ↥N₂) →\n                    let _x_1 := _y_3.1;\n                    let _x_2 := Semiring.toNonAssocSemiring;\n                    let _x_3 := RingHom.id R;\n                    let _x_4 := AddCommGroup.toAddCommMonoid;\n                    let _x_5 := Submodule.Quotient.addCommGroup p;\n                    let _x_6 := AddCommGroup.toAddCommMonoid;\n                    let _x_7 := Submodule.Quotient.module p;\n                    ↥N₂ →ₛₗ[_x_3] ↥N₂ ⧸ p",
  "constCategory": "Axiom"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
   "Ideal.IsPrime",
   "Submodule.Quotient.module",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Classical.propDecidable",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "Semiring.toModule",
   "HarderNarasimhan.S",
   "HarderNarasimhan.Coprimary.coprimary",
   "And.left",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_22",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Submodule.addCommGroup",
   "LinearMap",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.impl.piecewise_coprimary",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Set.instMembership",
   "Nat",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_20",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.toBoundedOrder",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "Submodule.hasQuotient",
   "Nat.find",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "ExistsUnique.exists",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.impl.prop3d11",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "CommRing.toCommSemiring",
   "instHAdd",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "HarderNarasimhan.impl.prop3d13₂",
   "AddCommGroup",
   "IsAssociatedPrime",
   "CommRing",
   "Exists.choose",
   "HarderNarasimhan.impl.prop3d13₁",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Submodule.completeLattice",
   "HarderNarasimhan.S₀",
   "Submodule.addCommMonoid",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_23",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (HNFil : HarderNarasimhan.HarderNarasimhanFiltration (HarderNarasimhan.μ R M)) (n : ℕ) (hn : n + 1 < Nat.find ⋯),\n  ⋯.choose.IsPrime",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "associatedPrimes",
   "Module",
   "Set",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "AddCommGroup",
   "CommRing",
   "Set.instMembership",
   "IsNoetherianRing",
   "HarderNarasimhan.Coprimary",
   "Ideal",
   "AddCommGroup.toAddCommMonoid",
   "ExistsUnique"],
  "name": "HarderNarasimhan.Coprimary.mk",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : AddCommGroup M]\n  [inst_3 : _root_.Module R M], (∃! p, p ∈ associatedPrimes R M) → HarderNarasimhan.Coprimary R M",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocCommSemiring", "NonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["Or", "Iff", "Or.comm"],
  "name": "or_comm",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ b ∨ a",
  "constCategory": "Theorem"},
 {"references": ["exists_prop", "Exists", "And", "Eq", "propext"],
  "name": "HarderNarasimhan.μB_res_intvl._proof_20",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
   "PartialOrder.toPreorder",
   "Submodule.instNontrivial",
   "Module",
   "HarderNarasimhan.μ",
   "HarderNarasimhan.HarderNarasimhanFiltration.fin_len",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.S",
   "HarderNarasimhan.impl.prop3d11",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "Exists",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "HarderNarasimhan.impl.prop3d13₂",
   "CommRing",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "HarderNarasimhan.impl.prop3d13₁",
   "Nat",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Nontrivial",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "ConditionallyCompleteLattice.toLattice",
   "HarderNarasimhan.S₀",
   "OrderTop.toTop",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_20",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (HNFil : HarderNarasimhan.HarderNarasimhanFiltration (HarderNarasimhan.μ R M)), ∃ n, HNFil.filtration n = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Lattice.toLinearOrder",
   "Real",
   "LinearOrder",
   "Classical.propDecidable",
   "Preorder.toLT",
   "LT.lt",
   "LE.le",
   "Real.leTotal_R",
   "Real.lattice",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "Real.linearOrder",
  "constType": "LinearOrder ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteLattice.toTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.FiniteTotalPayoff.fin_tot_payoff",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.FiniteTotalPayoff μ],\n  μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["List.nil",
   "instAddNat",
   "instHAdd",
   "List.brecOn",
   "List",
   "List.length.match_1",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "List.below",
   "Nat",
   "instOfNatNat",
   "List.cons"],
  "name": "List.length",
  "constType": "{α : Type u_1} → List α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "FunLike",
   "Exists",
   "SetLike.instMembership",
   "RingHomSurjective",
   "SemilinearMapClass",
   "Module",
   "Submodule.map",
   "Membership.mem",
   "And",
   "DFunLike.coe",
   "Submodule",
   "Submodule.mem_map",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_15",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} [inst_6 : RingHomSurjective σ₁₂] {F : Type u_9} [inst_7 : FunLike F M M₂]\n  [inst_8 : SemilinearMapClass F σ₁₂ M M₂] {f : F} {p : Submodule R M} {x : M₂},\n  (x ∈ Submodule.map f p) = ∃ y ∈ p, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient",
   "Submodule.Quotient.mk",
   "Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "IsScalarTower",
   "Module",
   "AddCommGroup.toAddGroup",
   "SMulZeroClass.toSMul",
   "IsScalarTower.mk",
   "Submodule",
   "SMul",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "DistribSMul.toSMulZeroClass",
   "AddZeroClass.toZero",
   "congr_arg",
   "Submodule.quotientRel",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "Submodule.Quotient.instSMul'",
   "AddCommGroup",
   "Ring.toSemiring",
   "Module.toDistribMulAction",
   "Quotient.ind'",
   "SubNegMonoid.toAddMonoid",
   "HSMul.hSMul",
   "AddCommGroup.toAddCommMonoid",
   "smul_assoc",
   "AddMonoid.toAddZeroClass",
   "Ring"],
  "name": "Submodule.Quotient.isScalarTower",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] {S : Type u_3}\n  [inst_3 : SMul S R] [inst_4 : SMul S M] [inst_5 : IsScalarTower S R M] (P : Submodule R M) (T : Type u_4)\n  [inst_6 : SMul T R] [inst_7 : SMul T M] [inst_8 : IsScalarTower T R M] [inst_9 : SMul S T] [IsScalarTower S T M],\n  IsScalarTower S T (M ⧸ P)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "OrderBot.toBot",
   "le_bot_iff",
   "Eq",
   "Preorder.toLE",
   "Bot.bot",
   "propext",
   "OrderBot"],
  "name": "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_19",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, (a ≤ ⊥) = (a = ⊥)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "SetLike.coe_eq_coe",
   "Membership.mem",
   "SetLike",
   "Eq",
   "Subtype.val",
   "propext"],
  "name": "_private.Mathlib.Data.SetLike.Basic.0._proof_4",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x y : ↥p}, (↑x = ↑y) = (x = y)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "Subtype.val",
   "OfNat.ofNat",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "SetLike.coe_eq_coe",
   "Iff",
   "Zero.toOfNat0",
   "Submodule.zero",
   "Eq",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "Submodule.coe_eq_zero",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  {p : Submodule R M} {x : ↥p}, ↑x = 0 ↔ x = 0",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "LinearOrderedCommMonoidWithZero"],
  "name": "LinearOrderedCommMonoidWithZero.toLinearOrder",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommMonoidWithZero α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "LE.le",
   "And.right",
   "And",
   "Iff.mp",
   "Preorder.toLT",
   "Preorder.toLE",
   "lt_iff_le_not_le"],
  "name": "not_le_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "Set.toFinset_congr",
   "Submodule.ext",
   "AddCommGroup.toAddGroup",
   "Submodule.Quotient.module",
   "Submodule.Quotient.instSMul",
   "HarderNarasimhan.impl.prop3d12",
   "SMulZeroClass.toSMul",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "HarderNarasimhan.impl.rmk4d14₂._proof_18",
   "HarderNarasimhan.impl.rmk4d14₁",
   "AddCommMonoid",
   "Finset.min'",
   "RingHom.id",
   "Eq.symm",
   "HarderNarasimhan.S",
   "Finset.min'_le",
   "FunLike",
   "Exists",
   "LinearMap.ker",
   "LinearOrder",
   "HarderNarasimhan.impl.rmk4d14₂._proof_17",
   "LinearMap",
   "Ring.toSemiring",
   "Iff",
   "SMulMemClass.smul_mem",
   "Submodule.instBot",
   "Top.top",
   "Eq.mpr",
   "Quotient.out",
   "HarderNarasimhan.Semistable",
   "RelEmbedding.toEmbedding",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "CommSemiring",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.Quotient.instZeroQuotient",
   "AddCommMonoid.toAddMonoid",
   "Prod.fst",
   "Submodule.span_singleton_eq_bot",
   "Or.inl",
   "Eq",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Finset.min'_singleton",
   "smul_eq_mul",
   "LinearExtension",
   "Set",
   "Ideal.IsPrime.ne_top",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Set.toFinset",
   "HarderNarasimhan.impl.assinc",
   "lt_of_lt_of_le",
   "eq_self",
   "LinearEquiv.trans",
   "Module.toDistribMulAction",
   "_private.Mathlib.Data.FunLike.Embedding.0._proof_1",
   "_private.Mathlib.Algebra.Group.Submonoid.Defs.0._proof_47",
   "HarderNarasimhan.instPartialOrderS₀",
   "Ne",
   "Semiring",
   "Submodule.Quotient.mk",
   "PartialOrder.toPreorder",
   "SemilinearMapClass",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Mul.toSMul",
   "Preorder.toLT",
   "Submodule.span",
   "Algebra.id",
   "RelEmbedding.instFunLike",
   "Submodule.subtype",
   "Semiring.toNonAssocSemiring",
   "Or",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "eq_of_heq",
   "DistribMulAction.toMulAction",
   "PrimeSpectrum.instPartialOrder",
   "AddGroup.toSubNegMonoid",
   "Semiring.toModule",
   "Eq.rec",
   "Finset.Nonempty",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "DistribSMul.toSMulZeroClass",
   "AddZeroClass.toZero",
   "outParam",
   "PrimeSpectrum.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And.right",
   "Bot.bot",
   "Exists.casesOn",
   "Finset.instSingleton",
   "HasSubset.Subset",
   "Iff.of_eq",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_13",
   "CommRing.mul_comm",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "LinearMap.toSpanSingleton",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Eq.mp",
   "Submodule.module",
   "Submodule.smulMemClass",
   "DFunLike.coe",
   "instDistribLatticeOfLinearOrder",
   "Algebra.toSMul",
   "PrimeSpectrum.asIdeal",
   "Set.toFinset_singleton",
   "Subtype.le",
   "HarderNarasimhan.impl.rmk4d14₂._proof_19",
   "Not",
   "LinearEquiv.AssociatedPrimes.eq",
   "le_top",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Distrib.toMul",
   "Submodule.quotientRel",
   "IsAssociatedPrime._proof_1",
   "IsAssociatedPrime",
   "Set.instSingletonSet",
   "LinearEquiv.symm",
   "LT.lt",
   "of_eq_true",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "False",
   "ExistsUnique.unique",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_3",
   "Subtype.mk",
   "OrderTop.toTop",
   "Ideal.IsPrime.mul_mem_iff_mem_or_mem",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Finset",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq.trans",
   "Singleton.singleton",
   "Exists.intro",
   "Membership.mem.out",
   "Membership",
   "Subtype.val",
   "Quotient.out_eq",
   "False.elim",
   "AddSubmonoidClass.toZeroMemClass",
   "letFun",
   "Submodule.mem_span_singleton",
   "Eq.ndrec",
   "Submodule.addSubmonoidClass",
   "rfl",
   "LinearMap.instZero",
   "HarderNarasimhan.impl.rmk4d14₂._proof_14",
   "ClosureOperator.IsClosed",
   "Submodule.smul_mem",
   "Submodule.addCommGroup",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "Classical.byContradiction",
   "Finset.instMembership",
   "AddCommGroup.toAddCommMonoid",
   "HEq",
   "RingHomInvPair.ids",
   "Set.ext",
   "CompleteLattice.toBoundedOrder",
   "Set.fintypeSingleton",
   "AddMonoid.toAddZeroClass",
   "setOf",
   "Quotient",
   "Or.inr",
   "Submodule.hasQuotient",
   "HarderNarasimhan.coe'",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Submodule.mem_span_singleton_self",
   "and_true",
   "HarderNarasimhan.impl.μ_nonempty",
   "Submodule.topEquiv",
   "MulActionWithZero.smul_zero",
   "congr",
   "not_true_eq_false",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "propext",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Submodule.instOrderTop",
   "ZeroMemClass.coe_eq_zero",
   "HarderNarasimhan.impl.rmk4d14₂._proof_16",
   "IsScalarTower.left",
   "Submodule.instTop",
   "AddCommGroup",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "CommRing.toRing",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.μA",
   "HarderNarasimhan._μ._proof_2",
   "Submodule.completeLattice",
   "ExistsUnique",
   "Submodule.smul",
   "HarderNarasimhan.S₀",
   "bot_lt_top",
   "_private.Mathlib.Data.Finset.Insert.0._proof_3",
   "Module.Finite",
   "Prod.mk",
   "RingHomCompTriple.ids",
   "Ideal.IsPrime",
   "Iff.mp",
   "Quotient.mk",
   "HMul.hMul",
   "And.intro",
   "Ideal.instIsTwoSided_1",
   "IsAssociatedPrime.isPrime",
   "Semiring.toNonUnitalSemiring",
   "SetLike.instMembership",
   "NonUnitalNonAssocSemiring.toDistrib",
   "HarderNarasimhan.impl.rmk4d14₂._proof_15",
   "And",
   "DistribMulAction.toDistribSMul",
   "Submodule.Quotient.mk_eq_zero",
   "Iff.mpr",
   "Nontrivial",
   "HSMul.hSMul",
   "NegZeroClass.toZero",
   "id",
   "instHMul",
   "ZeroMemClass.zero",
   "Submodule.quotEquivOfEqBot",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.submoduleOf",
   "Submodule.ker_subtype",
   "Subtype",
   "Submodule.coe_eq_zero",
   "Function.Embedding.toFun",
   "LinearEquiv",
   "SubNegZeroMonoid.toNegZeroClass",
   "LinearMap.toSpanSingleton_zero",
   "Submodule",
   "Iff.intro",
   "congrArg",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "RelEmbedding.instEmbeddingLike",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "RelEmbedding",
   "Submodule.instOrderBot",
   "Finset.min'_mem",
   "Set.instLE",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "True",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_2",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Module.toMulActionWithZero",
   "CommRing",
   "Eq.casesOn",
   "LinearMap.ker_zero",
   "exists_prop_congr",
   "Set.instHasSubset",
   "Or.casesOn",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "SubNegMonoid.toAddMonoid",
   "Submodule.setLike",
   "LE.le",
   "smul_assoc",
   "Submodule.zero",
   "Submodule.addCommMonoid"],
  "name": "HarderNarasimhan.impl.rmk4d14₂",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  HarderNarasimhan.Semistable (HarderNarasimhan.μ R M) ↔ ∃! p, p ∈ associatedPrimes R M",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instMembership",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "OfNat.ofNat",
   "Submodule",
   "AddCommMonoid",
   "ZeroMemClass.zero_mem",
   "Submodule.setLike",
   "AddSubmonoidClass.toZeroMemClass",
   "Zero.toOfNat0",
   "Submodule.addSubmonoidClass",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.zero_mem",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M), 0 ∈ p",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "OrderDual.toDual",
   "OrderDual",
   "PartialOrder.toPreorder",
   "Equiv.instFunLike",
   "GaloisConnection",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "DFunLike.coe",
   "Equiv",
   "Set.instMembership",
   "OrderDual.ofDual",
   "Iff.intro",
   "OrderDual.instPreorder",
   "upperBounds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "lowerBounds",
   "LE.le",
   "Preorder.toLE"],
  "name": "HarderNarasimhan.DedekindMacNeilleConnection",
  "constType":
  "∀ (α : Type) [inst : PartialOrder α],\n  GaloisConnection (fun A => OrderDual.toDual (upperBounds A)) fun A => lowerBounds (OrderDual.ofDual A)",
  "constCategory": "Theorem"},
 {"references":
  ["Module",
   "AddCommMonoid.toAddMonoid",
   "MulAction.toSMul",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "instHSMul",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Zero.toOfNat0",
   "Eq",
   "DistribMulAction",
   "Distrib.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddZeroClass.toZero",
   "instHAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "HSMul.hSMul",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "Module.mk",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] →\n      [inst_1 : AddCommMonoid M] →\n        [toDistribMulAction : DistribMulAction R M] →\n          (∀ (r s : R) (x : M), (r + s) • x = r • x + s • x) → (∀ (x : M), 0 • x = 0) → _root_.Module R M",
  "constCategory": "Other"},
 {"references":
  ["Nat", "MulOneClass.toOne", "Nat.instMulOneClass", "One", "inferInstance"],
  "name": "Nat.instOne",
  "constType": "One ℕ",
  "constCategory": "Definition"},
 {"references": ["_obj", "HarderNarasimhan.Resμ._rarg"],
  "name":
  "HarderNarasimhan.instCoeForallSubtypeProdLtFstSndForallIntervalOfCompleteLattice._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Real", "_private.Mathlib.Data.Real.Basic.0.Real.lt", "LT.mk", "LT"],
  "name": "Real.instLT",
  "constType": "LT ℝ",
  "constCategory": "Definition"},
 {"references": ["Monoid", "MonoidWithZero"],
  "name": "MonoidWithZero.toMonoid",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Monoid M₀",
  "constCategory": "Definition"},
 {"references": ["Exists", "And", "Eq", "propext", "exists_eq_right"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_25",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instPartialOrder",
   "AddCommMonoid",
   "Submodule.instOrderBot._proof_7",
   "PartialOrder.toPreorder",
   "Submodule.setLike",
   "Module",
   "Submodule.instBot",
   "Preorder.toLE",
   "OrderBot.mk",
   "OrderBot",
   "Submodule",
   "Semiring"],
  "name": "Submodule.instOrderBot",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → OrderBot (Submodule R M)",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "AddSemigroup", "instHAdd", "Add", "Eq"],
  "name": "AddSemigroup.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b c : G), a + b + c = a + (b + c)) → AddSemigroup G",
  "constCategory": "Other"},
 {"references": ["Set.Subset", "Set", "LE.mk", "LE"],
  "name": "Set.instLE",
  "constType": "{α : Type u} → LE (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "GetElem",
   "List.get",
   "Fin.mk",
   "List",
   "List.length",
   "GetElem.mk"],
  "name": "List.instGetElemNatLtLength",
  "constType":
  "{α : Type u_1} → GetElem (List α) ℕ α fun as i => i < as.length",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "Lattice",
   "SemilatticeSup.toPartialOrder",
   "Lattice.inf",
   "SemilatticeInf.mk",
   "Lattice.le_inf"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "HarderNarasimhan.JordanHolderFiltration",
   "Int.instLTInt",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "HarderNarasimhan.JordanHolderFiltration.noConfusion",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.mk.inj",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLinearOrder S} {μ : { p // p.1 < p.2 } → S} {filtration : ℕ → ℒ} {antitone : Antitone filtration}\n  {fin_len : ∃ N, filtration N = ⊥}\n  {strict_anti : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration j < filtration i}\n  {first_eq_top : filtration 0 = ⊤}\n  {step_cond₁ : ∀ (k : ℕ) (hk : k < Nat.find fin_len), μ ⟨(filtration (k + 1), filtration k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩}\n  {step_cond₂ :\n    ∀ (i : ℕ) (hi : i < Nat.find fin_len) (z : ℒ) (h' : filtration (i + 1) < z),\n      z < filtration i → μ ⟨(filtration (i + 1), z), h'⟩ < μ ⟨(filtration (i + 1), filtration i), ⋯⟩}\n  {filtration_1 : ℕ → ℒ} {antitone_1 : Antitone filtration_1} {fin_len_1 : ∃ N, filtration_1 N = ⊥}\n  {strict_anti_1 : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len_1 → filtration_1 j < filtration_1 i}\n  {first_eq_top_1 : filtration_1 0 = ⊤}\n  {step_cond₁_1 :\n    ∀ (k : ℕ) (hk : k < Nat.find fin_len_1), μ ⟨(filtration_1 (k + 1), filtration_1 k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩}\n  {step_cond₂_1 :\n    ∀ (i : ℕ) (hi : i < Nat.find fin_len_1) (z : ℒ) (h' : filtration_1 (i + 1) < z),\n      z < filtration_1 i → μ ⟨(filtration_1 (i + 1), z), h'⟩ < μ ⟨(filtration_1 (i + 1), filtration_1 i), ⋯⟩},\n  { filtration := filtration, antitone := antitone, fin_len := fin_len, strict_anti := strict_anti,\n        first_eq_top := first_eq_top, step_cond₁ := step_cond₁, step_cond₂ := step_cond₂ } =\n      { filtration := filtration_1, antitone := antitone_1, fin_len := fin_len_1, strict_anti := strict_anti_1,\n        first_eq_top := first_eq_top_1, step_cond₁ := step_cond₁_1, step_cond₂ := step_cond₂_1 } →\n    filtration = filtration_1",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "SetLike.instMembership",
   "Add",
   "Module",
   "instHAdd",
   "Membership.mem",
   "Submodule.add._proof_22",
   "Subtype.val",
   "Submodule",
   "HAdd.hAdd",
   "AddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "Submodule.setLike",
   "Add.mk",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Subtype.mk",
   "Semiring"],
  "name": "Submodule.add",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → {module_M : _root_.Module R M} → (p : Submodule R M) → Add ↥p",
  "constCategory": "Definition"},
 {"references":
  ["LE.le.eq_or_lt",
   "LT.lt",
   "Not",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Or.resolve_right",
   "Preorder.toLT",
   "Eq",
   "Preorder.toLE"],
  "name": "eq_of_le_of_not_lt",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≤ b → ¬a < b → a = b",
  "constCategory": "Theorem"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "∀ {α : Sort u} (a : α), HEq a a",
  "constCategory": "Other"},
 {"references": ["exists_prop", "Exists", "And", "Eq", "propext"],
  "name": "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_2",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.impl.prop3d4₀func.match_1",
   "instOfNatNat",
   "HarderNarasimhan.impl.prop3d4₀func._proof_4",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.impl.ℒₛ",
   "And",
   "HarderNarasimhan.impl.prop3d4₀func._proof_6",
   "BoundedOrder",
   "HarderNarasimhan.impl.prop3d4₀func._proof_3",
   "Prod.snd",
   "Nat.brecOn",
   "Exists.choose",
   "OfNat.ofNat",
   "Set.instMembership",
   "Unit",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.impl.prop3d4₀func._proof_5",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "Subtype.mk",
   "dite",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d4₀func",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        [h : WellFoundedGT ℒ] →\n          {S : Type} →\n            [CompleteLattice S] →\n              ({ p // p.1 < p.2 } → S) → (I : { p // p.1 < p.2 }) → ℕ → { p // HarderNarasimhan.InIntvl I p }",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.refl"],
  "name": "Iff.rfl",
  "constType": "∀ {a : Prop}, a ↔ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Subtype", "Subtype.forall", "Subtype.mk", "Eq", "propext"],
  "name": "_private.Init.Data.Subtype.0._proof_1",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∀ (x : { a // p a }), q x) = ∀ (a : α) (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "instLTNat",
   "Nat",
   "LE.le",
   "Nat.ge_of_not_lt",
   "instLENat"],
  "name": "Nat.le_of_not_lt",
  "constType": "∀ {a b : ℕ}, ¬a < b → b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Min"],
  "name": "Min.min",
  "constType": "{α : Type u} → [self : Min α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LE α",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "add_left_comm",
   "True",
   "Eq.trans",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "of_eq_true",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Eq",
   "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_gt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₂ c : R} (b₁ : R), a + b₂ = c → a + (b₁ + b₂) = b₁ + c",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.ConvexI.mk",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.InIntvl",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.ConvexI.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Lattice ℒ] →\n    {S : Type} →\n      [inst_1 : CompleteLattice S] →\n        {I : { p // p.1 < p.2 }} →\n          {μ : { p // p.1 < p.2 } → S} →\n            {motive : HarderNarasimhan.ConvexI I μ → Sort u} →\n              ((convex :\n                    ∀ (x y : ℒ),\n                      HarderNarasimhan.InIntvl I x →\n                        HarderNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩) →\n                  motive ⋯) →\n                (t : HarderNarasimhan.ConvexI I μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Unique",
   "AddUnits",
   "AddUnits.instInhabited",
   "PartialOrder.toPreorder",
   "AddZeroClass.toAdd",
   "PartialOrder",
   "Unique.mk",
   "CanonicallyOrderedAdd",
   "AddMonoid",
   "CanonicallyOrderedAddCommMonoid.toUniqueAddUnits._proof_12",
   "Preorder.toLE",
   "AddMonoid.toAddZeroClass"],
  "name": "CanonicallyOrderedAddCommMonoid.toUniqueAddUnits",
  "constType":
  "{α : Type u} → [inst : AddMonoid α] → [inst_1 : PartialOrder α] → [CanonicallyOrderedAdd α] → Unique (AddUnits α)",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMonoid",
   "SetLike.instMembership",
   "Subtype",
   "Submodule.toAddSubmonoid",
   "Submodule.setLike",
   "Module",
   "Membership.mem",
   "AddSubmonoid.toAddCommMonoid",
   "Submodule",
   "Semiring"],
  "name": "Submodule.addCommMonoid",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] →\n      [inst_1 : AddCommMonoid M] → {module_M : _root_.Module R M} → (p : Submodule R M) → AddCommMonoid ↥p",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Membership.mem",
   "Set.instEmptyCollection",
   "EmptyCollection.emptyCollection",
   "congrArg",
   "Iff.intro",
   "Mathlib.Tactic.PushNeg.not_nonempty_eq._proof_2",
   "Mathlib.Tactic.PushNeg.not_nonempty_eq._proof_1",
   "iff_self",
   "letFun",
   "congr",
   "Eq",
   "Not",
   "Set.Nonempty",
   "Exists",
   "True",
   "Set",
   "Set.instMembership",
   "of_eq_true",
   "Iff",
   "eq_false",
   "id",
   "Set.ext",
   "False",
   "Eq.mpr"],
  "name": "Mathlib.Tactic.PushNeg.not_nonempty_eq",
  "constType": "∀ {β : Type u_2} (s : Set β), (¬s.Nonempty) = (s = ∅)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "Lattice.toSemilatticeSup",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "SemilatticeSup.toPartialOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "OrderTop.le_top",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "LE.le",
   "Top.top",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "OrderTop.toTop",
   "CompleteLattice.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_40",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a : HarderNarasimhan.DedekindMacNeilleCompletion α), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "Nonneg.div",
   "GroupWithZero.toDivInvMonoid",
   "Subtype.val",
   "instHDiv",
   "HDiv.hDiv",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Lattice.toSemilatticeInf",
   "IsStrictOrderedRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toGroupWithZero",
   "DivisionSemiring.toSemiring",
   "DivInvMonoid.toDiv",
   "OfNat.ofNat",
   "DistribLattice.toLattice",
   "MulZeroClass.toZero",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semifield"],
  "name": "Nonneg.coe_div",
  "constType":
  "∀ {α : Type u_1} [inst : Semifield α] [inst_1 : LinearOrder α] [inst_2 : IsStrictOrderedRing α] (a b : { x // 0 ≤ x }),\n  ↑(a / b) = ↑a / ↑b",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "_obj", "Prod.mk", "_neutral"],
  "name": "HarderNarasimhan.Resμ._rarg._cstage2",
  "constType": "_obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["sSup_le_iff",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteSemilatticeSup",
   "Membership.mem",
   "CompleteSemilatticeSup.toSupSet",
   "Set.instMembership",
   "SupSet.sSup",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.CompleteLattice.Defs.0._proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, (sSup s ≤ a) = ∀ b ∈ s, b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Iff",
   "PartialOrder",
   "LE.le",
   "top_le_iff",
   "Top.top",
   "OrderTop",
   "Eq",
   "Preorder.toLE",
   "OrderTop.toTop",
   "Iff.symm"],
  "name": "eq_top_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, a = ⊤ ↔ ⊤ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["forall_apply_eq_imp_iff₂", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_43",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {p : α → Prop} {q : β → Prop},\n  (∀ (b : β) (a : α), p a → f a = b → q b) = ∀ (a : α), p a → q (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint",
   "Bool",
   "Eq.trans",
   "Prod.mk",
   "Lean.Omega.normalize_sat",
   "Lean.Omega.normalizeCoeffs",
   "Lean.Omega.Coeffs",
   "Option.some",
   "Lean.Omega.tidyCoeffs",
   "congrArg",
   "Prod.fst",
   "Lean.Omega.positivize?_eq_some",
   "Lean.Omega.positivizeConstraint",
   "Lean.Omega.positivizeCoeffs",
   "Eq.symm",
   "Eq",
   "Eq.ndrec",
   "Bool.true",
   "Lean.Omega.normalizeConstraint",
   "Lean.Omega.normalize",
   "Lean.Omega.positivize?",
   "Lean.Omega.normalize?",
   "Lean.Omega.positivize_sat",
   "Lean.Omega.tidy?.match_1",
   "True",
   "_private.Init.Omega.Constraint.0.Lean.Omega.tidy?.match_1.splitter",
   "And",
   "Option.getD",
   "Lean.Omega.tidyConstraint",
   "Prod.snd",
   "Unit",
   "Prod",
   "eq_self",
   "Option.none",
   "of_eq_true",
   "Lean.Omega.normalize?_eq_some",
   "Eq.refl",
   "Option",
   "id",
   "And.casesOn",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.tidy_sat",
  "constType":
  "∀ {s : Omega.Constraint} {x v : Omega.Coeffs},\n  s.sat' x v = true → (Omega.tidyConstraint s x).sat' (Omega.tidyCoeffs s x) v = true",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "le_refl",
   "PartialOrder.toPreorder",
   "sup_eq_left",
   "Eq.trans",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "GE.ge",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "And.intro",
   "PartialOrder",
   "letFun",
   "sSup_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "forall_congr",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "inf_eq_right",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "HarderNarasimhan.impl.lem2d4₂I",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "SemilatticeInf.toMin",
   "Subtype",
   "Eq.mp",
   "SemilatticeSup.toPartialOrder",
   "lt_of_le_of_ne",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Prod.fst",
   "le_rfl",
   "eq_of_le_of_le",
   "Subtype.prop",
   "_private.Init.PropLemmas.0._proof_12",
   "Preorder.toLE",
   "Eq",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "gt_of_ge_of_gt",
   "HarderNarasimhan.μmax._proof_2",
   "not_le_of_gt",
   "LT.lt",
   "Max.max",
   "ne_of_lt",
   "Min.min",
   "le_of_lt",
   "SemilatticeSup.toMax",
   "LE.le",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "Ne",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.rmk2d5₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ → HarderNarasimhan.μmax μ I = HarderNarasimhan.μmax (HarderNarasimhan.μmax μ) I",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "_private.Mathlib.Order.Lattice.0._proof_9",
   "And",
   "SemilatticeSup.toPartialOrder",
   "and_true",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "Max.max",
   "le_antisymm_iff",
   "iff_self",
   "of_eq_true",
   "congr",
   "Iff",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Eq",
   "Preorder.toLE",
   "_private.Mathlib.Order.Lattice.0._proof_8"],
  "name": "sup_eq_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "BiheytingAlgebra",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._rarg",
   "_neutral"],
  "name":
  "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["ne_comm",
   "Iff.trans",
   "PartialOrder.toPreorder",
   "AddZeroClass",
   "AddZeroClass.toZero",
   "LE.le.lt_iff_ne",
   "Preorder.toLT",
   "CanonicallyOrderedAdd",
   "OfNat.ofNat",
   "LT.lt",
   "AddZeroClass.toAdd",
   "zero_le",
   "Iff",
   "PartialOrder",
   "Zero.toOfNat0",
   "Ne",
   "Preorder.toLE"],
  "name": "pos_iff_ne_zero",
  "constType":
  "∀ {α : Type u} [inst : AddZeroClass α] [inst_1 : PartialOrder α] [CanonicallyOrderedAdd α] {a : α}, 0 < a ↔ a ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Submonoid.smul",
   "Exists.intro",
   "SMulZeroClass.toSMul",
   "LocalizedModule.mk",
   "LocalizedModule.instZero",
   "MulAction.toSMul",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "DistribMulAction.toMulAction",
   "NonAssocSemiring.toMulZeroOneClass",
   "DistribSMul.toSMulZeroClass",
   "LocalizedModule.mk_eq",
   "Exists",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "LocalizedModule",
   "Submonoid.instSetLike",
   "DistribMulAction.toDistribSMul",
   "Submonoid.mulAction",
   "Submonoid",
   "Iff.mpr",
   "Eq.refl",
   "HSMul.hSMul",
   "one_smul",
   "id",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass",
   "smul_zero",
   "Subtype",
   "Module",
   "CommSemiring",
   "MulZeroOneClass.toMulOneClass",
   "AddCommMonoid.toAddMonoid",
   "congrArg",
   "MulOneClass.toOne",
   "Submonoid.distribMulAction",
   "MonoidWithZero.toMonoid",
   "Monoid.toMulOneClass",
   "instHSMul",
   "Zero.toOfNat0",
   "Eq",
   "Submonoid.toMonoid",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Submonoid.one",
   "OfNat.ofNat",
   "Module.toDistribMulAction",
   "One.toOfNat1"],
  "name": "LocalizedModule.zero_mk",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] {S : Submonoid R} {M : Type v} [inst_1 : AddCommMonoid M]\n  [inst_2 : _root_.Module R M] (s : ↥S), LocalizedModule.mk 0 s = 0",
  "constCategory": "Theorem"},
 {"references": ["Nat.lt", "Nat", "LT.mk", "LT"],
  "name": "instLTNat",
  "constType": "LT ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Eq.symm",
   "WellFoundedGT",
   "HarderNarasimhan.impl.prop3d4₀func_len",
   "Preorder.toLE",
   "Eq",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not.decidable_imp_symm",
   "Not",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "eq_of_le_of_not_lt",
   "HarderNarasimhan.impl.prop3d4₀func",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.impl.prop3d4₀func_fin_len",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Nat.find_min",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d4₀func_defprop3₀",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 })\n  (hμDCC : HarderNarasimhan.μA_DescendingChainCondition μ),\n  ∀ i < HarderNarasimhan.impl.prop3d4₀func_len μ I hμDCC, (↑I).1 < ↑(HarderNarasimhan.impl.prop3d4₀func μ I i)",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "RingHom",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap",
   "SemilinearMapClass",
   "Module",
   "Submodule.instBot",
   "Bot.bot",
   "Submodule",
   "Semiring"],
  "name": "LinearMap.ker",
  "constType":
  "{R : Type u_1} →\n  {R₂ : Type u_2} →\n    {M : Type u_5} →\n      {M₂ : Type u_7} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                [inst_4 : _root_.Module R M] →\n                  [inst_5 : _root_.Module R₂ M₂] →\n                    {τ₁₂ : R →+* R₂} →\n                      {F : Type u_11} → [inst_6 : FunLike F M M₂] → [SemilinearMapClass F τ₁₂ M M₂] → F → Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "True",
   "Module",
   "Membership.mem",
   "Submodule.instTop",
   "eq_true",
   "Submodule.mem_top",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "Top.top",
   "Eq",
   "Semiring"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_28",
  "constType":
  "∀ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  (x ∈ ⊤) = True",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.impl.prop3d4₀func._proof_8",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "WellFounded.has_min",
   "Prod.mk",
   "Membership.mem",
   "Eq.mpr_not",
   "Preorder.toLT",
   "Classical.propDecidable",
   "eq_true",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "False.elim",
   "letFun",
   "PartialOrder",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop3d4₀func._proof_4",
   "Eq.rec",
   "Eq.ndrec",
   "HarderNarasimhan.impl.ℒₛ._proof_1",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "of_eq_false",
   "Exists",
   "Exists.choose_spec",
   "HarderNarasimhan.impl.ℒₛ",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.impl.prop3d4₀func_helper",
   "Set.instMembership",
   "Prod",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "eq_false",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "Subtype",
   "instDecidableTrue",
   "Eq.mp",
   "lt_of_le_of_ne",
   "dite_congr",
   "congrArg",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "IsWellFounded.wf",
   "not_true_eq_false",
   "WellFoundedGT",
   "instDecidableFalse",
   "dite_cond_eq_false",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "instHAdd",
   "HarderNarasimhan.impl.prop3d4₀func",
   "Exists.choose",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "HarderNarasimhan.μA",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "HarderNarasimhan.impl.ℒₛ._proof_2",
   "CompleteLattice",
   "HarderNarasimhan.impl.prop3d4₀func._proof_7"],
  "name": "HarderNarasimhan.impl.prop3d4₀func_defprop1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ)\n  (hi : (↑I).1 ≠ ↑(HarderNarasimhan.impl.prop3d4₀func μ I (i + 1))),\n  HarderNarasimhan.μA μ ⟨((↑I).1, ↑(HarderNarasimhan.impl.prop3d4₀func μ I (i + 1))), ⋯⟩ >\n    HarderNarasimhan.μA μ ⟨((↑I).1, ↑(HarderNarasimhan.impl.prop3d4₀func μ I i)), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "instAddNat",
   "HarderNarasimhan.SlopeLike",
   "Eq.trans",
   "Classical.propDecidable",
   "HarderNarasimhan.JordanHolderFiltration",
   "Eq.symm",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Eq.ndrec",
   "instLTNat",
   "Exists",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat.find_spec",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.Semistable",
   "AddMonoid.toAddZeroClass",
   "setOf",
   "Nat.find",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Nat.instPreorder",
   "Prod.fst",
   "le_rfl",
   "Nat.instNeZeroSucc",
   "instOfNatNat",
   "congr",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Nat.le_induction",
   "Nat.instAddMonoid",
   "Set",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "eq_self",
   "AddZeroClass.toAdd",
   "HarderNarasimhan.impl.JHFil_anti_mono",
   "HarderNarasimhan.impl.JHFil",
   "Ne",
   "dite",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "Nat.find_min",
   "lt_trans",
   "PartialOrder.toPreorder",
   "false_and",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "bot_le",
   "_private.Mathlib.Data.Set.Basic.0._proof_26",
   "GT.gt",
   "Nat.instAddCommMonoid",
   "forall_congr",
   "funext",
   "CompleteLinearOrder",
   "Nat.instIsOrderedAddMonoid",
   "Eq.rec",
   "Nat.instLinearOrder",
   "HarderNarasimhan.impl.JHFil_prop₁",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "And",
   "Nonempty",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Bot.bot",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "Iff.of_eq",
   "lt_of_not_le",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "HarderNarasimhan.impl.JHFil._proof_4",
   "HarderNarasimhan.FiniteTotalPayoff.fin_tot_payoff",
   "_private.Init.PropLemmas.0._proof_16",
   "HarderNarasimhan.WeakDescendingChainCondition'.wdcc'",
   "Subtype",
   "HarderNarasimhan.impl.JHFil_prop₂",
   "le_trans",
   "dite_congr",
   "congrArg",
   "Nonempty.intro",
   "Nat.instOne",
   "BoundedOrder.toOrderTop",
   "Nat.instIsOrderedCancelAddMonoid",
   "dite_cond_eq_false",
   "OrderBot.toBot",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_16",
   "Not",
   "bot_lt_iff_ne_bot",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Nat.decLe",
   "Exists.choose",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "exists_prop_congr",
   "Eq.mpr_prop",
   "LT.lt",
   "lt_add_one",
   "of_eq_true",
   "One.toOfNat1",
   "le_of_lt",
   "HarderNarasimhan.impl.JHFil_fin_len",
   "LE.le",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "False",
   "Subtype.mk",
   "instLENat",
   "OrderTop.toTop"],
  "name":
  "HarderNarasimhan.instNonemptyJordanHolderFiltrationOfFiniteTotalPayoffOfSlopeLikeOfSemistableOfWeakDescendingChainCondition'",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} [hftp : HarderNarasimhan.FiniteTotalPayoff μ]\n  [hsl : HarderNarasimhan.SlopeLike μ] [hst : HarderNarasimhan.Semistable μ]\n  [hwdcc' : HarderNarasimhan.WeakDescendingChainCondition' μ], Nonempty (HarderNarasimhan.JordanHolderFiltration μ)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HarderNarasimhan.μA_DescendingChainCondition.mk",
   "Nat",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μA_DescendingChainCondition.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.μA_DescendingChainCondition μ → Sort u} →\n                ((μ_dcc :\n                      ∀ (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n                        (∀ (n : ℕ), f n > f (n + 1)) →\n                          ∃ N, HarderNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(a, f N), ⋯⟩) →\n                    motive ⋯) →\n                  (t : HarderNarasimhan.μA_DescendingChainCondition μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "absurd",
   "LT.lt",
   "Preorder",
   "lt_irrefl",
   "Preorder.toLT",
   "False",
   "Ne",
   "Eq.rec",
   "Eq"],
  "name": "ne_of_gt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, b < a → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible.noConfusionType",
   "HarderNarasimhan.μ_Admissible.casesOn",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "IsTotal",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μ_Admissible.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                {P : Sort u} →\n                  {v1 v2 : HarderNarasimhan.μ_Admissible μ} →\n                    v1 = v2 → HarderNarasimhan.μ_Admissible.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.μ_Admissible.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨ ∀ (I : { p // p.1 < p.2 }), HarderNarasimhan.IsAttained μ I) →\n    HarderNarasimhan.μ_Admissible μ",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "HarderNarasimhan.WeakAscendingChainCondition.mk",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HarderNarasimhan.WeakAscendingChainCondition.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakAscendingChainCondition μ → Sort u} →\n                ((wacc : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                    motive ⋯) →\n                  (t : HarderNarasimhan.WeakAscendingChainCondition μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["And.intro",
   "True",
   "And.right",
   "And",
   "Eq",
   "trivial",
   "propext",
   "Iff.intro"],
  "name": "true_and",
  "constType": "∀ (p : Prop), (True ∧ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "Preorder",
   "Preorder.toLT",
   "not_lt_of_le",
   "Preorder.toLE",
   "GE.ge"],
  "name": "not_lt_of_ge",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≥ b → ¬a < b",
  "constCategory": "Theorem"},
 {"references": ["Ord", "LinearOrder"],
  "name": "LinearOrder.toOrd",
  "constType": "{α : Type u_2} → [self : LinearOrder α] → Ord α",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.rec", "Nat.zero"],
  "name": "Nat.casesOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → motive Nat.zero → ((n : ℕ) → motive n.succ) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Function.Injective.eq_iff",
   "Finset.singleton_injective",
   "Finset.instSingleton",
   "Finset",
   "Iff",
   "Singleton.singleton",
   "Eq"],
  "name": "Finset.singleton_inj",
  "constType": "∀ {α : Type u_1} {a b : α}, {a} = {b} ↔ a = b",
  "constCategory": "Theorem"},
 {"references": ["Top"],
  "name": "Top.top",
  "constType": "{α : Type u_1} → [self : Top α] → α",
  "constCategory": "Definition"},
 {"references": ["Eq.symm", "Eq.rec", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "HarderNarasimhan.CoprimaryFiltration.rec",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Submodule.instBot",
   "Nontrivial",
   "HarderNarasimhan.CoprimaryFiltration.mk",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.casesOn",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] →\n                {motive : HarderNarasimhan.CoprimaryFiltration R M → Sort u} →\n                  (t : HarderNarasimhan.CoprimaryFiltration R M) →\n                    ((filtration : ℕ → HarderNarasimhan.ℒ R M) →\n                        (monotone : Monotone filtration) →\n                          (first_eq_bot : filtration 0 = ⊥) →\n                            (fin_len : ∃ n, filtration n = ⊤) →\n                              (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                (piecewise_coprimary :\n                                    ∀ n < Nat.find fin_len,\n                                      HarderNarasimhan.Coprimary R\n                                        (↥(filtration (n + 1)) ⧸\n                                          Submodule.submoduleOf (filtration n) (filtration (n + 1)))) →\n                                  (strict_mono_associated_prime :\n                                      ∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len),\n                                        { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }) →\n                                    motive\n                                      { filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot,\n                                        fin_len := fin_len, strict_mono := strict_mono,\n                                        piecewise_coprimary := piecewise_coprimary,\n                                        strict_mono_associated_prime := strict_mono_associated_prime }) →\n                      motive t",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "HarderNarasimhan.impl.instμ_Admissible",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "Option.none",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "instHSub",
   "PartialOrder.toPreorder",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GT.gt",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "Nontrivial",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.cast",
   "instDecidableAnd",
   "Subtype",
   "HarderNarasimhan.impl.HNFil",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HarderNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HarderNarasimhan.Convex μ) (f : ℕ → ℒ),\n  (∃ n, f n = ⊤) →\n    ∀ (n : ℕ) (h₂ : ∃ N ≥ n + 1, HarderNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n      Nat.find h₂ > 0 → ¬Nat.find h₂ - 1 < Nat.find h₂ → False",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Preorder", "Preorder.toLT"],
  "name": "StrictMono",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "OrderDual", "Equiv"],
  "name": "OrderDual.toDual",
  "constType": "{α : Type u_1} → α ≃ αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["AddCommMonoid", "Semiring"],
  "name": "Module",
  "constType":
  "(R : Type u) → (M : Type v) → [Semiring R] → [AddCommMonoid M] → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["PartialOrder", "OmegaCompletePartialOrder"],
  "name": "OmegaCompletePartialOrder.toPartialOrder",
  "constType":
  "{α : Type u_6} → [self : OmegaCompletePartialOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "SemilinearMapClass",
   "Submodule.mem_comap",
   "Module",
   "Membership.mem",
   "DFunLike.coe",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "_private.Mathlib.Algebra.Module.Submodule.Map.0._proof_13",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} {x : M} {F : Type u_9} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F σ₁₂ M M₂] {f : F}\n  {p : Submodule R₂ M₂}, (x ∈ Submodule.comap f p) = (f x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.WeakSlopeLike₂.rec",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakSlopeLike₂.mk",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₂.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakSlopeLike₂ μ → Sort u} →\n                (t : HarderNarasimhan.WeakSlopeLike₂ μ) →\n                  ((wsl₂ :\n                        ∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n                          μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references": ["Option"],
  "name": "Option.some",
  "constType": "{α : Type u} → α → Option α",
  "constCategory": "Other"},
 {"references": ["AddCommMonoid", "AddMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "instLTNat", "Nat", "Fin.val", "Fin", "LT.mk", "LT"],
  "name": "instLTFin",
  "constType": "{n : ℕ} → LT (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "LinearMap.instFunLike",
   "Module",
   "Submodule.module",
   "Submodule.map",
   "Membership.mem",
   "Submodule.map_subtype_top",
   "congrArg",
   "Submodule",
   "Submodule.subtype",
   "LinearMap.semilinearMapClass",
   "eq_top_iff",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq",
   "Preorder.toLE",
   "Submodule.map_le_iff_le_comap",
   "Submodule.instOrderTop",
   "Iff.trans",
   "SetLike.instMembership",
   "Submodule.instTop",
   "Iff.rfl",
   "LinearMap",
   "Iff.symm",
   "RingHomSurjective.ids",
   "Submodule.comap",
   "Submodule.setLike",
   "Iff",
   "LE.le",
   "id",
   "Submodule.completeLattice",
   "Top.top",
   "Eq.mpr",
   "Submodule.addCommMonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "Semiring"],
  "name": "Submodule.comap_subtype_eq_top",
  "constType":
  "∀ {R : Type u_1} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {p p' : Submodule R M}, Submodule.comap p.subtype p' = ⊤ ↔ p ≤ p'",
  "constCategory": "Theorem"},
 {"references":
  ["associatedPrimes",
   "CommRing.toCommSemiring",
   "HarderNarasimhan.Coprimary.noConfusionType",
   "HarderNarasimhan.Coprimary.casesOn",
   "Set",
   "Module",
   "Membership.mem",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "Set.instMembership",
   "IsNoetherianRing",
   "HarderNarasimhan.Coprimary",
   "Ideal",
   "AddCommGroup.toAddCommMonoid",
   "ExistsUnique",
   "Eq",
   "Eq.ndrec"],
  "name": "HarderNarasimhan.Coprimary.noConfusion",
  "constType":
  "{R : Type} →\n  {inst : CommRing R} →\n    {inst_1 : IsNoetherianRing R} →\n      {M : Type} →\n        {inst_2 : AddCommGroup M} →\n          {inst_3 : _root_.Module R M} →\n            {P : Sort u} →\n              {v1 v2 : HarderNarasimhan.Coprimary R M} → v1 = v2 → HarderNarasimhan.Coprimary.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Finset",
   "Set.mem_toFinset",
   "Set",
   "Membership.mem",
   "Finset.instMembership",
   "Set.toFinset",
   "Eq",
   "Fintype",
   "propext",
   "Set.Elem",
   "Set.instMembership"],
  "name": "HarderNarasimhan.impl.prop3d12p2._proof_4",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, (a ∈ s.toFinset) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "PartialOrder.mk",
   "DecidableLE",
   "DecidableEq",
   "Iff",
   "LE.mk",
   "id",
   "And",
   "LT.mk",
   "Preorder.mk",
   "decidableEqOfDecidableLE",
   "Eq"],
  "name":
  "HarderNarasimhan.TotallyOrderedRealVectorSpace.toDecidableEq._inherited_default",
  "constType":
  "{V : Type} →\n  (le lt : V → V → Prop) →\n    (∀ (a : V), le a a) →\n      (∀ (a b c : V), le a b → le b c → le a c) →\n        (∀ (a b : V), lt a b ↔ le a b ∧ ¬le b a) →\n          (∀ (a b : V), le a b → le b a → a = b) → DecidableLE V → DecidableEq V",
  "constCategory": "Definition"},
 {"references":
  ["Decidable",
   "Subsingleton.elim",
   "Classical.propDecidable",
   "HarderNarasimhan.S₂I",
   "HarderNarasimhan.S₁I",
   "HarderNarasimhan.S₁I._proof_1",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Nat.sub_one_add_one",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instLTNat",
   "Exists",
   "ne_of_gt",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "HarderNarasimhan.impl.HNFil_of_fin_len",
   "not_lt_of_ge",
   "HarderNarasimhan.InIntvl",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "HarderNarasimhan.Semistable",
   "HarderNarasimhan.impl.theorem3d10._proof_10",
   "Nat.find",
   "HarderNarasimhan.impl.instμ_Admissible",
   "Nat.add_one_pos",
   "HarderNarasimhan.Resμ",
   "Pi.instSubsingleton",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "HarderNarasimhan.impl.theorem3d10._proof_8",
   "Or.inl",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "Eq",
   "not_ne_iff",
   "Set",
   "HarderNarasimhan.impl.theorem3d10._proof_13",
   "lt_of_lt_of_le",
   "CompletelyDistribLattice.toCompleteLattice",
   "eq_self",
   "HarderNarasimhan.impl.HNFil_is_strict_mono",
   "AddZeroClass.toAdd",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "_private.Mathlib.Order.Defs.LinearOrder.0._proof_2",
   "PartialOrder.toPreorder",
   "le_of_le_of_eq",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "Nat.instAddCommMonoid",
   "GE.ge",
   "Nat.lt_add_one_iff",
   "Or",
   "PartialOrder",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HarderNarasimhan.impl.theorem3d10._proof_9",
   "Nat.instPartialOrder",
   "lt_of_le_of_lt",
   "And.right",
   "Bot.bot",
   "HarderNarasimhan.impl.semistableI_iff",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "Mathlib.Tactic.PushNeg.not_le_eq",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "SemilatticeInf.toMin",
   "HarderNarasimhan.StI",
   "instDecidableAnd",
   "Eq.mp",
   "le_trans",
   "DecidablePred",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "BoundedOrder.toOrderTop",
   "instSubsingletonDecidable",
   "Not",
   "not_and_or",
   "le_top",
   "instHAdd",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_3",
   "Nat.sub_le_sub_right",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "LT.lt",
   "lt_add_one",
   "of_eq_true",
   "One.toOfNat1",
   "instSubNat",
   "ne_of_lt",
   "le_of_lt",
   "Nat.succ",
   "SemilatticeSup.toMax",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "False",
   "Subtype.mk",
   "OrderTop.toTop",
   "_private.Init.Core.0._proof_39",
   "HarderNarasimhan.impl.lem2d4₃I",
   "instAddNat",
   "Eq.trans",
   "HarderNarasimhan.semistableI",
   "Exists.intro",
   "HarderNarasimhan.impl.theorem3d10._proof_7",
   "HarderNarasimhan.impl.theorem3d10._proof_15",
   "Membership.mem.out",
   "Subtype.val",
   "HarderNarasimhan.impl.theorem3d10._proof_5",
   "False.elim",
   "le_sup_right",
   "letFun",
   "Nat.le_of_lt_add_one",
   "Eq.ndrec",
   "le_iff_eq_or_lt",
   "HarderNarasimhan.impl.theorem3d10._proof_14",
   "rfl",
   "eq_of_ge_of_not_gt",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists.choose_spec",
   "eq_comm",
   "Nat.recAux",
   "Prod.snd",
   "HarderNarasimhan.impl.theorem3d10._proof_11",
   "Set.instMembership",
   "Prod",
   "Nat.find_spec",
   "BoundedOrder.toOrderBot",
   "Iff.not",
   "Eq.refl",
   "Lattice",
   "Classical.byContradiction",
   "Nat.sub_one_lt_of_le",
   "HarderNarasimhan.in_TotIntvl",
   "AddMonoid.toAddZeroClass",
   "Or.inr",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HarderNarasimhan.impl.HNlen",
   "Nat.instPreorder",
   "le_inf",
   "instOfNatNat",
   "congr",
   "WellFoundedGT",
   "not_true_eq_false",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "Preorder.toLE",
   "sup_le_iff",
   "propext",
   "inf_lt_left",
   "Nat.instAddMonoid",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Max.max",
   "HarderNarasimhan.μA",
   "dite",
   "right_lt_sup",
   "le_of_not_lt",
   "Nat.find_min",
   "le_refl",
   "Lattice.toSemilatticeSup",
   "HarderNarasimhan.impl.theorem3d10._proof_6",
   "Prod.mk",
   "_private.Init.Core.0._proof_38",
   "Iff.mp",
   "Nat.sub_one_lt",
   "HarderNarasimhan.impl.HNFil_prop_of_def",
   "And.intro",
   "Nat.sub_add_cancel",
   "funext",
   "HSub.hSub",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "Nat.add_one_le_iff",
   "And",
   "IsOrderedAddMonoid.toAddLeftMono",
   "HarderNarasimhan.impl.theorem3d10._proof_12",
   "HarderNarasimhan.TotIntvl",
   "HarderNarasimhan.impl.HNFil_ne_top_iff_lt_len",
   "Nat.decLt",
   "Nat.gt_of_not_le",
   "Decidable.byContradiction",
   "upperBounds",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "Subtype",
   "not_le_of_lt",
   "SemilatticeSup.toPartialOrder",
   "HarderNarasimhan.impl.HNFil",
   "congrArg",
   "eq_of_le_of_le",
   "Nat.instOne",
   "Nat.instIsOrderedCancelAddMonoid",
   "HarderNarasimhan.Interval",
   "OrderBot.toBot",
   "Lattice.toSemilatticeInf",
   "eq_of_le_of_not_lt",
   "True",
   "Nat.decLe",
   "Exists.choose",
   "Or.casesOn",
   "HarderNarasimhan.instNontrivialInterval",
   "Min.min",
   "LE.le",
   "instLENat"],
  "name": "HarderNarasimhan.impl.theorem3d10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HarderNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HarderNarasimhan.Convex μ) (f : ℕ → ℒ),\n  f 0 = ⊥ →\n    ∀ (hffin : ∃ n, f n = ⊤) (hfsi : ∀ (i j : ℕ), i < j → j ≤ Nat.find hffin → f i < f j),\n      (∀ i ≥ Nat.find hffin, f i = ⊤) →\n        (∀ (j : ℕ) (hj : j < Nat.find hffin),\n            HarderNarasimhan.Semistable (HarderNarasimhan.Resμ ⟨(f j, f (j + 1)), ⋯⟩ μ)) →\n          (∀ (i j : ℕ) (hij : i < j) (hj : j < Nat.find hffin),\n              HarderNarasimhan.μA μ ⟨(f i, f (i + 1)), ⋯⟩ > HarderNarasimhan.μA μ ⟨(f j, f (j + 1)), ⋯⟩) →\n            f = HarderNarasimhan.impl.HNFil μ",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "HarderNarasimhan.impl.prop4d18₁",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HarderNarasimhan.impl.prop4d18₂",
   "Prod.fst",
   "And.intro",
   "HarderNarasimhan.NashEquilibrium",
   "Or",
   "HarderNarasimhan.μBstar",
   "HarderNarasimhan.WeakSlopeLike₁",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.proposition_4_18",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Semistable μ →\n    HarderNarasimhan.μBstar μ ≤ HarderNarasimhan.μAstar μ ∧\n      (HarderNarasimhan.WeakAscendingChainCondition μ ∧ HarderNarasimhan.WeakSlopeLike₁ μ ∨\n          HarderNarasimhan.WeakDescendingChainCondition μ ∧ HarderNarasimhan.WeakSlopeLike₂ μ →\n        HarderNarasimhan.NashEquilibrium μ)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "OrderDual.toDual",
   "OrderDual",
   "PartialOrder.toPreorder",
   "Equiv.instFunLike",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "DFunLike.coe",
   "Equiv",
   "OrderDual.ofDual",
   "HarderNarasimhan.DedekindMacNeilleConnection",
   "OrderDual.instPreorder",
   "upperBounds",
   "GaloisConnection.closureOperator",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "lowerBounds",
   "Preorder.toLE"],
  "name": "HarderNarasimhan.DedekindMacNeilleClosureOperator",
  "constType": "(α : Type) → [PartialOrder α] → ClosureOperator (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.NashEquilibrium.casesOn",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.μBstar",
   "Nontrivial",
   "Lattice",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.NashEquilibrium.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u → HarderNarasimhan.NashEquilibrium μ → HarderNarasimhan.NashEquilibrium μ → Sort u",
  "constCategory": "Definition"},
 {"references": ["HeytingAlgebra", "BiheytingAlgebra"],
  "name": "BiheytingAlgebra.toHeytingAlgebra",
  "constType":
  "{α : Type u_4} → [self : BiheytingAlgebra α] → HeytingAlgebra α",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Neg"],
  "name": "SubNegMonoid.toNeg",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Neg G",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "Equiv",
   "And.intro",
   "SupSet.sSup",
   "HarderNarasimhan.μBstar",
   "funext",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "ConditionallyCompleteLattice.toInfSet",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Set.ext",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "OrderDual.instBoundedOrder",
   "setOf",
   "HarderNarasimhan.μAstar",
   "OrderDual",
   "OrderDual.toDual",
   "Ne.symm",
   "Subtype",
   "OrderDual.instLattice",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "Iff.intro",
   "congrArg",
   "OrderDual.ofDual",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "HarderNarasimhan.μmin",
   "OrderDual.instLT",
   "BoundedOrder.toOrderTop",
   "congr",
   "OrderDual.instCompleteLattice",
   "InfSet.sInf",
   "OrderDual.instPartialOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Not",
   "_private.Mathlib.Order.Synonym.0._proof_6",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "Set",
   "HarderNarasimhan.μmax._proof_2",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.impl.dualμBstar_eq_μAstar",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  OrderDual.ofDual\n    ((HarderNarasimhan.μBstar fun p => OrderDual.toDual (μ ⟨((↑p).2, (↑p).1), ⋯⟩)) = HarderNarasimhan.μAstar μ)",
  "constCategory": "Theorem"},
 {"references": ["Iff", "LE.le", "LE", "Iff.rfl", "GE.ge"],
  "name": "ge_iff_le",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, x ≥ y ↔ y ≤ x",
  "constCategory": "Theorem"},
 {"references": ["SDiff", "BiheytingAlgebra"],
  "name": "BiheytingAlgebra.toSDiff",
  "constType": "{α : Type u_4} → [self : BiheytingAlgebra α] → SDiff α",
  "constCategory": "Definition"},
 {"references":
  ["Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "Preorder.toLT",
   "Classical.propDecidable",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Int.instLEInt",
   "Eq.symm",
   "HSub.hSub",
   "HarderNarasimhan.JordanHolderFiltration",
   "CompleteLinearOrder",
   "Int.add_one_le_of_lt",
   "List.cons",
   "Bool.true",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Bot.bot",
   "Int.instNegInt",
   "Prod",
   "instDecidableEqBool",
   "Nat",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Lean.Omega.Constraint.addEquality_sat",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Bool",
   "Subtype",
   "Nat.cast",
   "Lean.Omega.Constraint.combine_sat'",
   "Option.some",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Prod.fst",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "instNatCastInt",
   "of_decide_eq_true",
   "List.nil",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Option.none",
   "instSubNat",
   "LE.le",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "instLENat"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_10",
  "constType":
  "∀ (n : ℕ) (ℒ : Type) (ntl : Nontrivial ℒ) (l : Lattice ℒ) (bo : BoundedOrder ℒ) (wacc : WellFoundedGT ℒ) (S : Type)\n  (clo : CompleteLinearOrder S) (μ : { p // p.1 < p.2 } → S) (JHy JHx : HarderNarasimhan.JordanHolderFiltration μ),\n  0 < Nat.find ⋯ - 1 → ¬Nat.find ⋯ - 1 < Nat.find ⋯ → False",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "DecidableLE",
   "PartialOrder.toPreorder",
   "Decidable",
   "Decidable.isFalse",
   "DecidableEq",
   "decidableEqOfDecidableLE._proof_4",
   "decidableEqOfDecidableLE._proof_3",
   "decidableLTOfDecidableLE.match_1",
   "PartialOrder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "dite",
   "le_antisymm",
   "Decidable.isTrue"],
  "name": "decidableEqOfDecidableLE",
  "constType":
  "{α : Type u_1} → [inst : PartialOrder α] → [DecidableLE α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "Or",
   "LE.le",
   "LinearOrder",
   "Preorder.toLE"],
  "name": "LinearOrder.le_total",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.SlopeLike",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.impl.rmk4d13",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "List.tfae_of_cycle",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "eq_of_le_of_le",
   "HarderNarasimhan.μmin",
   "HarderNarasimhan.impl.rmk4d10₀",
   "letFun",
   "Eq.symm",
   "List.TFAE",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "List.nil",
   "HarderNarasimhan.impl.prop4d12",
   "HarderNarasimhan.impl.prop4d14",
   "Lattice.toSemilatticeInf",
   "List.Chain.cons",
   "And.right",
   "And",
   "BoundedOrder",
   "List.Chain.nil",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.impl.rmk4d15",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop4d16₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ →\n    [HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl,\n        HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl,\n        HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl].TFAE",
  "constCategory": "Theorem"},
 {"references":
  ["Fin.instLinearOrder._proof_2",
   "LinearOrder",
   "Fin",
   "Fin.instLinearOrder._proof_3",
   "LinearOrder.liftWithOrd",
   "Fin.instLinearOrder._proof_5",
   "Fin.instLinearOrder._proof_4",
   "instOrdFin",
   "Max.mk",
   "Min.mk",
   "Nat.instMax_mathlib",
   "Nat",
   "Max.max",
   "Fin.val",
   "Fin.val_injective",
   "Min.min",
   "Nat.instMin_mathlib",
   "Fin.mk",
   "Nat.instLinearOrder",
   "Fin.instLinearOrder._proof_1"],
  "name": "Fin.instLinearOrder",
  "constType": "{n : ℕ} → LinearOrder (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["sorryAx",
   "Submodule.toAddSubmonoid",
   "Lean.Name",
   "Submodule.Quotient.module",
   "Lean.Name.str",
   "Bool.false",
   "Membership.mem",
   "Inter.inter",
   "LinearMap.semilinearMapClass",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "Semiring.toModule",
   "NonAssocSemiring.toMulZeroOneClass",
   "Set.instInter",
   "Set.instSDiff",
   "LinearMap.ker",
   "SetLike.instMembership",
   "LocalizedModule",
   "Submonoid.instSetLike",
   "Submodule.addCommGroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "LinearMap",
   "Set.instMembership",
   "Submonoid",
   "Nat",
   "SetLike.coe",
   "LocalizedModule.isModule'",
   "Iff",
   "AddCommGroup.toAddCommMonoid",
   "AddSubmonoid.toAddSubsemigroup",
   "setOf",
   "AddMonoid.toAddZeroClass",
   "associatedPrimes",
   "Submodule.hasQuotient",
   "Lean.Name.anonymous",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "LocalizedModule.instAddCommMonoid",
   "MulZeroOneClass.toMulOneClass",
   "AddCommMonoid.toAddMonoid",
   "EmptyCollection.emptyCollection",
   "Set.instEmptyCollection",
   "LocalizedModule.mkLinearMap",
   "Submodule",
   "AddSubsemigroup.carrier",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "Eq",
   "CommRing.toCommSemiring",
   "Set",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "CommRing",
   "OfNat.ofNat",
   "CommRing.toRing",
   "IsNoetherianRing",
   "AddZeroClass.toAdd",
   "Submodule.setLike",
   "SDiff.sdiff",
   "Lean.Name.num"],
  "name":
  "HarderNarasimhan.impl.bourbaki_elements_math_alg_comm_chIV_sec1_no2_prop6",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [IsNoetherianRing R] {M : Type} [inst_2 : AddCommGroup M] [inst_3 : _root_.Module R M]\n  (S : Submonoid R) (N : Submodule R M),\n  associatedPrimes R ↥N = associatedPrimes R M \\ {p | p ∈ associatedPrimes R M ∧ p.carrier ∩ ↑S = ∅} ∧\n      associatedPrimes R (M ⧸ N) = {p | p ∈ associatedPrimes R M ∧ p.carrier ∩ ↑S = ∅} ↔\n    N = LinearMap.ker (LocalizedModule.mkLinearMap S M)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "EmptyCollection.emptyCollection",
   "Set.instEmptyCollection",
   "DFunLike.coe",
   "ClosureOperator.instFunLike",
   "Set.instCompleteAtomicBooleanAlgebra",
   "ClosureOperator.isClosed_closure"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_16",
  "constType": "∀ {α : Type} (T : ClosureOperator (Set α)), T.IsClosed (T ∅)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "True",
   "_private.Mathlib.Order.Lattice.0._proof_9",
   "SemilatticeSup.toPartialOrder",
   "And",
   "congrArg",
   "and_self",
   "Max.max",
   "_private.Mathlib.Order.Lattice.0._proof_7",
   "of_eq_true",
   "congr",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Eq",
   "Preorder.toLE",
   "le_antisymm",
   "_private.Mathlib.Order.Lattice.0._proof_8"],
  "name": "sup_comm",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] (a b : α), a ⊔ b = b ⊔ a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "Nonneg.coe_zero",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toSemiring",
   "Subtype.val",
   "OfNat.ofNat",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "DistribLattice.toLattice",
   "MulZeroClass.toZero",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semifield",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "Preorder.toLE",
   "Eq",
   "Nonneg.zero",
   "SemilatticeInf.toPartialOrder"],
  "name": "Nonneg.semifield._proof_15",
  "constType":
  "∀ {α : Type u_1} [inst : Semifield α] [inst_1 : LinearOrder α], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat.find",
   "Nat.le_of_not_lt",
   "Nat",
   "Exists",
   "LE.le",
   "DecidablePred",
   "instLENat",
   "Nat.find_min"],
  "name": "Nat.find_min'",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n) {m : ℕ}, p m → Nat.find H ≤ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteLattice",
  "constType": "Type u_8 → Type u_8",
  "constCategory": "Other"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "MonoidWithZero.toMulZeroOneClass",
   "Subtype.val",
   "instDistribLatticeOfLinearOrder",
   "MonoidWithZero.toMonoid",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Nonneg.semifield._proof_13",
   "instHPow",
   "Nonneg.pow",
   "Lattice.toSemilatticeInf",
   "IsStrictOrderedRing",
   "IsStrictOrderedRing.toIsOrderedRing",
   "LinearOrder",
   "Semiring.toMonoidWithZero",
   "DivisionSemiring.toSemiring",
   "HPow.hPow",
   "Nonneg.semifield._proof_12",
   "OfNat.ofNat",
   "Nat",
   "DistribLattice.toLattice",
   "Monoid.toNatPow",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toZero",
   "LE.le",
   "Semifield",
   "Nonneg.coe_pow",
   "IsOrderedRing.toPosMulMono",
   "IsStrictOrderedRing.toZeroLEOneClass"],
  "name": "Nonneg.semifield._proof_18",
  "constType":
  "∀ {α : Type u_1} [inst : Semifield α] [inst_1 : LinearOrder α] [inst_2 : IsStrictOrderedRing α] (a : { x // 0 ≤ x })\n  (n : ℕ), ↑(a ^ n) = ↑a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.SlopeLike",
   "Or.inr",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "not_le_of_lt",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "And.intro",
   "Or.inl",
   "Or",
   "BoundedOrder.toOrderTop",
   "letFun",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Bot.bot",
   "Or.casesOn",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "HarderNarasimhan.SlopeLike.slopelike",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.rmk4d13",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ →\n    ∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      ¬μ ⟨(⊥, x), ⋯⟩ ≤ μ HarderNarasimhan.TotIntvl ∨ μ HarderNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Eq.symm",
   "HarderNarasimhan.JordanHolderFiltration",
   "Int.instLTInt",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "HEq",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "HarderNarasimhan.JordanHolderFiltration.noConfusion",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Eq.propIntro",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "instHAdd",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Eq.casesOn",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.mk.injEq",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} (filtration : ℕ → ℒ) (antitone : Antitone filtration)\n  (fin_len : ∃ N, filtration N = ⊥)\n  (strict_anti : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration j < filtration i)\n  (first_eq_top : filtration 0 = ⊤)\n  (step_cond₁ : ∀ (k : ℕ) (hk : k < Nat.find fin_len), μ ⟨(filtration (k + 1), filtration k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩)\n  (step_cond₂ :\n    ∀ (i : ℕ) (hi : i < Nat.find fin_len) (z : ℒ) (h' : filtration (i + 1) < z),\n      z < filtration i → μ ⟨(filtration (i + 1), z), h'⟩ < μ ⟨(filtration (i + 1), filtration i), ⋯⟩)\n  (filtration_1 : ℕ → ℒ) (antitone_1 : Antitone filtration_1) (fin_len_1 : ∃ N, filtration_1 N = ⊥)\n  (strict_anti_1 : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len_1 → filtration_1 j < filtration_1 i)\n  (first_eq_top_1 : filtration_1 0 = ⊤)\n  (step_cond₁_1 :\n    ∀ (k : ℕ) (hk : k < Nat.find fin_len_1), μ ⟨(filtration_1 (k + 1), filtration_1 k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩)\n  (step_cond₂_1 :\n    ∀ (i : ℕ) (hi : i < Nat.find fin_len_1) (z : ℒ) (h' : filtration_1 (i + 1) < z),\n      z < filtration_1 i → μ ⟨(filtration_1 (i + 1), z), h'⟩ < μ ⟨(filtration_1 (i + 1), filtration_1 i), ⋯⟩),\n  ({ filtration := filtration, antitone := antitone, fin_len := fin_len, strict_anti := strict_anti,\n        first_eq_top := first_eq_top, step_cond₁ := step_cond₁, step_cond₂ := step_cond₂ } =\n      { filtration := filtration_1, antitone := antitone_1, fin_len := fin_len_1, strict_anti := strict_anti_1,\n        first_eq_top := first_eq_top_1, step_cond₁ := step_cond₁_1, step_cond₂ := step_cond₂_1 }) =\n    (filtration = filtration_1)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "LinearMap.ker",
   "AddZeroClass.toZero",
   "SemilinearMapClass",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "OfNat.ofNat",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "LinearMap.mem_ker",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "HarderNarasimhan.impl.assp._proof_1",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {τ₁₂ : R →+* R₂} {F : Type u_11} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F τ₁₂ M M₂] {f : F} {y : M},\n  (y ∈ LinearMap.ker f) = (f y = 0)",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE", "Eq.rec", "Eq"],
  "name": "le_of_le_of_eq",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LE α], a ≤ b → b = c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Inter"],
  "name": "Inter.inter",
  "constType": "{α : Type u} → [self : Inter α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Nat.find",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "HarderNarasimhan.impl.function_wrapper._proof_6",
   "Preorder.toLT",
   "Classical.propDecidable",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Bot.bot",
   "LT.lt",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nat.succ",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "OrderBot.toBot",
   "dite",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.function_wrapper.eq_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ) (atf : ∃ k, f k = ⊥)\n  (n_1 : ℕ),\n  HarderNarasimhan.impl.function_wrapper f atf n_1.succ =\n    if hcond : HarderNarasimhan.impl.function_wrapper f atf n_1 = ⊥ then ⊥ else f (Nat.find ⋯)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "ne_eq",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "Eq.symm",
   "Ne",
   "Eq",
   "Eq.rec"],
  "name": "Mathlib.Tactic.PushNeg.not_ne_eq",
  "constType": "∀ {α : Sort u_1} (x y : α), (¬x ≠ y) = (x = y)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "SupSet.sSup",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.μmax._proof_2",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μmax",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "HarderNarasimhan.HarderNarasimhanFiltration.casesOn",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.ext.match_1",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HarderNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HarderNarasimhan.Convex μ} {h : HarderNarasimhan.μ_Admissible μ}\n  (motive : HarderNarasimhan.HarderNarasimhanFiltration μ → Prop) (h_1 : HarderNarasimhan.HarderNarasimhanFiltration μ),\n  (∀ (filtration : ℕ → ℒ) (monotone : Monotone filtration) (first_eq_bot : filtration 0 = ⊥)\n      (fin_len : ∃ n, filtration n = ⊤)\n      (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j)\n      (piecewise_semistable :\n        ∀ (i : ℕ) (h : i < Nat.find fin_len),\n          HarderNarasimhan.Semistable (HarderNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ))\n      (μA_pseudo_strict_anti :\n        ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n          ¬HarderNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n              HarderNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩),\n      motive\n        { filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot, fin_len := fin_len,\n          strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n          μA_pseudo_strict_anti := μA_pseudo_strict_anti }) →\n    motive h_1",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.ConvexI.mk",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.InIntvl",
   "Min.min",
   "Iff.mpr",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.ConvexI.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {S : Type} [inst_1 : CompleteLattice S] {I : { p // p.1 < p.2 }}\n  {μ : { p // p.1 < p.2 } → S},\n  (∀ (x y : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        HarderNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩) →\n    HarderNarasimhan.ConvexI I μ",
  "constCategory": "Definition"},
 {"references":
  ["add_left_comm",
   "Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "congr",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq.ndrec",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddSemigroup.toAdd",
   "Distrib.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "True",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "AddCommMonoid.toAddCommSemigroup",
   "add_assoc",
   "AddMonoid.toAddSemigroup"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b₁ b₂ c₁ c₂ : R},\n  a₁ + b₁ = c₁ → a₂ + b₂ = c₂ → a₁ + a₂ + (b₁ + b₂) = c₁ + c₂",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.instAddMonoid",
   "Nat",
   "AddZeroClass.toZero",
   "MulZeroClass",
   "instMulNat",
   "MulZeroClass.mk",
   "Nat.zero_mul",
   "Nat.mul_zero",
   "AddMonoid.toAddZeroClass"],
  "name": "Nat.instMulZeroClass",
  "constType": "MulZeroClass ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Bool",
   "True",
   "Eq.trans",
   "BEq",
   "congrArg",
   "_private.Init.Core.0._proof_22",
   "iff_self",
   "Bool.eq_iff_iff",
   "of_eq_true",
   "LawfulBEq",
   "congr",
   "Iff",
   "id",
   "Eq.mpr",
   "Eq",
   "BEq.beq",
   "Bool.true",
   "propext"],
  "name": "beq_eq_beq",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : BEq α] [LawfulBEq α] [inst_2 : BEq β] [LawfulBEq β] {a₁ a₂ : α} {b₁ b₂ : β},\n  (a₁ == a₂) = (b₁ == b₂) ↔ (a₁ = a₂ ↔ b₁ = b₂)",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Int"],
  "name": "Int.ofNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references": ["Exists", "Finset", "Membership.mem", "Finset.instMembership"],
  "name": "Finset.Nonempty",
  "constType": "{α : Type u_1} → Finset α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "BoundedOrder",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_17",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ], ⊥ < ⊤",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "WellFounded",
  "constType": "{α : Sort u} → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Preorder.toLT",
   "OfNat.ofNat",
   "Nat.lt_add_one",
   "Nat.instPreorder",
   "LT.lt",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "Lattice",
   "StrictMono",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (x : ℕ → ℒ), StrictMono x → ∀ (N : ℕ), x N < x (N + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "le_top",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "Nat.lt_add_one",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "Lattice",
   "Top.top",
   "OrderTop.toTop",
   "StrictMono"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (x : ℕ → ℒ), StrictMono x → ∀ (N : ℕ), (x N, ⊤).1 < (x N, ⊤).2",
  "constCategory": "Theorem"},
 {"references":
  ["True", "Iff.mpr", "Iff", "Eq", "trivial", "propext", "Iff.intro"],
  "name": "iff_true",
  "constType": "∀ (p : Prop), (p ↔ True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["rfl", "Subtype", "Subtype.ext.match_1", "Subtype.mk", "Eq", "Subtype.val"],
  "name": "Subtype.ext",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.WeakSlopeLike₁.casesOn",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₁.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u → HarderNarasimhan.WeakSlopeLike₁ μ → HarderNarasimhan.WeakSlopeLike₁ μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.StI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HarderNarasimhan.S₂I",
   "Subtype.val",
   "HarderNarasimhan.S₁I",
   "Prod.fst",
   "eq_of_le_of_le",
   "le_of_not_gt",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "HarderNarasimhan.S₁I._proof_1",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Exists.casesOn",
   "LinearOrder.toPartialOrder",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.InIntvl",
   "Lattice",
   "Nontrivial",
   "Ne",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "And.casesOn"],
  "name": "HarderNarasimhan.impl.rmk3d5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  ∀ x ∈ HarderNarasimhan.StI μ I, ∀ y ∈ HarderNarasimhan.StI μ I, x = y",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.ConvexI",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "Bot.bot",
   "HarderNarasimhan.IsComparable",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "le_total",
   "Or.inr",
   "Subtype",
   "not_le_of_lt",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "le_rfl",
   "Or.inl",
   "BoundedOrder.toOrderTop",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "HarderNarasimhan.impl.prop2d6₃I",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_top",
   "Or.casesOn",
   "CompletelyDistribLattice.toCompleteLattice",
   "LT.lt",
   "HarderNarasimhan.μA",
   "le_of_lt",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top"],
  "name": "HarderNarasimhan.impl.rmk2d7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI ⟨(⊥, ⊤), ⋯⟩ μ →\n    ∀ (x : ℒ) (h : ⊥ < x ∧ x < ⊤),\n      HarderNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HarderNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩ →\n        HarderNarasimhan.μA μ ⟨(x, ⊤), ⋯⟩ = HarderNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "Submodule.hasQuotient",
   "Subtype",
   "SemilinearMapClass",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "RingHom.id._at.HarderNarasimhan.impl.lift_quot._spec_9",
   "FunLike",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "CommSemiring.toSemiring",
   "Submodule.addCommGroup",
   "AddCommGroup",
   "LinearMap",
   "CommRing",
   "Ring.toSemiring",
   "CommRing.toRing",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.addCommMonoid",
   "Submodule.submoduleOf._at.HarderNarasimhan.impl.lift_quot._spec_4",
   "Semiring",
   "Ring",
   "Submodule.submoduleOf"],
  "name": "Submodule.comap._at.HarderNarasimhan.impl.lift_quot._spec_17",
  "constType":
  "(R : Type) →\n  (inst : CommRing R) →\n    (M : Type) →\n      (inst_1 : AddCommGroup M) →\n        (inst_2 : _root_.Module R M) →\n          (N₁ N₂ : Submodule R M) →\n            (_x_1 : Ring R) →\n              let _x_2 := _x_1.1;\n              (_x_6 : Semiring R) →\n                let _x_7 := N₂.addCommGroup;\n                let _x_8 := AddCommGroup.toAddCommMonoid;\n                (_x_9 : AddCommMonoid M) →\n                  let _x_10 := N₂.module;\n                  let _x_16 :=\n                    Submodule.submoduleOf._at.HarderNarasimhan.impl.lift_quot._spec_4 R inst M inst_1 inst_2 N₁ N₂;\n                  let _x_17 := Submodule.Quotient.addCommGroup _x_16;\n                  let _x_18 := AddCommGroup.toAddCommMonoid;\n                  let _x_19 := Submodule.Quotient.module _x_16;\n                  let _x_21 := RingHom.id._at.HarderNarasimhan.impl.lift_quot._spec_9 R inst;\n                  let _x_22 := AddCommGroup.toAddCommMonoid;\n                  let _x_23 := LinearMap.instFunLike;\n                  let _y_5 := _x_2;\n                  let _y_6 := _x_6;\n                  let _y_7 := _x_8;\n                  let _y_8 := _x_18;\n                  let _y_9 := _x_10;\n                  let _y_10 := _x_19;\n                  let _y_12 := _x_23;\n                  {σ₁₂ : R →+* R} →\n                    SemilinearMapClass (↥N₂ →ₗ[R] ↥N₂ ⧸ N₁.submoduleOf N₂) σ₁₂ (↥N₂) (↥N₂ ⧸ N₁.submoduleOf N₂) →\n                      (↥N₂ →ₗ[R] ↥N₂ ⧸ N₁.submoduleOf N₂) → Submodule R (↥N₂ ⧸ N₁.submoduleOf N₂) → Submodule R ↥N₂",
  "constCategory": "Axiom"},
 {"references":
  ["not_le",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_le_eq",
  "constType":
  "∀ {β : Type u_2} [inst : LinearOrder β] (a b : β), (¬a ≤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "LE",
   "OrderDual.instOrderBot",
   "OrderTop",
   "BoundedOrder",
   "inferInstanceAs",
   "OrderDual.instLE",
   "BoundedOrder.mk",
   "OrderBot",
   "OrderDual.instOrderTop"],
  "name": "OrderDual.instBoundedOrder",
  "constType":
  "(α : Type u) → [inst : LE α] → [BoundedOrder α] → BoundedOrder αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid",
   "DivisionMonoid",
   "DivisionMonoid.toDivInvOneMonoid._proof_15",
   "DivInvOneMonoid",
   "DivInvOneMonoid.mk"],
  "name": "DivisionMonoid.toDivInvOneMonoid",
  "constType": "{α : Type u_1} → [DivisionMonoid α] → DivInvOneMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "InfSet",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μA._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderDual",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Definition"},
 {"references": ["RingHom", "Semiring.toNonAssocSemiring", "Semiring"],
  "name": "RingHomSurjective",
  "constType":
  "{R₁ : Type u_1} → {R₂ : Type u_2} → [inst : Semiring R₁] → [inst_1 : Semiring R₂] → (R₁ →+* R₂) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "OrderDual",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.inf",
   "OrderDual.instSemilatticeSup",
   "OrderDual.instLattice._proof_26",
   "Lattice",
   "Lattice.mk",
   "OrderDual.instLattice._proof_27",
   "OrderDual.instLattice._proof_25",
   "OrderDual.instSemilatticeInf"],
  "name": "OrderDual.instLattice",
  "constType": "(α : Type u_1) → [Lattice α] → Lattice αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "Submodule.module._proof_36",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "SMulZeroClass.toSMul",
   "instDistribSMul",
   "AddMonoidWithOne.toAddMonoid",
   "Submodule",
   "Submodule.module'",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Submodule.addCommMonoid",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring",
   "AddMonoid.toAddZeroClass",
   "DistribSMul.toSMulZeroClass"],
  "name": "Submodule.module",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] →\n      [inst_1 : AddCommMonoid M] → {module_M : _root_.Module R M} → (p : Submodule R M) → _root_.Module R ↥p",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Nat.find",
   "PartialOrder.toPreorder",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "instLTNat",
   "CommRing.toCommSemiring",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "AddCommGroup",
   "CommRing",
   "LT.lt",
   "Nat",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Nontrivial",
   "LE.le",
   "Submodule.completeLattice",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "HarderNarasimhan.CoprimaryFiltration.fin_len",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.strict_mono",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (self : HarderNarasimhan.CoprimaryFiltration R M) (i j : ℕ),\n  i < j → j ≤ Nat.find ⋯ → self.filtration i < self.filtration j",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Decidable",
   "Subsingleton.elim",
   "Classical.propDecidable",
   "eq_true",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "Int.instLTInt",
   "Eq.symm",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "true_and",
   "Ring.toSemiring",
   "Nat.le_succ",
   "instOfNat",
   "eq_false",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Eq.mpr",
   "covariant_swap_add_of_covariant_add",
   "Nat.find",
   "Pi.instSubsingleton",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "HPow.hPow",
   "lt_of_lt_of_le",
   "Nat.cast_add",
   "eq_self",
   "and_self",
   "dite_cond_eq_true",
   "Monoid.toNatPow",
   "instHSub",
   "contravariant_swap_add_of_contravariant_add",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "Nat.instAddCommMonoid",
   "GE.ge",
   "IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT",
   "IsCancelAdd.toIsRightCancelAdd",
   "Semiring.toNonAssocSemiring",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Eq.rec",
   "Int.ofNat",
   "_private.Mathlib.Algebra.Order.Monoid.Unbundled.Basic.0._proof_4",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "of_eq_false",
   "Nat.instPartialOrder",
   "And.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Exists.casesOn",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "le_bot_iff",
   "Nat.cast",
   "Eq.mp",
   "DecidablePred",
   "lt_of_le_of_ne",
   "CommRing.toNonUnitalCommRing",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommSemigroup.toAddCommMagma",
   "instSubsingletonDecidable",
   "dite_cond_eq_false",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "of_eq_true",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "le_of_lt",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "False",
   "lt_self_iff_false",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Nat.instAddCommSemigroup",
   "Exists.intro",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "letFun",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Nat.recAux",
   "HarderNarasimhan.impl.function_wrapper",
   "Nat.find_spec",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Classical.byContradiction",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "contravariant_lt_of_covariant_le",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "AddCommMagma.toAdd",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instDecidableEqNat",
   "dite",
   "neg_neg_of_pos",
   "le_of_not_lt",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "_private.Init.Core.0._proof_38",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "And.intro",
   "Ring.toAddGroupWithOne",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "And",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "True",
   "HarderNarasimhan.impl.function_wrapper._proof_6",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.impl.function_wrapper_prop0'",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ) (atf : ∃ k, f k = ⊥),\n  Antitone f → f 0 = ⊤ → ∀ (i : ℕ), ∃ j ≥ i, HarderNarasimhan.impl.function_wrapper f atf i = f j",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Bot.mk",
   "Preorder.toLT",
   "LE",
   "Subtype.val",
   "BoundedOrder.mk",
   "Prod.fst",
   "PartialOrder",
   "Bot",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "OrderBot.mk",
   "OrderBot",
   "OrderTop.mk",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Top",
   "And",
   "OrderTop",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "SemilatticeInf",
   "Preorder",
   "lcProof",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.mk",
   "Subtype.mk"],
  "name": "HarderNarasimhan.instBoundedOrderInterval._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → BoundedOrder (HarderNarasimhan.Interval z)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HarderNarasimhan.μB",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Bot",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderBot",
   "Top",
   "BoundedOrder",
   "OrderTop",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "lcProof",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μBstar._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → S",
  "constCategory": "Definition"},
 {"references":
  ["Int.instSub",
   "instOfNat",
   "Eq.refl",
   "Int.sub_self",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "instHSub",
   "Eq",
   "OfNat.ofNat",
   "congrArg",
   "Int"],
  "name": "Int.sub_eq_zero_of_eq",
  "constType": "∀ {a b : ℤ}, a = b → a - b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "CommGroupWithZero.toDivisionCommMonoid",
   "Subtype.val",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "Preorder.toLE",
   "Eq",
   "DivisionCommMonoid.toDivisionMonoid",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Inv.inv",
   "Lattice.toSemilatticeInf",
   "IsStrictOrderedRing",
   "InvOneClass.toInv",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toSemiring",
   "OfNat.ofNat",
   "DivInvOneMonoid.toInvOneClass",
   "DistribLattice.toLattice",
   "MulZeroClass.toZero",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semifield",
   "Nonneg.inv",
   "DivisionMonoid.toDivInvOneMonoid",
   "Semifield.toCommGroupWithZero"],
  "name": "Nonneg.coe_inv",
  "constType":
  "∀ {α : Type u_1} [inst : Semifield α] [inst_1 : LinearOrder α] [inst_2 : IsStrictOrderedRing α] (a : { x // 0 ≤ x }),\n  ↑a⁻¹ = (↑a)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.impl.prop2d8₁I",
   "Prod.mk",
   "HarderNarasimhan.ConvexI",
   "Preorder.toLT",
   "sup_le",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.IsComparable",
   "Exists.casesOn",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "ConditionallyCompleteLattice.toLattice",
   "inf_comm",
   "SemilatticeInf.toMin",
   "Or.inr",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "Or.inl",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.impl.prop2d8₀I",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.IsAttained._proof_4",
   "inf_eq_left",
   "LT.lt",
   "Or.casesOn",
   "Max.max",
   "HarderNarasimhan.μA",
   "Min.min",
   "SemilatticeSup.toMax",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "lt_sup_of_lt_left"],
  "name": "HarderNarasimhan.impl.prop2d8₂I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HarderNarasimhan.InIntvl I y →\n            ∀ (u : ℒ),\n              HarderNarasimhan.InIntvl I u →\n                ∀ (h : u < x ∧ u < y),\n                  HarderNarasimhan.IsComparable (HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩)\n                        (HarderNarasimhan.μA μ ⟨(u, y), ⋯⟩) ∨\n                      HarderNarasimhan.IsAttained μ ⟨(u, x ⊔ y), ⋯⟩ →\n                    HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩ ∨\n                      HarderNarasimhan.μA μ ⟨(u, y), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["le_refl", "Preorder", "True", "LE.le", "eq_true", "Eq", "Preorder.toLE"],
  "name": "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "Prod.fst",
   "SupSet.sSup",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.μmax._proof_2",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μmax.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.μmax μ I = sSup {x | ∃ u, ∃ (h : HarderNarasimhan.InIntvl I u ∧ (↑I).1 ≠ u), μ ⟨((↑I).1, u), ⋯⟩ = x}",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "isMax_top",
   "Preorder",
   "Preorder.toLT",
   "Top.top",
   "OrderTop",
   "IsMax.not_lt",
   "Preorder.toLE",
   "OrderTop.toTop"],
  "name": "not_top_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α] {a : α}, ¬⊤ < a",
  "constCategory": "Theorem"},
 {"references":
  ["zero_le'",
   "Ne.symm",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "CommMonoidWithZero.toMonoidWithZero",
   "LinearOrderedCommMonoidWithZero.toLinearOrder",
   "ne_of_gt",
   "Preorder.toLT",
   "MonoidWithZero.toMulZeroOneClass",
   "lt_of_le_of_ne",
   "LinearOrderedCommMonoidWithZero",
   "OfNat.ofNat",
   "Iff.intro",
   "LT.lt",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toZero",
   "Iff",
   "Ne",
   "Zero.toOfNat0",
   "LinearOrderedCommMonoidWithZero.toCommMonoidWithZero",
   "SemilatticeInf.toPartialOrder"],
  "name": "zero_lt_iff",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedCommMonoidWithZero α] {a : α}, 0 < a ↔ a ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name": "HarderNarasimhan.μmax._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["GroupWithZero", "MonoidWithZero"],
  "name": "GroupWithZero.toMonoidWithZero",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → MonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references":
  ["absurd",
   "Not",
   "rfl",
   "Subsingleton",
   "Decidable.isFalse",
   "Decidable",
   "Subsingleton.intro",
   "Eq",
   "instSubsingletonDecidable.match_1",
   "Decidable.isTrue"],
  "name": "instSubsingletonDecidable",
  "constType": "∀ (p : Prop), Subsingleton (Decidable p)",
  "constCategory": "Theorem"},
 {"references": ["Subtype", "LE.le", "LE.mk", "LE", "Subtype.val"],
  "name": "Subtype.le",
  "constType": "{α : Type u_2} → [LE α] → {p : α → Prop} → LE (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nat",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.JordanHolderFiltration.first_eq_top",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} (self : HarderNarasimhan.JordanHolderFiltration μ),\n  self.filtration 0 = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.Affine",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "inf_lt_left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HarderNarasimhan.Affine.casesOn",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.Affine.noConfusionType",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HarderNarasimhan.Affine.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.Affine μ} → v1 = v2 → HarderNarasimhan.Affine.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "IsStrictOrderedRing",
   "Lattice.toSemilatticeInf",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toSemiring",
   "ZeroLEOneClass",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "DistribLattice.toLattice",
   "MulZeroClass.toZero",
   "AddMonoidWithOne.toOne",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semifield",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Semifield.toDivisionSemiring",
   "Preorder.toLE",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "SemilatticeInf.toPartialOrder",
   "IsStrictOrderedRing.toZeroLEOneClass"],
  "name": "Nonneg.semifield._proof_13",
  "constType":
  "∀ {α : Type u_1} [inst : Semifield α] [inst_1 : LinearOrder α] [IsStrictOrderedRing α], ZeroLEOneClass α",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.fst",
   "LT.lt",
   "Nat",
   "BoundedOrder.toOrderTop",
   "Nat.succ",
   "Iff.mpr",
   "Lattice",
   "Nat.below",
   "Top.top",
   "Ne",
   "lt_top_iff_ne_top",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.HNFil._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (n : ℕ) (x : Nat.below n.succ), ¬x.1 = ⊤ → (x.1, ⊤).1 < ⊤",
  "constCategory": "Theorem"},
 {"references": ["Add.add", "HAdd.mk", "HAdd", "Add"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Prod",
   "Prod.mk",
   "Prod.mk.eta.match_1",
   "Prod.snd",
   "Eq",
   "Prod.fst"],
  "name": "Prod.mk.eta",
  "constType": "∀ {α : Type u_1} {β : Type u_2} {p : α × β}, (p.1, p.2) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "GT.gt",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Int.instLEInt",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HarderNarasimhan.JordanHolderFiltration",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "Int.add_one_le_of_lt",
   "List.cons",
   "Bool.true",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Bot.bot",
   "Int.instNegInt",
   "Prod",
   "instDecidableEqBool",
   "Nat",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Lean.Omega.Constraint.addEquality_sat",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Subtype",
   "Nat.cast",
   "Bool",
   "Lean.Omega.Constraint.combine_sat'",
   "Option.some",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.LinearCombo.mk",
   "Prod.fst",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "instNatCastInt",
   "of_decide_eq_true",
   "List.nil",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Option.none",
   "instSubNat",
   "LE.le",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Ne",
   "Lean.Omega.Constraint.mk",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "instHSub",
   "instLENat"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_7",
  "constType":
  "∀ (n : ℕ) (ℒ : Type) (ntl : Nontrivial ℒ) (l : Lattice ℒ) (bo : BoundedOrder ℒ) (wacc : WellFoundedGT ℒ) (S : Type)\n  (clo : CompleteLinearOrder S) (μ : { p // p.1 < p.2 } → S) (JHy JHx : HarderNarasimhan.JordanHolderFiltration μ),\n  Nat.find ⋯ ≠ 0 → ¬Nat.find ⋯ = 1 → ¬Nat.find ⋯ - 1 < Nat.find ⋯ → False",
  "constCategory": "Theorem"},
 {"references": ["WellFounded", "IsWellFounded"],
  "name": "IsWellFounded.mk",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop}, WellFounded r → IsWellFounded α r",
  "constCategory": "Other"},
 {"references": ["Not", "Exists", "Classical.not_forall", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_forall_eq",
  "constType": "∀ {α : Sort u_1} (s : α → Prop), (¬∀ (x : α), s x) = ∃ x, ¬s x",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Submodule.neg_mem",
   "Module",
   "AddCommGroup.toAddGroup",
   "Membership.mem",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Submodule",
   "sub_eq_add_neg",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "propext",
   "SetLike.instMembership",
   "instHAdd",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "AddCommGroup",
   "Iff.rfl",
   "Ring.toSemiring",
   "HAdd.hAdd",
   "NegZeroClass.toNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "Submodule.setLike",
   "Iff",
   "Submodule.add_mem_iff_left",
   "AddCommGroup.toAddCommMonoid",
   "id",
   "Eq.mpr",
   "instHSub",
   "Ring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.sub_mem_iff_left",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] {module_M : _root_.Module R M} (p : Submodule R M)\n  {x y : M}, y ∈ p → (x - y ∈ p ↔ x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Classical.propDecidable",
   "eq_true",
   "ite_cond_eq_true",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Or",
   "IsTotal.total",
   "SemilatticeInf.toPartialOrder",
   "sup_of_le_right",
   "ClosureOperator.IsClosed",
   "CompleteLattice.toLattice",
   "LinearOrder",
   "ite_cond_eq_false",
   "false_or",
   "Set.instCompleteAtomicBooleanAlgebra",
   "eq_false",
   "id",
   "Eq.mpr",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Eq.mp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SemilatticeSup.toPartialOrder",
   "Subtype.decidableLE",
   "congrArg",
   "instDistribLatticeOfLinearOrder",
   "congr",
   "Classical.decRel",
   "Subtype.le",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Set.instLE",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "ite",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "HarderNarasimhan.instIsTotalDedekindMacNeilleCompletionLe",
   "eq_self",
   "Max.max",
   "DistribLattice.toLattice",
   "of_eq_true",
   "LE.le",
   "SemilatticeSup.toMax",
   "False",
   "dite",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "_private.Mathlib.Order.Lattice.0._proof_10"],
  "name":
  "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_24",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α),\n  max a b = if a ≤ b then b else a",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring",
   "CommSemiring",
   "CommRing",
   "Semiring"],
  "name": "RingHom.id._at.HarderNarasimhan.impl.lift_quot._spec_1",
  "constType":
  "(R : Type) →\n  (inst : CommRing R) →\n    let _x_3 := CommRing.toCommSemiring;\n    let _x_6 := _x_3.1;\n    let _x_11 := Semiring.toNonAssocSemiring;\n    let _y_2 := _x_11;\n    R →+* R",
  "constCategory": "Axiom"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "HarderNarasimhan.WeakDescendingChainCondition.casesOn",
   "Prod.snd",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u →\n                HarderNarasimhan.WeakDescendingChainCondition μ →\n                  HarderNarasimhan.WeakDescendingChainCondition μ → Sort u",
  "constCategory": "Definition"},
 {"references": ["Unique", "Inhabited"],
  "name": "Unique.toInhabited",
  "constType": "{α : Sort u} → Unique α → Inhabited α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Semistable.rec",
   "HarderNarasimhan.Semistable.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.Semistable.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.Semistable μ → Sort u} →\n                (t : HarderNarasimhan.Semistable μ) →\n                  ((semistable :\n                        ∀ (x : ℒ) (hx : x ≠ ⊥),\n                          ¬HarderNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HarderNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Membership.mem",
   "CompleteSemilatticeInf.le_sInf",
   "Preorder.toLE",
   "Set.instMembership",
   "CompleteSemilatticeInf"],
  "name": "le_sInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "instHAdd",
   "Lean.Omega.LinearCombo.coeffs",
   "Lean.Omega.LinearCombo",
   "Int.instAdd",
   "Lean.Omega.Coeffs",
   "Lean.Omega.LinearCombo.const",
   "Lean.Omega.Coeffs.dot",
   "Int"],
  "name": "Lean.Omega.LinearCombo.eval",
  "constType": "Omega.LinearCombo → Omega.Coeffs → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "HarderNarasimhan.HarderNarasimhanFiltration.noConfusionType",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "HarderNarasimhan.HarderNarasimhanFiltration.casesOn",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                {hμ : HarderNarasimhan.μA_DescendingChainCondition μ} →\n                  {hμcvx : HarderNarasimhan.Convex μ} →\n                    {h : HarderNarasimhan.μ_Admissible μ} →\n                      {P : Sort u} →\n                        {v1 v2 : HarderNarasimhan.HarderNarasimhanFiltration μ} →\n                          v1 = v2 → HarderNarasimhan.HarderNarasimhanFiltration.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "CompleteLattice.toLattice",
   "Membership.mem",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Set.instMembership",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "SupSet.sSup",
   "CompleteLattice.sSup_le",
   "LE.le",
   "Preorder.toLE",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_37",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (s : Set (HarderNarasimhan.DedekindMacNeilleCompletion α))\n  (a : HarderNarasimhan.DedekindMacNeilleCompletion α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HarderNarasimhan.μB",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.μmin",
   "SupSet.sSup",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.μmax._proof_2",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μB.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.μB μ I =\n    sSup {x | ∃ a, ∃ (ha : HarderNarasimhan.InIntvl I a ∧ (↑I).1 ≠ a), HarderNarasimhan.μmin μ ⟨((↑I).1, a), ⋯⟩ = x}",
  "constCategory": "Theorem"},
 {"references": ["Sub.mk", "Sub", "Int.sub", "Int"],
  "name": "Int.instSub",
  "constType": "Sub ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "OrderDual.instPreorder",
   "OrderDual",
   "Nat",
   "Preorder",
   "Preorder.toLT",
   "WellFoundedGT",
   "not_strictAnti_of_wellFoundedLT",
   "instWellFoundedLTOrderDualOfWellFoundedGT",
   "Nat.instPreorder",
   "StrictMono"],
  "name": "not_strictMono_of_wellFoundedGT",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [WellFoundedGT α] (f : ℕ → α), ¬StrictMono f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finset",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["CommRing.toCommSemiring",
   "Subtype",
   "SetLike.instMembership",
   "Module",
   "Submodule.module",
   "CommSemiring.toSemiring",
   "CommSemiring",
   "Membership.mem",
   "AddCommGroup",
   "CommRing",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.addCommMonoid",
   "Semiring"],
  "name": "Submodule.submoduleOf._at.HarderNarasimhan.impl.f2._spec_2",
  "constType":
  "(R : Type) →\n  (inst : CommRing R) →\n    (M : Type) →\n      (inst_1 : AddCommGroup M) →\n        (inst_2 : _root_.Module R M) →\n          let _x_1 := CommRing.toCommSemiring;\n          let _x_4 := _x_1.1;\n          let _x_7 := AddCommGroup.toAddCommMonoid;\n          let _y_3 := _x_4;\n          let _y_4 := _x_7;\n          let _y_5 := inst_2;\n          Submodule R M →\n            (q : Submodule R M) →\n              let _x_1 := q.addCommMonoid;\n              let _x_2 := q.module;\n              Submodule R ↥q",
  "constCategory": "Axiom"},
 {"references":
  ["HarderNarasimhan.StI",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Set",
   "Membership.mem",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Set.instMembership",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.semistableI",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Prop",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "FunLike",
   "Exists",
   "SetLike.instMembership",
   "RingHomSurjective",
   "SemilinearMapClass",
   "Module",
   "Submodule.map",
   "Membership.mem",
   "And",
   "DFunLike.coe",
   "Submodule",
   "Submodule.mem_map",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.koqcl_iso._proof_11",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} [inst_6 : RingHomSurjective σ₁₂] {F : Type u_9} [inst_7 : FunLike F M M₂]\n  [inst_8 : SemilinearMapClass F σ₁₂ M M₂] {f : F} {p : Submodule R M} {x : M₂},\n  (x ∈ Submodule.map f p) = ∃ y ∈ p, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "inferInstance",
   "AddCommSemigroup",
   "Nat.instAddCommMonoid"],
  "name": "Nat.instAddCommSemigroup",
  "constType": "AddCommSemigroup ℕ",
  "constCategory": "Definition"},
 {"references": ["Option"],
  "name": "WithTop",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Definition"},
 {"references":
  ["le_rfl",
   "SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "inf_le_inf",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_le_inf_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a : α) {b c : α}, b ≤ c → a ⊓ b ≤ a ⊓ c",
  "constCategory": "Theorem"},
 {"references": ["Exists", "exists_and_right", "And", "Eq", "propext"],
  "name": "HarderNarasimhan.impl.lift_quot_middle._proof_20",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, p x ∧ b) = ((∃ x, p x) ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribSMul.mk",
   "AddZeroClass.toZero",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "instDistribSMul._proof_10",
   "MulZeroClass.toSMulWithZero",
   "AddCommMonoid.toAddMonoid",
   "DistribSMul",
   "SMulWithZero.toSMulZeroClass",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddZeroClass"],
  "name": "instDistribSMul",
  "constType":
  "{R : Type u_1} → [inst : NonUnitalNonAssocSemiring R] → DistribSMul R R",
  "constCategory": "Definition"},
 {"references": ["Subtype", "Set", "Membership.mem", "Set.instMembership"],
  "name": "Set.Elem",
  "constType": "{α : Type u} → Set α → Type u",
  "constCategory": "Definition"},
 {"references": ["Finite", "Fintype", "Fintype.finite"],
  "name": "Finite.of_fintype",
  "constType": "∀ (α : Type u_4) [Fintype α], Finite α",
  "constCategory": "Theorem"},
 {"references": ["Inhabited"],
  "name": "Inhabited.default",
  "constType": "{α : Sort u} → [self : Inhabited α] → α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition.wdcc",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.WeakDescendingChainCondition μ]\n  (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["upperBounds", "Set", "Membership.mem", "And", "LE", "Set.instMembership"],
  "name": "IsGreatest",
  "constType": "{α : Type u_1} → [LE α] → Set α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instIsTransLt",
   "instHAdd",
   "Preorder.toLT",
   "OfNat.ofNat",
   "Nat.instPreorder",
   "LT.lt",
   "HAdd.hAdd",
   "Preorder",
   "Nat",
   "instOfNatNat",
   "Nat.rel_of_forall_rel_succ_of_lt",
   "StrictMono"],
  "name": "strictMono_nat_of_lt_succ",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α}, (∀ (n : ℕ), f n < f (n + 1)) → StrictMono f",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "associatedPrimes",
   "Module",
   "Set",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "AddCommGroup",
   "CommRing",
   "HarderNarasimhan.Coprimary.mk",
   "Set.instMembership",
   "IsNoetherianRing",
   "HarderNarasimhan.Coprimary",
   "Ideal",
   "AddCommGroup.toAddCommMonoid",
   "ExistsUnique"],
  "name": "HarderNarasimhan.Coprimary.mk._flat_ctor",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : AddCommGroup M]\n  [inst_3 : _root_.Module R M], (∃! p, p ∈ associatedPrimes R M) → HarderNarasimhan.Coprimary R M",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references":
  ["LinearMap.instZero",
   "RingHom",
   "LinearMap.ker",
   "LinearMap.instFunLike",
   "Module",
   "LinearMap.ker_eq_top",
   "Submodule.instTop",
   "LinearMap",
   "OfNat.ofNat",
   "Submodule",
   "LinearMap.semilinearMapClass",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Top.top",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_22",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂}, (LinearMap.ker f = ⊤) = (f = 0)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "letFun",
  "constType":
  "{α : Sort u} → {β : α → Sort v} → (v : α) → ((x : α) → β x) → β v",
  "constCategory": "Definition"},
 {"references": ["_obj", "HarderNarasimhan.impl.f2._rarg", "_neutral"],
  "name": "HarderNarasimhan.impl.f2._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "HMul.hMul",
   "Exists.intro",
   "SMulZeroClass.toSMul",
   "Submodule.span",
   "Submodule.span_induction",
   "MulAction.toSMul",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Eq.symm",
   "DistribMulAction.toMulAction",
   "_private.Mathlib.Data.Set.Insert.0._proof_14",
   "MulOneClass.toMul",
   "Eq.ndrec",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "DistribSMul.toSMulZeroClass",
   "SetLike.instMembership",
   "Exists",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddZeroClass.toZero",
   "Submodule.smul_mem",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "DistribMulAction.toDistribSMul",
   "SMulWithZero.toSMulZeroClass",
   "Set.instMembership",
   "Exists.casesOn",
   "Iff",
   "Eq.refl",
   "HSMul.hSMul",
   "AddMonoidWithOne.toOne",
   "one_smul",
   "HEq",
   "instHMul",
   "zero_smul",
   "Submodule.subset_span",
   "AddMonoid.toAddZeroClass",
   "Module",
   "AddCommMonoid.toAddMonoid",
   "Iff.intro",
   "Submodule",
   "congrArg",
   "MulOneClass.toOne",
   "MonoidWithZero.toMonoid",
   "Monoid.toMulOneClass",
   "instHSMul",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "MulActionWithZero.toSMulWithZero",
   "Distrib.toAdd",
   "True",
   "HEq.refl",
   "instHAdd",
   "Set",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "Module.toMulActionWithZero",
   "Set.instSingletonSet",
   "Eq.casesOn",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Module.toDistribMulAction",
   "AddCommMonoid.toAddCommSemigroup",
   "One.toOfNat1",
   "of_eq_true",
   "MulZeroClass.toZero",
   "Submodule.setLike",
   "smul_smul",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "add_smul",
   "Semiring"],
  "name": "Submodule.mem_span_singleton",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x y : M},\n  x ∈ Submodule.span R {y} ↔ ∃ a, a • y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "LE.le",
   "not_le_of_lt",
   "Preorder.toLT",
   "Preorder.toLE"],
  "name": "LT.lt.not_le",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["PUnit.unit", "Unit"],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "GT.gt",
   "GE.ge",
   "Eq.symm",
   "Int.instLEInt",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nat.lt_of_not_le",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Bool",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Option.some",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Int.instAdd",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_14",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (n : ℕ),\n  n + 1 > Nat.find hffin → ¬n + 1 ≥ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Nat.lt_of_lt_of_le",
   "LT.lt",
   "instLTNat",
   "Nat",
   "instHAdd",
   "Nat.le_add_right"],
  "name": "Nat.lt_add_right",
  "constType": "∀ {a b : ℕ} (c : ℕ), a < b → a < b + c",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "Exists",
   "SetLike.instMembership",
   "RingHomSurjective",
   "SemilinearMapClass",
   "Module",
   "Submodule.map",
   "Membership.mem",
   "And",
   "DFunLike.coe",
   "Submodule",
   "Submodule.mem_map",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "_private.Mathlib.Algebra.Module.Submodule.Map.0._proof_5",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} [inst_6 : RingHomSurjective σ₁₂] {F : Type u_9} [inst_7 : FunLike F M M₂]\n  [inst_8 : SemilinearMapClass F σ₁₂ M M₂] {f : F} {p : Submodule R M} {x : M₂},\n  (x ∈ Submodule.map f p) = ∃ y ∈ p, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Nat",
   "instHAdd",
   "instOfNatNat",
   "Nat.rec",
   "OfNat.ofNat"],
  "name": "Nat.recAux",
  "constType":
  "{motive : ℕ → Sort u} → motive 0 → ((n : ℕ) → motive n → motive (n + 1)) → (t : ℕ) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "PartialOrder.toPreorder",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.Quotient.module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "NonAssocSemiring",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "Submodule.addCommGroup",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "Prod.snd",
   "LinearMap",
   "CommRing",
   "Ring.toSemiring",
   "LT.lt",
   "Prod",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Module.Finite",
   "Semiring",
   "Ring"],
  "name": "Submodule.mkQ._at.HarderNarasimhan.impl.f2._spec_7",
  "constType":
  "(R : Type) →\n  (inst : CommRing R) →\n    (inst_1 : IsNoetherianRing R) →\n      (M : Type) →\n        (inst_2 : Nontrivial M) →\n          (inst_3 : AddCommGroup M) →\n            (inst_4 : _root_.Module R M) →\n              (inst_5 : Module.Finite R M) →\n                (I : { z // z.1 < z.2 }) →\n                  (_x_4 : Semiring R) →\n                    (_x_7 : AddCommMonoid M) →\n                      (_x_9 : HarderNarasimhan.ℒ R M) →\n                        (_x_11 : Ring R) →\n                          let _x_12 := Submodule.addCommGroup _x_9;\n                          let _x_13 := Submodule.module _x_9;\n                          let _y_3 := _x_11;\n                          let _y_4 := _x_12;\n                          let _y_5 := _x_13;\n                          (p : Submodule R ↥(↑I).2) →\n                            let _x_1 := _y_3.1;\n                            let _x_2 := Semiring.toNonAssocSemiring;\n                            let _x_3 := RingHom.id R;\n                            let _x_4 := AddCommGroup.toAddCommMonoid;\n                            let _x_5 := Submodule.Quotient.addCommGroup p;\n                            let _x_6 := AddCommGroup.toAddCommMonoid;\n                            let _x_7 := Submodule.Quotient.module p;\n                            ↥(↑I).2 →ₛₗ[_x_3] ↥(↑I).2 ⧸ p",
  "constCategory": "Axiom"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod",
   "LT.lt",
   "And.intro",
   "Subtype.prop",
   "le_of_lt",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.prop3d4₀func._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }), (↑I).1 ≤ (↑I).2 ∧ (↑I).2 ≤ (↑I).2",
  "constCategory": "Theorem"},
 {"references":
  ["PUnit.unit",
   "PUnit",
   "Nat",
   "Nat.succ",
   "Nat.rec",
   "Nat.below",
   "PProd",
   "Nat.zero",
   "PProd.mk"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "instLTNat",
   "Nat.find",
   "Nat",
   "Exists",
   "Subtype.property",
   "And",
   "Nat.findX",
   "DecidablePred",
   "Subtype.val",
   "And.left"],
  "name": "Nat.find_spec",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n), p (Nat.find H)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HEq",
  "constType": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "constCategory": "Other"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "SemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLattice.toInfSet",
   "Exists",
   "And.right",
   "And",
   "ne_top_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Set.ext",
   "HarderNarasimhan.in_TotIntvl",
   "lt_top_iff_ne_top",
   "setOf",
   "Subtype",
   "HarderNarasimhan.TotIntvl._proof_1",
   "Prod.fst",
   "congrArg",
   "Iff.intro",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "InfSet.sInf",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Lattice.toSemilatticeInf",
   "Set",
   "LT.lt",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop4d1_helper",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  sInf {x | ∃ x_1, ∃ (hx : x_1 < ⊤), μ ⟨(x_1, ⊤), hx⟩ = x} = HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Int.instLTInt",
   "HarderNarasimhan.JordanHolderFiltration",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "HarderNarasimhan.JordanHolderFiltration.strict_anti",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.step_cond₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} (self : HarderNarasimhan.JordanHolderFiltration μ)\n  (k : ℕ) (hk : k < Nat.find ⋯), μ ⟨(self.filtration (k + 1), self.filtration k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.SlopeLike.casesOn",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.SlopeLike.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} → Sort u → HarderNarasimhan.SlopeLike μ → HarderNarasimhan.SlopeLike μ → Sort u",
  "constCategory": "Definition"},
 {"references": ["HarderNarasimhan.μB._rarg", "_obj", "Prod.mk", "_neutral"],
  "name": "HarderNarasimhan.μBstar._rarg._cstage2",
  "constType": "_obj → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "SetLike.coe_eq_coe",
   "Membership.mem",
   "SetLike",
   "Eq",
   "Subtype.val",
   "propext"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_23",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x y : ↥p}, (↑x = ↑y) = (x = y)",
  "constCategory": "Theorem"},
 {"references": ["Set"],
  "name": "setOf",
  "constType": "{α : Type u} → (α → Prop) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["le_rfl",
   "Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "sup_le_sup",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "sup_le_sup_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → ∀ (c : α), a ⊔ c ≤ b ⊔ c",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Prod",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "Subtype",
   "Subtype.prop",
   "Lattice",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.stableI._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }), (↑I).1 < (↑I).2",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Ne", "Eq"],
  "name": "Ne.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a",
  "constCategory": "Theorem"},
 {"references":
  ["DivInvMonoid.toInv",
   "NonUnitalNonAssocSemiring.toMul",
   "Field",
   "Field.mk",
   "Real.field._proof_78",
   "HMul.hMul",
   "Real.instNontrivial",
   "Real.commRing",
   "NNRat",
   "Real.instRatCast",
   "Rat.cast",
   "DivInvMonoid.zpow_neg'",
   "NNRat.cast",
   "DivInvMonoid.zpow",
   "Semiring.toNonUnitalSemiring",
   "Real",
   "Real.field._proof_76",
   "Real.field._proof_77",
   "Real.field._proof_75",
   "Real.field._proof_74",
   "DivInvMonoid.toDiv",
   "Ring.toSemiring",
   "CommRing.toRing",
   "DivInvMonoid.zpow_succ'",
   "Rat",
   "DivInvMonoid.zpow_zero'",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "instHMul",
   "Real.field._proof_79",
   "Real.instNNRatCast",
   "DivInvMonoid.div_eq_mul_inv",
   "Real.instDivInvMonoid"],
  "name": "Real.field",
  "constType": "Field ℝ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "BoundedOrder",
   "Bot.bot",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "eq_false",
   "Nontrivial",
   "Top.top",
   "False",
   "OrderBot.toBot",
   "bot_ne_top",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop"],
  "name": "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_36",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : BoundedOrder α] [Nontrivial α], (⊥ = ⊤) = False",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "HarderNarasimhan.impl.prop3d4₀func._proof_8",
   "Eq.trans",
   "Eq.mpr_not",
   "Classical.propDecidable",
   "eq_true",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "False.elim",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.ndrec",
   "LT.lt.not_le",
   "HarderNarasimhan.impl.ℒₛ._proof_1",
   "Exists",
   "Exists.choose_spec",
   "BoundedOrder",
   "HarderNarasimhan.impl.prop3d4₀func_helper",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "eq_false",
   "Eq.refl",
   "Lattice",
   "Classical.byContradiction",
   "Eq.mpr",
   "instDecidableTrue",
   "Prod.fst",
   "instOfNatNat",
   "congr",
   "WellFoundedGT",
   "not_true_eq_false",
   "Eq",
   "Preorder.toLE",
   "Set",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "dite_cond_eq_true",
   "HarderNarasimhan.μA",
   "Ne",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.impl.ℒₛ._proof_2",
   "LE.le.ge",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "WellFounded.has_min",
   "_private.Init.Core.0._proof_38",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "And.intro",
   "PartialOrder",
   "funext",
   "forall_congr",
   "HarderNarasimhan.impl.prop3d4₀func._proof_4",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "of_eq_false",
   "HarderNarasimhan.impl.ℒₛ",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "Nat",
   "Nontrivial",
   "id",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "congrArg",
   "dite_congr",
   "Subtype.prop",
   "IsWellFounded.wf",
   "instDecidableFalse",
   "dite_cond_eq_false",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "HarderNarasimhan.impl.prop3d4₀func",
   "gt_of_ge_of_gt",
   "Exists.choose",
   "Eq.mpr_prop",
   "LT.lt",
   "ne_of_lt",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39",
   "HarderNarasimhan.impl.prop3d4₀func._proof_7"],
  "name": "HarderNarasimhan.impl.prop3d4₀func_defprop2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ)\n  (hi : (↑I).1 ≠ ↑(HarderNarasimhan.impl.prop3d4₀func μ I (i + 1))) (z : ℒ)\n  (hz : ↑(HarderNarasimhan.impl.prop3d4₀func μ I (i + 1)) < z ∧ z ≤ ↑(HarderNarasimhan.impl.prop3d4₀func μ I i)),\n  ¬HarderNarasimhan.μA μ ⟨((↑I).1, z), ⋯⟩ ≥\n      HarderNarasimhan.μA μ ⟨((↑I).1, ↑(HarderNarasimhan.impl.prop3d4₀func μ I (i + 1))), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Preorder"],
  "name": "ClosureOperator",
  "constType": "(α : Type u_1) → [Preorder α] → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "le_refl",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Eq.mpr_not",
   "Preorder.toLT",
   "Classical.propDecidable",
   "IsGreatest",
   "HarderNarasimhan.impl.HNFil._proof_3",
   "Monotone",
   "letFun",
   "Eq.symm",
   "HarderNarasimhan.Convex",
   "Eq.rec",
   "Eq.ndrec",
   "Nat.instLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "Nat.instPartialOrder",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "HarderNarasimhan.impl.HNFil_of_fin_len",
   "Nat",
   "Nat.find_spec",
   "lt_of_not_le",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "Subtype",
   "HarderNarasimhan.StI",
   "instDecidableTrue",
   "lt_of_le_of_ne",
   "HarderNarasimhan.impl.HNFil",
   "HarderNarasimhan.impl.HNlen",
   "dite_congr",
   "congrArg",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Not",
   "HarderNarasimhan.impl.HNFil._proof_4",
   "Nat.le_induction",
   "le_top",
   "Lattice.toSemilatticeInf",
   "True",
   "HarderNarasimhan.μ_Admissible",
   "instHAdd",
   "Nat.decLe",
   "HarderNarasimhan.impl.HNFil_is_strict_mono'",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "dite_cond_eq_true",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "instDecidableEqNat",
   "Subtype.mk",
   "dite",
   "instLENat",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ], Monotone (HarderNarasimhan.impl.HNFil μ)",
  "constCategory": "Theorem"},
 {"references":
  ["ExistsUnique.exists.match_1",
   "Exists",
   "Exists.intro",
   "ExistsUnique",
   "Eq"],
  "name": "ExistsUnique.exists",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (∃! x, p x) → ∃ x, p x",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Min.min",
   "SemilatticeInf.le_inf",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "le_inf",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub",
   "AddGroup.mk",
   "Nat.cast",
   "Zero.ofOfNat0",
   "Int.zero_add",
   "HMul.hMul",
   "Int.add_zero",
   "Int.instAddCommGroup._proof_4",
   "Int.instMul",
   "Int.zero_mul",
   "AddCommGroup.mk",
   "Int.instAdd",
   "Int.sub_eq_add_neg",
   "SubNegMonoid.mk",
   "AddSemigroup.mk",
   "instNatCastInt",
   "Int.add_assoc",
   "Int.instAddCommGroup._proof_3",
   "AddCommGroup",
   "Int.instNegInt",
   "AddMonoid.mk",
   "Int",
   "Nat",
   "instOfNat",
   "Int.add_left_neg",
   "Int.add_comm",
   "instHMul"],
  "name": "Int.instAddCommGroup",
  "constType": "AddCommGroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["ContravariantClass.mk",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "Iff.mp",
   "Contravariant",
   "CovariantClass",
   "CovariantClass.elim",
   "covariant_le_iff_contravariant_lt",
   "ContravariantClass",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Covariant",
   "Preorder.toLE"],
  "name": "contravariant_lt_of_covariant_le",
  "constType":
  "∀ (N : Type u_2) (mu : N → N → N) [inst : LinearOrder N] [CovariantClass N N mu fun x1 x2 => x1 ≤ x2],\n  ContravariantClass N N mu fun x1 x2 => x1 < x2",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "not_lt",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "_private.Mathlib.Order.Defs.LinearOrder.0._proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references": ["HarderNarasimhan.μAstar._rarg", "_obj", "_neutral"],
  "name": "HarderNarasimhan.μAstar._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Quotient.mk''",
   "Quotient",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Subtype",
   "add_neg_cancel_left",
   "HasQuotient.Quotient",
   "Membership.mem",
   "Iff.mp",
   "QuotientAddGroup.leftRel",
   "Exists.intro",
   "Subtype.val",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubtractionMonoid",
   "congrArg",
   "Quotient.out_eq'",
   "Eq.symm",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Exists",
   "SetLike.instMembership",
   "instHAdd",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "AddSubgroup.instSetLike",
   "HAdd.hAdd",
   "AddSubgroup",
   "NegZeroClass.toNeg",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "QuotientAddGroup.instHasQuotientAddSubgroup",
   "Eq.refl",
   "id",
   "QuotientAddGroup.mk",
   "AddGroup",
   "Eq.mpr",
   "QuotientAddGroup.eq",
   "Subtype.mk",
   "Quotient.out",
   "AddMonoid.toAddZeroClass"],
  "name": "QuotientAddGroup.mk_out_eq_mul",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] (s : AddSubgroup α) (g : α), ∃ h, Quotient.out ↑g = g + ↑h",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "EmbeddingLike.apply_eq_iff_eq",
   "EmbeddingLike",
   "Eq",
   "DFunLike.coe",
   "propext"],
  "name": "HarderNarasimhan.impl.rmk4d14₁._proof_14",
  "constType":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [inst : FunLike F α β] [i : EmbeddingLike F α β] (f : F) {x y : α},\n  (f x = f y) = (x = y)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "CompleteLattice.le_sInf",
   "Set.Nonempty",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "CompleteLattice.toInfSet",
   "Set",
   "CompleteLattice.toLattice",
   "Membership.mem",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "BddBelow",
   "BddAbove",
   "Set.instMembership",
   "upperBounds",
   "ConditionallyCompleteLattice",
   "lowerBounds",
   "CompleteLattice.sSup_le",
   "Preorder.toLE",
   "CompleteLattice",
   "ConditionallyCompleteLattice.mk",
   "CompleteLattice.sInf_le"],
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_1} → [CompleteLattice α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat.le_trans",
   "Nat",
   "Nat.succ",
   "LE.le",
   "instLENat"],
  "name": "Nat.lt_of_lt_of_le",
  "constType": "∀ {n m k : ℕ}, n < m → m ≤ k → n < k",
  "constCategory": "Theorem"},
 {"references": ["Not", "LT.lt", "Preorder", "lt_asymm", "Preorder.toLT"],
  "name": "not_lt_of_gt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → ¬b < a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "HarderNarasimhan.impl.prop2d6₁I",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "Membership.mem.out",
   "Subtype.val",
   "HarderNarasimhan.S₂I",
   "HarderNarasimhan.S₁I",
   "And.intro",
   "HarderNarasimhan.S₁I._proof_1",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "eq_of_ge_of_not_gt",
   "Exists",
   "Exists.choose_spec",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "Eq.refl",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "ConditionallyCompleteLattice.toLattice",
   "Mathlib.Tactic.PushNeg.not_implies_eq",
   "SemilatticeInf.toMin",
   "HarderNarasimhan.StI",
   "Subtype",
   "Eq.mp",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "le_rfl",
   "Subtype.prop",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Not",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "Lattice.toSemilatticeInf",
   "Set",
   "Mathlib.Tactic.PushNeg.not_forall_eq",
   "Exists.choose",
   "inf_eq_left",
   "exists_prop_congr",
   "not_le_of_gt",
   "LT.lt",
   "ne_of_lt",
   "le_of_lt",
   "Min.min",
   "HarderNarasimhan.μA",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "And.casesOn"],
  "name": "HarderNarasimhan.impl.prop3d7₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ) (hxSt : x ∈ HarderNarasimhan.StI μ I) (y : ℒ),\n      HarderNarasimhan.InIntvl I y →\n        ∀ (hy : y > x), ¬HarderNarasimhan.μA μ ⟨((↑I).1, x), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(x, y), hy⟩",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "HAdd.hAdd",
   "instDistribLatticeOfLinearOrder",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.elim_AddLeftMono",
   "DistribLattice.toLattice",
   "AddCommMonoid.toAddCommSemigroup",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "LE.le",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "CovariantClass.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instAddLeftMono_harderNarasimhan",
  "constType":
  "∀ {V : Type} [inst : HarderNarasimhan.TotallyOrderedRealVectorSpace V], AddLeftMono V",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HarderNarasimhan.TotIntvl._proof_1",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.TotIntvl.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ],\n  HarderNarasimhan.TotIntvl = ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "Membership.mem",
   "isGLB_sInf",
   "CompleteSemilatticeInf",
   "Set.instMembership",
   "CompleteSemilatticeInf.toInfSet",
   "Iff",
   "CompleteSemilatticeInf.toPartialOrder",
   "InfSet.sInf",
   "LE.le",
   "le_isGLB_iff",
   "Preorder.toLE"],
  "name": "le_sInf_iff",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, a ≤ sInf s ↔ ∀ b ∈ s, a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["IsStrictOrderedRing.toPosMulStrictMono",
   "PartialOrder.toPreorder",
   "IsStrictOrderedRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "mul_le_mul_of_nonneg_left",
   "IsOrderedRing.mk",
   "MulPosStrictMono.toMulPosMono",
   "IsOrderedRing",
   "Semiring.toNonAssocSemiring",
   "mul_le_mul_of_nonneg_right",
   "MulZeroClass.toZero",
   "PartialOrder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsOrderedCancelAddMonoid.toIsOrderedAddMonoid",
   "PosMulStrictMono.toPosMulMono",
   "IsStrictOrderedRing.toMulPosStrictMono",
   "Semiring",
   "IsStrictOrderedRing.toIsOrderedCancelAddMonoid",
   "IsStrictOrderedRing.toZeroLEOneClass"],
  "name": "IsStrictOrderedRing.toIsOrderedRing",
  "constType":
  "∀ {R : Type u} [inst : Semiring R] [inst_1 : PartialOrder R] [IsStrictOrderedRing R], IsOrderedRing R",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Ring.toNonAssocRing",
   "Finset",
   "Eq.trans",
   "instInfiniteNat",
   "Submodule.Quotient.module",
   "Singleton.singleton",
   "AddGroupWithOne.toAddMonoidWithOne",
   "SMulZeroClass.toSMul",
   "HarderNarasimhan.impl.prop3d12",
   "instDistribSMul",
   "Subtype.val",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Submodule.Quotient.instSMul._proof_3",
   "strictMono_nat_of_lt_succ",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "strictAnti_nat_of_succ_lt",
   "Finset.min'",
   "congrFun",
   "RingHom.id",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Module.IsNoetherian.finite",
   "Eq.symm",
   "associatedPrimes.finite",
   "HarderNarasimhan.S",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Submodule.coe_mem",
   "LinearMap.ker",
   "Exists",
   "ne_iff_lt_or_gt",
   "ClosureOperator.IsClosed",
   "Submodule.addCommGroup",
   "Set.Infinite",
   "Prod.snd",
   "HarderNarasimhan.S₀_order'",
   "LinearMap",
   "HarderNarasimhan.impl.assp",
   "Set.instMembership",
   "Prod",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "Classical.byContradiction",
   "PrimeSpectrum.ext",
   "Finset.instMembership",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "Quotient.out",
   "CompleteLattice.toBoundedOrder",
   "AddMonoid.toAddZeroClass",
   "setOf",
   "Or.inr",
   "Submodule.hasQuotient",
   "RelEmbedding.toEmbedding",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "HarderNarasimhan.impl.μ_nonempty",
   "Prod.fst",
   "le_rfl",
   "_private.Init.PropLemmas.0._proof_15",
   "Or.inl",
   "instOfNatNat",
   "Ideal.ext",
   "congr",
   "HarderNarasimhan._μ",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "LinearExtension",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Set.toFinset",
   "Eq.to_iff",
   "AddCommGroup",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "HAdd.hAdd",
   "CommRing.toRing",
   "LinearOrder.toPartialOrder",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan._μ._proof_2",
   "Submodule.completeLattice",
   "instDecidableEqNat",
   "Ne",
   "HarderNarasimhan.S₀",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Module.Finite",
   "_private.Mathlib.Order.Defs.LinearOrder.0._proof_2",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "Prod.mk",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "Subtype.preorder",
   "AddMonoidWithOne.toAddMonoid",
   "GT.gt",
   "RelEmbedding.instFunLike",
   "And.intro",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Or",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "forall_congr",
   "PrimeSpectrum.instPartialOrder",
   "Eq.rec",
   "Semiring.toModule",
   "Nat.instLinearOrder",
   "Nat.zero_lt_of_ne_zero",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DistribSMul.toSMulZeroClass",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "And.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Exists.casesOn",
   "isNoetherian_submodule'",
   "Nat",
   "Finset.instSingleton",
   "HasSubset.Subset",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_13",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_12",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Set.infinite_of_injective_forall_mem",
   "Subtype",
   "Submodule.instNontrivial",
   "Module.Finite.quotient",
   "Eq.mp",
   "Submodule.module",
   "Function.Embedding.toFun",
   "DFunLike.coe",
   "Submodule",
   "congrArg",
   "Submodule.Quotient.addCommGroup",
   "instDistribLatticeOfLinearOrder",
   "Ideal",
   "isNoetherian_of_isNoetherianRing_of_finite",
   "HarderNarasimhan.instLinearOrderS₀",
   "PrimeSpectrum.asIdeal",
   "RelEmbedding",
   "Subtype.le",
   "Finset.min'_mem",
   "Set.instLE",
   "Not",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Submodule.quotientRel",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "IsAssociatedPrime",
   "CommRing",
   "Or.casesOn",
   "Set.instHasSubset",
   "LT.lt",
   "HarderNarasimhan.μA_DescendingChainCondition.mk",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "le_of_lt",
   "Submodule.setLike",
   "LE.le",
   "False",
   "lt_self_iff_false",
   "Subtype.mk",
   "Submodule.addCommMonoid",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.impl.prop3d13₂",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  HarderNarasimhan.μA_DescendingChainCondition (HarderNarasimhan.μ R M)",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE", "RelEmbedding"],
  "name": "OrderEmbedding",
  "constType":
  "(α : Type u_6) → (β : Type u_7) → [LE α] → [LE β] → Type (max u_6 u_7)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inhabited",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["Exists", "Eq"],
  "name": "Function.Surjective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Preorder",
   "LE.le",
   "not_le_of_lt",
   "Preorder.toLT",
   "Preorder.toLE",
   "GT.gt"],
  "name": "not_le_of_gt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a > b → ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Max"],
  "name": "Max.max",
  "constType": "{α : Type u} → [self : Max α] → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["CommRing.toRing",
   "Semiring.toNonAssocSemiring",
   "RingHomSurjective",
   "RingHom.id",
   "CommRing",
   "Ring.toSemiring",
   "RingHomSurjective.ids"],
  "name": "HarderNarasimhan.impl.lift_quot._proof_14",
  "constType":
  "∀ {R : Type} [inst : CommRing R], RingHomSurjective (RingHom.id R)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "PartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "CompleteSemilatticeInf.toInfSet",
   "HarderNarasimhan.InIntvl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μA",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "BiheytingAlgebra.toHeytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "Lattice.inf",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Lattice.le_inf",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "LE.le",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "GeneralizedHeytingAlgebra.toLattice",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_35",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b c : HarderNarasimhan.DedekindMacNeilleCompletion α),\n  a ≤ b → a ≤ c → a ≤ Lattice.inf b c",
  "constCategory": "Theorem"},
 {"references": ["MulZeroClass", "Zero"],
  "name": "MulZeroClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "eq_true",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "Exists.choose_spec",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "eq_false",
   "Eq.refl",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.rawCast",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "HarderNarasimhan.Semistable",
   "Linarith.add_lt_of_neg_of_le",
   "instDecidableTrue",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Nat.instPreorder",
   "Prod.fst",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Set",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "HarderNarasimhan.impl.JHFil",
   "Ne",
   "dite",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "WellFounded.has_min",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLattice.toTop",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "Bot.bot",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "HarderNarasimhan.impl.JHFil._proof_4",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "dite_congr",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "IsWellFounded.wf",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "instDecidableFalse",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Exists.choose",
   "Mathlib.Tactic.Ring.add_congr",
   "Eq.mpr_prop",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "LE.le",
   "Linarith.zero_lt_one",
   "False",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "instLENat",
   "OrderTop.toTop",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.impl.JHFil_anti_mono",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hacc : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤)\n  (hμsl : HarderNarasimhan.SlopeLike μ) (hst : HarderNarasimhan.Semistable μ)\n  (hdc : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) (k : ℕ),\n  HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc k > ⊥ →\n    HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc k > HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc (k + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "Not",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "SemilatticeSup.toPartialOrder",
   "LE.le.lt_iff_ne",
   "right_eq_sup",
   "LT.lt",
   "Max.max",
   "le_sup_right",
   "Iff",
   "not_congr",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Ne",
   "Eq",
   "Preorder.toLE"],
  "name": "right_lt_sup",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b < a ⊔ b ↔ ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Submodule.instBot",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "HarderNarasimhan.CoprimaryFiltration.casesOn",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.noConfusionType",
  "constType":
  "{R : Type} →\n  {inst : CommRing R} →\n    {inst_1 : IsNoetherianRing R} →\n      {M : Type} →\n        {inst_2 : Nontrivial M} →\n          {inst_3 : AddCommGroup M} →\n            {inst_4 : _root_.Module R M} →\n              {inst_5 : Module.Finite R M} →\n                Sort u → HarderNarasimhan.CoprimaryFiltration R M → HarderNarasimhan.CoprimaryFiltration R M → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "One.toOfNat1",
   "LE.le",
   "zero_le_one",
   "One.mk",
   "LE",
   "One",
   "Zero.toOfNat0",
   "Subtype.mk",
   "Zero",
   "OfNat.ofNat",
   "ZeroLEOneClass"],
  "name": "Nonneg.one",
  "constType":
  "{α : Type u_1} → [inst : Zero α] → [inst_1 : One α] → [inst_2 : LE α] → [ZeroLEOneClass α] → One { x // 0 ≤ x }",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.impl.rmk2d5₃",
   "Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "bot_le",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "And.intro",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.impl.rmk2d5₂",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.rmk2d5₁",
   "le_top",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.Convex_of_Convex_large",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "CompleteLattice"],
  "name": "HarderNarasimhan.remark_2_5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Convex μ →\n    HarderNarasimhan.Convex (HarderNarasimhan.μmax μ) ∧\n      ∀ (I : { p // p.1 < p.2 }),\n        HarderNarasimhan.μmax μ I = HarderNarasimhan.μmax (HarderNarasimhan.μmax μ) I ∧\n          HarderNarasimhan.μA μ I = HarderNarasimhan.μA (HarderNarasimhan.μmax μ) I",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1",
   "Nat.rawCast",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
  "constType":
  "∀ {α : Type u} {a : α} {n : ℕ} [inst : AddMonoidWithOne α], Mathlib.Meta.NormNum.IsNat a n → a = n.rawCast",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "instHAdd",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddGroup",
   "Zero.toOfNat0",
   "Eq",
   "AddSemigroup.toAdd"],
  "name": "AddGroup.mk",
  "constType":
  "{A : Type u} → [toSubNegMonoid : SubNegMonoid A] → (∀ (a : A), -a + a = 0) → AddGroup A",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "PrimeSpectrum.isPrime",
   "Semiring.toNonAssocSemiring",
   "Finset.min'",
   "RingHom.id",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "SetLike.instMembership",
   "LocalizedModule",
   "Submodule.addCommGroup",
   "Prod.snd",
   "LinearMap",
   "Prod",
   "LocalizedModule.isModule'",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "LocalizedModule.instAddCommMonoid",
   "HarderNarasimhan.impl.μ_nonempty",
   "LocalizedModule.mkLinearMap",
   "Prod.fst",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Ideal.primeCompl",
   "PrimeSpectrum.asIdeal",
   "HarderNarasimhan._μ",
   "CommRing.toCommSemiring",
   "LinearExtension",
   "CommSemiring.toSemiring",
   "Set.toFinset",
   "AddCommGroup",
   "CommRing",
   "LT.lt",
   "PrimeSpectrum",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.f1._proof_4",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.f1",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] →\n                (I : { z // z.1 < z.2 }) →\n                  ↥(↑I).2 ⧸ Submodule.submoduleOf (↑I).1 (↑I).2 →ₗ[R]\n                    LocalizedModule ((HarderNarasimhan._μ R M I).toFinset.min' ⋯).asIdeal.primeCompl\n                      (↥(↑I).2 ⧸ Submodule.submoduleOf (↑I).1 (↑I).2)",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "HarderNarasimhan.HarderNarasimhanFiltration.casesOn",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                {hμ : HarderNarasimhan.μA_DescendingChainCondition μ} →\n                  {hμcvx : HarderNarasimhan.Convex μ} →\n                    {h : HarderNarasimhan.μ_Admissible μ} →\n                      Sort u →\n                        HarderNarasimhan.HarderNarasimhanFiltration μ →\n                          HarderNarasimhan.HarderNarasimhanFiltration μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "GroupWithZero.toDivInvMonoid",
   "Div.mk",
   "Subtype.val",
   "instHDiv",
   "HDiv.hDiv",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "Nonneg.div._proof_3",
   "Preorder.toLE",
   "Div",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "IsStrictOrderedRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toGroupWithZero",
   "DivisionSemiring.toSemiring",
   "OfNat.ofNat",
   "DivInvMonoid.toDiv",
   "DistribLattice.toLattice",
   "MulZeroClass.toZero",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semifield",
   "Subtype.mk"],
  "name": "Nonneg.div",
  "constType":
  "{α : Type u_1} → [inst : Semifield α] → [inst_1 : LinearOrder α] → [IsStrictOrderedRing α] → Div { x // 0 ≤ x }",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "HarderNarasimhan.instCoeOutInterval._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "BiheytingAlgebra.toHeytingAlgebra",
   "BiheytingAlgebra.toHNot",
   "HNot.hnot",
   "SemilatticeSup.toPartialOrder",
   "BiheytingAlgebra.toSDiff",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "SDiff.sdiff",
   "Top.top",
   "Eq",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "OrderTop.toTop",
   "GeneralizedHeytingAlgebra.toLattice"],
  "name": "BiheytingAlgebra.top_sdiff",
  "constType":
  "∀ {α : Type u_4} [self : BiheytingAlgebra α] (a : α), ⊤ \\ a = ￢a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZero",
   "Real",
   "PartialOrder",
   "NNReal",
   "LE.le",
   "Subtype.partialOrder",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Real.partialOrder",
   "Real.instLE"],
  "name": "instNNRealPartialOrder",
  "constType": "PartialOrder NNReal",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Prod.fst",
   "Nat.instPreorder",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_1",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "instHAdd",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_2",
   "BoundedOrder",
   "HarderNarasimhan.impl.prop4d1₁_seq",
   "Prod.snd",
   "Exists.choose",
   "OfNat.ofNat",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_3",
   "CompleteLattice",
   "setOf",
   "StrictMono"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._proof_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S)\n  (h₁ : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩)\n  (h₂ :\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty) (k : ℕ),\n  ↑(HarderNarasimhan.impl.prop4d1₁_seq μ h₁ h₂ h₃ k) < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Singleton.singleton",
   "HarderNarasimhan.μ",
   "Preorder.toLT",
   "HarderNarasimhan.impl.prop3d12",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Finset.min'",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "HarderNarasimhan.S",
   "ClosureOperator.IsClosed",
   "Prod.snd",
   "Prod",
   "HarderNarasimhan.μ_nonempty",
   "Finset.instSingleton",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "CompleteLattice.toBoundedOrder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.instNontrivial",
   "Subtype",
   "RelEmbedding.toEmbedding",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Function.Embedding.toFun",
   "HarderNarasimhan.coe'",
   "Prod.fst",
   "HarderNarasimhan._μ",
   "Eq",
   "Preorder.toLE",
   "Subtype.le",
   "Set.instLE",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "CommRing.toCommSemiring",
   "LinearExtension",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "CommSemiring.toSemiring",
   "Set.toFinset",
   "AddCommGroup",
   "CommRing",
   "LT.lt",
   "PrimeSpectrum",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.instPartialOrderS₀",
   "LE.le",
   "Submodule.completeLattice",
   "HarderNarasimhan.S₀",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.proposition_3_12",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  HarderNarasimhan.μA (HarderNarasimhan.μ R M) I =\n    HarderNarasimhan.coe'.toFun {(HarderNarasimhan._μ R M I).toFinset.min' ⋯}",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.impl.prop2d6₂I₂",
   "Prod.mk",
   "HarderNarasimhan.impl.prop2d6₁I",
   "Preorder.toLT",
   "GE.ge",
   "HarderNarasimhan.impl.prop2d6₀",
   "Prod.fst",
   "And.intro",
   "Or",
   "HarderNarasimhan.impl.prop2d6₃I",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.Convex",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "HarderNarasimhan.IsComparable",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.impl.prop2d6₂I₁",
   "Min.min",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.in_TotIntvl",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_2_6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (x y z : ℒ) (h : x < y ∧ y < z),\n  HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ ∧\n    (HarderNarasimhan.Convex μ →\n      HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ≥ HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩ ⊓ HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ ∧\n        ((HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≥ HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ →\n              HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ = HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩) ∧\n            (HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩ < HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ →\n              HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∧\n                HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩)) ∧\n          (HarderNarasimhan.IsComparable (HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩) (HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩) ∨\n              HarderNarasimhan.IsAttained μ ⟨(x, z), ⋯⟩ →\n            HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ = HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∨\n              HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∧\n                HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ < HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩))",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "EmbeddingLike.apply_eq_iff_eq",
   "EmbeddingLike",
   "Eq",
   "DFunLike.coe",
   "propext"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_11",
  "constType":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [inst : FunLike F α β] [i : EmbeddingLike F α β] (f : F) {x y : α},\n  (f x = f y) = (x = y)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "PartialOrder.toPreorder",
   "false_and",
   "Eq.trans",
   "Prod.mk",
   "Preorder.toLT",
   "Iff.mp",
   "or_assoc",
   "GT.gt",
   "And.intro",
   "Or",
   "letFun",
   "Eq.symm",
   "gt_trans",
   "Eq.rec",
   "not_lt_of_lt",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "And.right",
   "And",
   "Or.resolve_left",
   "_private.Mathlib.Order.Basic.0._proof_1",
   "BoundedOrder",
   "HarderNarasimhan.proposition_4_6",
   "Prod.snd",
   "true_and",
   "Prod",
   "false_or",
   "Nontrivial",
   "Lattice",
   "id",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Or.resolve_right",
   "and_true",
   "Prod.fst",
   "congrArg",
   "congr",
   "Preorder.toLE",
   "Eq",
   "propext",
   "not_lt_of_gt",
   "Lattice.toSemilatticeInf",
   "True",
   "LT.lt",
   "eq_self",
   "and_self",
   "of_eq_true",
   "and_false",
   "False",
   "Subtype.mk",
   "lt_self_iff_false",
   "_private.Init.Core.0._proof_39",
   "CompleteLattice"],
  "name": "HarderNarasimhan.seesaw_useful",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ →\n    ∀ (x y z : ℒ) (h : x < y ∧ y < z),\n      ((μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ → μ ⟨(x, y), ⋯⟩ < μ ⟨(y, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩) ∧\n          (μ ⟨(x, y), ⋯⟩ < μ ⟨(y, z), ⋯⟩ → μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩) ∧\n            (μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩ → μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, y), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) ∧\n        ((μ ⟨(x, y), ⋯⟩ > μ ⟨(x, z), ⋯⟩ → μ ⟨(x, y), ⋯⟩ > μ ⟨(y, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ > μ ⟨(y, z), ⋯⟩) ∧\n            (μ ⟨(x, y), ⋯⟩ > μ ⟨(y, z), ⋯⟩ → μ ⟨(x, y), ⋯⟩ > μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ > μ ⟨(y, z), ⋯⟩) ∧\n              (μ ⟨(x, z), ⋯⟩ > μ ⟨(y, z), ⋯⟩ → μ ⟨(x, y), ⋯⟩ > μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, y), ⋯⟩ > μ ⟨(y, z), ⋯⟩)) ∧\n          (μ ⟨(x, y), ⋯⟩ = μ ⟨(x, z), ⋯⟩ → μ ⟨(x, y), ⋯⟩ = μ ⟨(y, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ = μ ⟨(y, z), ⋯⟩) ∧\n            (μ ⟨(x, y), ⋯⟩ = μ ⟨(y, z), ⋯⟩ → μ ⟨(x, y), ⋯⟩ = μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ = μ ⟨(y, z), ⋯⟩) ∧\n              (μ ⟨(x, z), ⋯⟩ = μ ⟨(y, z), ⋯⟩ → μ ⟨(x, y), ⋯⟩ = μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, y), ⋯⟩ = μ ⟨(y, z), ⋯⟩)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "Unit.unit",
   "OfNat.ofNat",
   "Unit"],
  "name": "HarderNarasimhan.impl.prop3d4₀func.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "Ideal",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Ideal.instIsTwoSided",
   "CommRing",
   "Ideal.IsTwoSided"],
  "name": "Ideal.instIsTwoSided_1",
  "constType":
  "∀ {α : Type u_1} [inst : CommRing α] (I : Ideal α), I.IsTwoSided",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "Nat.add_sub_of_le",
   "Nat.add_comm",
   "congrArg",
   "HAdd.hAdd",
   "Nat",
   "instSubNat",
   "Eq.refl",
   "LE.le",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "Eq",
   "instHSub",
   "instLENat"],
  "name": "Nat.sub_add_cancel",
  "constType": "∀ {n m : ℕ}, m ≤ n → n - m + m = n",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.sound", "letFun", "Quot.liftOn", "Eq", "Quot.mk", "Quot", "congrArg"],
  "name": "funext",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "HarderNarasimhan.HarderNarasimhanFiltration.rec",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] →\n                    [h : HarderNarasimhan.μ_Admissible μ] →\n                      {motive : HarderNarasimhan.HarderNarasimhanFiltration μ → Sort u} →\n                        (t : HarderNarasimhan.HarderNarasimhanFiltration μ) →\n                          ((filtration : ℕ → ℒ) →\n                              (monotone : Monotone filtration) →\n                                (first_eq_bot : filtration 0 = ⊥) →\n                                  (fin_len : ∃ n, filtration n = ⊤) →\n                                    (strict_mono :\n                                        ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                      (piecewise_semistable :\n                                          ∀ (i : ℕ) (h : i < Nat.find fin_len),\n                                            HarderNarasimhan.Semistable\n                                              (HarderNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)) →\n                                        (μA_pseudo_strict_anti :\n                                            ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n                                              ¬HarderNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n                                                  HarderNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩) →\n                                          motive\n                                            { filtration := filtration, monotone := monotone,\n                                              first_eq_bot := first_eq_bot, fin_len := fin_len,\n                                              strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n                                              μA_pseudo_strict_anti := μA_pseudo_strict_anti }) →\n                            motive t",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "SemilatticeInf.mk",
  "constType":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    (inf : α → α → α) →\n      (∀ (a b : α), inf a b ≤ a) →\n        (∀ (a b : α), inf a b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ inf b c) → SemilatticeInf α",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocRing", "NonAssocRing"],
  "name": "NonAssocRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "Union.union",
   "DFunLike.coe",
   "Subtype.val",
   "ClosureOperator.instFunLike",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "ClosureOperator.isClosed_closure",
   "Set.instUnion"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds), T.IsClosed (T (↑A ∪ ↑B))",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Or.inl",
   "Set",
   "Membership.mem",
   "Set.instUnion",
   "Union.union",
   "Set.instMembership"],
  "name": "Set.subset_union_left",
  "constType": "∀ {α : Type u} {s t : Set α}, s ⊆ s ∪ t",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "StarRing",
   "starRingOfComm",
   "Nat.instCommSemiring",
   "Nat.instNonUnitalNonAssocSemiring"],
  "name": "Nat.instStarRing",
  "constType": "StarRing ℕ",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftMono",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddCommMonoid.toAddMonoid",
   "IsOrderedAddMonoid.add_le_add_left",
   "HAdd.hAdd",
   "AddCommMonoid",
   "AddZeroClass.toAdd",
   "PartialOrder",
   "IsOrderedAddMonoid",
   "LE.le",
   "CovariantClass.mk",
   "Preorder.toLE",
   "AddMonoid.toAddZeroClass"],
  "name": "IsOrderedAddMonoid.toAddLeftMono",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : PartialOrder α] [IsOrderedAddMonoid α], AddLeftMono α",
  "constCategory": "Theorem"},
 {"references":
  ["not_le",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "_private.HarderNarasimhan.DedekindMacNeilleCompletion.0._proof_21",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (¬a ≤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder", "PartialOrder", "LE.le", "Eq", "Preorder.toLE"],
  "name": "PartialOrder.le_antisymm",
  "constType":
  "∀ {α : Type u_2} [self : PartialOrder α] (a b : α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["And.intro",
   "Exists",
   "exists_prop.match_2",
   "exists_prop.match_1",
   "Iff",
   "And",
   "Exists.intro",
   "Iff.intro"],
  "name": "exists_prop",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) ↔ a ∧ b",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddCommGroup.toAddGroup",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "SubNegMonoid.toAddMonoid",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "AddMonoid.toAddSemigroup",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddSemigroup.toAdd"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.elim_AddLeftMono",
  "constType":
  "∀ {V : Type} [self : HarderNarasimhan.TotallyOrderedRealVectorSpace V] {y z : V} (x : V), y ≤ z → x + y ≤ x + z",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.SlopeLike",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.impl.rmk4d13",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.remark_4_13",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ →\n    ∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      ¬μ ⟨(⊥, x), ⋯⟩ ≤ μ HarderNarasimhan.TotIntvl ∨ μ HarderNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Submodule.instBot",
   "Nontrivial",
   "HarderNarasimhan.CoprimaryFiltration.mk",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "HarderNarasimhan.CoprimaryFiltration",
   "instOfNatNat",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Submodule.instTop",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.mk._flat_ctor",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] →\n                (filtration : ℕ → HarderNarasimhan.ℒ R M) →\n                  Monotone filtration →\n                    filtration 0 = ⊥ →\n                      (fin_len : ∃ n, filtration n = ⊤) →\n                        (∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                          (piecewise_coprimary :\n                              ∀ n < Nat.find fin_len,\n                                HarderNarasimhan.Coprimary R\n                                  (↥(filtration (n + 1)) ⧸ Submodule.submoduleOf (filtration n) (filtration (n + 1)))) →\n                            (∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len),\n                                { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }) →\n                              HarderNarasimhan.CoprimaryFiltration R M",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "DFunLike.coe",
   "Subtype.val",
   "Equiv",
   "Prod.fst",
   "OrderDual.ofDual",
   "Subtype.prop",
   "OrderDual.instLT",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.fine",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [BoundedOrder ℒ] {S : Type} [CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  μ ⟨(OrderDual.ofDual (↑I).2, OrderDual.ofDual (↑I).1), ⋯⟩ = OrderDual.ofDual ((fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) I)",
  "constCategory": "Theorem"},
 {"references":
  ["WithTop.semilatticeInf._proof_75",
   "WithTop.semilatticeInf._proof_76",
   "WithTop.partialOrder",
   "SemilatticeInf.toMin",
   "WithTop",
   "WithTop.some",
   "Unit",
   "SemilatticeInf",
   "WithTop.top",
   "Min.min",
   "Top.top",
   "WithTop.semilatticeInf.match_1",
   "SemilatticeInf.mk",
   "WithTop.semilatticeInf._proof_77",
   "SemilatticeInf.toPartialOrder"],
  "name": "WithTop.semilatticeInf",
  "constType":
  "{α : Type u_1} → [SemilatticeInf α] → SemilatticeInf (WithTop α)",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lattice.toSemilatticeInf._rarg",
   "_neutral",
   "HarderNarasimhan.instLatticeInterval._rarg",
   "BoundedOrder.mk"],
  "name": "HarderNarasimhan.instBoundedOrderInterval._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.Quotient.module",
   "Submodule.liftQ",
   "LinearEquiv",
   "LinearMap.id",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "Submodule.quotEquivOfEqBot._proof_37",
   "Eq",
   "Submodule.quotEquivOfEqBot._proof_38",
   "Submodule.mkQ",
   "AddCommGroup",
   "Bot.bot",
   "Ring.toSemiring",
   "Submodule.quotEquivOfEqBot._proof_35",
   "LinearEquiv.ofLinear",
   "Submodule.instBot",
   "AddCommGroup.toAddCommMonoid",
   "RingHomInvPair.ids",
   "Submodule.Quotient.restrictScalarsEquiv._proof_2",
   "Ring"],
  "name": "Submodule.quotEquivOfEqBot",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] → [inst_2 : _root_.Module R M] → (p : Submodule R M) → p = ⊥ → (M ⧸ p) ≃ₗ[R] M",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat"],
  "name": "Mathlib.Meta.NormNum.isNat_ofNat",
  "constType":
  "∀ (α : Type u) [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, ↑n = a → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "BiheytingAlgebra.toHeytingAlgebra",
   "SemilatticeSup.sup",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "LE.le",
   "SemilatticeSup.le_sup_right",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "CompleteLattice.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_31",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α), b ≤ SemilatticeSup.sup a b",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_right",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Min.min",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_11",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HarderNarasimhan.Interval z), ↑a ⊓ ↑b ≤ ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Iff.mp",
   "Preorder.toLT",
   "eq_true",
   "List.tfae_of_cycle",
   "List.instGetElem?NatLtLength",
   "Nat.instAddCommMonoid",
   "HarderNarasimhan.μmax",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "And.intro",
   "GetElem?.getElem?",
   "Mathlib.Meta.NormNum.isNat_add",
   "HarderNarasimhan.NashEquilibrium",
   "Nat.instCharZero",
   "letFun",
   "List.TFAE",
   "Nat.instIsOrderedAddMonoid",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "_private.Init.Data.Nat.Basic.0._proof_6",
   "AddZeroClass.toZero",
   "Nat.instPartialOrder",
   "And",
   "BoundedOrder",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Nat.instNontrivial",
   "True.intro",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Nat.instCanonicallyOrderedAdd",
   "Prod",
   "zero_add",
   "Nat",
   "Iff.mpr",
   "Eq.refl",
   "Iff",
   "Option",
   "AddMonoidWithOne.toOne",
   "Nontrivial",
   "Lattice",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddMonoid.toAddZeroClass",
   "List.length",
   "List.getElem?_eq_getElem",
   "_private.Mathlib.Data.Nat.Cast.Order.Ring.0._proof_7",
   "HarderNarasimhan.impl.prop4d16₂",
   "Subtype",
   "List",
   "GetElem.getElem",
   "Option.some",
   "Nat.instAddMonoidWithOne",
   "congrArg",
   "Prod.fst",
   "Nat.instSemiring",
   "HarderNarasimhan.μmin",
   "instOfNatNat",
   "congr",
   "_private.Mathlib.Data.Nat.Cast.Order.Basic.0._proof_15",
   "Zero.toOfNat0",
   "Eq",
   "Preorder.toLE",
   "List.nil",
   "List.instGetElemNatLtLength",
   "Nat.instAddMonoid",
   "Lattice.toSemilatticeInf",
   "List.TFAE.out",
   "IsStrictOrderedRing.toIsOrderedRing",
   "True",
   "List.Chain.cons",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "instHAdd",
   "List.Chain.nil",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "OfNat.ofNat",
   "LT.lt",
   "HarderNarasimhan.impl.prop4d16₁",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Nat.instIsStrictOrderedRing",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_4_16",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ →\n    [HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl,\n          HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl,\n          HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl].TFAE ∧\n      (HarderNarasimhan.WeakAscendingChainCondition μ →\n        HarderNarasimhan.WeakDescendingChainCondition μ →\n          [HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl,\n              HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl,\n              HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl,\n              HarderNarasimhan.NashEquilibrium μ].TFAE)",
  "constCategory": "Theorem"},
 {"references": ["PartialOrder", "SemilatticeSup"],
  "name": "SemilatticeSup.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "CompleteLattice.le_sSup",
   "CompleteLattice.toLattice",
   "CompleteSemilatticeSup",
   "CompleteLattice.sSup_le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "CompleteSemilatticeSup.mk",
   "CompleteLattice"],
  "name": "CompleteLattice.toCompleteSemilatticeSup",
  "constType":
  "{α : Type u_8} → [self : CompleteLattice α] → CompleteSemilatticeSup α",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.rec",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddSemigroup.toAdd",
   "PosSMulStrictMono",
   "Real",
   "AddCommGroup.add_comm",
   "instHAdd",
   "LinearOrder",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.mk",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "AddMonoid.toAddSemigroup",
   "LE.le"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.recOn",
  "constType":
  "{V : Type} →\n  {motive : HarderNarasimhan.TotallyOrderedRealVectorSpace V → Sort u} →\n    (t : HarderNarasimhan.TotallyOrderedRealVectorSpace V) →\n      ([toAddCommGroup : AddCommGroup V] →\n          [toModule : _root_.Module ℝ V] →\n            [toLinearOrder : LinearOrder V] →\n              [toPosSMulStrictMono : PosSMulStrictMono ℝ V] →\n                (elim_AddLeftMono : ∀ {y z : V} (x : V), y ≤ z → x + y ≤ x + z) →\n                  motive\n                    { toAddCommGroup := toAddCommGroup, toModule := toModule, toLinearOrder := toLinearOrder,\n                      toPosSMulStrictMono := toPosSMulStrictMono, elim_AddLeftMono := elim_AddLeftMono }) →\n        motive t",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.WeakSlopeLike₁.casesOn",
   "BoundedOrder",
   "HarderNarasimhan.WeakSlopeLike₁.noConfusionType",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₁.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.WeakSlopeLike₁ μ} →\n                  v1 = v2 → HarderNarasimhan.WeakSlopeLike₁.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["AddCommMonoid", "Module", "Semiring"],
  "name": "Submodule",
  "constType":
  "(R : Type u) → (M : Type v) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [_root_.Module R M] → Type v",
  "constCategory": "Other"},
 {"references":
  ["LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "not_lt",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "HarderNarasimhan.impl.rmk4d14₁._proof_17",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "QuotientAddGroup.Quotient.addCommGroup",
   "Module",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "Submodule.toAddSubgroup",
   "Submodule",
   "Ring.toSemiring",
   "Ring"],
  "name": "Submodule.Quotient.addCommGroup",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] → [inst_2 : _root_.Module R M] → (p : Submodule R M) → AddCommGroup (M ⧸ p)",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "OrderDual", "LT.mk", "LT"],
  "name": "OrderDual.instLT",
  "constType": "(α : Type u_5) → [LT α] → LT αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "CompleteLattice.toLattice",
   "LinearOrder",
   "SemilatticeSup.toPartialOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "HarderNarasimhan.instIsTotalDedekindMacNeilleCompletionLe",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "Or",
   "LE.le",
   "IsTotal.total",
   "Preorder.toLE",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_22",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.find",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Classical.propDecidable",
   "HarderNarasimhan.impl.prop3d4₀func",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.impl.prop3d4₀func_fin_len",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.prop3d4₀func_len",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              (μ : { p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → HarderNarasimhan.μA_DescendingChainCondition μ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.Quotient.mk",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Submodule.map",
   "Exists.intro",
   "HarderNarasimhan.impl.lift_quot_middle._proof_20",
   "Membership",
   "Subtype.val",
   "Submodule.subtype",
   "And.intro",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "eq_of_heq",
   "funext",
   "Eq.symm",
   "HarderNarasimhan.impl.lift_quot._proof_15",
   "Eq.ndrec",
   "HarderNarasimhan.impl.lift_quot_middle._proof_18",
   "SetLike.instMembership",
   "Exists",
   "AddZeroClass.toZero",
   "outParam",
   "Submodule.addCommGroup",
   "And",
   "HarderNarasimhan.impl.lift_quot_middle._proof_21",
   "LinearMap",
   "Ring.toSemiring",
   "Iff.of_eq",
   "Submodule.comap",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "HEq",
   "AddCommGroup.toAddCommMonoid",
   "id",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Eq.mp",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "AddCommMonoid.toAddMonoid",
   "HarderNarasimhan.impl.lift_quot_middle._proof_19",
   "DFunLike.coe",
   "Submodule.zero_mem",
   "congrArg",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "HarderNarasimhan.impl.lift_quot_middle._proof_17",
   "Zero.toOfNat0",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Submodule.mkQ",
   "CommRing.toCommSemiring",
   "HEq.refl",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.impl.lift_quot._proof_16",
   "AddCommGroup",
   "Exists.choose",
   "_private.Mathlib.LinearAlgebra.Quotient.Defs.0._proof_1",
   "CommRing",
   "Eq.casesOn",
   "OfNat.ofNat",
   "exists_prop_congr",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.lift_quot._proof_14",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "HarderNarasimhan.impl.lift_quot",
   "Subtype.mk",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.lift_quot_middle",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (N₁ N₂ : Submodule R M),\n  N₁ ≤ N₂ →\n    ∀ (x : Submodule R (↥N₂ ⧸ N₁.submoduleOf N₂)),\n      N₁ ≤ HarderNarasimhan.impl.lift_quot N₁ N₂ x ∧ HarderNarasimhan.impl.lift_quot N₁ N₂ x ≤ N₂",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "And.intro",
   "Set.image",
   "Set",
   "Membership.mem",
   "And",
   "Exists.intro",
   "Eq",
   "Set.instMembership"],
  "name": "Set.mem_image_of_mem",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) {x : α} {a : Set α}, x ∈ a → f x ∈ f '' a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.mk",
   "OrderDual.instPreorder",
   "OrderDual",
   "Preorder",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "inferInstanceAs",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "OrderDual.instPartialOrder",
  "constType": "(α : Type u_5) → [PartialOrder α] → PartialOrder αᵒᵈ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "RelEmbedding",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → (α → α → Prop) → (β → β → Prop) → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references": ["Not", "Exists", "Classical.not_forall", "Eq", "propext"],
  "name": "_private.HarderNarasimhan.DedekindMacNeilleCompletion.0._proof_19",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) = ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references": ["DivisionMonoid", "DivisionCommMonoid"],
  "name": "DivisionCommMonoid.toDivisionMonoid",
  "constType":
  "{G : Type u} → [self : DivisionCommMonoid G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.isInt_mul.match_1",
   "Ring.toNonAssocRing",
   "Int.mul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Distrib.toMul",
   "HMul.hMul",
   "Int.cast",
   "Int.instMul",
   "Int",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "Ring.toAddGroupWithOne",
   "Int.cast_mul",
   "NonAssocRing.toAddCommGroupWithOne",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.symm",
   "AddGroupWithOne.toIntCast",
   "instHMul",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.isInt_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → a'.mul b' = c → Mathlib.Meta.NormNum.IsInt (a * b) c",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.SlopeLike.casesOn",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice",
   "HarderNarasimhan.SlopeLike.noConfusionType"],
  "name": "HarderNarasimhan.SlopeLike.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.SlopeLike μ} → v1 = v2 → HarderNarasimhan.SlopeLike.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "Iff",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.rfl",
   "Eq",
   "Set.instSingletonSet",
   "Set.instMembership"],
  "name": "Set.mem_singleton_iff",
  "constType": "∀ {α : Type u} {a b : α}, a ∈ {b} ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "not_lt",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_lt_eq",
  "constType":
  "∀ {β : Type u_2} [inst : LinearOrder β] (a b : β), (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.find",
   "Subtype",
   "PartialOrder.toPreorder",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "Prod.fst",
   "instOfNatNat",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OfNat.ofNat",
   "Exists.casesOn",
   "LT.lt",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "instLENat"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma.match_1",
  "constType":
  "∀ (ℒ : Type) (ntl : Nontrivial ℒ) (l : Lattice ℒ) (bo : BoundedOrder ℒ) (wacc : WellFoundedGT ℒ) (S : Type)\n  (clo : CompleteLinearOrder S) (μ : { p // p.1 < p.2 } → S) (motive : (∃ JH, Nat.find ⋯ ≤ 0) → Prop)\n  (h : ∃ JH, Nat.find ⋯ ≤ 0),\n  (∀ (JH : HarderNarasimhan.JordanHolderFiltration μ) (hJH : Nat.find ⋯ ≤ 0), motive ⋯) → motive h",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Int.NonNeg.mk",
   "Nat",
   "Nat.cast",
   "instOfNat",
   "instHAdd",
   "LE.le",
   "Int.instLEInt",
   "OfNat.ofNat",
   "instNatCastInt",
   "Int"],
  "name": "Int.ofNat_nonneg",
  "constType": "∀ (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "Eq.symm",
   "PrimeSpectrum.instPartialOrder",
   "HarderNarasimhan.CoprimaryFiltration.ext.match_1",
   "Eq.ndrec",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Eq.refl",
   "Submodule.instBot",
   "Nontrivial",
   "HEq",
   "HarderNarasimhan.CoprimaryFiltration.mk",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "Eq.casesOn",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.ext",
  "constType":
  "∀ {R : Type} {inst : CommRing R} {inst_1 : IsNoetherianRing R} {M : Type} {inst_2 : Nontrivial M}\n  {inst_3 : AddCommGroup M} {inst_4 : _root_.Module R M} {inst_5 : Module.Finite R M}\n  {x y : HarderNarasimhan.CoprimaryFiltration R M}, x.filtration = y.filtration → x = y",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA_DescendingChainCondition",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "Nonempty",
   "Prod.snd",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "instNonemptyOfInhabited",
   "Nontrivial",
   "Lattice",
   "inferInstance",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instNonemptyHarderNarasimhanFiltration",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ],\n  Nonempty (HarderNarasimhan.HarderNarasimhanFiltration μ)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset",
   "Set.mem_toFinset",
   "Set",
   "Membership.mem",
   "Finset.instMembership",
   "Set.toFinset",
   "Eq",
   "Fintype",
   "propext",
   "Set.Elem",
   "Set.instMembership"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_21",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, (a ∈ s.toFinset) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "Set",
   "LE.le",
   "Membership.mem",
   "Set.mem_Iic",
   "Eq",
   "Preorder.toLE",
   "Set.Iic",
   "propext",
   "Set.instMembership"],
  "name": "_private.Mathlib.Order.Interval.Set.Defs.0._proof_5",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {b x : α}, (x ∈ Set.Iic b) = (x ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._rarg",
   "_obj",
   "_neutral"],
  "name":
  "HarderNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.hasQuotient",
   "Submodule.Quotient.mk",
   "SetLike.instMembership",
   "HasQuotient.Quotient",
   "Module",
   "Membership.mem",
   "Submodule.Quotient.instZeroQuotient",
   "AddCommGroup",
   "Submodule.Quotient.mk_eq_zero",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "Submodule",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "Ring"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_19",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} {x : M} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), (Submodule.Quotient.mk x = 0) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "OfNat.ofNat",
   "Submodule",
   "Submodule.zero._proof_23",
   "AddCommMonoid",
   "Zero.mk",
   "Submodule.setLike",
   "Zero.toOfNat0",
   "Zero",
   "Subtype.mk",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "Submodule.zero",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → {module_M : _root_.Module R M} → (p : Submodule R M) → Zero ↥p",
  "constCategory": "Definition"},
 {"references": ["Bool", "BEq"],
  "name": "BEq.beq",
  "constType": "{α : Type u} → [self : BEq α] → α → α → Bool",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "Nat.brecOn",
   "Nat.le_refl",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat",
   "Nat.add",
   "Nat.le_add_right.match_1",
   "Nat.le_succ_of_le",
   "instOfNatNat",
   "Nat.succ",
   "LE.le",
   "Nat.below",
   "instLENat"],
  "name": "Nat.le_add_right",
  "constType": "∀ (n k : ℕ), n ≤ n + k",
  "constCategory": "Theorem"},
 {"references": ["Inhabited.mk", "True", "True.intro", "Inhabited"],
  "name": "instInhabitedTrue",
  "constType": "Inhabited True",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Ring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "And.left",
   "HarderNarasimhan.impl.ℒₛ._proof_1",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Exists.choose_spec",
   "Set",
   "HarderNarasimhan.impl.ℒₛ",
   "HarderNarasimhan.impl.prop3d4₀func",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.InIntvl",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.impl.ℒₛ._proof_2",
   "CompleteLattice",
   "HarderNarasimhan.impl.prop3d4₀func._proof_7"],
  "name": "HarderNarasimhan.impl.prop3d4₀func._proof_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ)\n  (hbot : ¬(↑I).1 = ↑(HarderNarasimhan.impl.prop3d4₀func μ I n))\n  (hne : (HarderNarasimhan.impl.ℒₛ μ I (HarderNarasimhan.impl.prop3d4₀func μ I n) hbot).Nonempty),\n  HarderNarasimhan.InIntvl I ⋯.choose",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.ConvexI.mk",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.InIntvl",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "HarderNarasimhan.ConvexI.rec",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.ConvexI.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Lattice ℒ] →\n    {S : Type} →\n      [inst_1 : CompleteLattice S] →\n        {I : { p // p.1 < p.2 }} →\n          {μ : { p // p.1 < p.2 } → S} →\n            {motive : HarderNarasimhan.ConvexI I μ → Sort u} →\n              (t : HarderNarasimhan.ConvexI I μ) →\n                ((convex :\n                      ∀ (x y : ℒ),\n                        HarderNarasimhan.InIntvl I x →\n                          HarderNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩) →\n                    motive ⋯) →\n                  motive t",
  "constCategory": "Definition"},
 {"references": ["HNot"],
  "name": "HNot.hnot",
  "constType": "{α : Type u_1} → [self : HNot α] → α → α",
  "constCategory": "Definition"},
 {"references": ["HNot", "BiheytingAlgebra"],
  "name": "BiheytingAlgebra.toHNot",
  "constType": "{α : Type u_4} → [self : BiheytingAlgebra α] → HNot α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "eq_self",
   "instDecidableTrue",
   "Eq.trans",
   "of_eq_true",
   "True",
   "Decidable",
   "ite",
   "Eq.refl",
   "Eq",
   "ite_congr",
   "congrArg"],
  "name": "ite_cond_eq_true",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} (a b : α), c = True → (if c then a else b) = a",
  "constCategory": "Theorem"},
 {"references": ["Lattice"],
  "name": "Lattice.inf",
  "constType": "{α : Type u} → [self : Lattice α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid",
   "AddGroup.toSubtractionMonoid._proof_11",
   "SubtractionMonoid.mk",
   "AddGroup.toSubtractionMonoid._proof_12",
   "AddGroup",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "AddGroup.toSubNegMonoid"],
  "name": "AddGroup.toSubtractionMonoid",
  "constType": "{G : Type u_1} → [AddGroup G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Int.instCommRing",
   "CommRing.toCommSemiring",
   "CommSemiring",
   "inferInstance",
   "Int"],
  "name": "Int.instCommSemiring",
  "constType": "CommSemiring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma",
   "RingHom",
   "PartialOrder.toPreorder",
   "Submodule.Quotient.module",
   "AddHom.mk",
   "Membership.mem",
   "Preorder.toLT",
   "SMulZeroClass.toSMul",
   "Subtype.val",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "NonAssocSemiring",
   "DistribSMul.toSMulZeroClass",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Add",
   "Submodule.addCommGroup",
   "DistribMulAction.toDistribSMul",
   "Prod.snd",
   "LinearMap",
   "Ring.toSemiring",
   "Prod",
   "HSMul.hSMul",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "AddHom",
   "AddMonoid.toAddZeroClass",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "LinearMap.mk",
   "Submodule.module",
   "CommSemiring",
   "OmegaCompletePartialOrder.toPartialOrder",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "Prod.fst",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Eq",
   "Submodule.mkQ",
   "CommRing.toCommSemiring",
   "instHAdd",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "CommRing",
   "AddCommSemigroup",
   "HAdd.hAdd",
   "LT.lt",
   "CommRing.toRing",
   "Module.toDistribMulAction",
   "IsNoetherianRing",
   "lcProof",
   "HarderNarasimhan.ℒ",
   "AddCommMonoid.toAddCommSemigroup",
   "Submodule.setLike",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Semiring",
   "Module.Finite",
   "Ring"],
  "name": "HarderNarasimhan.impl.f2._cstage1",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] →\n                (I : { z // z.1 < z.2 }) → ↥(↑I).2 →ₗ[R] ↥(↑I).2 ⧸ Submodule.submoduleOf (↑I).1 (↑I).2",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.lt",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Subtype.mk_lt_mk",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Subtype.GCongr.coe_lt_coe",
   "Subtype.prop",
   "Subtype.property",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "rfl",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "lt_iff_le_not_le",
   "LT.lt",
   "Prod",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μ_res_intvl",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {I : { p // p.1 < p.2 }} {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} {J : { p // p.1 < p.2 }},\n  HarderNarasimhan.Resμ I μ J = μ ⟨(↑(↑J).1, ↑(↑J).2), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Int.lt", "LT.mk", "LT", "Int"],
  "name": "Int.instLTInt",
  "constType": "LT ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "IsNoetherianRing",
   "HarderNarasimhan.instPartialOrderS₀",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.S₀",
   "CommRing",
   "HarderNarasimhan.DedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.S",
  "constType": "(R : Type) → [inst : CommRing R] → [IsNoetherianRing R] → Type",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Finset",
   "Membership.mem",
   "LinearOrder",
   "Exists.intro",
   "WithTop",
   "WithTop.some",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "Finset.min'",
   "WithTop.coe_untop",
   "LE.le",
   "Finset.inf'._proof_13",
   "id",
   "Finset.instMembership",
   "Eq.symm",
   "Finset.min",
   "Preorder.toLE",
   "Finset.min_le_of_eq",
   "WithTop.untop",
   "SemilatticeInf.toPartialOrder"],
  "name": "Finset.min'_le",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrder α] (s : Finset α) (x : α) (H2 : x ∈ s), s.min' ⋯ ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "SemilinearMapClass",
   "AddZeroClass.toZero",
   "Module",
   "outParam",
   "MulActionSemiHomClass",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "RingHom.instFunLike",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "Module.toDistribMulAction",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "DistribSMul.toSMulZeroClass",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "SemilinearMapClass.toMulActionSemiHomClass",
  "constType":
  "∀ {F : Type u_14} {R : outParam (Type u_15)} {S : outParam (Type u_16)} {inst : Semiring R} {inst_1 : Semiring S}\n  {σ : outParam (R →+* S)} {M : outParam (Type u_17)} {M₂ : outParam (Type u_18)} {inst_2 : AddCommMonoid M}\n  {inst_3 : AddCommMonoid M₂} {inst_4 : _root_.Module R M} {inst_5 : _root_.Module S M₂} {inst_6 : FunLike F M M₂}\n  [self : SemilinearMapClass F σ M M₂], MulActionSemiHomClass F (⇑σ) M M₂",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "SemilinearMapClass",
   "Submodule.mem_comap",
   "Module",
   "Membership.mem",
   "DFunLike.coe",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.piecewise_coprimary._proof_17",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} {x : M} {F : Type u_9} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F σ₁₂ M M₂] {f : F}\n  {p : Submodule R₂ M₂}, (x ∈ Submodule.comap f p) = (f x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.hasQuotient",
   "Submodule.Quotient.mk",
   "SetLike.instMembership",
   "HasQuotient.Quotient",
   "Module",
   "Membership.mem",
   "Submodule.Quotient.instZeroQuotient",
   "AddCommGroup",
   "Submodule.Quotient.mk_eq_zero",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "Submodule",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "Ring"],
  "name": "HarderNarasimhan.impl.rmk4d14₂._proof_17",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} {x : M} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), (Submodule.Quotient.mk x = 0) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "LinearOrder.le_total",
   "instDistribLatticeOfLinearOrder",
   "LinearOrder.toPartialOrder",
   "DistribLattice.toLattice",
   "Or",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_46",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakDescendingChainCondition.mk",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakDescendingChainCondition.rec",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakDescendingChainCondition μ → Sort u} →\n                (t : HarderNarasimhan.WeakDescendingChainCondition μ) →\n                  ((wdcc : ∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["List.nil",
   "Nat",
   "instOfNat",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Coeffs.set",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.mk"],
  "name": "Lean.Omega.LinearCombo.coordinate",
  "constType": "ℕ → Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.Quotient.mk",
   "Eq.trans",
   "AddCommGroup.toAddGroup",
   "HarderNarasimhan.impl.assp._proof_1",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Iff.mp",
   "Quotient.mk",
   "Exists.intro",
   "Submodule.Quotient.instSMul",
   "SMulZeroClass.toSMul",
   "Algebra.id",
   "Subtype.val",
   "Quotient.out_eq",
   "Submodule.subtype",
   "LinearMap.semilinearMapClass",
   "MulAction.toSMul",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "letFun",
   "HarderNarasimhan.impl.assp._proof_3",
   "Eq.symm",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Semiring.toModule",
   "DistribSMul.toSMulZeroClass",
   "rfl",
   "Exists",
   "LinearMap.ker",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Submodule.addCommGroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "DistribMulAction.toDistribSMul",
   "Submodule.Quotient.instSMul'",
   "LinearMap",
   "Submodule.Quotient.mk_eq_zero",
   "Ring.toSemiring",
   "Submodule.comap",
   "Iff.mpr",
   "SMulMemClass.smul_mem",
   "Nontrivial",
   "HSMul.hSMul",
   "id",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "Quotient.out",
   "Submodule.submoduleOf",
   "AddMonoid.toAddZeroClass",
   "Quotient",
   "LinearMap.toSpanSingleton",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Eq.mp",
   "Module",
   "Submodule.module",
   "Submodule.smulMemClass",
   "Submodule.Quotient.instZeroQuotient",
   "AddCommMonoid.toAddMonoid",
   "congrArg",
   "Submodule",
   "Iff.intro",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "Ideal.ext",
   "Algebra.toSMul",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "Eq",
   "CommRing.toCommSemiring",
   "True",
   "IsScalarTower.left",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.quotientRel",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "CommRing",
   "Submodule.submoduleOf._proof_14",
   "OfNat.ofNat",
   "Submodule.isScalarTower'",
   "eq_self",
   "CommRing.toRing",
   "Module.toDistribMulAction",
   "IsNoetherianRing",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "Submodule.setLike",
   "HarderNarasimhan.impl.assp._proof_2",
   "Submodule.smul",
   "Subtype.mk",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.assp",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [IsNoetherianRing R] {M : Type} [Nontrivial M] [inst_3 : AddCommGroup M]\n  [inst_4 : _root_.Module R M] [Module.Finite R M] {N₁ u N₃ : Submodule R M} (p : Ideal R) (m : ↥u ⧸ N₁.submoduleOf u),\n  p = LinearMap.ker (LinearMap.toSpanSingleton R (↥u ⧸ N₁.submoduleOf u) m) →\n    ↑(Quotient.out m) ∈ N₃ → ∃ x, p = LinearMap.ker (LinearMap.toSpanSingleton R (↥N₃ ⧸ N₁.submoduleOf N₃) x)",
  "constCategory": "Theorem"},
 {"references":
  ["Localization",
   "LocalizedModule.isModule",
   "LocalizedModule",
   "OreLocalization.oreSetComm",
   "Module",
   "CommSemiring",
   "CommSemiring.toSemiring",
   "LocalizedModule.instAddCommMonoid",
   "MulZeroOneClass.toMulOneClass",
   "Algebra.id",
   "CommSemiring.toCommMonoid",
   "Submonoid",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "OreLocalization.instAlgebra",
   "OreLocalization.instSemiring",
   "OreLocalization.instCommSemiring",
   "Localization.isLocalization",
   "NonAssocSemiring.toMulZeroOneClass",
   "algebraMap",
   "Module.compHom"],
  "name": "LocalizedModule.isModule'",
  "constType":
  "{R : Type u} →\n  [inst : CommSemiring R] →\n    {S : Submonoid R} →\n      {M : Type v} → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → _root_.Module R (LocalizedModule S M)",
  "constCategory": "Definition"},
 {"references": ["HasQuotient.quotient'", "outParam", "HasQuotient"],
  "name": "HasQuotient.Quotient",
  "constType":
  "(A : outParam (Type u)) → {B : Type v} → [HasQuotient A B] → B → Type (max u v)",
  "constCategory": "Definition"},
 {"references":
  ["FunLike",
   "RingHom",
   "Module",
   "LinearMap.toAddHom",
   "LinearMap.instFunLike._proof_3",
   "LinearMap",
   "AddCommMonoid",
   "DFunLike.mk",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "AddHom.toFun",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Semiring"],
  "name": "LinearMap.instFunLike",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_5} →\n    {M : Type u_8} →\n      {M₃ : Type u_11} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring S] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₃] →\n                [inst_4 : _root_.Module R M] →\n                  [inst_5 : _root_.Module S M₃] → {σ : R →+* S} → FunLike (M →ₛₗ[σ] M₃) M M₃",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "True",
   "Eq.trans",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring",
   "Distrib.toMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "HMul.hMul",
   "add_mul",
   "congrArg",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "instHMul",
   "Eq",
   "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.add_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b c₁ c₂ d : R},\n  a₁ * b = c₁ → a₂ * b = c₂ → c₁ + c₂ = d → (a₁ + a₂) * b = d",
  "constCategory": "Theorem"},
 {"references": ["IsWellOrder", "IsWellFounded"],
  "name": "IsWellOrder.toIsWellFounded",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [self : IsWellOrder α r], IsWellFounded α r",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.mk''",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.quotientRel",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddCommGroup",
   "SubNegZeroMonoid.toNegZeroClass",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "Submodule",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Zero.mk",
   "NegZeroClass.toZero",
   "AddCommGroup.toAddCommMonoid",
   "Zero.toOfNat0",
   "Zero",
   "Ring"],
  "name": "Submodule.Quotient.instZeroQuotient",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : _root_.Module R M] → (p : Submodule R M) → Zero (M ⧸ p)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "Bot",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderBot",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Top",
   "OrderTop",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod",
   "LT.lt",
   "lcProof",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.TotIntvl._cstage1",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references": ["MulOneClass", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulOneClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulOneClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Module",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "AddCommMonoid.toAddMonoid",
   "Submodule",
   "congrArg",
   "_private.Mathlib.LinearAlgebra.Span.Defs.0._proof_7",
   "AddCommMonoid",
   "iff_self",
   "forall_congr",
   "_private.Init.PropLemmas.0._proof_18",
   "Zero.toOfNat0",
   "_private.Mathlib.Data.Set.Insert.0._proof_14",
   "Eq",
   "AddZeroClass.toZero",
   "True",
   "Set",
   "Set.instSingletonSet",
   "Bot.bot",
   "OfNat.ofNat",
   "Set.instMembership",
   "of_eq_true",
   "Eq.refl",
   "Iff",
   "Submodule.instBot",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.span_singleton_eq_bot",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  Submodule.span R {x} = ⊥ ↔ x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toNatCast",
   "NonAssocSemiring.natCast_zero",
   "Semiring.mk",
   "Nat.instSemiring._proof_8",
   "Nat.instNonUnitalSemiring",
   "Nat.instMonoidWithZero",
   "MonoidWithZero",
   "NonAssocSemiring.one_mul",
   "Nat",
   "Nat.instSemiring._proof_9",
   "NonAssocSemiring.mul_one",
   "Nat.instNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring",
   "NonUnitalSemiring",
   "Monoid.npow",
   "Semiring",
   "NonAssocSemiring.natCast_succ"],
  "name": "Nat.instSemiring",
  "constType": "Semiring ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "HarderNarasimhan.HarderNarasimhanFiltration.rec",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] →\n                    [h : HarderNarasimhan.μ_Admissible μ] →\n                      {motive : HarderNarasimhan.HarderNarasimhanFiltration μ → Sort u} →\n                        (t : HarderNarasimhan.HarderNarasimhanFiltration μ) →\n                          ((filtration : ℕ → ℒ) →\n                              (monotone : Monotone filtration) →\n                                (first_eq_bot : filtration 0 = ⊥) →\n                                  (fin_len : ∃ n, filtration n = ⊤) →\n                                    (strict_mono :\n                                        ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                      (piecewise_semistable :\n                                          ∀ (i : ℕ) (h : i < Nat.find fin_len),\n                                            HarderNarasimhan.Semistable\n                                              (HarderNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)) →\n                                        (μA_pseudo_strict_anti :\n                                            ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n                                              ¬HarderNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n                                                  HarderNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩) →\n                                          motive\n                                            { filtration := filtration, monotone := monotone,\n                                              first_eq_bot := first_eq_bot, fin_len := fin_len,\n                                              strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n                                              μA_pseudo_strict_anti := μA_pseudo_strict_anti }) →\n                            motive t",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "HarderNarasimhan.μA_DescendingChainCondition.noConfusionType",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.μA_DescendingChainCondition.casesOn",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μA_DescendingChainCondition.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.μA_DescendingChainCondition μ} →\n                  v1 = v2 → HarderNarasimhan.μA_DescendingChainCondition.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["_obj", "HarderNarasimhan.μA._rarg", "_neutral"],
  "name": "HarderNarasimhan.μA._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Top",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["LE"],
  "name": "OrderTop",
  "constType": "(α : Type u) → [LE α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["Eq.trans",
   "Submodule.Quotient.module",
   "Exists.intro",
   "Subtype.val",
   "RingHom.id",
   "Eq.symm",
   "Eq.ndrec",
   "Exists",
   "LinearMap.ker",
   "Submodule.addCommGroup",
   "Prod.snd",
   "LinearMap",
   "Set.instMembership",
   "HarderNarasimhan.impl.assp",
   "Ring.toSemiring",
   "Prod",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "Quotient.out",
   "setOf",
   "Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.Quotient.instZeroQuotient",
   "and_true",
   "Prod.fst",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "Eq",
   "propext",
   "LinearExtension",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "_private.Mathlib.LinearAlgebra.Quotient.Defs.0._proof_1",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "PrimeSpectrum",
   "CommRing.toRing",
   "eq_self",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan._μ._proof_2",
   "_private.Mathlib.Data.SetLike.Basic.0._proof_5",
   "Submodule.completeLattice",
   "Module.Finite",
   "And.casesOn",
   "Submodule.Quotient.mk",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Ideal.IsPrime",
   "Membership.mem",
   "Preorder.toLT",
   "Iff.mp",
   "HarderNarasimhan.impl.assinc._proof_1",
   "And.intro",
   "Semiring.toNonAssocSemiring",
   "Semiring.toModule",
   "And.left",
   "SetLike.instMembership",
   "PrimeSpectrum.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And.right",
   "And",
   "Submodule.Quotient.mk_eq_zero",
   "Exists.casesOn",
   "HasSubset.Subset",
   "Iff.of_eq",
   "Nontrivial",
   "id",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "LinearMap.toSpanSingleton",
   "associatedPrimes",
   "Subtype",
   "Submodule.module",
   "Submodule",
   "congrArg",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "Zero.toOfNat0",
   "CommRing.toCommSemiring",
   "True",
   "CommSemiring.toSemiring",
   "Submodule.quotientRel",
   "IsAssociatedPrime._proof_1",
   "CommRing",
   "IsAssociatedPrime",
   "exists_prop_congr",
   "Set.instHasSubset",
   "LT.lt",
   "IsNoetherianRing",
   "of_eq_true",
   "Submodule.setLike",
   "LE.le",
   "Subtype.mk",
   "Submodule.addCommMonoid"],
  "name": "HarderNarasimhan.impl.assinc",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] {N₁ u N₃ : Submodule R M}\n  (h₁ : N₁ < u) (h₂ : u ≤ N₃), HarderNarasimhan._μ R M ⟨(N₁, u), h₁⟩ ⊆ HarderNarasimhan._μ R M ⟨(N₁, N₃), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Eq.symm", "Eq.rec", "Eq", "LT"],
  "name": "lt_of_eq_of_lt",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LT α], a = b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "True",
   "instHAdd",
   "List",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_1",
  "constType":
  "∀ {a0 a1 : ℤ} {t : List ℤ}, (Omega.LinearCombo.coordinate 1).eval (Omega.Coeffs.ofList (a0 :: a1 :: t)) = a1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.instLinearOrderedCommMonoidWithZero._proof_1",
   "Nat.instCommMonoidWithZero",
   "PartialOrder.toPreorder",
   "Bot.mk",
   "Nat.zero_le",
   "LinearOrderedCommMonoidWithZero",
   "OfNat.ofNat",
   "LinearOrder.toPartialOrder",
   "LinearOrderedCommMonoidWithZero.mk",
   "Nat",
   "instOfNatNat",
   "Preorder.toLE",
   "Nat.instLinearOrder",
   "OrderBot.mk",
   "Nat.instLinearOrderedCommMonoidWithZero._proof_2"],
  "name": "Nat.instLinearOrderedCommMonoidWithZero",
  "constType": "LinearOrderedCommMonoidWithZero ℕ",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMonoid",
   "Module",
   "MonoidWithZero.toMonoid",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "DistribMulAction",
   "Semiring"],
  "name": "Module.toDistribMulAction",
  "constType":
  "{R : Type u} →\n  {M : Type v} → {inst : Semiring R} → {inst_1 : AddCommMonoid M} → [self : _root_.Module R M] → DistribMulAction R M",
  "constCategory": "Definition"},
 {"references": ["And.intro", "And", "Eq", "propext", "And.left", "Iff.intro"],
  "name": "and_self",
  "constType": "∀ (p : Prop), (p ∧ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.SlopeLike.rec",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.SlopeLike.mk",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.SlopeLike.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.SlopeLike μ → Sort u} →\n                (t : HarderNarasimhan.SlopeLike μ) →\n                  ((slopelike :\n                        ∀ (x y z : ℒ) (h : x < y ∧ y < z),\n                          (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n                            (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n                              (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n                                (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.find",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "Preorder.toLT",
   "Classical.propDecidable",
   "_private.Mathlib.Data.Nat.Find.0._proof_10",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "congrArg",
   "Prod.fst",
   "False.elim",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.JordanHolderFiltration.first_eq_top",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "Nat",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_37",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "False",
   "Ne",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.JH_pos_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} (JH : HarderNarasimhan.JordanHolderFiltration μ),\n  Nat.find ⋯ ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "EmptyCollection.emptyCollection",
   "Set.instEmptyCollection",
   "Subtype.val",
   "DFunLike.coe",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "ClosureOperator.isClosed_closure",
   "Eq.rec",
   "Eq",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Set.empty_subset",
   "Set.instMembership",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_16",
   "Subtype.mk"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_17",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A : T.Closeds) ⦃a : α⦄, a ∈ ↑⟨T ∅, ⋯⟩ → a ∈ ↑A",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "PartialOrder.toPreorder",
   "Add",
   "instHAdd",
   "AddLeftStrictMono",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "CovariantClass.elim",
   "HAdd.hAdd",
   "LT.lt",
   "IsLeftCancelAdd",
   "Iff.mpr",
   "PartialOrder",
   "LT.lt.ne",
   "LE.le",
   "add_ne_add_right",
   "Ne",
   "Preorder.toLE",
   "CovariantClass.mk",
   "LT.lt.le"],
  "name": "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [IsLeftCancelAdd N] [inst_2 : PartialOrder N] [AddLeftMono N], AddLeftStrictMono N",
  "constCategory": "Theorem"},
 {"references": ["HasCompl", "HeytingAlgebra"],
  "name": "HeytingAlgebra.toHasCompl",
  "constType": "{α : Type u_4} → [self : HeytingAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Exists",
   "Iff",
   "Eq.refl",
   "Exists.intro",
   "exists_prop_eq.match_1",
   "Eq.rec",
   "Eq",
   "Iff.intro"],
  "name": "exists_prop_eq",
  "constType":
  "∀ {α : Sort u_1} {a' : α} {p : (a : α) → a = a' → Prop}, (∃ a, ∃ (h : a = a'), p a h) ↔ p a' ⋯",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Function.Injective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["ContravariantClass.mk",
   "instHAdd",
   "Contravariant",
   "AddCommSemigroup",
   "ContravariantClass.elim",
   "Function.swap",
   "AddCommMagma.to_isCommutative",
   "ContravariantClass",
   "flip",
   "HAdd.hAdd",
   "Iff.mpr",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "contravariant_flip_iff"],
  "name": "contravariant_swap_add_of_contravariant_add",
  "constType":
  "∀ (N : Type u_2) (r : N → N → Prop) [inst : AddCommSemigroup N] [ContravariantClass N N (fun x1 x2 => x1 + x2) r],\n  ContravariantClass N N (Function.swap fun x1 x2 => x1 + x2) r",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Eq.symm",
   "Int.instLTInt",
   "HarderNarasimhan.JordanHolderFiltration",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "HEq",
   "Int.negOfNat",
   "Top.top",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "HarderNarasimhan.JordanHolderFiltration.ext.match_1",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "instHAdd",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Eq.casesOn",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.ext",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLinearOrder S} {μ : { p // p.1 < p.2 } → S} {x y : HarderNarasimhan.JordanHolderFiltration μ},\n  x.filtration = y.filtration → x = y",
  "constCategory": "Theorem"},
 {"references":
  ["instLinearOrderLinearExtensionOfPartialOrder._proof_4",
   "instLinearOrderLinearExtensionOfPartialOrder._proof_9",
   "PartialOrder.toPreorder",
   "Pi.hasLe",
   "instLinearOrderLinearExtensionOfPartialOrder._proof_7",
   "compareOfLessAndEq",
   "Min.mk",
   "PartialOrder.mk",
   "decidableLTOfDecidableLE",
   "IsLinearOrder",
   "Ord.mk",
   "PartialOrder",
   "Prop.le",
   "Classical.decRel",
   "LT.mk",
   "Preorder.toLE",
   "instLinearOrderLinearExtensionOfPartialOrder._proof_1",
   "Not",
   "LinearExtension",
   "instLinearOrderLinearExtensionOfPartialOrder._proof_8",
   "ite",
   "LinearOrder",
   "And",
   "decidableEqOfDecidableLE",
   "LinearOrder.mk",
   "Exists.choose",
   "Max.mk",
   "instLinearOrderLinearExtensionOfPartialOrder._proof_3",
   "instLinearOrderLinearExtensionOfPartialOrder._proof_5",
   "instLinearOrderLinearExtensionOfPartialOrder._proof_2",
   "LE.le",
   "LE.mk",
   "instLinearOrderLinearExtensionOfPartialOrder._proof_6",
   "Preorder.mk"],
  "name": "instLinearOrderLinearExtensionOfPartialOrder",
  "constType":
  "{α : Type u} → [PartialOrder α] → LinearOrder (LinearExtension α)",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "RelEmbedding.toEmbedding",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "Preorder.toLT",
   "Function.Embedding.toFun",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Prod.fst",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "HarderNarasimhan._μ",
   "HarderNarasimhan.S",
   "Subtype.le",
   "Preorder.toLE",
   "Set.instLE",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "CommRing.toCommSemiring",
   "LinearExtension",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "CommSemiring.toSemiring",
   "Set.toFinset",
   "AddCommGroup",
   "Prod.snd",
   "CommRing",
   "PrimeSpectrum",
   "LT.lt",
   "Prod",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Set.instCompleteAtomicBooleanAlgebra",
   "HarderNarasimhan.instPartialOrderS₀",
   "LE.le",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "HarderNarasimhan.S₀",
   "Module.Finite"],
  "name": "HarderNarasimhan.μ",
  "constType":
  "(R : Type) →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      (M : Type) →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] → [inst_5 : Module.Finite R M] → { z // z.1 < z.2 } → HarderNarasimhan.S R",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Prod.fst",
   "instOfNatNat",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.first_eq_bot",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ]\n  (self : HarderNarasimhan.HarderNarasimhanFiltration μ), self.filtration 0 = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "AddCommMonoid",
   "inferInstance",
   "Nat.instAddCancelCommMonoid",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "Nat.instAddCommMonoid",
  "constType": "AddCommMonoid ℕ",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "gt_iff_lt", "Eq", "GT.gt", "LT", "propext"],
  "name": "HarderNarasimhan.impl.rmk4d14₁._proof_16",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "DistribMulActionSemiHomClass",
   "outParam",
   "Monoid",
   "AddMonoid",
   "AddMonoidHomClass",
   "DistribMulAction",
   "AddMonoid.toAddZeroClass"],
  "name": "DistribMulActionSemiHomClass.toAddMonoidHomClass",
  "constType":
  "∀ {F : Type u_10} {M : outParam (Type u_11)} {N : outParam (Type u_12)} {φ : outParam (M → N)}\n  {A : outParam (Type u_13)} {B : outParam (Type u_14)} {inst : Monoid M} {inst_1 : Monoid N} {inst_2 : AddMonoid A}\n  {inst_3 : AddMonoid B} {inst_4 : DistribMulAction M A} {inst_5 : DistribMulAction N B} {inst_6 : FunLike F A B}\n  [self : DistribMulActionSemiHomClass F φ A B], AddMonoidHomClass F A B",
  "constCategory": "Theorem"},
 {"references": ["SMul", "MulAction", "Monoid"],
  "name": "MulAction.toSMul",
  "constType":
  "{α : Type u_9} → {β : Type u_10} → {inst : Monoid α} → [self : MulAction α β] → SMul α β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SMul",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["absurd",
   "rfl",
   "dif_pos.match_1",
   "Not",
   "Decidable.isFalse",
   "Decidable",
   "dite",
   "Eq",
   "Decidable.isTrue"],
  "name": "dif_pos",
  "constType":
  "∀ {c : Prop} {h : Decidable c} (hc : c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = t hc",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Monotone",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Not", "False.elim", "True", "False", "eq_true", "Eq"],
  "name": "not_false_eq_true",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_and", "And", "Eq", "propext"],
  "name": "_private.Init.SimpLemmas.0._proof_5",
  "constType": "∀ {a b : Prop}, (¬(a ∧ b)) = (a → ¬b)",
  "constCategory": "Theorem"},
 {"references": ["MulAction", "Monoid", "AddMonoid", "DistribMulAction"],
  "name": "DistribMulAction.toMulAction",
  "constType":
  "{M : Type u_12} →\n  {A : Type u_13} → {inst : Monoid M} → {inst_1 : AddMonoid A} → [self : DistribMulAction M A] → MulAction M A",
  "constCategory": "Definition"},
 {"references": ["Iff", "Membership.mem", "List.instMembership", "List"],
  "name": "List.TFAE",
  "constType": "List Prop → Prop",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "SetLike",
  "constType": "Type u_1 → outParam (Type u_2) → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "And.intro",
   "SupSet.sSup",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Set.ext",
   "HarderNarasimhan.in_TotIntvl",
   "setOf",
   "Ne.symm",
   "Subtype",
   "HarderNarasimhan.TotIntvl._proof_1",
   "Prod.fst",
   "congrArg",
   "Iff.intro",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.μmax._proof_2",
   "LT.lt",
   "ne_of_lt",
   "Ne",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop4d3_helper",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  sSup {x | ∃ y, ∃ (hy : ⊥ < y), μ ⟨(⊥, y), hy⟩ = x} = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Membership.mem",
   "And",
   "sInf_le_of_le",
   "CompleteSemilatticeInf",
   "Set.instMembership",
   "CompleteSemilatticeInf.toInfSet",
   "sInf_le_sInf_of_forall_exists_le.match_1",
   "LE.le",
   "CompleteSemilatticeInf.toPartialOrder",
   "InfSet.sInf",
   "le_sInf",
   "Preorder.toLE"],
  "name": "sInf_le_sInf_of_forall_exists_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s t : Set α}, (∀ x ∈ s, ∃ y ∈ t, y ≤ x) → sInf t ≤ sInf s",
  "constCategory": "Theorem"},
 {"references": ["AddZeroClass", "Zero"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["Iff",
   "Function.Embedding",
   "RelEmbedding",
   "Function.instFunLikeEmbedding",
   "DFunLike.coe"],
  "name": "RelEmbedding.mk",
  "constType":
  "{α : Type u_5} →\n  {β : Type u_6} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} → (toEmbedding : α ↪ β) → (∀ {a b : α}, s (toEmbedding a) (toEmbedding b) ↔ r a b) → r ↪r s",
  "constCategory": "Other"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "le_of_lt",
   "not_le_of_lt",
   "le_trans",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLT",
   "Preorder.toLE"],
  "name": "lt_of_le_of_lt",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "iff_self",
   "True",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "Iff",
   "exists_and_right._proof_25",
   "funext",
   "And",
   "_private.Init.PropLemmas.0._proof_24",
   "congrArg"],
  "name": "exists_and_right",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, p x ∧ b) ↔ (∃ x, p x) ∧ b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Set.setOf_subset_setOf",
   "Eq",
   "propext",
   "setOf"],
  "name": "_private.Mathlib.Data.Set.Basic.0._proof_18",
  "constType":
  "∀ {α : Type u} {p q : α → Prop}, ({a | p a} ⊆ {a | q a}) = ∀ (a : α), p a → q a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.JordanHolderFiltration._sizeOf_1",
   "SizeOf",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "SizeOf.mk",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.JordanHolderFiltration._sizeOf_inst",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLinearOrder S} →\n              (μ : { p // p.1 < p.2 } → S) →\n                [SizeOf ℒ] → [SizeOf S] → SizeOf (HarderNarasimhan.JordanHolderFiltration μ)",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "lt_trans",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "Or",
   "HarderNarasimhan.μBstar",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop4d1₁",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Nat.lt_add_one",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Eq.mpr",
   "setOf",
   "StrictMono",
   "HarderNarasimhan.μAstar",
   "Subtype",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Nat.instPreorder",
   "Prod.fst",
   "congrArg",
   "le_rfl",
   "Subtype.prop",
   "HarderNarasimhan.μmin",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Lattice.toSemilatticeInf",
   "le_top",
   "instHAdd",
   "HarderNarasimhan.μmax._proof_2",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "ne_of_lt",
   "LE.le",
   "le_sSup",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop4d1₂",
  "constType":
  "∀ (ℒ : Type) [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n        μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n      HarderNarasimhan.μAstar μ ≤ HarderNarasimhan.μBstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "Top",
   "OrderDual.instTop",
   "LE",
   "OrderTop",
   "bot_le",
   "OrderDual.instLE",
   "OrderBot.toBot",
   "inferInstanceAs",
   "OrderBot",
   "OrderTop.mk"],
  "name": "OrderDual.instOrderTop",
  "constType": "(α : Type u) → [inst : LE α] → [OrderBot α] → OrderTop αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "IsSuccArchimedean.mk",
   "PartialOrder.toPreorder",
   "Exists.intro",
   "Nat.instAddCommSemigroup",
   "Nat.instSuccOrder",
   "IsSuccArchimedean",
   "Nat.instAddCommMonoid",
   "Nat.instPreorder",
   "congrArg",
   "Nat.instOrderedSub",
   "HSub.hSub",
   "add_tsub_cancel_of_le",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Nat.instIsOrderedAddMonoid",
   "Eq",
   "Preorder.toLE",
   "Order.succ",
   "Nat.succ_eq_succ",
   "Nat.instPartialOrder",
   "instHAdd",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Nat.succ_iterate",
   "Nat.instCanonicallyOrderedAdd",
   "HAdd.hAdd",
   "Nat",
   "Nat.iterate",
   "instSubNat",
   "CanonicallyOrderedAdd.toExistsAddOfLE",
   "Nat.succ",
   "Eq.refl",
   "LE.le",
   "id",
   "Eq.mpr",
   "instHSub"],
  "name": "Nat.instIsSuccArchimedean",
  "constType": "IsSuccArchimedean ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "Nat.cast",
   "Eq.trans",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroOneClass.toMulOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Nat.instAddMonoidWithOne",
   "pow_one",
   "Semiring.toNonAssocSemiring",
   "instOfNatNat",
   "congr",
   "MonoidWithZero.toMonoid",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "instHPow",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "mul_one",
   "add_zero",
   "HPow.hPow",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "of_eq_true",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "AddMonoidWithOne.toOne",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.atom_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references":
  ["Finset",
   "Set.mem_toFinset",
   "Set",
   "Membership.mem",
   "Finset.instMembership",
   "Set.toFinset",
   "Eq",
   "Fintype",
   "propext",
   "Set.Elem",
   "Set.instMembership"],
  "name": "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_13",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, (a ∈ s.toFinset) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "BiheytingAlgebra.toHeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "BiheytingAlgebra.toSDiff",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "instDistribLatticeOfLinearOrder",
   "Max.max",
   "DistribLattice.toLattice",
   "Iff",
   "SemilatticeSup.toMax",
   "LE.le",
   "SDiff.sdiff",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toLattice",
   "CompleteLattice.toBoundedOrder",
   "LinearOrder.toBiheytingAlgebra",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "BiheytingAlgebra.sdiff_le_iff",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_44",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b c : HarderNarasimhan.DedekindMacNeilleCompletion α), a \\ b ≤ c ↔ a ≤ max b c",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "True",
   "instHAdd",
   "List",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_7",
  "constType":
  "∀ {a0 a1 a2 a3 a4 a5 a6 a7 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 7).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: a4 :: a5 :: a6 :: a7 :: t)) = a7",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "CompleteLattice",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLattice.toTop",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition'.wdcc'",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.WeakDescendingChainCondition' μ]\n  (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤",
  "constCategory": "Theorem"},
 {"references": ["Set", "SupSet"],
  "name": "SupSet.mk",
  "constType": "{α : Type u_1} → (Set α → α) → SupSet α",
  "constCategory": "Other"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "AddCommGroup.toAddGroup",
   "Iff.mp",
   "SMulZeroClass.toSMul",
   "MonoidWithZero.toMulZeroOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "NoZeroSMulDivisors",
   "AddGroup.toSubtractionMonoid",
   "Semiring.toNonAssocSemiring",
   "Or",
   "AddMonoidHom",
   "injective_iff_map_eq_zero",
   "AddMonoidHom.instFunLike",
   "AddGroup.toSubNegMonoid",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "DistribSMul.toSMulZeroClass",
   "AddZeroClass.toZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "DistribMulAction.toDistribSMul",
   "Or.resolve_left",
   "SMulWithZero.toSMulZeroClass",
   "MulZeroOneClass.toMulZeroClass",
   "Iff.mpr",
   "HSMul.hSMul",
   "AddCommGroup.toAddCommMonoid",
   "NegZeroClass.toZero",
   "AddMonoidHom.instAddCommMonoid",
   "smul_eq_zero",
   "AddMonoid.toAddZeroClass",
   "smulAddHom",
   "Module",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoidHom.instAddMonoidHomClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "DFunLike.coe",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "MulActionWithZero.toSMulWithZero",
   "Semiring.toMonoidWithZero",
   "Module.toMulActionWithZero",
   "AddCommGroup",
   "OfNat.ofNat",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Ne",
   "Semiring",
   "Function.Injective"],
  "name": "smul_right_injective",
  "constType":
  "∀ {R : Type u_1} (M : Type u_2) [inst : Semiring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  [NoZeroSMulDivisors R M] {c : R}, c ≠ 0 → Function.Injective fun x => c • x",
  "constCategory": "Theorem"},
 {"references": ["exists_prop", "Exists", "And", "Eq", "propext"],
  "name": "HarderNarasimhan.μA_res_intvl._proof_20",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Subtype.partialOrder",
   "ClosureOperator",
   "Union.union",
   "DFunLike.coe",
   "Subtype.val",
   "congrArg",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "Eq.symm",
   "ClosureOperator.isClosed_closure",
   "Preorder.toLE",
   "Set.instUnion",
   "Eq.rec",
   "Eq",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
   "Set.subset_union_left",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Subtype.coe_eq_of_eq_mk",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "Subtype.mk"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_2",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds), A ≤ ⟨T (↑A ∪ ↑B), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["WithTop.top",
   "LE",
   "OrderTop",
   "WithTop",
   "WithTop.orderTop._proof_62",
   "WithTop.le",
   "OrderTop.mk"],
  "name": "WithTop.orderTop",
  "constType": "{α : Type u_1} → [inst : LE α] → OrderTop (WithTop α)",
  "constCategory": "Definition"},
 {"references": ["LE", "OrderTop", "BoundedOrder"],
  "name": "BoundedOrder.toOrderTop",
  "constType":
  "{α : Type u} → {inst : LE α} → [self : BoundedOrder α] → OrderTop α",
  "constCategory": "Definition"},
 {"references": ["HasCompl"],
  "name": "HasCompl.compl",
  "constType": "{α : Type u_1} → [self : HasCompl α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Preorder.toLT",
   "Coe.mk",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["True",
   "AddZeroClass.toZero",
   "AddZeroClass.toAdd",
   "AddZeroClass",
   "zero_le",
   "LE.le",
   "LE",
   "eq_true",
   "CanonicallyOrderedAdd",
   "Zero.toOfNat0",
   "Eq",
   "OfNat.ofNat"],
  "name": "_private.Mathlib.Algebra.Order.Monoid.Canonical.Defs.0._proof_6",
  "constType":
  "∀ {α : Type u} [inst : AddZeroClass α] [inst_1 : LE α] [CanonicallyOrderedAdd α] (a : α), (0 ≤ a) = True",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "OrderHom.toFun", "Monotone", "OrderHom"],
  "name": "OrderHom.monotone'",
  "constType":
  "∀ {α : Type u_6} {β : Type u_7} [inst : Preorder α] [inst_1 : Preorder β] (self : α →o β), Monotone self.toFun",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "of_eq_false",
   "Decidable",
   "Eq.trans",
   "True",
   "Eq.mpr_not",
   "dite_congr",
   "Eq.mpr_prop",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "Eq.refl",
   "False",
   "instDecidableFalse",
   "Eq",
   "dite",
   "not_false"],
  "name": "dite_cond_eq_false",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} {t : c → α} {e : ¬c → α} (h : c = False), dite c t e = e ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.WeakDescendingChainCondition'.wdcc'",
   "Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instPreorder",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "HarderNarasimhan.instBoundedOrderInterval",
   "lt_iff_le_not_le",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.instNontrivialInterval",
   "StrictAnti",
   "Nat",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "HarderNarasimhan.WeakDescendingChainCondition'.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.instWeakDescendingChainCondition'IntervalResμ",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [h : HarderNarasimhan.WeakDescendingChainCondition' μ]\n  {I : { p // p.1 < p.2 }}, HarderNarasimhan.WeakDescendingChainCondition' (HarderNarasimhan.Resμ I μ)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "eq_false",
   "Preorder.toLT",
   "False",
   "not_lt_bot",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "Bot.bot",
   "OrderBot"],
  "name": "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_16",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderBot α] {a : α}, (a < ⊥) = False",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Exists.intro",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "CompleteLattice.toBoundedOrder",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "HarderNarasimhan.WeakDescendingChainCondition.mk",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "CompleteLattice.toCompleteSemilatticeInf",
   "neg_neg_of_pos",
   "instHSub",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "CompleteLattice",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLattice.toTop",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Eq.rec",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "lt_of_le_of_lt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.lt_add_one",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Exists.casesOn",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "HarderNarasimhan.WeakDescendingChainCondition'.wdcc'",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "le_top",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "instLENat",
   "Int.instAddMonoid"],
  "name":
  "HarderNarasimhan.instWeakDescendingChainConditionOfWeakDescendingChainCondition'",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [h : HarderNarasimhan.WeakDescendingChainCondition' μ],\n  HarderNarasimhan.WeakDescendingChainCondition μ",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_4",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_8",
   "Set.Elem",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_10",
   "HarderNarasimhan.impl.prop4d1₁_seq.match_1",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_1",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_2",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "Unit",
   "Set.instMembership",
   "Prod",
   "Nat",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_9",
   "StrictMono",
   "setOf",
   "Subtype",
   "Nat.instPreorder",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Not",
   "Set.Nonempty",
   "le_top",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Set",
   "HarderNarasimhan.impl.prop4d1₁_seq",
   "Exists.choose",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_3"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._sunfold",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [inst_1 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_2 : CompleteLattice S] →\n            (μ : { p // p.1 < p.2 } → S) →\n              (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                    μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                  {YA |\n                        ∃ (h : YA < ⊤),\n                          ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty →\n                    ℕ → ↑{YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Definition"},
 {"references":
  ["Finset",
   "Decidable",
   "Eq.trans",
   "Singleton.singleton",
   "Exists.intro",
   "_private.HarderNarasimhan.CoprimaryFiltration.Lex'Order.0.Lex'Order.Lex'LinearOrder._proof_14",
   "Min.mk",
   "linearOrderOfSTO",
   "decidableLTOfDecidableLE",
   "_private.HarderNarasimhan.CoprimaryFiltration.Lex'Order.0.Lex'Order.le_antisymm",
   "letFun",
   "_private.HarderNarasimhan.CoprimaryFiltration.Lex'Order.0.Lex'Order.Lex'LinearOrder._proof_13",
   "Lex'Order.instDecidableLeFinset_harderNarasimhan",
   "instLTNat",
   "Exists",
   "List.LE'",
   "LinearOrder",
   "true_and",
   "List.instLinearOrder._proof_4",
   "LinearOrder.toDecidableLT",
   "false_or",
   "Eq.refl",
   "Iff",
   "Lex'Order.Lex'Order_prop._proof_17",
   "Eq.mpr",
   "Preorder.mk",
   "Finset.ssubset_iff_subset_ne",
   "_private.HarderNarasimhan.CoprimaryFiltration.Lex'Order.0.Lex'Order.Lex'LinearOrder",
   "_private.HarderNarasimhan.CoprimaryFiltration.Lex'Order.0._proof_3",
   "_private.HarderNarasimhan.CoprimaryFiltration.Lex'Order.0.Lex'Order.Lex'LinearOrder._proof_9",
   "Or.inr",
   "Lex'Order.LexLE",
   "List",
   "and_true",
   "List.instLinearOrder",
   "Nat.instPreorder",
   "PartialOrder.mk",
   "Or.inl",
   "instOfNatNat",
   "Ord.mk",
   "congr",
   "Eq",
   "Preorder.toLE",
   "_private.HarderNarasimhan.CoprimaryFiltration.Lex'Order.0.Lex'Order.Lex'LinearOrder._proof_15",
   "HasSSubset.SSubset",
   "ite",
   "LinearOrder.mk",
   "decidableEqOfDecidableLE",
   "OfNat.ofNat",
   "Finset.decidableEq",
   "LinearOrder.toPartialOrder",
   "eq_self",
   "Finset.sort_singleton",
   "LinearOrder.toDecidableEq",
   "LinearOrder.toDecidableLE",
   "List.lt",
   "instDecidableEqNat",
   "Ne",
   "dite",
   "le_refl",
   "PartialOrder.toPreorder",
   "DecidableRel",
   "Lex'Order.Lex'Order_prop._proof_16",
   "Preorder.toLT",
   "And.intro",
   "Or",
   "funext",
   "LT.mk",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "Lex'Order.LexLE._proof_2",
   "_private.HarderNarasimhan.CoprimaryFiltration.Lex'Order.0.Lex'Order.Lex'LinearOrder._proof_11",
   "Finset.instHasSSubset",
   "List.instLinearOrder._proof_5",
   "And",
   "Max.mk",
   "Nat.decLt",
   "Nat",
   "Finset.instSingleton",
   "HasSubset.Subset",
   "Iff.mpr",
   "id",
   "instDecidableAnd",
   "Eq.mp",
   "_private.HarderNarasimhan.CoprimaryFiltration.Lex'Order.0.Lex'Order.Lex'LinearOrder._proof_10",
   "lt_of_le_of_ne",
   "compareOfLessAndEq",
   "congrArg",
   "Iff.intro",
   "Lex'Order.LexLE._proof_1",
   "Finset.card_lt_card",
   "IsStrictTotalOrder",
   "instDistribLatticeOfLinearOrder",
   "Finset.sort",
   "le_of_eq",
   "LE.isTotal",
   "List.instLT",
   "instDecidableOr",
   "Not",
   "List.nil",
   "DecidableLE",
   "Lattice.toSemilatticeInf",
   "True",
   "Finset.card",
   "Finset.instHasSubset",
   "_private.HarderNarasimhan.CoprimaryFiltration.Lex'Order.0.Lex'Order.Lex'LinearOrder._proof_12",
   "Or.casesOn",
   "LT.lt",
   "DistribLattice.toLattice",
   "le_of_lt",
   "List.cons.injEq",
   "LE.mk",
   "LE.le",
   "List.Lex",
   "List.Lex.decidableRel",
   "False",
   "Lex'Order.LexLT",
   "Finset.card_singleton"],
  "name": "Lex'Order.Lex'Order_prop",
  "constType":
  "∀ (α : Type) [lo : LinearOrder α], ∃ lo_1, (∀ (A B : Finset α), A ⊆ B → A ≤ B) ∧ ∀ (a b : α), a ≤ b ↔ {a} ≤ {b}",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "DFunLike.coe",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "Set.univ",
   "ClosureOperator.instFunLike",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "trivial",
   "Preorder.toLE"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_15",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)), T.IsClosed Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.choose_spec",
   "implies_congr",
   "Finset",
   "Eq.trans",
   "Module.annihilator_le_of_mem_support",
   "AddCommGroup.toAddGroup",
   "Singleton.singleton",
   "Exists.intro",
   "SMulZeroClass.toSMul",
   "Classical.choose",
   "Subtype.val",
   "Set.Elem",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "mul_comm",
   "Eq.symm",
   "Monoid.toSemigroup",
   "MulOneClass.toMul",
   "Submodule.annihilator",
   "Exists",
   "Dvd.dvd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Submodule.FG",
   "Set.instMembership",
   "Finset.dvd_prod_of_mem",
   "Iff",
   "Eq.refl",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Finset.instMembership",
   "Submodule.mem_annihilator_span",
   "Eq.mpr",
   "Mathlib.Tactic.PushNeg.not_implies_eq",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "AddCommMonoid.toAddMonoid",
   "Semigroup.toMul",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "Set",
   "Submodule.instTop",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "OfNat.ofNat",
   "CommRing.toCommMonoid",
   "PrimeSpectrum",
   "Module.toDistribMulAction",
   "Submodule.completeLattice",
   "Module.Finite.casesOn",
   "Module.Finite",
   "semigroupDvd",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Iff.mp",
   "HMul.hMul",
   "Finset.toSet",
   "Submodule.span",
   "PrimeSpectrum.isPrime",
   "MulAction.toSMul",
   "And.intro",
   "Semiring.toNonAssocSemiring",
   "Subtype.forall'",
   "funext",
   "forall_congr",
   "DistribMulAction.toMulAction",
   "Module.annihilator",
   "AddGroup.toSubNegMonoid",
   "Semiring.toModule",
   "And.left",
   "DistribSMul.toSMulZeroClass",
   "SetLike.instMembership",
   "CommMagma.toMul",
   "AddZeroClass.toZero",
   "And.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "DistribMulAction.toDistribSMul",
   "Exists.casesOn",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "instHMul",
   "Module.mem_support_iff_of_finite._proof_3",
   "smul_zero",
   "SetLike.instPartialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "MulAction.mul_smul",
   "Subtype",
   "CommMonoid.toMonoid",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "Finset.mem_attach",
   "Iff.intro",
   "Submodule",
   "congrArg",
   "Ideal",
   "Monoid.toMulOneClass",
   "MonoidWithZero.toMonoid",
   "Module.mem_support_iff_of_span_eq_top",
   "Ideal.primeCompl",
   "instHSMul",
   "PrimeSpectrum.asIdeal",
   "Zero.toOfNat0",
   "Submonoid.prod_mem",
   "Submodule.annihilator_top",
   "Not",
   "CommRing.toCommSemiring",
   "Module.support",
   "Mathlib.Tactic.PushNeg.not_and_eq",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.PushNeg.not_forall_eq",
   "Set.instSingletonSet",
   "CommRing",
   "Mathlib.Tactic.Contrapose.mtr",
   "Finset.prod",
   "SubNegMonoid.toAddMonoid",
   "Submodule.setLike",
   "LE.le",
   "Module.mem_support_iff_of_finite._proof_2",
   "Finset.attach"],
  "name": "Module.mem_support_iff_of_finite",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  {p : PrimeSpectrum R} [Module.Finite R M], p ∈ Module.support R M ↔ Module.annihilator R M ≤ p.asIdeal",
  "constCategory": "Theorem"},
 {"references":
  ["Nonneg.semifield",
   "Real.instIsStrictOrderedRing",
   "Real",
   "NNReal",
   "Real.field",
   "Field.toSemifield",
   "Semifield",
   "Real.linearOrder"],
  "name": "NNReal.instSemifield",
  "constType": "Semifield NNReal",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "constCategory": "Definition"},
 {"references":
  ["instTransEq",
   "Trans.trans",
   "AddZeroClass",
   "AddRightStrictMono",
   "AddZeroClass.toZero",
   "instHAdd",
   "OfNat.ofNat",
   "add_lt_add_right",
   "LT.lt",
   "HAdd.hAdd",
   "zero_add",
   "AddZeroClass.toAdd",
   "Eq.symm",
   "Zero.toOfNat0",
   "Eq",
   "LT"],
  "name": "lt_add_of_pos_left",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α] [AddRightStrictMono α] (a : α) {b : α}, 0 < b → a < b + a",
  "constCategory": "Theorem"},
 {"references": ["_obj", "HarderNarasimhan.Resμ._rarg", "_neutral"],
  "name": "HarderNarasimhan.Resμ._cstage2",
  "constType":
  "_neutral → _neutral → _obj → _obj → _obj → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.StI",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Set",
   "HarderNarasimhan.semistableI",
   "Membership.mem",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Set.instMembership",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.semistableI.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.semistableI μ I = ((↑I).2 ∈ HarderNarasimhan.StI μ I)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "GaloisConnection.lowerAdjoint",
   "OrderDual",
   "OrderDual.toDual",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "LowerAdjoint.toFun",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "DFunLike.coe",
   "_private.Init.Core.0._proof_25",
   "Equiv",
   "congrArg",
   "OrderDual.ofDual",
   "Iff.intro",
   "HarderNarasimhan.DedekindMacNeilleConnection",
   "PartialOrder",
   "forall_congr",
   "funext",
   "Eq",
   "Preorder.toLE",
   "True",
   "Equiv.instFunLike",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Set.Iic",
   "Set.instMembership",
   "implies_true",
   "OrderDual.instPreorder",
   "of_eq_true",
   "_private.Mathlib.Order.Interval.Set.Defs.0._proof_5",
   "Set.instCompleteAtomicBooleanAlgebra",
   "upperBounds",
   "Eq.refl",
   "LE.le",
   "lowerBounds",
   "Set.ext",
   "setOf"],
  "name": "HarderNarasimhan.coe'._proof_48",
  "constType":
  "∀ {α : Type} [inst : PartialOrder α] (x : α),\n  lowerBounds (OrderDual.ofDual (⋯.lowerAdjoint.toFun (Set.Iic x))) = Set.Iic x",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Eq.ndrec",
   "Eq",
   "add_comm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Neg.neg",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "SubNegMonoid.toNeg",
   "neg_add_rev",
   "HAdd.hAdd",
   "Ring.toAddCommGroup",
   "eq_self",
   "NegZeroClass.toNeg",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "Ring",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.neg_add",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a₁ a₂ b₁ b₂ : R}, -a₁ = b₁ → -a₂ = b₂ → -(a₁ + a₂) = b₁ + b₂",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "AddZeroClass.toZero",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.semistableI",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "bot_le",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "HarderNarasimhan.S₂I",
   "HarderNarasimhan.S₁I",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.Convex",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Exists.choose_spec",
   "And",
   "HarderNarasimhan.St",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.in_TotIntvl",
   "HarderNarasimhan.Semistable",
   "Subtype",
   "HarderNarasimhan.StI",
   "lt_of_le_of_ne",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "HarderNarasimhan.Interval",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Not",
   "HarderNarasimhan.impl.prop3d7₂",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.semistableI_iff",
   "HarderNarasimhan.instBoundedOrderInterval",
   "Exists.choose",
   "LT.lt",
   "HarderNarasimhan.instNontrivialInterval",
   "HarderNarasimhan.μA",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.impl.prop3d7₁",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_3_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Convex μ →\n    ∀ (x : ℒ) (hxSt : x ∈ HarderNarasimhan.St μ),\n      HarderNarasimhan.Semistable (HarderNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ) ∧\n        ∀ (y : ℒ) (hy : y > x), ¬HarderNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(x, y), hy⟩",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalSemiring", "NonUnitalNonAssocSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.hasQuotient",
   "Submodule.Quotient.mk",
   "SetLike.instMembership",
   "HasQuotient.Quotient",
   "Module",
   "Membership.mem",
   "Submodule.Quotient.instZeroQuotient",
   "AddCommGroup",
   "Submodule.Quotient.mk_eq_zero",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "Submodule",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "Ring"],
  "name": "HarderNarasimhan.impl.assp._proof_2",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} {x : M} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), (Submodule.Quotient.mk x = 0) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references": ["default.sizeOf", "SizeOf", "SizeOf.mk"],
  "name": "instSizeOfDefault",
  "constType": "(α : Sort u) → SizeOf α",
  "constCategory": "Definition"},
 {"references": ["eq_false", "And.right", "And", "False", "Eq"],
  "name": "and_false",
  "constType": "∀ (p : Prop), (p ∧ False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans", "Eq.symm", "ExistsUnique.unique.match_1", "ExistsUnique", "Eq"],
  "name": "ExistsUnique.unique",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop}, (∃! x, p x) → ∀ {y₁ y₂ : α}, p y₁ → p y₂ → y₁ = y₂",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.SlopeLike",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["SubtractionMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegZeroMonoid.mk",
   "SubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid._proof_16",
   "SubNegZeroMonoid"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid",
  "constType": "{α : Type u_1} → [SubtractionMonoid α] → SubNegZeroMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.InIntvl",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.ConvexI.convex",
  "constType":
  "∀ {ℒ : Type} {inst : Lattice ℒ} {S : Type} {inst_1 : CompleteLattice S} {I : { p // p.1 < p.2 }}\n  {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.ConvexI I μ] (x y : ℒ),\n  HarderNarasimhan.InIntvl I x → HarderNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instBoundedOrderInterval._proof_16",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a : HarderNarasimhan.Interval z), (↑z).1 ≤ ↑a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.singleton",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → [self : Singleton α β] → α → β",
  "constCategory": "Definition"},
 {"references": ["Not", "Eq.symm", "Eq.rec", "Eq"],
  "name": "Eq.mpr_not",
  "constType": "∀ {p q : Prop}, p = q → ¬q → ¬p",
  "constCategory": "Theorem"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Eq.symm",
   "Int.instLEInt",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nat.lt_of_not_le",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Bool",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Option.some",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Int.instAdd",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (i j : ℕ),\n  i < j → j < Nat.find hffin → ¬i + 1 ≤ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "HarderNarasimhan.HarderNarasimhanFiltration.ext.match_1",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "HEq",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "Eq.casesOn",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.ext",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HarderNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HarderNarasimhan.Convex μ} {h : HarderNarasimhan.μ_Admissible μ}\n  {x y : HarderNarasimhan.HarderNarasimhanFiltration μ}, x.filtration = y.filtration → x = y",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.NashEquilibrium",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace", "LinearOrder"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
  "constType":
  "{V : Type} → [self : HarderNarasimhan.TotallyOrderedRealVectorSpace V] → LinearOrder V",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocSemiring.mk",
   "AddCommGroup.add_comm",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocCommRing",
   "NonUnitalNonAssocCommRing.mul_comm",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.zero_mul",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.left_distrib"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "AddMonoidWithOne.toOne",
   "Lattice",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Preorder.toLT",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.impl.JHFil._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (x : ℕ → ℒ), StrictAnti x → ∀ (N : ℕ), x (N + 1) < x N",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.ConvexI",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.lem2d4₁",
   "Preorder.toLE",
   "inf_lt_left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "gt_of_ge_of_gt",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.impl.lem2d4₂I",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.InIntvl",
   "Min.min",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "HarderNarasimhan.impl.lem2d4₃I"],
  "name": "HarderNarasimhan.impl.lem2d4I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (w : ℒ),\n          HarderNarasimhan.InIntvl I w →\n            ∀ (hxw : ¬x ≤ w) (u t : ℒ) (huxw : u ≤ x ⊓ w) (hxwt : x ⊔ w ≤ t),\n              HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HarderNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩ ∧\n                HarderNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩ ≤ HarderNarasimhan.μmax μ ⟨(w, t), ⋯⟩ ∧\n                  HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(w, x ⊔ w), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "instLTNat",
   "instHAdd",
   "Nat.leRec",
   "Nat.leRec._proof_5",
   "Nat.le_refl",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Nat",
   "Nat.le_succ_of_le",
   "instOfNatNat",
   "LE.le",
   "Nat.le_of_succ_le",
   "Nat.lt_succ_self",
   "Nat.decreasingInduction._proof_11",
   "instLENat",
   "Nat.decreasingInduction._proof_10"],
  "name": "Nat.decreasingInduction",
  "constType":
  "{n : ℕ} →\n  {motive : (m : ℕ) → m ≤ n → Sort u_1} →\n    ((k : ℕ) → (h : k < n) → motive (k + 1) h → motive k ⋯) → motive n ⋯ → {m : ℕ} → (mn : m ≤ n) → motive m mn",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "eq_comm",
   "Singleton.singleton",
   "Set.ext",
   "Set.instSingletonSet",
   "Eq",
   "setOf"],
  "name": "Set.setOf_eq_eq_singleton'",
  "constType": "∀ {α : Type u} {a : α}, {x | a = x} = {a}",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.toAddSubmonoid",
   "AddZeroClass.toZero",
   "Module",
   "AddSubsemigroup.add_mem'",
   "AddCommMonoid.toAddMonoid",
   "Submodule",
   "AddCommMonoid",
   "AddZeroClass.toAdd",
   "Submodule.setLike",
   "AddSubmonoid.zero_mem'",
   "ZeroMemClass.mk",
   "AddMemClass.mk",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubmonoidClass",
   "AddSubmonoidClass.mk",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.addSubmonoidClass",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M],\n  AddSubmonoidClass (Submodule R M) M",
  "constCategory": "Theorem"},
 {"references":
  ["neg_add_cancel_right",
   "AddRightStrictMono",
   "congrArg",
   "sub_eq_add_neg",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "Eq.symm",
   "AddGroup.toSubNegMonoid",
   "AddGroup.covconv_swap",
   "Eq",
   "propext",
   "instHAdd",
   "add_lt_add_iff_right",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "Iff.rfl",
   "LT.lt",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddZeroClass.toAdd",
   "Iff",
   "id",
   "AddGroup",
   "Eq.mpr",
   "instHSub",
   "LT",
   "AddMonoid.toAddZeroClass"],
  "name": "lt_sub_iff_add_lt",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α] [AddRightStrictMono α] {a b c : α}, a < c - b ↔ a + b < c",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "PartialOrder.toPreorder",
   "eq_of_le_of_not_lt",
   "PartialOrder",
   "LE.le",
   "Eq.symm",
   "Preorder.toLT",
   "Eq",
   "Preorder.toLE"],
  "name": "eq_of_ge_of_not_gt",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≤ b → ¬a < b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "CompleteLattice",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLattice.toTop",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "HarderNarasimhan.WeakDescendingChainCondition'.mk",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition'.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) →\n    HarderNarasimhan.WeakDescendingChainCondition' μ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint",
   "Bool",
   "Lean.Omega.Coeffs.dot_smul_left",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs",
   "HMul.hMul",
   "Lean.Omega.IntList.instHMulInt",
   "Lean.Omega.Coeffs.combo_eq_smul_add_smul",
   "Int.instMul",
   "congrArg",
   "Lean.Omega.Constraint.combo_sat",
   "Lean.Omega.IntList",
   "Lean.Omega.IntList.instAdd",
   "Int.instAdd",
   "Eq",
   "Bool.true",
   "Lean.Omega.Constraint.sat'.eq_1",
   "instHAdd",
   "Lean.Omega.Coeffs.combo",
   "Lean.Omega.Constraint.combo",
   "Int",
   "HAdd.hAdd",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "id",
   "instHMul",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.combo_sat'",
  "constType":
  "∀ (s t : Omega.Constraint) (a : ℤ) (x : Omega.Coeffs) (b : ℤ) (y v : Omega.Coeffs),\n  s.sat' x v = true → t.sat' y v = true → (Omega.Constraint.combo a s b t).sat' (Omega.Coeffs.combo a x b y) v = true",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "lt_or_gt_of_ne",
   "ne_of_gt",
   "GT.gt",
   "Iff.intro",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Or",
   "ne_of_lt",
   "Iff",
   "Ne"],
  "name": "ne_iff_lt_or_gt",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, a ≠ b ↔ a < b ∨ a > b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "HarderNarasimhan.impl.test._proof_20",
   "Eq.trans",
   "LinearMap.instFunLike",
   "Eq.mp",
   "Module",
   "Submodule.module",
   "Membership.mem",
   "Submodule.map",
   "HarderNarasimhan.impl.test._proof_19",
   "Subtype.val",
   "DFunLike.coe",
   "congrArg",
   "Submodule",
   "Submodule.subtype",
   "LinearMap.semilinearMapClass",
   "HarderNarasimhan.impl.test._proof_18",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "funext",
   "Eq",
   "propext",
   "CommRing.toCommSemiring",
   "Exists",
   "SetLike.instMembership",
   "CommSemiring.toSemiring",
   "And",
   "HarderNarasimhan.impl.test._proof_17",
   "AddCommGroup",
   "CommRing",
   "LinearMap",
   "exists_prop_congr",
   "RingHomSurjective.ids",
   "Exists.casesOn",
   "Iff.of_eq",
   "Submodule.setLike",
   "Eq.refl",
   "Iff.mpr",
   "AddCommGroup.toAddCommMonoid",
   "Subtype.mk",
   "Submodule.addCommMonoid"],
  "name": "HarderNarasimhan.impl.test",
  "constType":
  "∀ {R : Type} [inst : CommRing R] {M : Type} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] (N : Submodule R M)\n  (N' : Submodule R ↥N) (x : M) (hx1 : x ∈ N), x ∈ Submodule.map N.subtype N' → ⟨x, hx1⟩ ∈ N'",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "AddZeroClass",
   "AddZeroClass.toZero",
   "CanonicallyOrderedAdd",
   "nonpos_iff_eq_zero",
   "OfNat.ofNat",
   "AddZeroClass.toAdd",
   "PartialOrder",
   "LE.le",
   "Zero.toOfNat0",
   "Preorder.toLE",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Algebra.Order.Monoid.Canonical.Defs.0._proof_10",
  "constType":
  "∀ {α : Type u} [inst : AddZeroClass α] [inst_1 : PartialOrder α] [CanonicallyOrderedAdd α] {a : α}, (a ≤ 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "Preorder.toLT",
   "False",
   "lt_self_iff_false",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.Basic.0._proof_1",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] (x : α), (x < x) = False",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.S₀_order",
   "HarderNarasimhan.instLES₀",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Singleton.singleton",
   "Iff.mp",
   "Preorder.toLT",
   "congrArg",
   "instDistribLatticeOfLinearOrder",
   "iff_self",
   "HarderNarasimhan.instLinearOrderS₀",
   "PrimeSpectrum.instPartialOrder",
   "Preorder.toLE",
   "propext",
   "SemilatticeInf.toPartialOrder",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "True",
   "LinearExtension",
   "And.right",
   "CommSemiring.toSemiring",
   "Finset.instHasSubset",
   "CommRing",
   "PrimeSpectrum",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "le_iff_le_iff_lt_iff_lt",
   "IsNoetherianRing",
   "Finset.instSingleton",
   "DistribLattice.toLattice",
   "HasSubset.Subset",
   "of_eq_true",
   "HarderNarasimhan.instPartialOrderS₀",
   "Iff",
   "LE.le",
   "HarderNarasimhan.S₀"],
  "name": "HarderNarasimhan.S₀_order'",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {a b : LinearExtension (PrimeSpectrum R)},\n  a < b ↔ {a} < {b}",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "IsStrictOrderedRing",
   "Lattice.toSemilatticeInf",
   "NonUnitalNonAssocSemiring.toDistrib",
   "IsStrictOrderedRing.toIsOrderedRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "LinearOrder",
   "DivisionSemiring.toSemiring",
   "PosMulMono",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "DistribLattice.toLattice",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semifield",
   "Semifield.toDivisionSemiring",
   "IsOrderedRing.toPosMulMono",
   "SemilatticeInf.toPartialOrder"],
  "name": "Nonneg.semifield._proof_12",
  "constType":
  "∀ {α : Type u_1} [inst : Semifield α] [inst_1 : LinearOrder α] [IsStrictOrderedRing α], PosMulMono α",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Ring.toNonAssocRing",
   "Submodule.Quotient.module",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "SMulZeroClass.toSMul",
   "HarderNarasimhan.impl.quot_ntl",
   "instDistribSMul",
   "Submodule.Quotient.instSMul._proof_3",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "RingHom.id",
   "letFun",
   "Module.IsNoetherian.finite",
   "not_lt_of_le",
   "Eq.symm",
   "HarderNarasimhan.impl.quot_ntl'",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HarderNarasimhan.S",
   "instLTNat",
   "HarderNarasimhan.impl.piecewise_coprimary._proof_17",
   "Submodule.addCommGroup",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "LinearMap",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "Set.instMembership",
   "Ring.toSemiring",
   "Prod",
   "Nat.instStarOrderedRing",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.Semistable",
   "AddMonoid.toAddZeroClass",
   "Nat.find",
   "Submodule.hasQuotient",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.mem_top",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Nat.instSemiring",
   "instOfNatNat",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.impl.prop3d11",
   "propext",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Submodule.instOrderTop",
   "Nat.instAddMonoid",
   "Set",
   "AddCommGroup",
   "HarderNarasimhan.impl.prop3d13₂",
   "HarderNarasimhan.instBoundedOrderInterval",
   "HarderNarasimhan.impl.prop3d13₁",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "CommRing.toRing",
   "HarderNarasimhan.ℒ",
   "AddZeroClass.toAdd",
   "HarderNarasimhan.instPartialOrderS₀",
   "Submodule.completeLattice",
   "ExistsUnique",
   "Ne",
   "HarderNarasimhan.S₀",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "Module.Finite",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Iff.mp",
   "instZeroLEOneClass",
   "Preorder.toLT",
   "HarderNarasimhan.HarderNarasimhanFiltration.fin_len",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.instAddCommMonoid",
   "Submodule.subtype",
   "Semiring.toNonAssocSemiring",
   "HarderNarasimhan.Coprimary",
   "Ring.toAddGroupWithOne",
   "Eq.rec",
   "Nat.instIsOrderedAddMonoid",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DistribSMul.toSMulZeroClass",
   "SemilatticeInf.toPartialOrder",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Nat.instPartialOrder",
   "Nat.instStarRing",
   "IsOrderedAddMonoid.toAddLeftMono",
   "HarderNarasimhan.Coprimary.mk",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "isNoetherian_submodule'",
   "Nat",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Subtype",
   "Module.Finite.quotient",
   "Eq.mp",
   "Submodule.module",
   "HarderNarasimhan.impl.rmk4d14₂",
   "congrArg",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "HarderNarasimhan.HarderNarasimhanFiltration.strict_mono",
   "Nat.instOne",
   "BoundedOrder.toOrderTop",
   "isNoetherian_of_isNoetherianRing_of_finite",
   "Nat.instIsOrderedCancelAddMonoid",
   "HarderNarasimhan.Interval",
   "HarderNarasimhan.HarderNarasimhanFiltration.piecewise_semistable",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CommSemiring.toSemiring",
   "CommRing",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Submodule.submoduleOf._proof_14",
   "LT.lt",
   "HarderNarasimhan.instNontrivialInterval",
   "IsNoetherianRing",
   "lt_add_one",
   "One.toOfNat1",
   "Submodule.Quotient.nontrivial_of_lt_top",
   "Submodule.setLike",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "HarderNarasimhan.impl.ss_iff'",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "False",
   "Subtype.mk",
   "Submodule.addCommMonoid",
   "OrderTop.toTop",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.impl.piecewise_coprimary",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (HNFil : HarderNarasimhan.HarderNarasimhanFiltration (HarderNarasimhan.μ R M)),\n  ∀ n < Nat.find ⋯,\n    HarderNarasimhan.Coprimary R\n      (↥(HNFil.filtration (n + 1)) ⧸ Submodule.submoduleOf (HNFil.filtration n) (HNFil.filtration (n + 1)))",
  "constCategory": "Theorem"},
 {"references": ["Membership.mk", "Set", "Set.Mem", "Membership"],
  "name": "Set.instMembership",
  "constType": "{α : Type u} → Membership α (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "instLTNat",
   "Fintype.card_lt_of_injective_not_surjective",
   "Function.surjInv",
   "Function.Bijective",
   "Fintype",
   "Function.Surjective",
   "Finite.of_fintype",
   "Fintype.card",
   "LT.lt",
   "And.intro",
   "Nat",
   "Function.injective_surjInv",
   "letFun",
   "Equiv.ofBijective",
   "Function.Surjective.injective_of_fintype",
   "Equiv.symm",
   "False",
   "Function.Injective"],
  "name": "Fintype.card_lt_of_surjective_not_injective",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Fintype α] [inst_1 : Fintype β] (f : α → β),\n  Function.Surjective f → ¬Function.Injective f → Fintype.card β < Fintype.card α",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "DecidableLT",
   "Preorder.toLT",
   "LinearOrder"],
  "name": "LinearOrder.toDecidableLT",
  "constType": "{α : Type u_2} → [self : LinearOrder α] → DecidableLT α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "Classical.propDecidable",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "Nat.findGreatest",
   "HarderNarasimhan.JordanHolderFiltration",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "Lean.Omega.combo_sat'",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Bool",
   "Option.some",
   "Nat.lt_or_gt_of_ne",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Option.none",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "instHSub",
   "PartialOrder.toPreorder",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GT.gt",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Bot.bot",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "Nontrivial",
   "Nat.lt_of_not_le",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.cast",
   "Subtype",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "OrderBot.toBot",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Constraint.isImpossible",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "instLENat"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_15",
  "constType":
  "∀ (n : ℕ) (ℒ : Type) (ntl : Nontrivial ℒ) (l : Lattice ℒ) (bo : BoundedOrder ℒ) (wacc : WellFoundedGT ℒ) (S : Type)\n  (clo : CompleteLinearOrder S) (μ : { p // p.1 < p.2 } → S) (JHy JHx : HarderNarasimhan.JordanHolderFiltration μ),\n  Nat.findGreatest (fun n => JHx.filtration (Nat.find ⋯ - 1) ≤ JHy.filtration n) (Nat.find ⋯ - 1) ≤ Nat.find ⋯ - 1 →\n    ¬Nat.findGreatest (fun n => JHx.filtration (Nat.find ⋯ - 1) ≤ JHy.filtration n) (Nat.find ⋯ - 1) + 1 ≤\n          Nat.find ⋯ - 1 →\n      Nat.findGreatest (fun n => JHx.filtration (Nat.find ⋯ - 1) ≤ JHy.filtration n) (Nat.find ⋯ - 1) + 1 ≤ Nat.find ⋯ →\n        ¬Nat.findGreatest (fun n => JHx.filtration (Nat.find ⋯ - 1) ≤ JHy.filtration n) (Nat.find ⋯ - 1) + 1 =\n              Nat.find ⋯ →\n          False",
  "constCategory": "Theorem"},
 {"references": ["Not", "Iff", "not_congr"],
  "name": "Iff.not",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "HarderNarasimhan.CoprimaryFiltration.rec",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Submodule.instBot",
   "Nontrivial",
   "HarderNarasimhan.CoprimaryFiltration.mk",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.recOn",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] →\n                {motive : HarderNarasimhan.CoprimaryFiltration R M → Sort u} →\n                  (t : HarderNarasimhan.CoprimaryFiltration R M) →\n                    ((filtration : ℕ → HarderNarasimhan.ℒ R M) →\n                        (monotone : Monotone filtration) →\n                          (first_eq_bot : filtration 0 = ⊥) →\n                            (fin_len : ∃ n, filtration n = ⊤) →\n                              (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                (piecewise_coprimary :\n                                    ∀ n < Nat.find fin_len,\n                                      HarderNarasimhan.Coprimary R\n                                        (↥(filtration (n + 1)) ⧸\n                                          Submodule.submoduleOf (filtration n) (filtration (n + 1)))) →\n                                  (strict_mono_associated_prime :\n                                      ∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len),\n                                        { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }) →\n                                    motive\n                                      { filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot,\n                                        fin_len := fin_len, strict_mono := strict_mono,\n                                        piecewise_coprimary := piecewise_coprimary,\n                                        strict_mono_associated_prime := strict_mono_associated_prime }) →\n                      motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "Submodule.Quotient.module",
   "Submodule.module",
   "Membership.mem",
   "LinearEquiv",
   "LinearMap.quotientInfToSupQuotient._proof_12",
   "Submodule",
   "Submodule.subtype",
   "LinearMap.semilinearMapClass",
   "LinearMap.quotientInfEquivSupQuotient._proof_13",
   "Submodule.Quotient.addCommGroup",
   "Semiring.toNonAssocSemiring",
   "LinearMap.quotKerEquivRange._proof_6",
   "RingHom.id",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SetLike.instMembership",
   "LinearMap.quotientInfToSupQuotient",
   "Submodule.addCommGroup",
   "AddCommGroup",
   "LinearMap",
   "Ring.toSemiring",
   "Max.max",
   "Submodule.comap",
   "Submodule.setLike",
   "Min.min",
   "SemilatticeSup.toMax",
   "RingHomInvPair.ids",
   "Submodule.completeLattice",
   "AddCommGroup.toAddCommMonoid",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.instMin",
   "Submodule.addCommMonoid",
   "LinearMap.subToSupQuotient._proof_10",
   "LinearEquiv.ofBijective",
   "Ring"],
  "name": "LinearMap.quotientInfEquivSupQuotient",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : _root_.Module R M] →\n          (p p' : Submodule R M) →\n            (↥p ⧸ Submodule.comap p.subtype p ⊓ Submodule.comap p.subtype p') ≃ₗ[R]\n              ↥(p ⊔ p') ⧸ Submodule.comap (p ⊔ p').subtype p'",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toPartialOrder",
   "HeytingAlgebra",
   "Bot.bot",
   "GeneralizedHeytingAlgebra.toHImp",
   "HasCompl.compl",
   "OrderBot.toBot",
   "HeytingAlgebra.toOrderBot",
   "Eq",
   "HImp.himp",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Preorder.toLE",
   "HeytingAlgebra.toHasCompl",
   "GeneralizedHeytingAlgebra.toLattice"],
  "name": "HeytingAlgebra.himp_bot",
  "constType": "∀ {α : Type u_4} [self : HeytingAlgebra α] (a : α), a ⇨ ⊥ = aᶜ",
  "constCategory": "Theorem"},
 {"references": ["Subtype", "BEq.mk", "BEq", "BEq.beq", "Subtype.val"],
  "name": "Subtype.instBEq",
  "constType": "{α : Type u} → {p : α → Prop} → [BEq α] → BEq { x // p x }",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "OrderDual",
   "Min.min",
   "OrderDual.instSemilatticeSup",
   "Eq",
   "sup_comm"],
  "name": "inf_comm",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a b : α), a ⊓ b = b ⊓ a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Submodule.instNontrivial",
   "Module",
   "HarderNarasimhan.μ",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "HarderNarasimhan.impl.noname",
   "Eq",
   "HarderNarasimhan.S",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "Prod.snd",
   "CommRing",
   "Prod",
   "LT.lt",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "HarderNarasimhan.S₀",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.μmax_eq_μ",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  HarderNarasimhan.μmax (HarderNarasimhan.μ R M) I = HarderNarasimhan.μ R M I",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Set.Finite.nonempty_fintype",
   "Fintype",
   "Set.Finite",
   "Set.Elem",
   "Nonempty.some"],
  "name": "Set.Finite.fintype",
  "constType": "{α : Type u} → {s : Set α} → s.Finite → Fintype ↑s",
  "constCategory": "Definition"},
 {"references":
  ["Set.inter_subset_right",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Inter.inter",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "ClosureOperator",
   "Subtype.val",
   "DFunLike.coe",
   "Set.inter_subset_left",
   "And.intro",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "Preorder.toLE",
   "Eq.rec",
   "Eq",
   "Set.instInter",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "ClosureOperator.IsClosed.closure_eq"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_5",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds), T.IsClosed (↑A ∩ ↑B)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Subtype",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "letFun",
   "PartialOrder",
   "Preorder.toLE",
   "Subtype.le",
   "HarderNarasimhan.coe'._proof_49",
   "Set.instLE",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Function.Embedding.mk",
   "RelEmbedding.mk",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OrderEmbedding",
   "Set.Iic",
   "HarderNarasimhan.coe'._proof_50",
   "HarderNarasimhan.coe'._proof_48",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LE.le",
   "Subtype.mk",
   "Function.Injective"],
  "name": "HarderNarasimhan.coe'",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → α ↪o HarderNarasimhan.DedekindMacNeilleCompletion α",
  "constCategory": "Definition"},
 {"references": ["forall_const", "Nonempty", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_17",
  "constType":
  "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (∀ (a : α), b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["True",
   "LE.le",
   "LE",
   "bot_le",
   "eq_true",
   "OrderBot.toBot",
   "Eq",
   "Bot.bot",
   "OrderBot"],
  "name": "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_13",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderBot α] {a : α}, (⊥ ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["And.intro",
   "True",
   "And",
   "Eq",
   "trivial",
   "propext",
   "And.left",
   "Iff.intro"],
  "name": "and_true",
  "constType": "∀ (p : Prop), (p ∧ True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "instOfNat",
   "instHAdd",
   "Iff",
   "Int.instAdd",
   "LE.le",
   "Int.instLTInt",
   "Int.instLEInt",
   "Iff.rfl",
   "OfNat.ofNat",
   "Int"],
  "name": "Int.add_one_le_iff",
  "constType": "∀ {a b : ℤ}, a + 1 ≤ b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "HarderNarasimhan.impl.prop4d18₁",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "HarderNarasimhan.WeakSlopeLike₁.wsl₁",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.NashEquilibrium.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "HarderNarasimhan.WeakDescendingChainCondition.wdcc",
   "eq_of_le_of_le",
   "HarderNarasimhan.NashEquilibrium",
   "Or.inl",
   "Or",
   "HarderNarasimhan.WeakAscendingChainCondition.wacc",
   "HarderNarasimhan.μBstar",
   "HarderNarasimhan.WeakSlopeLike₂.wsl₂",
   "HarderNarasimhan.WeakSlopeLike₁",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "HarderNarasimhan.impl.prop4d3₂",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "HarderNarasimhan.impl.prop4d1₂",
   "Or.casesOn",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Eq.refl",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "HarderNarasimhan.WeakSlopeLike₂",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.impl.prop4d18₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Semistable μ →\n    HarderNarasimhan.WeakAscendingChainCondition μ ∧ HarderNarasimhan.WeakSlopeLike₁ μ ∨\n        HarderNarasimhan.WeakDescendingChainCondition μ ∧ HarderNarasimhan.WeakSlopeLike₂ μ →\n      HarderNarasimhan.NashEquilibrium μ",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommMonoid",
   "SetLike.instMembership",
   "Submodule.setLike",
   "Module",
   "Submodule.instTop",
   "Membership.mem",
   "Top.top",
   "trivial",
   "Submodule",
   "Semiring"],
  "name": "Submodule.mem_top",
  "constType":
  "∀ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  x ∈ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.ConvexI.convex",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.ConvexI",
   "Preorder.toLT",
   "HarderNarasimhan.ConvexI.mk",
   "Subtype.val",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Iff.intro",
   "Subtype.prop",
   "HarderNarasimhan.Convex",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "HarderNarasimhan.instBoundedOrderInterval",
   "HarderNarasimhan.TotIntvl",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.instNontrivialInterval",
   "HarderNarasimhan.InIntvl",
   "Iff",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "HarderNarasimhan.in_TotIntvl",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.ConvexI_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ ↔ HarderNarasimhan.Convex (HarderNarasimhan.Resμ I μ)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.instFunLike",
   "FunLike",
   "ClosureOperator.instFunLike._proof_1",
   "DFunLike.mk",
   "Preorder",
   "OrderHom",
   "ClosureOperator.toOrderHom",
   "ClosureOperator",
   "DFunLike.coe"],
  "name": "ClosureOperator.instFunLike",
  "constType":
  "(α : Type u_1) → [inst : Preorder α] → FunLike (ClosureOperator α) α α",
  "constCategory": "Definition"},
 {"references": ["Nat", "OfNat", "OfNat.mk"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "instDecidableIff",
   "instDecidableEqOfIff",
   "Bool",
   "True",
   "instDecidableTrue",
   "Decidable.decide",
   "Eq.refl",
   "id",
   "False",
   "instDecidableFalse",
   "Eq",
   "Bool.true",
   "of_decide_eq_true",
   "instDecidableNot"],
  "name": "not_true_eq_false",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "associatedPrimes",
   "Subtype",
   "PartialOrder.toPreorder",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.Quotient.module",
   "Submodule.module",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Subtype.val",
   "Submodule",
   "Prod.fst",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "Eq",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "Exists",
   "LinearExtension",
   "Set",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "Prod.snd",
   "CommRing",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "PrimeSpectrum",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "HarderNarasimhan._μ._proof_2",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Submodule.submoduleOf",
   "Module.Finite",
   "setOf"],
  "name": "HarderNarasimhan._μ",
  "constType":
  "(R : Type) →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      (M : Type) →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] → { z // z.1 < z.2 } → Set (LinearExtension (PrimeSpectrum R))",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "sup_le_iff.match_1",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "And",
   "sup_le",
   "le_sup_left",
   "Iff.intro",
   "And.intro",
   "Max.max",
   "le_sup_right",
   "Iff",
   "LE.le",
   "SemilatticeSup.toMax",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "sup_le_iff",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ⊔ b ≤ c ↔ a ≤ c ∧ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Subtype.partialOrder",
   "ClosureOperator",
   "Union.union",
   "DFunLike.coe",
   "Subtype.val",
   "congrArg",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "Eq.symm",
   "ClosureOperator.isClosed_closure",
   "Preorder.toLE",
   "Set.instUnion",
   "Eq.rec",
   "Eq",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Set.subset_union_right",
   "Subtype.coe_eq_of_eq_mk",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "Subtype.mk"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_3",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds), B ≤ ⟨T (↑A ∪ ↑B), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup.le_sup_left",
   "Lattice.toSemilatticeSup",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "BiheytingAlgebra.toHeytingAlgebra",
   "SemilatticeSup.sup",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "LE.le",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "CompleteLattice.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_30",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α), a ≤ SemilatticeSup.sup a b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "compareOfLessAndEq",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_29",
   "instDistribLatticeOfLinearOrder",
   "decidableLTOfDecidableLE",
   "Ord.mk",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_22",
   "Classical.decRel",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "CompleteLattice.toLattice",
   "LinearOrder",
   "LinearOrder.mk",
   "decidableEqOfDecidableLE",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_24",
   "DistribLattice.toLattice",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_23",
   "SemilatticeSup.toMax",
   "LE.le",
   "ConditionallyCompleteLattice.toLattice",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "CompleteLattice"],
  "name": "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
  "constType":
  "{α : Type} → [inst : LinearOrder α] → LinearOrder (HarderNarasimhan.DedekindMacNeilleCompletion α)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "SetLike.instMembership",
   "Subtype.ext_iff",
   "Membership.mem",
   "Iff.symm",
   "Subtype.val",
   "OfNat.ofNat",
   "ZeroMemClass",
   "Iff",
   "SetLike",
   "Zero.toOfNat0",
   "ZeroMemClass.zero",
   "Zero",
   "Eq"],
  "name": "ZeroMemClass.coe_eq_zero",
  "constType":
  "∀ {A : Type u_3} {M₁ : Type u_4} [inst : SetLike A M₁] [inst_1 : Zero M₁] [hA : ZeroMemClass A M₁] {S' : A} {x : ↥S'},\n  ↑x = 0 ↔ x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "_private.Init.Core.0._proof_38",
   "Classical.propDecidable",
   "Preorder.toLT",
   "GE.ge",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "of_eq_false",
   "Nat.instPartialOrder",
   "And.right",
   "Nat.recAux",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Bot.bot",
   "Exists.casesOn",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Antitone",
   "eq_false",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Eq.mpr",
   "Nat.find",
   "Ne.symm",
   "Eq.mp",
   "HarderNarasimhan.impl.function_wrapper_prop0'",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_13",
   "lt_of_le_of_ne",
   "Nat.instPreorder",
   "congrArg",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "congr",
   "le_of_eq",
   "OrderBot.toBot",
   "dite_cond_eq_false",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "HarderNarasimhan.impl.function_wrapper._proof_6",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "dite_cond_eq_true",
   "le_of_lt",
   "LE.le",
   "instDecidableEqNat",
   "dite",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.function_wrapper_prop3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ),\n  f 0 = ⊤ → ∀ (atf : ∃ k, f k = ⊥), Antitone f → ∀ (k : ℕ), HarderNarasimhan.impl.function_wrapper f atf k ≤ f k",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.map",
   "Subtype",
   "Finset",
   "_private.Mathlib.Data.Finset.Image.0._proof_2",
   "Eq.trans",
   "Membership.mem",
   "DFunLike.coe",
   "Subtype.val",
   "Set.Elem",
   "congrArg",
   "iff_self",
   "_private.Init.PropLemmas.0._proof_23",
   "_private.Init.Data.Subtype.0._proof_2",
   "funext",
   "Function.Embedding.subtype",
   "Eq",
   "Function.instFunLikeEmbedding",
   "propext",
   "Finset.univ",
   "Exists",
   "True",
   "Set",
   "_private.Init.PropLemmas.0._proof_38",
   "Function.Embedding",
   "And",
   "Set.toFinset",
   "true_and",
   "Fintype",
   "exists_prop_congr",
   "Set.instMembership",
   "Iff.of_eq",
   "of_eq_true",
   "Eq.refl",
   "Iff",
   "_private.Mathlib.Data.Fintype.Defs.0._proof_1",
   "Finset.instMembership",
   "Subtype.mk"],
  "name": "Set.mem_toFinset",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, a ∈ s.toFinset ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "DecidableRel", "LT"],
  "name": "DecidableLT",
  "constType": "(α : Type u) → [LT α] → Type (max 0 u)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.semistableI",
   "Preorder.toLT",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "HarderNarasimhan.instBoundedOrderInterval",
   "Prod.snd",
   "HarderNarasimhan.Resμ",
   "HarderNarasimhan.impl.semistableI_iff",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.instNontrivialInterval",
   "Iff",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "CompleteLattice",
   "HarderNarasimhan.Semistable",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.semistableI_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.semistableI μ I ↔ HarderNarasimhan.Semistable (HarderNarasimhan.Resμ I μ)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_4",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "Set.Elem",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop4d1₁_seq.match_1",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_5",
   "Exists",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_1",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_7",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_2",
   "BoundedOrder",
   "Prod.snd",
   "Nat.brecOn",
   "Nat.lt_add_one",
   "Unit",
   "Set.instMembership",
   "Prod",
   "Nat",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "StrictMono",
   "setOf",
   "Subtype",
   "Nat.instPreorder",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Not",
   "Set.Nonempty",
   "le_top",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_6",
   "Nat.succ",
   "LE.le",
   "Nat.below",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_3"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [inst_1 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_2 : CompleteLattice S] →\n            (μ : { p // p.1 < p.2 } → S) →\n              (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                    μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                  {YA |\n                        ∃ (h : YA < ⊤),\n                          ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty →\n                    ℕ → ↑{YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_4"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Submodule.hasQuotient",
   "Subtype",
   "RingHomSurjective",
   "SemilinearMapClass",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "Submodule.Quotient.module",
   "Submodule.map",
   "CommSemiring",
   "Membership.mem",
   "Submodule.subtype",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "NonAssocSemiring",
   "Submodule.mkQ",
   "FunLike",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "CommSemiring.toSemiring",
   "Submodule.addCommGroup",
   "AddCommGroup",
   "LinearMap",
   "CommRing",
   "Ring.toSemiring",
   "CommRing.toRing",
   "IsNoetherianRing",
   "lcProof",
   "Submodule.comap",
   "Submodule.setLike",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.addCommMonoid",
   "Module.Finite",
   "Submodule.submoduleOf",
   "Ring",
   "Semiring"],
  "name": "HarderNarasimhan.impl.lift_quot._cstage1",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [IsNoetherianRing R] →\n      {M : Type} →\n        [Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [Module.Finite R M] → (N₁ N₂ : Submodule R M) → Submodule R (↥N₂ ⧸ N₁.submoduleOf N₂) → Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["Finset.instSingleton",
   "Finset",
   "Finset.singleton_inj",
   "Singleton.singleton",
   "Eq",
   "propext"],
  "name": "HarderNarasimhan.impl.rmk4d14₁._proof_15",
  "constType": "∀ {α : Type u_1} {a b : α}, ({a} = {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Iff",
   "PartialOrder",
   "LE.le",
   "OrderBot.toBot",
   "le_bot_iff",
   "Eq",
   "Preorder.toLE",
   "Bot.bot",
   "Iff.symm",
   "OrderBot"],
  "name": "eq_bot_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, a = ⊥ ↔ a ≤ ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "Membership.mem",
   "Iff.mp",
   "Exists.intro",
   "Membership.mem.out",
   "PrimeSpectrum.isPrime",
   "And.intro",
   "Minimal",
   "Semiring.toNonAssocSemiring",
   "funext",
   "Module.annihilator",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "Exists",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "HarderNarasimhan.impl.exists_minimal_prime_contained_supp._proof_4",
   "And.right",
   "And",
   "Set.instMembership",
   "Exists.casesOn",
   "AddCommGroup.toAddCommMonoid",
   "id",
   "Eq.mpr",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "congrArg",
   "Ideal.exists_minimalPrimes_le",
   "Ideal",
   "Ideal.minimalPrimes",
   "PrimeSpectrum.asIdeal",
   "Preorder.toLE",
   "Eq",
   "CommRing.toCommSemiring",
   "Set",
   "Module.mem_support_iff_of_finite",
   "Module.support",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "PrimeSpectrum",
   "IsNoetherianRing",
   "LE.le",
   "Submodule.completeLattice",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.exists_minimal_prime_contained_supp",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [IsNoetherianRing R] {M : Type} [inst_2 : AddCommGroup M] [inst_3 : _root_.Module R M]\n  [Module.Finite R M], ∀ q ∈ Module.support R M, ∃ p, Minimal (fun J => J ∈ Module.support R M) p ∧ p ≤ q",
  "constCategory": "Theorem"},
 {"references": ["CommRing", "Ring"],
  "name": "CommRing.toRing",
  "constType": "{α : Type u} → [self : CommRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Membership.mem",
   "Set.mem_iInter",
   "Eq",
   "Set.iInter",
   "propext",
   "Set.instMembership"],
  "name": "_private.Mathlib.Order.SetNotation.0._proof_4",
  "constType":
  "∀ {α : Type u} {ι : Sort v} {x : α} {s : ι → Set α}, (x ∈ ⋂ i, s i) = ∀ (i : ι), x ∈ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub",
   "Eq.trans",
   "Classical.propDecidable",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "Exists.intro",
   "Subtype.val",
   "HarderNarasimhan.JordanHolderFiltration",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Prod.snd",
   "le_sup_left",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Antitone",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Bool",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "HarderNarasimhan.impl.function_wrapper_prop1",
   "Option.some",
   "Nat.instPreorder",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "Max.max",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "Nat.sub_le",
   "instHSub",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.Int.ofNat_le_of_le",
   "And.intro",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLinearOrder",
   "Eq.rec",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.JordanHolderFiltration.strict_anti",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "And",
   "Bot.bot",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "Nontrivial",
   "id",
   "Lean.Omega.LinearCombo.coordinate_eval_7",
   "Subtype",
   "Nat.cast",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Interval",
   "OrderBot.toBot",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "HarderNarasimhan.JordanHolderFiltration.first_eq_top",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "le_top",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "HarderNarasimhan.instNontrivialInterval",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "SemilatticeSup.toMax",
   "LE.le",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "Subtype.mk",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "OrderTop.toTop",
   "instLENat"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_14",
  "constType":
  "∀ (n : ℕ) (ℒ : Type) (ntl : Nontrivial ℒ) (l : Lattice ℒ) (bo : BoundedOrder ℒ) (wacc : WellFoundedGT ℒ) (S : Type)\n  (clo : CompleteLinearOrder S) (μ : { p // p.1 < p.2 } → S) (JHy JHx : HarderNarasimhan.JordanHolderFiltration μ)\n  (this : 0 < Nat.find ⋯ - 1),\n  (Antitone fun n => ⟨JHx.filtration (Nat.find ⋯ - 1) ⊔ JHy.filtration n, ⋯⟩) →\n    (fun n => ⟨JHx.filtration (Nat.find ⋯ - 1) ⊔ JHy.filtration n, ⋯⟩) 0 = ⊤ →\n      (fun n => ⟨JHx.filtration (Nat.find ⋯ - 1) ⊔ JHy.filtration n, ⋯⟩) (Nat.find ⋯) = ⊥ →\n        ∀ (i j : ℕ), ¬Nat.find ⋯ - 1 < Nat.find ⋯ → False",
  "constCategory": "Theorem"},
 {"references":
  ["PrimeSpectrum",
   "CommRing.toCommSemiring",
   "IsNoetherianRing",
   "Finset",
   "LinearExtension",
   "CommSemiring.toSemiring",
   "CommRing"],
  "name": "HarderNarasimhan.S₀",
  "constType": "(R : Type) → [inst : CommRing R] → [IsNoetherianRing R] → Type",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "IsScalarTower",
   "Module",
   "Membership.mem",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "Subtype.val",
   "Submodule",
   "SMul",
   "AddCommMonoid",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "DistribSMul.toSMulZeroClass",
   "SMul.mk",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Submodule.smul._proof_24",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "Module.toDistribMulAction",
   "Submodule.setLike",
   "HSMul.hSMul",
   "Subtype.mk",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "Submodule.smul",
  "constType":
  "{S : Type u'} →\n  {R : Type u} →\n    {M : Type v} →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] →\n          {module_M : _root_.Module R M} →\n            (p : Submodule R M) → [inst_2 : SMul S R] → [inst_3 : SMul S M] → [IsScalarTower S R M] → SMul S ↥p",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "le_refl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "absurd",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Or",
   "le_of_lt",
   "LE.le",
   "Eq.rec",
   "Eq",
   "Preorder.toLE",
   "lt_trichotomy",
   "le_of_not_lt.match_1"],
  "name": "le_of_not_lt",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬b < a → a ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommMagma",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["CommRing.toCommSemiring",
   "Submodule.instNontrivial",
   "Module",
   "CommSemiring.toSemiring",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "CommRing",
   "Submodule"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
  "constType":
  "∀ {R : Type} [inst : CommRing R] {M : Type} [Nontrivial M] [inst_2 : AddCommGroup M] [inst_3 : _root_.Module R M],\n  Nontrivial (Submodule R M)",
  "constCategory": "Theorem"},
 {"references": ["Ideal", "Semiring"],
  "name": "Ideal.IsPrime",
  "constType": "{α : Type u} → [inst : Semiring α] → Ideal α → Prop",
  "constCategory": "Other"},
 {"references": ["_obj", "Set.instCompleteAtomicBooleanAlgebra", "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "HSub.hSub",
   "Ne",
   "Nat.pred_lt",
   "instHSub",
   "OfNat.ofNat"],
  "name": "Nat.sub_one_lt",
  "constType": "∀ {n : ℕ}, n ≠ 0 → n - 1 < n",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "associatedPrimes",
   "PartialOrder.toPreorder",
   "LinearMap.instFunLike",
   "Module",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Exists.intro",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "Submodule",
   "LinearMap.semilinearMapClass",
   "Semiring.toNonAssocSemiring",
   "Ideal",
   "RingHom.id",
   "exists_ne",
   "Zero.toOfNat0",
   "Preorder.toLE",
   "Semiring.toModule",
   "CommRing.toCommSemiring",
   "Set.Nonempty",
   "exists_le_isAssociatedPrime_of_isNoetherianRing",
   "LinearMap.ker",
   "Exists",
   "Set",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "And",
   "AddCommGroup",
   "LinearMap",
   "CommRing",
   "IsAssociatedPrime",
   "OfNat.ofNat",
   "Set.instMembership",
   "Exists.casesOn",
   "IsNoetherianRing",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Nontrivial",
   "LE.le",
   "Submodule.completeLattice",
   "NegZeroClass.toZero",
   "AddCommGroup.toAddCommMonoid",
   "Ne",
   "And.casesOn"],
  "name": "associatedPrimes.nonempty",
  "constType":
  "∀ (R : Type u_1) [inst : CommRing R] (M : Type u_2) [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  [IsNoetherianRing R] [Nontrivial M], (associatedPrimes R M).Nonempty",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "Subtype", "Preorder.lift", "Subtype.val"],
  "name": "Subtype.preorder",
  "constType":
  "{α : Type u_2} → [Preorder α] → (p : α → Prop) → Preorder (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "SubNegMonoid.zsmul_neg'._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "True",
   "instHAdd",
   "List",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_4",
  "constType":
  "∀ {a0 a1 a2 a3 a4 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 4).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: a4 :: t)) = a4",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "le_refl",
   "Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.ConvexI.mk",
   "congrArg",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.Convex",
   "HarderNarasimhan.Affine",
   "Eq",
   "Preorder.toLE",
   "inf_lt_left",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.Affine.affine",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "id",
   "Eq.mpr",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.instConvexOfAffine",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [haff : HarderNarasimhan.Affine μ],\n  HarderNarasimhan.Convex μ",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Fin"],
  "name": "Fin.val",
  "constType": "{n : ℕ} → Fin n → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Ring.intCast_ofNat",
   "Ring.toNeg",
   "Semiring.natCast_succ",
   "Ring.toSub",
   "Semiring.toOne",
   "Ring.zsmul",
   "AddGroupWithOne.mk",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddGroupWithOne",
   "AddCommMonoid.toAddMonoid",
   "Ring.neg_add_cancel",
   "Ring.zsmul_neg'",
   "AddMonoidWithOne.mk",
   "Ring.intCast_negSucc",
   "Ring.toSemiring",
   "Ring.zsmul_zero'",
   "Ring.sub_eq_add_neg",
   "Ring.toIntCast",
   "Semiring.toNatCast",
   "Semiring.natCast_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNonUnitalSemiring",
   "Ring"],
  "name": "Ring.toAddGroupWithOne",
  "constType": "{R : Type u} → [self : Ring R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "HarderNarasimhan.WeakSlopeLike₁.wsl₁",
   "Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Prod.fst",
   "And.intro",
   "HarderNarasimhan.μmin",
   "HarderNarasimhan.WeakAscendingChainCondition.wacc",
   "HarderNarasimhan.μBstar",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁",
   "HarderNarasimhan.impl.prop4d1₁",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "HarderNarasimhan.impl.prop4d1₂",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_4_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.WeakAscendingChainCondition μ →\n    HarderNarasimhan.WeakSlopeLike₁ μ →\n      HarderNarasimhan.μAstar μ = HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl ∧\n        HarderNarasimhan.μAstar μ ≤ HarderNarasimhan.μBstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakSlopeLike₂.mk",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₂.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1), μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n    HarderNarasimhan.WeakSlopeLike₂ μ",
  "constCategory": "Definition"},
 {"references":
  ["Unique",
   "Subsingleton",
   "Unique.eq_default",
   "subsingleton_of_forall_eq",
   "Unique.instInhabited",
   "Inhabited.default"],
  "name": "Unique.instSubsingleton",
  "constType": "∀ {α : Sort u_1} [Unique α], Subsingleton α",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "Unit.unit",
   "OfNat.ofNat",
   "Unit"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((k : ℕ) → motive k.succ) → motive k",
  "constCategory": "Definition"},
 {"references": ["Not", "LT.lt", "Preorder", "lt_asymm", "Preorder.toLT"],
  "name": "not_lt_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → ¬b < a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "HarderNarasimhan.JordanHolderFiltration",
   "Int.instLTInt",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.mk._flat_ctor",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLinearOrder S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                (filtration : ℕ → ℒ) →\n                  Antitone filtration →\n                    (fin_len : ∃ N, filtration N = ⊥) →\n                      (strict_anti : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration j < filtration i) →\n                        filtration 0 = ⊤ →\n                          (∀ (k : ℕ) (hk : k < Nat.find fin_len),\n                              μ ⟨(filtration (k + 1), filtration k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩) →\n                            (∀ (i : ℕ) (hi : i < Nat.find fin_len) (z : ℒ) (h' : filtration (i + 1) < z),\n                                z < filtration i →\n                                  μ ⟨(filtration (i + 1), z), h'⟩ < μ ⟨(filtration (i + 1), filtration i), ⋯⟩) →\n                              HarderNarasimhan.JordanHolderFiltration μ",
  "constCategory": "Definition"},
 {"references": ["AddSemigroup", "Add"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["Submonoid",
   "Submonoid.instSetLike._proof_1",
   "Subsemigroup.carrier",
   "SetLike.mk",
   "MulOneClass",
   "SetLike",
   "Submonoid.toSubsemigroup",
   "MulOneClass.toMul"],
  "name": "Submonoid.instSetLike",
  "constType":
  "{M : Type u_1} → [inst : MulOneClass M] → SetLike (Submonoid M) M",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Set",
   "Membership.mem",
   "Preorder.toLT",
   "HarderNarasimhan.St",
   "BoundedOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "HarderNarasimhan.impl.rmk3d5",
   "Set.instMembership",
   "Prod.fst",
   "CompletelyDistribLattice.toCompleteLattice",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.remark_3_5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  ∀ x ∈ HarderNarasimhan.St μ, ∀ y ∈ HarderNarasimhan.St μ, x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.neg_mem",
   "Submodule.toAddSubmonoid",
   "Module",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddCommMonoid.toAddMonoid",
   "AddSubgroup.mk",
   "Ring.toSemiring",
   "Submodule",
   "AddSubgroup",
   "AddSubmonoid",
   "AddCommGroup.toAddCommMonoid",
   "Ring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.toAddSubgroup",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → {module_M : _root_.Module R M} → Submodule R M → AddSubgroup M",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Submodule.Quotient.mk",
   "Submodule.hasQuotient",
   "Eq.trans",
   "HasQuotient.Quotient",
   "Eq.mp",
   "Module",
   "AddCommGroup.toAddGroup",
   "Membership.mem",
   "Submodule.Quotient.instZeroQuotient",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "congrArg",
   "Submodule",
   "Submodule.addSubgroupClass",
   "AddCommSemigroup.toAddCommMagma",
   "Zero.toOfNat0",
   "AddCommMagma.toAdd",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "_private.Mathlib.Algebra.Group.Subgroup.Defs.0._proof_2",
   "SetLike.instMembership",
   "AddSubgroupClass.toNegMemClass",
   "AddZeroClass.toZero",
   "Neg.neg",
   "instHAdd",
   "AddCommGroup",
   "add_zero",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "HAdd.hAdd",
   "NegZeroClass.toNeg",
   "SubNegMonoid.toAddMonoid",
   "AddZeroClass.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Submodule.setLike",
   "Iff",
   "AddCommGroup.toAddCommMonoid",
   "NegZeroClass.toZero",
   "Submodule.Quotient.eq'",
   "AddMonoid.toAddZeroClass",
   "Ring"],
  "name": "Submodule.Quotient.mk_eq_zero",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} {x : M} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), Submodule.Quotient.mk x = 0 ↔ x ∈ p",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Or",
   "Iff",
   "Decidable.or_iff_not_imp_left",
   "Classical.propDecidable"],
  "name": "Classical.or_iff_not_imp_left",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ ¬a → b",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.le_trans",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b c : HarderNarasimhan.Interval z), ↑a ≤ ↑b → ↑b ≤ ↑c → ↑a ≤ ↑c",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Preorder.toLT",
   "Ne",
   "lt_of_le_of_ne",
   "Preorder.toLE",
   "flip"],
  "name": "Ne.lt_of_le",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≠ b → a ≤ b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "instLTNat",
   "Nat.gt_of_not_le",
   "Nat",
   "LE.le",
   "instLENat"],
  "name": "Nat.lt_of_not_le",
  "constType": "∀ {a b : ℕ}, ¬a ≤ b → b < a",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.stableI._proof_3",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "HarderNarasimhan.semistableI",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.stableI._proof_2",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.InIntvl",
   "Nontrivial",
   "Lattice",
   "Ne",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.stableI",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Prop",
  "constCategory": "Definition"},
 {"references": ["Zero", "NegZeroClass"],
  "name": "NegZeroClass.toZero",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Zero G",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_8",
   "Subtype.val",
   "Prod.fst",
   "Nat.instPreorder",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_1",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "instHAdd",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_2",
   "BoundedOrder",
   "HarderNarasimhan.impl.prop4d1₁_seq",
   "Prod.snd",
   "Exists.choose",
   "OfNat.ofNat",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_3",
   "CompleteLattice",
   "setOf",
   "StrictMono"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._proof_9",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S)\n  (h₁ : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩)\n  (h₂ :\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty) (k : ℕ),\n  ∃ xB,\n    ∃ (hAB : ↑(HarderNarasimhan.impl.prop4d1₁_seq μ h₁ h₂ h₃ k) < xB),\n      ¬μ ⟨(↑(HarderNarasimhan.impl.prop4d1₁_seq μ h₁ h₂ h₃ k), xB), hAB⟩ ≤\n          μ ⟨(↑(HarderNarasimhan.impl.prop4d1₁_seq μ h₁ h₂ h₃ k), ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteDistribLattice.toHNot",
   "CompleteDistribLattice.toFrame",
   "Order.Frame.toCompleteLattice",
   "Order.Coframe",
   "CompleteDistribLattice.toSDiff",
   "CompleteDistribLattice.sdiff_le_iff",
   "CompleteDistribLattice.top_sdiff",
   "Order.Coframe.mk",
   "CompleteDistribLattice"],
  "name": "CompleteDistribLattice.toCoframe",
  "constType":
  "{α : Type u_1} → [self : CompleteDistribLattice α] → Order.Coframe α",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Inter.inter",
   "Membership.mem",
   "And.right",
   "Set.instInter",
   "Set.instMembership"],
  "name": "Set.inter_subset_right",
  "constType": "∀ {α : Type u} {s t : Set α}, s ∩ t ⊆ t",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE", "OrderBot.toBot", "Bot.bot", "OrderBot"],
  "name": "OrderBot.bot_le",
  "constType":
  "∀ {α : Type u} {inst : LE α} [self : OrderBot α] (a : α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.rec", "Eq"],
  "name": "Eq.substr",
  "constType": "∀ {α : Sort u} {p : α → Prop} {a b : α}, b = a → p a → p b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Int.instLTInt",
   "HarderNarasimhan.JordanHolderFiltration",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "HarderNarasimhan.JordanHolderFiltration.rec",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLinearOrder S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                {motive : HarderNarasimhan.JordanHolderFiltration μ → Sort u} →\n                  (t : HarderNarasimhan.JordanHolderFiltration μ) →\n                    ((filtration : ℕ → ℒ) →\n                        (antitone : Antitone filtration) →\n                          (fin_len : ∃ N, filtration N = ⊥) →\n                            (strict_anti : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration j < filtration i) →\n                              (first_eq_top : filtration 0 = ⊤) →\n                                (step_cond₁ :\n                                    ∀ (k : ℕ) (hk : k < Nat.find fin_len),\n                                      μ ⟨(filtration (k + 1), filtration k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩) →\n                                  (step_cond₂ :\n                                      ∀ (i : ℕ) (hi : i < Nat.find fin_len) (z : ℒ) (h' : filtration (i + 1) < z),\n                                        z < filtration i →\n                                          μ ⟨(filtration (i + 1), z), h'⟩ < μ ⟨(filtration (i + 1), filtration i), ⋯⟩) →\n                                    motive\n                                      { filtration := filtration, antitone := antitone, fin_len := fin_len,\n                                        strict_anti := strict_anti, first_eq_top := first_eq_top,\n                                        step_cond₁ := step_cond₁, step_cond₂ := step_cond₂ }) →\n                      motive t",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "HMul.hMul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "mul_neg",
   "MonoidWithZero.toMonoid",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "InvolutiveNeg.toNeg",
   "Eq.ndrec",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "instHPow",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "HPow.hPow",
   "Ring.toSemiring",
   "Ring.toAddCommGroup",
   "eq_self",
   "Nat",
   "NegZeroClass.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Monoid.toNatPow",
   "of_eq_true",
   "instHMul",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_mul",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] (a₁ : R) (a₂ : ℕ) {a₃ b : R}, -a₃ = b → -(a₁ ^ a₂ * a₃) = a₁ ^ a₂ * b",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "SubNegZeroMonoid"],
  "name": "SubNegZeroMonoid.toSubNegMonoid",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → SubNegMonoid G",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection.mk", "Set", "False", "EmptyCollection"],
  "name": "Set.instEmptyCollection",
  "constType": "{α : Type u} → EmptyCollection (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Iff", "Membership.mem", "Iff.rfl", "setOf", "Set.instMembership"],
  "name": "Set.mem_setOf",
  "constType": "∀ {α : Type u} {a : α} {p : α → Prop}, a ∈ {x | p x} ↔ p a",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.Quotient.mk",
   "Eq.trans",
   "Submodule.Quotient.module",
   "Submodule.map",
   "Membership.mem",
   "Quotient.mk",
   "Membership",
   "Subtype.val",
   "Submodule.subtype",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "letFun",
   "eq_of_heq",
   "funext",
   "Eq.symm",
   "HarderNarasimhan.impl.lift_quot._proof_15",
   "Eq.ndrec",
   "Submodule.eq_bot_iff",
   "SetLike.instMembership",
   "Exists",
   "AddZeroClass.toZero",
   "outParam",
   "_private.Mathlib.Algebra.Module.Submodule.Map.0._proof_5",
   "Submodule.addCommGroup",
   "And",
   "LinearMap",
   "Submodule.Quotient.mk_eq_zero",
   "Bot.bot",
   "Ring.toSemiring",
   "Exists.casesOn",
   "Submodule.comap",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Submodule.instBot",
   "HEq",
   "id",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "Submodule.submoduleOf",
   "AddMonoid.toAddZeroClass",
   "Quotient",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "_private.Mathlib.Data.SetLike.Basic.0._proof_4",
   "Submodule.module",
   "Submodule.Quotient.instZeroQuotient",
   "_private.Mathlib.Algebra.Module.Submodule.Map.0._proof_13",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "congrArg",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "_private.Init.PropLemmas.0._proof_23",
   "congr",
   "Quotient.exists_rep",
   "Zero.toOfNat0",
   "Eq",
   "Submodule.mkQ",
   "CommRing.toCommSemiring",
   "HEq.refl",
   "CommSemiring.toSemiring",
   "Submodule.quotientRel",
   "HarderNarasimhan.impl.lift_quot._proof_16",
   "AddCommGroup",
   "CommRing",
   "Eq.casesOn",
   "OfNat.ofNat",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.lift_quot._proof_14",
   "Submodule.setLike",
   "HarderNarasimhan.impl.lift_quot",
   "Ne",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.lift_quot_not_bot",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (N₁ N₂ : Submodule R M)\n  (x : Submodule R (↥N₂ ⧸ N₁.submoduleOf N₂)), x ≠ ⊥ → HarderNarasimhan.impl.lift_quot N₁ N₂ x ≠ N₁",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "OfNat.mk", "Zero", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references": ["GeneralizedHeytingAlgebra", "HeytingAlgebra"],
  "name": "HeytingAlgebra.toGeneralizedHeytingAlgebra",
  "constType":
  "{α : Type u_4} → [self : HeytingAlgebra α] → GeneralizedHeytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.mem_coe",
   "SetLike.instMembership",
   "SetLike.coe",
   "Set",
   "Membership.mem",
   "SetLike",
   "Eq",
   "propext",
   "Set.instMembership"],
  "name": "HarderNarasimhan.impl.submoduleOf_map_subtype._proof_11",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ∈ ↑p) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq.symm", "Eq.ndrec", "Eq"],
  "name": "Mathlib.Tactic.Ring.of_eq",
  "constType": "∀ {α : Sort u_2} {a b c : α}, a = c → b = c → a = b",
  "constCategory": "Theorem"},
 {"references": ["DecidableLE", "ite", "LE.mk", "id"],
  "name":
  "HarderNarasimhan.TotallyOrderedRealVectorSpace.max._inherited_default",
  "constType": "{V : Type} → (le : V → V → Prop) → DecidableLE V → V → V → V",
  "constCategory": "Definition"},
 {"references":
  ["instLTNat",
   "List",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.263",
   "Option.some",
   "List.instGetElem?NatLtLength",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.251",
   "LT.lt",
   "GetElem?.getElem?",
   "Nat",
   "Iff",
   "Option",
   "List.mem_of_getElem?",
   "List.TFAE",
   "autoParam",
   "Eq",
   "List.length"],
  "name": "List.TFAE.out",
  "constType":
  "∀ {l : List Prop},\n  l.TFAE →\n    ∀ (n₁ n₂ : ℕ) {a b : Prop}, autoParam (l[n₁]? = some a) _auto✝ → autoParam (l[n₂]? = some b) _auto✝¹ → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Preorder.toLT",
   "Exists.intro",
   "Eq.symm",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Exists.choose_spec",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Exists.choose",
   "Bot.bot",
   "LT.lt",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Ne"],
  "name": "HarderNarasimhan.impl.function_wrapper._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ) (atf : ∃ k, f k = ⊥)\n  (t : ℕ),\n  ¬HarderNarasimhan.impl.function_wrapper f atf t = ⊥ → ∃ k, f k < HarderNarasimhan.impl.function_wrapper f atf t",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "LocalizedModule",
   "Set",
   "Module",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "PrimeSpectrum",
   "Module.support._proof_1",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Ideal.primeCompl",
   "PrimeSpectrum.asIdeal",
   "setOf"],
  "name": "Module.support",
  "constType":
  "(R : Type u_1) →\n  (M : Type u_2) → [inst : CommRing R] → [inst_1 : AddCommGroup M] → [_root_.Module R M] → Set (PrimeSpectrum R)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "And.right",
   "Preorder.toLT",
   "Prod.snd",
   "lt_of_le_of_ne",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.InIntvl",
   "PartialOrder",
   "LE.le",
   "Ne",
   "Preorder.toLE"],
  "name": "HarderNarasimhan.IsAttained._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (I : { p // p.1 < p.2 }) (a : ℒ),\n  HarderNarasimhan.InIntvl I a → a ≠ (↑I).2 → (a, (↑I).2).1 < (a, (↑I).2).2",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "Semiring.mul_one",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "MonoidWithZero",
   "Semiring.one_mul",
   "Semiring.npow_succ",
   "MonoidWithZero.mk",
   "Semigroup.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Monoid.mk",
   "Semiring.npow",
   "Semiring.npow_zero",
   "Semiring.toNonUnitalSemiring",
   "Semiring",
   "NonUnitalSemiring.mul_assoc"],
  "name": "Semiring.toMonoidWithZero",
  "constType": "{α : Type u} → [self : Semiring α] → MonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "OfNat.ofNat",
   "AddMonoid.mk",
   "HAdd.hAdd",
   "SubNegMonoid.sub'",
   "Nat",
   "Zero.mk",
   "instOfNatNat",
   "id",
   "Add.mk",
   "Zero.toOfNat0",
   "Eq",
   "Neg.mk",
   "AddSemigroup.mk"],
  "name":
  "HarderNarasimhan.TotallyOrderedRealVectorSpace.sub._inherited_default",
  "constType":
  "{V : Type} →\n  (add : V → V → V) →\n    (∀ (a b c : V), a + b + c = a + (b + c)) →\n      (zero : V) →\n        (∀ (a : V), 0 + a = a) →\n          (∀ (a : V), a + 0 = a) →\n            (nsmul : ℕ → V → V) →\n              (∀ (x : V), nsmul 0 x = 0) → (∀ (n : ℕ) (x : V), nsmul (n + 1) x = nsmul n x + x) → (V → V) → V → V → V",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "le_trans",
   "Iff.mp",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil",
   "HarderNarasimhan.impl.HNlen",
   "Nat.instPreorder",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "letFun",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Nat.le_induction",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "instHAdd",
   "Nat.add_one_le_iff",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.impl.HNFil_ne_top_iff_lt_len",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Nat.le_succ",
   "HarderNarasimhan.impl.HNFil_is_strict_mono",
   "Nat.succ",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Ne",
   "OrderTop.toTop",
   "instLENat",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil_is_strict_mono'",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (i j : ℕ),\n  i < j → j ≤ HarderNarasimhan.impl.HNlen μ → HarderNarasimhan.impl.HNFil μ i < HarderNarasimhan.impl.HNFil μ j",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemilatticeInf",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "Prod.fst",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_5",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nat.below",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (k : ℕ) (x : Nat.below k.succ),\n  ∃ xB, ∃ (hAB : ↑x.1 < xB), ¬μ ⟨(↑x.1, xB), hAB⟩ ≤ μ ⟨(↑x.1, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "PUnit.unit",
  "constType": "PUnit.{u}",
  "constCategory": "Other"},
 {"references":
  ["IsNoetherian",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Semiring.toModule",
   "Semiring"],
  "name": "IsNoetherianRing",
  "constType": "(R : Type u_1) → [Semiring R] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Iff.trans",
   "PartialOrder.toPreorder",
   "le_top",
   "eq_comm",
   "OrderTop",
   "LE.le.le_iff_eq",
   "PartialOrder",
   "Iff",
   "LE.le",
   "Top.top",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop"],
  "name": "top_le_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, ⊤ ≤ a ↔ a = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Inv.mk",
   "CommGroupWithZero.toDivisionCommMonoid",
   "Subtype.val",
   "instDistribLatticeOfLinearOrder",
   "Inv",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "Preorder.toLE",
   "DivisionCommMonoid.toDivisionMonoid",
   "SemilatticeInf.toPartialOrder",
   "Inv.inv",
   "Lattice.toSemilatticeInf",
   "IsStrictOrderedRing",
   "InvOneClass.toInv",
   "Nonneg.inv._proof_1",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toSemiring",
   "OfNat.ofNat",
   "DistribLattice.toLattice",
   "DivInvOneMonoid.toInvOneClass",
   "MulZeroClass.toZero",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semifield",
   "Subtype.mk",
   "DivisionMonoid.toDivInvOneMonoid",
   "Semifield.toCommGroupWithZero"],
  "name": "Nonneg.inv",
  "constType":
  "{α : Type u_1} → [inst : Semifield α] → [inst_1 : LinearOrder α] → [IsStrictOrderedRing α] → Inv { x // 0 ≤ x }",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "SemilinearMapClass.instAddMonoidHomClass",
   "DistribMulActionSemiHomClass.mk",
   "SemilinearMapClass",
   "Module",
   "AddMonoidHomClass.mk",
   "RingHom.instFunLike",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "congrArg",
   "AddCommMonoid",
   "DistribMulActionSemiHomClass",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Eq",
   "AddHomClass",
   "DistribSMul.toSMulZeroClass",
   "FunLike",
   "SemilinearMapClass.toMulActionSemiHomClass",
   "AddZeroClass.toZero",
   "outParam",
   "AddMonoidHomClass.toZeroHomClass",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "SemilinearMapClass.toAddHomClass",
   "MulActionSemiHomClass.map_smulₛₗ",
   "Module.toDistribMulAction",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.refl",
   "MulActionSemiHomClass.mk",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "SemilinearMapClass.distribMulActionSemiHomClass",
  "constType":
  "∀ {R : Type u_1} {S : Type u_5} {M : Type u_8} {M₃ : Type u_11} (F : Type u_14) [inst : Semiring R]\n  [inst_1 : Semiring S] [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₃] [inst_4 : _root_.Module R M]\n  [inst_5 : _root_.Module S M₃] {σ : R →+* S} [inst_6 : FunLike F M M₃] [SemilinearMapClass F σ M M₃],\n  DistribMulActionSemiHomClass F (⇑σ) M M₃",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "Not",
   "Decidable.isFalse",
   "Decidable",
   "False",
   "instDecidableAnd.match_1",
   "Decidable.isTrue"],
  "name": "instDecidableNot",
  "constType": "{p : Prop} → [dp : Decidable p] → Decidable ¬p",
  "constCategory": "Definition"},
 {"references":
  ["Finset",
   "HEq.refl",
   "Set",
   "Lean.Meta.FastSubsingleton.elim",
   "Set.toFinset",
   "Fintype",
   "Fintype.instFastSubsingleton",
   "Eq.casesOn",
   "Set.Elem",
   "Eq.refl",
   "eq_of_heq",
   "HEq",
   "Eq.symm",
   "Eq",
   "Eq.ndrec"],
  "name": "Set.toFinset_congr",
  "constType":
  "∀ {α : Type u_1} {s t : Set α} [inst : Fintype ↑s] [inst_1 : Fintype ↑t], s = t → s.toFinset = t.toFinset",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid",
   "AddMonoid.toOppositeAddAction",
   "Subtype",
   "SetLike.instMembership",
   "AddOpposite",
   "Membership.mem",
   "AddSubgroup.instSetLike",
   "AddAction.orbitRel",
   "AddAction.instAddAction",
   "AddSubgroup.op",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddGroup",
   "AddSubgroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "AddOpposite.instAddGroup"],
  "name": "QuotientAddGroup.leftRel",
  "constType":
  "{α : Type u_1} → [inst : AddGroup α] → AddSubgroup α → Setoid α",
  "constCategory": "Definition"},
 {"references": ["True", "Eq", "trivial", "propext", "Iff.intro"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.S₁I._proof_1",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.S₁I",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        {S : Type} →\n          [CompleteLattice S] →\n            ({ p // p.1 < p.2 } → S) →\n              (I : { p // p.1 < p.2 }) → (x : ℒ) → HarderNarasimhan.InIntvl I x → (↑I).1 ≠ x → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Submodule.instBot",
   "Nontrivial",
   "HarderNarasimhan.CoprimaryFiltration.mk",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.rec",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] →\n                {motive : HarderNarasimhan.CoprimaryFiltration R M → Sort u} →\n                  ((filtration : ℕ → HarderNarasimhan.ℒ R M) →\n                      (monotone : Monotone filtration) →\n                        (first_eq_bot : filtration 0 = ⊥) →\n                          (fin_len : ∃ n, filtration n = ⊤) →\n                            (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                              (piecewise_coprimary :\n                                  ∀ n < Nat.find fin_len,\n                                    HarderNarasimhan.Coprimary R\n                                      (↥(filtration (n + 1)) ⧸\n                                        Submodule.submoduleOf (filtration n) (filtration (n + 1)))) →\n                                (strict_mono_associated_prime :\n                                    ∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len),\n                                      { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }) →\n                                  motive\n                                    { filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot,\n                                      fin_len := fin_len, strict_mono := strict_mono,\n                                      piecewise_coprimary := piecewise_coprimary,\n                                      strict_mono_associated_prime := strict_mono_associated_prime }) →\n                    (t : HarderNarasimhan.CoprimaryFiltration R M) → motive t",
  "constCategory": "Other"},
 {"references": ["_obj", "_neutral"],
  "name": "HarderNarasimhan.μA._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "le_top",
   "PartialOrder.toPreorder",
   "Min.min",
   "inf_of_le_left",
   "Top.top",
   "OrderTop",
   "Eq",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_top_eq",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : OrderTop α] (a : α), a ⊓ ⊤ = a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "OrderDual",
   "instHAdd",
   "Preorder.toLT",
   "OfNat.ofNat",
   "Nat.instPreorder",
   "LT.lt",
   "HAdd.hAdd",
   "strictMono_nat_of_lt_succ",
   "StrictAnti",
   "Preorder",
   "Nat",
   "OrderDual.instPreorder",
   "instOfNatNat"],
  "name": "strictAnti_nat_of_succ_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α}, (∀ (n : ℕ), f (n + 1) < f n) → StrictAnti f",
  "constCategory": "Theorem"},
 {"references":
  ["instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "Lattice.toSemilatticeInf",
   "Finset",
   "id",
   "LinearOrder",
   "Finset.Nonempty",
   "Finset.inf'"],
  "name": "Finset.min'",
  "constType":
  "{α : Type u_2} → [LinearOrder α] → (s : Finset α) → s.Nonempty → α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.InIntvl",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.S₁I._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (y : ℒ),\n  HarderNarasimhan.InIntvl I y → (↑I).1 ≠ y → ((↑I).1, y).1 < ((↑I).1, y).2",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.impl.prop3d4₀func._proof_8",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.impl.prop3d4₀func._proof_4",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.impl.ℒₛ",
   "And",
   "HarderNarasimhan.impl.prop3d4₀func",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "Nat.succ",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "dite",
   "CompleteLattice",
   "HarderNarasimhan.impl.prop3d4₀func._proof_7"],
  "name": "HarderNarasimhan.impl.prop3d4₀func.eq_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ),\n  HarderNarasimhan.impl.prop3d4₀func μ I n.succ =\n    if hbot : (↑I).1 = ↑(HarderNarasimhan.impl.prop3d4₀func μ I n) then ⟨(↑I).1, ⋯⟩\n    else\n      if hne : (HarderNarasimhan.impl.ℒₛ μ I (HarderNarasimhan.impl.prop3d4₀func μ I n) hbot).Nonempty then\n        let res := ⋯;\n        ⟨res.choose, ⋯⟩\n      else ⟨(↑I).1, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "_private.Mathlib.Order.Lattice.0._proof_9",
   "SemilatticeSup.toPartialOrder",
   "And",
   "and_true",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "Max.max",
   "le_antisymm_iff",
   "iff_self",
   "of_eq_true",
   "congr",
   "Iff",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Eq",
   "Preorder.toLE",
   "_private.Mathlib.Order.Lattice.0._proof_8"],
  "name": "sup_of_le_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → a ⊔ b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "Set.Finite.dependent_image",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Preorder.toLT",
   "AddGroupWithOne.toAddMonoidWithOne",
   "SMulZeroClass.toSMul",
   "Membership.mem.out",
   "AddMonoidWithOne.toAddMonoid",
   "instDistribSMul",
   "Subtype.val",
   "Submodule.Quotient.instSMul._proof_3",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "RingHom.id",
   "Module.IsNoetherian.finite",
   "associatedPrimes.finite",
   "Semiring.toModule",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "And.left",
   "DistribSMul.toSMulZeroClass",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "Prod.snd",
   "LinearMap",
   "Set.instMembership",
   "Prod",
   "isNoetherian_submodule'",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Set.Finite",
   "setOf",
   "Submodule.submoduleOf",
   "AddMonoid.toAddZeroClass",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Module.Finite.quotient",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Prod.fst",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "isNoetherian_of_isNoetherianRing_of_finite",
   "Eq",
   "CommRing.toCommSemiring",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "CommRing",
   "PrimeSpectrum",
   "LT.lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "HarderNarasimhan._μ._proof_2",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name":
  "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ._proof_3",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] {I : { z // z.1 < z.2 }},\n  {y |\n      ∃ x,\n        ∃ (hx : x ∈ associatedPrimes R (↥(↑I).2 ⧸ Submodule.submoduleOf (↑I).1 (↑I).2)),\n          { asIdeal := x, isPrime := ⋯ } = y}.Finite",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Ord.compare",
   "Preorder.toLT",
   "LinearOrder",
   "Ordering",
   "compareOfLessAndEq",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "LinearOrder.toPartialOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "instDistribLatticeOfLinearOrder",
   "LinearOrder.toOrd",
   "LinearOrder.toDecidableEq",
   "LinearOrder.toDecidableLT",
   "DistribLattice.toLattice",
   "Eq",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_47",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α),\n  compare a b = compareOfLessAndEq a b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Nat.find",
   "Subtype",
   "PartialOrder.toPreorder",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "Prod.fst",
   "instOfNatNat",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OfNat.ofNat",
   "Exists.casesOn",
   "HAdd.hAdd",
   "Prod",
   "LT.lt",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "instLENat"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma.match_2",
  "constType":
  "∀ (n : ℕ) (ℒ : Type) (ntl : Nontrivial ℒ) (l : Lattice ℒ) (bo : BoundedOrder ℒ) (wacc : WellFoundedGT ℒ) (S : Type)\n  (clo : CompleteLinearOrder S) (μ : { p // p.1 < p.2 } → S) (motive : (∃ JH, Nat.find ⋯ ≤ n + 1) → Prop)\n  (h : ∃ JH, Nat.find ⋯ ≤ n + 1),\n  (∀ (JHy : HarderNarasimhan.JordanHolderFiltration μ) (hJHy : Nat.find ⋯ ≤ n + 1), motive ⋯) → motive h",
  "constCategory": "Definition"},
 {"references":
  ["Not", "Or", "Iff", "Classical.propDecidable", "Decidable.imp_iff_or_not"],
  "name": "imp_iff_or_not",
  "constType": "∀ {b a : Prop}, b → a ↔ a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references": ["absurd", "Not", "Or.elim", "Or", "id"],
  "name": "Or.resolve_left",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬a → b",
  "constCategory": "Theorem"},
 {"references":
  ["True",
   "LE.le",
   "LE",
   "bot_le",
   "eq_true",
   "OrderBot.toBot",
   "Eq",
   "Bot.bot",
   "OrderBot"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_12",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderBot α] {a : α}, (⊥ ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nonneg.coe_div",
   "Eq.trans",
   "AddCommGroup.toAddGroup",
   "Exists.intro",
   "eq_true",
   "MonoidWithZero.toMulZeroOneClass",
   "SMulZeroClass.toSMul",
   "Subtype.val",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "NNReal.instLinearOrder",
   "NNReal.instLinearOrderedCommGroupWithZero",
   "False.elim",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "Function.Injective.groupWithZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "smul_inv_smul₀",
   "Exists",
   "Nonneg.semifield._proof_14",
   "ClosureOperator.IsClosed",
   "NNReal",
   "_private.Mathlib.Order.Basic.0._proof_1",
   "BoundedOrder",
   "Prod.snd",
   "DivisionSemiring.toSemiring",
   "Nonneg.semifield._proof_12",
   "Set.Iic",
   "Prod",
   "Nonneg.zpow",
   "LinearOrder.toDecidableLT",
   "MulZeroOneClass.toMulZeroClass",
   "Set.instCompleteAtomicBooleanAlgebra",
   "AddMonoidWithOne.toOne",
   "Lattice",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "AddMonoid.toAddZeroClass",
   "instNNRealZero",
   "Real.instIsStrictOrderedRing",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Real.field",
   "HarderNarasimhan.coe'",
   "AddCommMonoid.toAddMonoid",
   "Prod.fst",
   "Prod.casesOn",
   "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Set",
   "OrderEmbedding",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "OfNat.ofNat",
   "eq_self",
   "Module.toDistribMulAction",
   "dite_cond_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Ne",
   "Subtype.casesOn",
   "dite",
   "Nonneg.semifield._proof_17",
   "Nonneg.semifield._proof_15",
   "Semifield.toCommGroupWithZero",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "Nonneg.one",
   "PartialOrder.toPreorder",
   "Nonneg.semifield._proof_18",
   "Nonneg.div",
   "Prod.mk",
   "Preorder.toLT",
   "Nonneg.coe_zpow",
   "Nonneg.semifield._proof_16",
   "CommGroupWithZero.toDivisionCommMonoid",
   "GT.gt",
   "instNNRealPartialOrder",
   "RelEmbedding.instFunLike",
   "And.intro",
   "Semiring.toNonAssocSemiring",
   "DistribMulAction.toMulAction",
   "NNReal.instMulActionOfReal",
   "CompleteLattice.toTop",
   "Semifield.toDivisionSemiring",
   "AddGroup.toSubNegMonoid",
   "SemilatticeInf.toPartialOrder",
   "DistribSMul.toSMulZeroClass",
   "InvOneClass.toInv",
   "AddZeroClass.toZero",
   "Real",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "DistribMulAction.toDistribSMul",
   "Real.instMonoid",
   "HSMul.hSMul",
   "Nontrivial",
   "id",
   "Real.linearOrder",
   "CommGroupWithZero.toGroupWithZero",
   "DivisionMonoid.toDivInvOneMonoid",
   "instNNRealSemiring",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "Aesop.BuiltinRules.not_intro",
   "Nonneg.coe_inv",
   "DFunLike.coe",
   "congrArg",
   "instDistribLatticeOfLinearOrder",
   "GroupWithZero.toMonoidWithZero",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Subtype.le",
   "DivisionCommMonoid.toDivisionMonoid",
   "Set.instLE",
   "Nonneg.semifield._proof_13",
   "Not",
   "Nonneg.pow",
   "Inv.inv",
   "Lattice.toSemilatticeInf",
   "True",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Semiring.toMonoidWithZero",
   "NNReal.instDistribMulActionOfReal",
   "Real.semiring",
   "HarderNarasimhan.μQuotient",
   "LT.lt",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toModule",
   "Nonneg.mul",
   "DistribLattice.toLattice",
   "DivInvOneMonoid.toInvOneClass",
   "HarderNarasimhan.coe'._proof_48",
   "SubNegMonoid.toAddMonoid",
   "of_eq_true",
   "LE.le",
   "Field.toSemifield",
   "False",
   "Nonneg.inv",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39",
   "Nonneg.zero",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.impl.μQuotient_helper",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {V : Type}\n  [inst_3 : HarderNarasimhan.TotallyOrderedRealVectorSpace V] (r : { p // p.1 < p.2 } → NNReal)\n  (d : { p // p.1 < p.2 } → V) (z : { p // p.1 < p.2 }),\n  r z > 0 → ∃ μ, HarderNarasimhan.μQuotient r d z = HarderNarasimhan.coe' μ ∧ r z • μ = d z",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OmegaCompletePartialOrder",
  "constType": "Type u_6 → Type u_6",
  "constCategory": "Other"},
 {"references": [],
  "name": "Ordering",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Eq",
   "Set.instSingletonSet",
   "propext",
   "Set.instMembership"],
  "name": "HarderNarasimhan.impl.associated_primes_quot_koqcl._proof_11",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.mp",
   "Iff.mp",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil",
   "GT.gt",
   "Prod.fst",
   "IsEmpty",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "IsWellFounded.wf",
   "IsEmpty.elim",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "WellFounded",
   "Not",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.impl.HNFil_is_strict_mono",
   "Lattice",
   "Nontrivial",
   "Classical.byContradiction",
   "Top.top",
   "False",
   "Ne",
   "Subtype.mk",
   "WellFounded.wellFounded_iff_no_descending_seq",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil_of_fin_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ], ∃ N, HarderNarasimhan.impl.HNFil μ N = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "HarderNarasimhan.JordanHolderFiltration",
   "Int.instLTInt",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "SizeOf",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HarderNarasimhan.JordanHolderFiltration._sizeOf_inst",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "SizeOf.sizeOf",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "instSizeOfDefault",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.mk.sizeOf_spec",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} [inst_5 : SizeOf ℒ] [inst_6 : SizeOf S]\n  (filtration : ℕ → ℒ) (antitone : Antitone filtration) (fin_len : ∃ N, filtration N = ⊥)\n  (strict_anti : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration j < filtration i)\n  (first_eq_top : filtration 0 = ⊤)\n  (step_cond₁ : ∀ (k : ℕ) (hk : k < Nat.find fin_len), μ ⟨(filtration (k + 1), filtration k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩)\n  (step_cond₂ :\n    ∀ (i : ℕ) (hi : i < Nat.find fin_len) (z : ℒ) (h' : filtration (i + 1) < z),\n      z < filtration i → μ ⟨(filtration (i + 1), z), h'⟩ < μ ⟨(filtration (i + 1), filtration i), ⋯⟩),\n  sizeOf\n      { filtration := filtration, antitone := antitone, fin_len := fin_len, strict_anti := strict_anti,\n        first_eq_top := first_eq_top, step_cond₁ := step_cond₁, step_cond₂ := step_cond₂ } =\n    1 + sizeOf fin_len + sizeOf first_eq_top",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Preorder.le_refl",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a : HarderNarasimhan.Interval z), ↑a ≤ ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "le_inf",
   "Min.min",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_12",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b c : HarderNarasimhan.Interval z), ↑a ≤ ↑b → ↑a ≤ ↑c → ↑a ≤ ↑b ⊓ ↑c",
  "constCategory": "Theorem"},
 {"references": ["Nat", "OfNat", "OfNat.mk", "Int.ofNat", "Int"],
  "name": "instOfNat",
  "constType": "{n : ℕ} → OfNat ℤ n",
  "constCategory": "Definition"},
 {"references":
  ["MulZeroOneClass.toZero",
   "MulZeroOneClass.zero_mul",
   "MulZeroClass",
   "MulZeroClass.mk",
   "MulZeroOneClass",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toMul",
   "MulZeroOneClass.mul_zero"],
  "name": "MulZeroOneClass.toMulZeroClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulZeroClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "HarderNarasimhan.St",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.impl.prop3d4",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.proposition_3_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.μA_DescendingChainCondition μ → HarderNarasimhan.Convex μ → (HarderNarasimhan.St μ).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Bool",
   "PartialOrder.toPreorder",
   "Nat.cast",
   "Nat.cast_lt",
   "Mathlib.Meta.NormNum.ble_eq_false",
   "Bool.false",
   "Iff.mp",
   "Preorder.toLT",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "Semiring.toNonAssocSemiring",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "CharZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Nat.ble",
   "IsOrderedRing.toZeroLEOneClass",
   "instLTNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Meta.NormNum.isNat_lt_true.match_1",
   "IsOrderedAddMonoid.toAddLeftMono",
   "LT.lt",
   "IsOrderedRing",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.IsNat",
   "Semiring"],
  "name": "Mathlib.Meta.NormNum.isNat_lt_true",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] [CharZero α] {a b : α} {a' b' : ℕ},\n  Mathlib.Meta.NormNum.IsNat a a' → Mathlib.Meta.NormNum.IsNat b b' → b'.ble a' = false → a < b",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_1._cstage2",
  "constType": "_obj → _neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.WeakSlopeLike₂",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "InfSet",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Subtype.mk_lt_mk",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "Subtype.coe_inj",
   "And.intro",
   "Subtype.GCongr.coe_lt_coe",
   "funext",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "lt_iff_le_not_le",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Set.ext",
   "Eq.mpr",
   "setOf",
   "Subtype",
   "Subtype.lt",
   "le_trans",
   "and_true",
   "HarderNarasimhan.Resμ",
   "Iff.intro",
   "Prod.fst",
   "congrArg",
   "HarderNarasimhan.μmin",
   "Subtype.prop",
   "congr",
   "Subtype.property",
   "InfSet.sInf",
   "HarderNarasimhan.Interval",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "HarderNarasimhan.μmin_res_intvl._proof_20",
   "HarderNarasimhan.instBoundedOrderInterval",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "eq_self",
   "HarderNarasimhan.instNontrivialInterval",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μmin_res_intvl",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {I : { p // p.1 < p.2 }} {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} {J : { p // p.1 < p.2 }},\n  HarderNarasimhan.μmin (HarderNarasimhan.Resμ I μ) J = HarderNarasimhan.μmin μ ⟨(↑(↑J).1, ↑(↑J).2), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "OrderDual.instLT",
   "Lattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (p : { p // p.1 < p.2 }), (↑p).1 < (↑p).2",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "HarderNarasimhan.μmin",
   "Or",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HarderNarasimhan.impl.prop4d14",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_4_14",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      μ ⟨(⊥, x), ⋯⟩ ≤ μ HarderNarasimhan.TotIntvl ∨ ¬μ HarderNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩) →\n    HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl →\n      HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["neg_eq_zero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "SubtractionMonoid",
   "NegZeroClass.toNeg",
   "Neg.neg",
   "NegZeroClass.toZero",
   "Zero.toOfNat0",
   "Eq",
   "SubNegZeroMonoid.toNegZeroClass",
   "OfNat.ofNat",
   "propext"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_34",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] {a : α}, (-a = 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "CompleteLattice.le_sSup",
   "Lattice.toSemilatticeInf",
   "Set",
   "CompleteLattice.toLattice",
   "Membership.mem",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Set.instMembership",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_36",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (s : Set (HarderNarasimhan.DedekindMacNeilleCompletion α)), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "Set.iInter",
   "Subtype.val",
   "DFunLike.coe",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.prop",
   "forall_congr",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_12",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "_private.Init.Data.Subtype.0._proof_1",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "_private.Mathlib.Order.SetNotation.0._proof_4",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "Subtype.mk"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_13",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds), ∀ A ∈ 𝒮, ∀ ⦃x : α⦄, x ∈ ↑⟨⋂ a ∈ 𝒮, ↑a, ⋯⟩ → x ∈ ↑A",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "List.rec",
   "GetElem.getElem",
   "List",
   "Option.some",
   "List.instGetElem?NatLtLength",
   "Nat.le.casesOn",
   "GetElem?.getElem?",
   "instOfNatNat",
   "Nat.le.refl",
   "Eq.symm",
   "Eq.ndrec",
   "Eq",
   "List.get._proof_34",
   "List.cons",
   "Nat.le",
   "Nat.casesAuxOn",
   "List.nil",
   "List.instGetElemNatLtLength",
   "instLTNat",
   "HEq.refl",
   "instHAdd",
   "Nat.noConfusion",
   "Nat.le.step",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "Nat.succ",
   "Option",
   "Eq.refl",
   "HEq",
   "List.length"],
  "name": "List.getElem?_eq_getElem",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i : ℕ} (h : i < l.length), l[i]? = some l[i]",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "Or.inl",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "CompleteSemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "WellFoundedGT",
   "LE.isTotal",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.μ_Admissible.mk",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "IsTotal",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "HarderNarasimhan.impl.instμ_Admissible",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S}, HarderNarasimhan.μ_Admissible μ",
  "constCategory": "Theorem"},
 {"references": ["Function.Embedding", "RelEmbedding"],
  "name": "RelEmbedding.toEmbedding",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → {r : α → α → Prop} → {s : β → β → Prop} → r ↪r s → α ↪ β",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "True",
   "instHAdd",
   "List",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_2",
  "constType":
  "∀ {a0 a1 a2 : ℤ} {t : List ℤ}, (Omega.LinearCombo.coordinate 2).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: t)) = a2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "instHAdd",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "OfNat.ofNat"],
  "name": "Nat.add_one_pos",
  "constType": "∀ (n : ℕ), 0 < n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Eq.symm",
   "Int.instLEInt",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nat.lt_of_not_le",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Bool",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Option.some",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Int.instAdd",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (filtration : ℕ → ℒ) (fin_len : ∃ n, filtration n = ⊤)\n  (i : ℕ), i + 1 < Nat.find fin_len → ¬i + 1 ≤ Nat.find fin_len → False",
  "constCategory": "Theorem"},
 {"references": ["EmptyCollection"],
  "name":
  "EmptyCollection.emptyCollection._@.Mathlib.Data.Set.Operations._hyg.16",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references":
  ["List.finRange",
   "List.nodup_finRange",
   "Fintype.mk",
   "Nat",
   "Finset.mk",
   "List.mem_finRange",
   "Fin",
   "Fintype",
   "Multiset.ofList"],
  "name": "Fin.fintype",
  "constType": "(n : ℕ) → Fintype (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Subtype.lt", "Subtype", "Iff", "Iff.rfl", "Subtype.val", "LT"],
  "name": "Subtype.coe_lt_coe",
  "constType":
  "∀ {α : Type u_2} [inst : LT α] {p : α → Prop} {x y : Subtype p}, ↑x < ↑y ↔ x < y",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "Module",
   "LinearMap.mk",
   "CommSemiring",
   "AddHom.mk",
   "Membership.mem",
   "LocalizedModule.instAddCommMonoid",
   "MulZeroOneClass.toMulOneClass",
   "LocalizedModule.mk",
   "LocalizedModule.mkLinearMap._proof_59",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "LocalizedModule.mkLinearMap._proof_58",
   "NonAssocSemiring.toMulZeroOneClass",
   "SetLike.instMembership",
   "LocalizedModule",
   "Submonoid.instSetLike",
   "CommSemiring.toSemiring",
   "LinearMap",
   "OfNat.ofNat",
   "Submonoid.one",
   "Submonoid",
   "LocalizedModule.isModule'",
   "AddCommMonoid.toAddCommSemigroup",
   "One.toOfNat1"],
  "name": "LocalizedModule.mkLinearMap",
  "constType":
  "{R : Type u} →\n  [inst : CommSemiring R] →\n    (S : Submonoid R) →\n      (M : Type v) → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → M →ₗ[R] LocalizedModule S M",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg",
   "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "HMul.hMul",
   "Int.rawCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroup.toSubtractionMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "InvolutiveNeg.toNeg",
   "Eq.ndrec",
   "MulOneClass.toMul",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "Int.instNegInt",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoidWithOne.toOne",
   "Int.negOfNat",
   "instHMul",
   "one_mul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "MulZeroOneClass.toMulOneClass",
   "Int.cast",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Int.cast_one",
   "neg_mul",
   "MulOneClass.toOne",
   "Eq",
   "True",
   "Distrib.toMul",
   "OfNat.ofNat",
   "Int.cast_neg",
   "Int",
   "Ring.toAddCommGroup",
   "eq_self",
   "NegZeroClass.toNeg",
   "AddGroupWithOne.toAddGroup",
   "of_eq_true",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HasDistribNeg.toInvolutiveNeg",
   "One.toOfNat1",
   "AddGroupWithOne.toIntCast",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_one_mul",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a b : R}, (Int.negOfNat 1).rawCast * a = b → -a = b",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_not", "Iff", "Ne", "Eq"],
  "name": "not_ne_iff",
  "constType": "∀ {α : Sort u_1} {a b : α}, ¬a ≠ b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "HSMul.hSMul",
   "Mul",
   "Mul.toSMul",
   "instHMul",
   "HMul.hMul",
   "instHSMul",
   "Eq"],
  "name": "smul_eq_mul",
  "constType": "∀ {α : Type u_9} [inst : Mul α] (a b : α), a • b = a * b",
  "constCategory": "Theorem"},
 {"references": ["Not", "Exists", "not_exists", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_exists_eq",
  "constType": "∀ {α : Sort u_1} (s : α → Prop), (¬∃ x, s x) = ∀ (x : α), ¬s x",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "SetLike.instMembership",
   "Membership.mem",
   "Sub",
   "AddSubgroupClass.sub._proof_8",
   "Subtype.val",
   "AddSubgroupClass",
   "SubNegMonoid",
   "SubNegMonoid.toSub",
   "Sub.mk",
   "HSub.hSub",
   "SetLike",
   "Subtype.mk",
   "instHSub"],
  "name": "AddSubgroupClass.sub",
  "constType":
  "{G : Type u_1} →\n  {S : Type u_2} → [inst : SubNegMonoid G] → [inst_1 : SetLike S G] → [AddSubgroupClass S G] → {H : S} → Sub ↥H",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Set.not_subset._proof_21",
   "Set.not_subset._proof_22",
   "Exists",
   "Eq.trans",
   "True",
   "Set",
   "Membership.mem",
   "And",
   "Set.instMembership",
   "congrArg",
   "Set.instHasSubset",
   "HasSubset.Subset",
   "iff_self",
   "of_eq_true",
   "Iff",
   "funext"],
  "name": "Set.not_subset",
  "constType": "∀ {α : Type u} {s t : Set α}, ¬s ⊆ t ↔ ∃ a ∈ s, a ∉ t",
  "constCategory": "Theorem"},
 {"references":
  ["instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "LinearExtension",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "OrderHom",
   "PartialOrder",
   "toLinearExtension._proof_10",
   "OrderHom.mk",
   "SemilatticeInf.toPartialOrder"],
  "name": "toLinearExtension",
  "constType":
  "{α : Type u} → [inst : PartialOrder α] → α →o LinearExtension α",
  "constCategory": "Definition"},
 {"references":
  ["Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "le_trans",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "le_sup_left",
   "Preorder.toLE"],
  "name": "le_sup_of_le_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c ≤ a → c ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Nat.cast",
   "Eq.trans",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "instOfNatNat",
   "Nat.add_succ",
   "Zero.toOfNat0",
   "Nat.cast_succ",
   "Eq",
   "AddMonoidWithOne",
   "AddSemigroup.toAdd",
   "True",
   "AddZeroClass.toZero",
   "instHAdd",
   "Nat.recAux",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "of_eq_true",
   "Nat.succ",
   "Eq.refl",
   "add_assoc",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_zero",
   "AddMonoidWithOne.toOne",
   "id",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass"],
  "name": "Nat.cast_add",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "Equiv.left_inv",
   "LinearEquiv.toEquiv",
   "Module",
   "LinearMap.comp",
   "LinearEquiv.toLinearMap",
   "LinearEquiv",
   "LinearMap",
   "RingHomCompTriple",
   "Equiv",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Equiv.invFun",
   "Equiv.right_inv",
   "Equiv.trans",
   "LinearEquiv.mk",
   "RingHomInvPair",
   "Semiring"],
  "name": "LinearEquiv.trans",
  "constType":
  "{R₁ : Type u_2} →\n  {R₂ : Type u_3} →\n    {R₃ : Type u_4} →\n      {M₁ : Type u_7} →\n        {M₂ : Type u_8} →\n          {M₃ : Type u_9} →\n            [inst : Semiring R₁] →\n              [inst_1 : Semiring R₂] →\n                [inst_2 : Semiring R₃] →\n                  [inst_3 : AddCommMonoid M₁] →\n                    [inst_4 : AddCommMonoid M₂] →\n                      [inst_5 : AddCommMonoid M₃] →\n                        {module_M₁ : _root_.Module R₁ M₁} →\n                          {module_M₂ : _root_.Module R₂ M₂} →\n                            {module_M₃ : _root_.Module R₃ M₃} →\n                              {σ₁₂ : R₁ →+* R₂} →\n                                {σ₂₃ : R₂ →+* R₃} →\n                                  {σ₁₃ : R₁ →+* R₃} →\n                                    {σ₂₁ : R₂ →+* R₁} →\n                                      {σ₃₂ : R₃ →+* R₂} →\n                                        {σ₃₁ : R₃ →+* R₁} →\n                                          [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] →\n                                            [RingHomCompTriple σ₃₂ σ₂₁ σ₃₁] →\n                                              {re₁₂ : RingHomInvPair σ₁₂ σ₂₁} →\n                                                {re₂₃ : RingHomInvPair σ₂₃ σ₃₂} →\n                                                  [inst_8 : RingHomInvPair σ₁₃ σ₃₁] →\n                                                    {re₂₁ : RingHomInvPair σ₂₁ σ₁₂} →\n                                                      {re₃₂ : RingHomInvPair σ₃₂ σ₂₃} →\n                                                        [inst_9 : RingHomInvPair σ₃₁ σ₁₃] →\n                                                          (M₁ ≃ₛₗ[σ₁₂] M₂) → (M₂ ≃ₛₗ[σ₂₃] M₃) → M₁ ≃ₛₗ[σ₁₃] M₃",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instAddNat",
   "HAdd.hAdd",
   "instLTNat",
   "Nat",
   "Nat.succ",
   "instOfNatNat",
   "instHAdd",
   "Nat.le_of_succ_le",
   "OfNat.ofNat"],
  "name": "Nat.lt_of_succ_lt",
  "constType": "∀ {n m : ℕ}, n.succ < m → n < m",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "Option.none",
  "constType": "{α : Type u} → Option α",
  "constCategory": "Other"},
 {"references": ["AddZeroClass", "Add"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references": ["rfl", "Exists", "Eq", "exists_prop_eq", "propext"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_13",
  "constType":
  "∀ {α : Sort u_1} {a' : α} {p : (a : α) → a = a' → Prop}, (∃ a, ∃ (h : a = a'), p a h) = p a' ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "SemilinearMapClass",
   "Submodule.mem_comap",
   "Module",
   "Membership.mem",
   "DFunLike.coe",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.quot_ntl._proof_17",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} {x : M} {F : Type u_9} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F σ₁₂ M M₂] {f : F}\n  {p : Submodule R₂ M₂}, (x ∈ Submodule.comap f p) = (f x ∈ p)",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "Eq", "GT.gt", "LT", "propext"],
  "name": "HarderNarasimhan.impl.CP_HN._proof_28",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references": ["Lattice"],
  "name": "Lattice.toSemilatticeInf._elambda_1",
  "constType": "(α : Type u) → Lattice α → α → α → α",
  "constCategory": "Axiom"},
 {"references":
  ["PartialOrder.toPreorder",
   "BiheytingAlgebra.mk",
   "LinearOrder.toBiheytingAlgebra._proof_80",
   "HImp.mk",
   "HeytingAlgebra.mk",
   "instDistribLatticeOfLinearOrder",
   "BoundedOrder.toOrderTop",
   "HasCompl.mk",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "BiheytingAlgebra",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "ite",
   "LinearOrder",
   "BoundedOrder",
   "Bot.bot",
   "HNot.mk",
   "LinearOrder.toBiheytingAlgebra._proof_78",
   "LinearOrder.toDecidableEq",
   "DistribLattice.toLattice",
   "BoundedOrder.toOrderBot",
   "LinearOrder.toDecidableLE",
   "LinearOrder.toBiheytingAlgebra._proof_79",
   "Lattice",
   "LE.le",
   "Top.top",
   "SDiff.mk",
   "LinearOrder.toBiheytingAlgebra._proof_77",
   "OrderTop.toTop",
   "GeneralizedHeytingAlgebra.mk",
   "LinearOrder.toLattice"],
  "name": "LinearOrder.toBiheytingAlgebra",
  "constType":
  "{α : Type u_2} → [inst : LinearOrder α] → [BoundedOrder α] → BiheytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.instSingleton",
   "Finset",
   "Finset.singleton_inj",
   "Singleton.singleton",
   "Eq",
   "propext"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_18",
  "constType": "∀ {α : Type u_1} {a b : α}, ({a} = {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace",
  "constType": "Type → Type",
  "constCategory": "Other"},
 {"references":
  ["Preorder",
   "upperBounds",
   "Set",
   "Iff",
   "LE.le",
   "Membership.mem",
   "Iff.rfl",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "mem_upperBounds",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, a ∈ upperBounds s ↔ ∀ x ∈ s, x ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u_2} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → γ → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Singleton.singleton",
   "Submodule.Quotient.module",
   "AddCommGroup.toAddGroup",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Exists.intro",
   "Submodule.Quotient.instSMul",
   "SMulZeroClass.toSMul",
   "instDistribSMul",
   "Quotient.out_eq",
   "Submodule.Quotient.instSMul._proof_3",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "RingHom.id",
   "letFun",
   "SubNegMonoid.toSub",
   "Submodule.addSubgroupClass",
   "Eq.symm",
   "Submodule.annihilator",
   "Exists",
   "sub_self",
   "Submodule.addCommGroup",
   "Submodule.Quotient.mk_smul",
   "LinearMap",
   "Set.instMembership",
   "Ring.toSemiring",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "Quotient.out",
   "AddMonoid.toAddZeroClass",
   "Quotient",
   "Submodule.hasQuotient",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.Quotient.instZeroQuotient",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "Preorder.toLE",
   "propext",
   "AddSubgroupClass.sub",
   "IsScalarTower.left",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "CommRing.toRing",
   "Module.toDistribMulAction",
   "Submodule.completeLattice",
   "Submodule.smul",
   "instHSub",
   "Submodule.sub_mem_iff_right",
   "Quotient.mk''",
   "Submodule.Quotient.mk",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Iff.mp",
   "Quotient.mk",
   "Submodule.span",
   "AddMonoidWithOne.toAddMonoid",
   "Algebra.id",
   "Submodule.subtype",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "HarderNarasimhan.impl.support_quotient_mono._proof_4",
   "HSub.hSub",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Semiring.toModule",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DistribSMul.toSMulZeroClass",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "DistribMulAction.toDistribSMul",
   "Submodule.Quotient.instSMul'",
   "Submodule.Quotient.mk_eq_zero",
   "Exists.casesOn",
   "HasSubset.Subset",
   "Iff.mpr",
   "HSMul.hSMul",
   "id",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "Submodule.module",
   "DFunLike.coe",
   "Submodule",
   "congrArg",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "MonoidWithZero.toMonoid",
   "Algebra.toSMul",
   "instHSMul",
   "PrimeSpectrum.asIdeal",
   "Zero.toOfNat0",
   "CommRing.toCommSemiring",
   "Module.support",
   "CommSemiring.toSemiring",
   "Submodule.quotientRel",
   "Semiring.toMonoidWithZero",
   "Set.instSingletonSet",
   "CommRing",
   "Submodule.isScalarTower'",
   "Set.instHasSubset",
   "SubNegMonoid.toAddMonoid",
   "Submodule.setLike",
   "LE.le",
   "Submodule.mem_annihilator_span_singleton",
   "Submodule.addCommMonoid"],
  "name": "HarderNarasimhan.impl.support_quotient_mono",
  "constType":
  "∀ {R : Type} [inst : CommRing R] {M : Type} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  (N₁ N₂ N₃ : Submodule R M),\n  N₁ ≤ N₂ → Module.support R (↥N₃ ⧸ N₂.submoduleOf N₃) ⊆ Module.support R (↥N₃ ⧸ N₁.submoduleOf N₃)",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "Eq", "GT.gt", "LT", "propext"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_19",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Module",
   "Singleton.singleton",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.span",
   "Semiring.toNonAssocSemiring",
   "Ideal",
   "PrimeSpectrum.asIdeal",
   "Eq",
   "Preorder.toLE",
   "Semiring.toModule",
   "propext",
   "Submodule.annihilator",
   "CommRing.toCommSemiring",
   "Exists",
   "Set",
   "Module.support",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup",
   "Set.instSingletonSet",
   "CommRing",
   "Set.instMembership",
   "PrimeSpectrum",
   "LE.le",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "Module.mem_support_iff_exists_annihilator"],
  "name": "HarderNarasimhan.impl.support_quotient_mono._proof_4",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  {p : PrimeSpectrum R}, (p ∈ Module.support R M) = ∃ m, (Submodule.span R {m}).annihilator ≤ p.asIdeal",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Ne.symm",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "Preorder.toLT",
   "Ne.bot_lt",
   "Ne",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Bot.bot",
   "OrderBot"],
  "name": "Ne.bot_lt'",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, ⊥ ≠ a → ⊥ < a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.μmin",
   "PartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "CompleteSemilatticeInf.toInfSet",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μmin.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.μmin μ I = sInf {x | ∃ u, ∃ (h : HarderNarasimhan.InIntvl I u ∧ u ≠ (↑I).2), μ ⟨(u, (↑I).2), ⋯⟩ = x}",
  "constCategory": "Theorem"},
 {"references": ["IsTotal", "Or"],
  "name": "IsTotal.total",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop} [self : IsTotal α r] (a b : α), r a b ∨ r b a",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Nontrivial", "Ne"],
  "name": "Nontrivial.mk",
  "constType": "∀ {α : Type u_3}, (∃ x y, x ≠ y) → Nontrivial α",
  "constCategory": "Other"},
 {"references": ["List"],
  "name": "List.cons",
  "constType": "{α : Type u} → α → List α → List α",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.S₂I",
   "Prod.fst",
   "HarderNarasimhan.S₁I._proof_1",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.μA",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.S₂I.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (x : ℒ)\n  (hxI : HarderNarasimhan.InIntvl I x) (hx : (↑I).1 ≠ x),\n  HarderNarasimhan.S₂I μ I x hxI hx =\n    ∀ (y : ℒ) (hyI : HarderNarasimhan.InIntvl I y) (hy : (↑I).1 ≠ y),\n      HarderNarasimhan.μA μ ⟨((↑I).1, y), ⋯⟩ = HarderNarasimhan.μA μ ⟨((↑I).1, x), ⋯⟩ → y ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MulZeroOneClass",
   "MulZeroOneClass.mk",
   "AddCommMonoid.toAddMonoid",
   "NonAssocSemiring.one_mul",
   "MulOneClass.mk",
   "NonAssocSemiring.mul_one",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toMulZeroOneClass",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → MulZeroOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "eq_true",
   "Int.instCommSemiring",
   "Nat.sub_one_add_one",
   "Eq.symm",
   "gt_trans",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "Or.resolve_left",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "eq_false",
   "AddMonoid.toAddSemigroup",
   "Int.negOfNat",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.Semistable",
   "instDecidableTrue",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Classical.not_and_iff_not_or_not",
   "Prod.fst",
   "Or.inl",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Int.instIsOrderedAddMonoid",
   "HPow.hPow",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "eq_self",
   "dite_cond_eq_true",
   "Monoid.toNatPow",
   "HarderNarasimhan.impl.JHFil",
   "Ne",
   "instHSub",
   "PartialOrder.toPreorder",
   "false_and",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "HarderNarasimhan.impl.JHFil.eq_def",
   "GT.gt",
   "GE.ge",
   "not_false_eq_true",
   "Semiring.toNonAssocSemiring",
   "Or",
   "forall_congr",
   "Int.instLEInt",
   "CompleteLattice.toTop",
   "AddGroup.toSubNegMonoid",
   "CompleteLinearOrder",
   "Int.ofNat",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And.right",
   "Bot.bot",
   "Unit",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Iff.of_eq",
   "HarderNarasimhan.impl.JHFil._proof_4",
   "_private.Init.PropLemmas.0._proof_24",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "dite_congr",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "IsWellFounded.wf",
   "dite_cond_eq_false",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "Set.Nonempty",
   "instHAdd",
   "Distrib.toMul",
   "HarderNarasimhan.impl.JHFil.match_1",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "Eq.mpr_prop",
   "LT.lt",
   "ne_of_lt",
   "instSubNat",
   "of_eq_true",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "False",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "HarderNarasimhan.SlopeLike",
   "Eq.trans",
   "_private.Init.SimpLemmas.0._proof_4",
   "Membership.mem.out",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "False.elim",
   "SubNegMonoid.toSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "letFun",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "Exists.choose_spec",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "_private.Mathlib.Order.Basic.0._proof_1",
   "Nat.recAux",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Classical.byContradiction",
   "AddMonoidWithOne.toOne",
   "Lattice",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "setOf",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "EmptyCollection.emptyCollection",
   "Int.instRing",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "propext",
   "lt_of_not_ge",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.impl.prop4d6",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "HarderNarasimhan.impl.JHFil_anti_mono",
   "instDecidableEqNat",
   "neg_neg_of_pos",
   "dite",
   "bot_lt_top",
   "Nat.cast_one",
   "lt_trans",
   "Int.instCommRing",
   "Prod.mk",
   "Iff.mp",
   "Int.rawCast",
   "HMul.hMul",
   "_private.Mathlib.Data.Set.Basic.0._proof_26",
   "AddMonoidWithOne.toAddMonoid",
   "And.intro",
   "Ring.toAddGroupWithOne",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "And",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "implies_congr_ctx",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "Set.instEmptyCollection",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "instDecidableFalse",
   "_private.Init.PropLemmas.0._proof_12",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "True",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Exists.choose",
   "exists_prop_congr",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Mathlib.Tactic.PushNeg.not_nonempty_eq",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.impl.JHFil_prop₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hacc : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤)\n  (hμsl : HarderNarasimhan.SlopeLike μ) (hst : HarderNarasimhan.Semistable μ)\n  (hdc : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) (k : ℕ)\n  (hk : HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc k > ⊥),\n  μ ⟨(HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc (k + 1), HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc k), ⋯⟩ =\n    μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "Preorder.toLT",
   "IsSuccArchimedean",
   "congrArg",
   "PartialOrder",
   "forall_congr",
   "IsMax",
   "One",
   "_private.Init.PropLemmas.0._proof_12",
   "SuccAddOrder.toSuccOrder",
   "_private.Mathlib.Order.Max.0._proof_12",
   "Preorder.toLE",
   "Eq",
   "strictAnti_of_succ_lt",
   "Not",
   "Order.succ",
   "Exists",
   "Add",
   "instHAdd",
   "Order.succ_eq_add_one",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "Preorder",
   "One.toOfNat1",
   "SuccAddOrder",
   "Eq.refl",
   "id",
   "Eq.mpr"],
  "name": "strictAnti_of_add_one_lt",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : PartialOrder α] [inst_1 : Preorder β] [inst_2 : Add α] [inst_3 : One α]\n  [inst_4 : SuccAddOrder α] [IsSuccArchimedean α] {f : α → β}, (∀ (a : α), ¬IsMax a → f (a + 1) < f a) → StrictAnti f",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero", "AddZeroClass", "SMulZeroClass", "DistribSMul"],
  "name": "DistribSMul.toSMulZeroClass",
  "constType":
  "{M : Type u_12} → {A : Type u_13} → {inst : AddZeroClass A} → [self : DistribSMul M A] → SMulZeroClass M A",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Bool.false",
   "Classical.propDecidable",
   "eq_true",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "eq_top_iff",
   "congrFun",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "gt_trans",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "Ring.toSemiring",
   "Linarith.mul_neg",
   "Nat.le_succ",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Top.top",
   "Int.negOfNat",
   "Int.instCharZero",
   "Nat.find",
   "HarderNarasimhan.impl.instμ_Admissible",
   "Mathlib.Tactic.Ring.add_mul",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "Nat.le_refl",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Eq",
   "HarderNarasimhan.impl.theorem3d10",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "CompletelyDistribLattice.toCompleteLattice",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "CompleteLattice.toCompleteSemilatticeInf",
   "instHSub",
   "_private.Mathlib.Order.Defs.LinearOrder.0._proof_2",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "HarderNarasimhan.HarderNarasimhanFiltration.first_eq_bot",
   "HarderNarasimhan.HarderNarasimhanFiltration.fin_len",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Eq.rec",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_zero",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "Nat.cast",
   "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "HarderNarasimhan.HarderNarasimhanFiltration.strict_mono",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "HarderNarasimhan.HarderNarasimhanFiltration.piecewise_semistable",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "of_eq_true",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "HarderNarasimhan.impl.theorem3d10._proof_5",
   "Inhabited.default",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "HarderNarasimhan.HarderNarasimhanFiltration.ext",
   "Nat.le_succ_of_le",
   "letFun",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "Nat.find_spec",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "WellFoundedGT",
   "Preorder.toLE",
   "Mathlib.Tactic.Ring.mul_add",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.le_induction",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HarderNarasimhan.μA",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "HarderNarasimhan.impl.theorem3d10._proof_6",
   "Prod.mk",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "HarderNarasimhan.HarderNarasimhanFiltration.monotone",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "HarderNarasimhan.impl.HNFil",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "True",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.HarderNarasimhanFiltration.μA_pseudo_strict_anti",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.instUniqueHarderNarasimhanFiltration._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] (a : HarderNarasimhan.HarderNarasimhanFiltration μ), a = default",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.find",
   "Subtype",
   "PartialOrder.toPreorder",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "Prod.fst",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "instLENat"],
  "name": "HarderNarasimhan.JordanHolderFiltration.strict_anti",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} (self : HarderNarasimhan.JordanHolderFiltration μ)\n  (i j : ℕ), i < j → j ≤ Nat.find ⋯ → self.filtration j < self.filtration i",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible.casesOn",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.μ_Admissible.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                Sort u → HarderNarasimhan.μ_Admissible μ → HarderNarasimhan.μ_Admissible μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Preorder",
   "SMul",
   "PosSMulStrictMono",
   "HSMul.hSMul",
   "Preorder.toLT",
   "instHSMul",
   "Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat"],
  "name": "PosSMulStrictMono.mk",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : SMul α β] [inst_1 : Preorder α] [inst_2 : Preorder β] [inst_3 : Zero α],\n  (∀ ⦃a : α⦄, 0 < a → ∀ ⦃b₁ b₂ : β⦄, b₁ < b₂ → a • b₁ < a • b₂) → PosSMulStrictMono α β",
  "constCategory": "Other"},
 {"references": ["NonAssocSemiring", "NonUnitalNonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Int.instSub",
   "Eq.trans",
   "Decidable",
   "Subsingleton.elim",
   "Lean.Omega.Coeffs",
   "GE.ge",
   "Int.instLEInt",
   "HSub.hSub",
   "Eq.symm",
   "Eq.rec",
   "Eq.ndrec",
   "Bool.true",
   "decide_eq_true_eq",
   "Neg.neg",
   "Lean.Omega.UpperBound.sat",
   "And",
   "Lean.Omega.LowerBound.sat",
   "Int.instNegInt",
   "instDecidableEqBool",
   "instOfNat",
   "Int.zero_sub",
   "Eq.refl",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Int.decLe",
   "Lean.Omega.Constraint.sat'",
   "Bool",
   "instDecidableAnd",
   "Option.some",
   "and_true",
   "Decidable.decide",
   "congrArg",
   "congr",
   "Int.instAdd",
   "Lean.Omega.Constraint.lowerBound",
   "instSubsingletonDecidable",
   "Eq",
   "True",
   "instHAdd",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Option.none",
   "LE.le",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "Int.sub_left_le_of_le_add"],
  "name": "Lean.Omega.Constraint.addInequality_sat",
  "constType":
  "∀ {c : ℤ} {x y : Omega.Coeffs}, c + x.dot y ≥ 0 → { lowerBound := some (-c), upperBound := none }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references": ["Bot"],
  "name": "Bot.bot",
  "constType": "{α : Type u_1} → [self : Bot α] → α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Module",
   "AddEquivClass.mk",
   "LinearMap.toAddHom",
   "LinearEquiv.toLinearMap",
   "LinearEquiv",
   "SemilinearEquivClass",
   "AddHom.map_add'",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "SemilinearEquivClass.mk",
   "LinearMap.map_smul'",
   "RingHomInvPair",
   "LinearEquiv.instEquivLike",
   "Semiring"],
  "name": "LinearEquiv.instSemilinearEquivClass",
  "constType":
  "∀ {R : Type u_1} {S : Type u_5} {M : Type u_6} {M₂ : Type u_8} [inst : Semiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module S M₂]\n  {σ : R →+* S} {σ' : S →+* R} [inst_6 : RingHomInvPair σ σ'] [inst_7 : RingHomInvPair σ' σ],\n  SemilinearEquivClass (M ≃ₛₗ[σ] M₂) σ M M₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Set.toFinset",
   "Finset.toSet",
   "Iff.rfl",
   "Set.coe_toFinset",
   "Fintype",
   "Set.Elem",
   "congrArg",
   "Finset.coe_nonempty",
   "Iff",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Eq",
   "Finset.Nonempty",
   "propext"],
  "name": "Set.toFinset_nonempty",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s], s.toFinset.Nonempty ↔ s.Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Add", "Lean.Omega.LinearCombo.add", "Lean.Omega.LinearCombo", "Add.mk"],
  "name": "Lean.Omega.LinearCombo.instAdd",
  "constType": "Add Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Int.instLTInt",
   "HarderNarasimhan.JordanHolderFiltration",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLinearOrder S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                {motive : HarderNarasimhan.JordanHolderFiltration μ → Sort u} →\n                  ((filtration : ℕ → ℒ) →\n                      (antitone : Antitone filtration) →\n                        (fin_len : ∃ N, filtration N = ⊥) →\n                          (strict_anti : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration j < filtration i) →\n                            (first_eq_top : filtration 0 = ⊤) →\n                              (step_cond₁ :\n                                  ∀ (k : ℕ) (hk : k < Nat.find fin_len),\n                                    μ ⟨(filtration (k + 1), filtration k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩) →\n                                (step_cond₂ :\n                                    ∀ (i : ℕ) (hi : i < Nat.find fin_len) (z : ℒ) (h' : filtration (i + 1) < z),\n                                      z < filtration i →\n                                        μ ⟨(filtration (i + 1), z), h'⟩ < μ ⟨(filtration (i + 1), filtration i), ⋯⟩) →\n                                  motive\n                                    { filtration := filtration, antitone := antitone, fin_len := fin_len,\n                                      strict_anti := strict_anti, first_eq_top := first_eq_top,\n                                      step_cond₁ := step_cond₁, step_cond₂ := step_cond₂ }) →\n                    (t : HarderNarasimhan.JordanHolderFiltration μ) → motive t",
  "constCategory": "Other"},
 {"references": ["Exists", "exists_and_left", "And", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_24",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, b ∧ p x) = (b ∧ ∃ x, p x)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "BiheytingAlgebra.toHeytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "BiheytingAlgebra.toSDiff",
   "Max.max",
   "Iff",
   "SemilatticeSup.toMax",
   "LE.le",
   "SDiff.sdiff",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "GeneralizedHeytingAlgebra.toLattice"],
  "name": "BiheytingAlgebra.sdiff_le_iff",
  "constType":
  "∀ {α : Type u_4} [self : BiheytingAlgebra α] (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c",
  "constCategory": "Theorem"},
 {"references": ["exists_false", "Exists", "eq_false", "False", "Eq"],
  "name": "_private.Init.PropLemmas.0._proof_16",
  "constType": "∀ {α : Sort u_1}, (∃ _a, False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommMonoid",
   "Submodule.nontrivial_iff",
   "Module",
   "Iff.mpr",
   "Nontrivial",
   "Submodule",
   "Semiring"],
  "name": "Submodule.instNontrivial",
  "constType":
  "∀ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  [Nontrivial M], Nontrivial (Submodule R M)",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Subtype", "LT.mk", "Subtype.val", "LT"],
  "name": "Subtype.lt",
  "constType": "{α : Type u_2} → [LT α] → {p : α → Prop} → LT (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Inhabited.mk",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil_μA_pseudo_strict_anti",
   "HarderNarasimhan.impl.HNFil",
   "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration._proof_1",
   "Prod.fst",
   "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration._proof_2",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "HarderNarasimhan.impl.HNFil_piecewise_semistable",
   "Prod.snd",
   "Inhabited",
   "HarderNarasimhan.impl.HNFil_is_strict_mono'",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.impl.HNFil_of_fin_len",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] →\n                    [h : HarderNarasimhan.μ_Admissible μ] → Inhabited (HarderNarasimhan.HarderNarasimhanFiltration μ)",
  "constCategory": "Definition"},
 {"references": ["absurd", "Not", "Or.elim", "Or", "id"],
  "name": "Or.resolve_right",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Lattice.inf_le_left",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "Lattice.inf",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "LE.le",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "GeneralizedHeytingAlgebra.toLattice",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_33",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α), Lattice.inf a b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "LinearMap.comp._proof_19",
   "LinearMap.instFunLike",
   "Module",
   "LinearMap.mk",
   "AddHom.mk",
   "Function.comp",
   "LinearMap",
   "DFunLike.coe",
   "RingHomCompTriple",
   "LinearMap.comp._proof_20",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Semiring"],
  "name": "LinearMap.comp",
  "constType":
  "{R₁ : Type u_2} →\n  {R₂ : Type u_3} →\n    {R₃ : Type u_4} →\n      {M₁ : Type u_9} →\n        {M₂ : Type u_10} →\n          {M₃ : Type u_11} →\n            [inst : Semiring R₁] →\n              [inst_1 : Semiring R₂] →\n                [inst_2 : Semiring R₃] →\n                  [inst_3 : AddCommMonoid M₁] →\n                    [inst_4 : AddCommMonoid M₂] →\n                      [inst_5 : AddCommMonoid M₃] →\n                        {module_M₁ : _root_.Module R₁ M₁} →\n                          {module_M₂ : _root_.Module R₂ M₂} →\n                            {module_M₃ : _root_.Module R₃ M₃} →\n                              {σ₁₂ : R₁ →+* R₂} →\n                                {σ₂₃ : R₂ →+* R₃} →\n                                  {σ₁₃ : R₁ →+* R₃} →\n                                    [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] →\n                                      (M₂ →ₛₗ[σ₂₃] M₃) → (M₁ →ₛₗ[σ₁₂] M₂) → M₁ →ₛₗ[σ₁₃] M₃",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Int.instLTInt",
   "HarderNarasimhan.JordanHolderFiltration",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "HarderNarasimhan.JordanHolderFiltration.casesOn",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.ext.match_1",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLinearOrder S} {μ : { p // p.1 < p.2 } → S}\n  (motive : HarderNarasimhan.JordanHolderFiltration μ → Prop) (h : HarderNarasimhan.JordanHolderFiltration μ),\n  (∀ (filtration : ℕ → ℒ) (antitone : Antitone filtration) (fin_len : ∃ N, filtration N = ⊥)\n      (strict_anti : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration j < filtration i)\n      (first_eq_top : filtration 0 = ⊤)\n      (step_cond₁ : ∀ (k : ℕ) (hk : k < Nat.find fin_len), μ ⟨(filtration (k + 1), filtration k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩)\n      (step_cond₂ :\n        ∀ (i : ℕ) (hi : i < Nat.find fin_len) (z : ℒ) (h' : filtration (i + 1) < z),\n          z < filtration i → μ ⟨(filtration (i + 1), z), h'⟩ < μ ⟨(filtration (i + 1), filtration i), ⋯⟩),\n      motive\n        { filtration := filtration, antitone := antitone, fin_len := fin_len, strict_anti := strict_anti,\n          first_eq_top := first_eq_top, step_cond₁ := step_cond₁, step_cond₂ := step_cond₂ }) →\n    motive h",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint",
   "Bool",
   "Lean.Omega.Constraint.sat",
   "And",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Constraint.combine",
   "And.intro",
   "Eq.mpr",
   "Lean.Omega.Constraint.combine_sat",
   "Eq",
   "Bool.true",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.combine_sat'",
  "constType":
  "∀ {s t : Omega.Constraint} {x y : Omega.Coeffs}, s.sat' x y = true → t.sat' x y = true → (s.combine t).sat' x y = true",
  "constCategory": "Theorem"},
 {"references": ["GeneralizedHeytingAlgebra", "HImp"],
  "name": "GeneralizedHeytingAlgebra.toHImp",
  "constType": "{α : Type u_4} → [self : GeneralizedHeytingAlgebra α] → HImp α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "HarderNarasimhan.instLatticeInterval._rarg._lambda_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Eq", "propext", "Iff.intro"],
  "name": "Eq.propIntro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → a = b",
  "constCategory": "Theorem"},
 {"references": ["Option.none", "Top", "WithTop", "Top.mk"],
  "name": "WithTop.top",
  "constType": "{α : Type u_1} → Top (WithTop α)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.FiniteTotalPayoff.noConfusionType",
   "HarderNarasimhan.FiniteTotalPayoff.casesOn",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteLattice.toTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HarderNarasimhan.FiniteTotalPayoff.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.FiniteTotalPayoff μ} →\n                  v1 = v2 → HarderNarasimhan.FiniteTotalPayoff.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Finset",
   "Set.mem_toFinset",
   "Set",
   "Membership.mem",
   "Finset.instMembership",
   "Set.toFinset",
   "Eq",
   "Fintype",
   "propext",
   "Set.Elem",
   "Set.instMembership"],
  "name": "HarderNarasimhan.impl.prop3d12p1._proof_4",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, (a ∈ s.toFinset) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Real.partialOrder._proof_44",
   "Real.partialOrder._proof_45",
   "Real",
   "Real.partialOrder._proof_43",
   "Real.partialOrder._proof_42",
   "Real.instLE",
   "LT.lt",
   "PartialOrder.mk",
   "PartialOrder",
   "Real.instLT",
   "LE.mk",
   "LE.le",
   "Preorder.mk",
   "LT.mk"],
  "name": "Real.partialOrder",
  "constType": "PartialOrder ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Iff.trans",
   "exists_eq_left",
   "Exists",
   "Iff",
   "And",
   "exists_congr",
   "Eq",
   "And.comm"],
  "name": "exists_eq_right",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') ↔ p a'",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "le_trans",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "le_inf",
   "Subtype.prop",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Min.min",
   "Lattice",
   "Nontrivial",
   "LE.le"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_9",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HarderNarasimhan.Interval z), (↑z).1 ≤ ↑a ⊓ ↑b ∧ ↑a ⊓ ↑b ≤ (↑z).2",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "not_strictMono_of_wellFoundedGT",
   "Exists.intro",
   "Subtype.val",
   "Subtype.coe_inj",
   "False.elim",
   "SupSet.sSup",
   "HarderNarasimhan.μBstar",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.ndrec",
   "Exists",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Lattice",
   "HEq",
   "Top.top",
   "Set.ext",
   "HarderNarasimhan.instWellFoundedGTInterval",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "setOf",
   "StrictMono",
   "HarderNarasimhan.instSlopeLikeIntervalResμ",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instPreorder",
   "HarderNarasimhan.WeakAscendingChainCondition.mk",
   "instOfNatNat",
   "InfSet.sInf",
   "WellFoundedGT",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.impl.instWeakSlopeLike₁OfSlopeLike",
   "propext",
   "Set",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "HarderNarasimhan.μA",
   "SupSet",
   "inferInstance",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "bot_lt_top",
   "HarderNarasimhan.μA._proof_3",
   "InfSet",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Iff.mp",
   "HarderNarasimhan.μmax",
   "And.intro",
   "HarderNarasimhan.proposition_4_1",
   "eq_of_heq",
   "funext",
   "CompleteLinearOrder",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Nat.lt_add_one",
   "Exists.casesOn",
   "Nat",
   "Iff.of_eq",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "HarderNarasimhan.μAstar",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Iff.intro",
   "congrArg",
   "HarderNarasimhan.μmin",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Interval",
   "OrderBot.toBot",
   "HarderNarasimhan.Resμ._proof_19",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_top",
   "HEq.refl",
   "instHAdd",
   "HarderNarasimhan.μmax._proof_2",
   "Eq.casesOn",
   "exists_prop_congr",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "HarderNarasimhan.instNontrivialInterval",
   "LE.le",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.μA_eq_μmin",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) [HarderNarasimhan.SlopeLike μ] (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.μmin μ I = HarderNarasimhan.μA μ I",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Set", "Membership.mem", "Set.instMembership"],
  "name": "Set.Nonempty",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Not",
   "instLTNat",
   "Iff.mp",
   "And",
   "DecidablePred",
   "Nat.findGreatest",
   "Nat.findGreatest_eq_iff",
   "OfNat.ofNat",
   "LT.lt",
   "Nat",
   "instOfNatNat",
   "LE.le",
   "Ne",
   "Eq",
   "instLENat",
   "And.left"],
  "name": "Nat.findGreatest_le",
  "constType":
  "∀ {P : ℕ → Prop} [inst : DecidablePred P] (n : ℕ), Nat.findGreatest P n ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "InfSet",
   "PartialOrder.toPreorder",
   "Set",
   "Top",
   "Membership.mem",
   "SemilatticeSup.toPartialOrder",
   "Bot.bot",
   "Set.instMembership",
   "SupSet.sSup",
   "SupSet",
   "Lattice",
   "LE.le",
   "InfSet.sInf",
   "Top.top",
   "Bot",
   "Preorder.toLE",
   "CompleteLattice"],
  "name": "CompleteLattice.mk",
  "constType":
  "{α : Type u_8} →\n  [toLattice : Lattice α] →\n    [toSupSet : SupSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, a ≤ sSup s) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a) →\n          [toInfSet : InfSet α] →\n            (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) →\n                [toTop : Top α] → [toBot : Bot α] → (∀ (x : α), x ≤ ⊤) → (∀ (x : α), ⊥ ≤ x) → CompleteLattice α",
  "constCategory": "Other"},
 {"references": ["Mul", "Distrib"],
  "name": "Distrib.toMul",
  "constType": "{R : Type u_1} → [self : Distrib R] → Mul R",
  "constCategory": "Definition"},
 {"references": ["exists_prop", "Exists", "And", "Eq", "propext"],
  "name": "HarderNarasimhan.μmin_res_intvl._proof_20",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["HasSubset.mk",
   "Finset",
   "HasSubset",
   "Membership.mem",
   "Finset.instMembership"],
  "name": "Finset.instHasSubset",
  "constType": "{α : Type u_1} → HasSubset (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Submodule.Quotient.module",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "HarderNarasimhan.impl.prop3d12",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Int.instCommSemiring",
   "Finset.min'",
   "RingHom.id",
   "le_of_not_gt",
   "Eq.symm",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HarderNarasimhan.S",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "LinearMap",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.find",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_25",
   "RelEmbedding.toEmbedding",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "CommSemiring",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "HarderNarasimhan.impl.prop3d11",
   "Eq",
   "instNatCastInt",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Mathlib.Tactic.Ring.neg_zero",
   "LinearExtension",
   "Finset.val",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "Set.toFinset",
   "HPow.hPow",
   "Nat.cast_add",
   "eq_self",
   "Nat.lt_of_succ_lt",
   "Monoid.toNatPow",
   "AddZeroClass.toAdd",
   "HarderNarasimhan.instPartialOrderS₀",
   "instHSub",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "HarderNarasimhan.μ",
   "Preorder.toLT",
   "HarderNarasimhan.HarderNarasimhanFiltration.fin_len",
   "GT.gt",
   "Nat.instAddCommMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "Int.instLEInt",
   "PrimeSpectrum.instPartialOrder",
   "AddGroup.toSubNegMonoid",
   "Eq.rec",
   "Semiring.toModule",
   "Int.ofNat",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "PrimeSpectrum.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Nat.lt_add_one",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Exists.casesOn",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "Finset.instSingleton",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "LinearMap.toSpanSingleton",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Nat.cast",
   "Eq.mp",
   "Submodule.module",
   "CommRing.toNonUnitalCommRing",
   "instDistribLatticeOfLinearOrder",
   "HarderNarasimhan.HarderNarasimhanFiltration.strict_mono",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.instLinearOrderS₀",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Subtype.le",
   "Not",
   "instHAdd",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Distrib.toMul",
   "IsAssociatedPrime._proof_1",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsAssociatedPrime",
   "Mathlib.Tactic.Ring.add_congr",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "LT.lt",
   "lt_add_one",
   "of_eq_true",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "le_of_lt",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "ExistsUnique.unique",
   "Subtype.mk",
   "OrderTop.toTop",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Finset",
   "Eq.trans",
   "Singleton.singleton",
   "Membership.mem.out",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "SubNegMonoid.toSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "letFun",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.Coprimary.coprimary",
   "Exists.choose_spec",
   "ClosureOperator.IsClosed",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Submodule.addCommGroup",
   "HarderNarasimhan.S₀_order'",
   "Prod.snd",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.impl.piecewise_coprimary",
   "Set.instMembership",
   "Prod",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "AddMonoidWithOne.toOne",
   "Finset.instMembership",
   "AddCommGroup.toAddCommMonoid",
   "Nat.rawCast",
   "CompleteLattice.toBoundedOrder",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "AddMonoid.toAddZeroClass",
   "Linarith.add_lt_of_neg_of_le",
   "Submodule.hasQuotient",
   "HarderNarasimhan.coe'",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "HarderNarasimhan.impl.μ_nonempty",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "ExistsUnique.exists",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "lt_of_not_ge",
   "cast",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "Distrib.toAdd",
   "Nat.instAddMonoid",
   "Set.mem_toFinset",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Submodule.instTop",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.impl.prop3d13₂",
   "AddCommGroup",
   "HarderNarasimhan.impl.prop3d13₁",
   "OfNat.ofNat",
   "Int",
   "PrimeSpectrum",
   "HAdd.hAdd",
   "CommRing.toRing",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HarderNarasimhan.ℒ",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "HarderNarasimhan._μ._proof_2",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nat.le_of_succ_le",
   "Submodule.completeLattice",
   "ExistsUnique",
   "HarderNarasimhan.S₀",
   "neg_neg_of_pos",
   "Module.Finite",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Ideal.IsPrime",
   "Prod.mk",
   "Subtype.preorder",
   "Iff.mp",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_22",
   "instHPow",
   "SetLike.instMembership",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_24",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_23",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "lt_of_not_le",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_20",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_12",
   "instNatAtLeastTwo",
   "ConditionallyCompleteLattice.toLattice",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Multiset.instMembership",
   "Submodule.submoduleOf",
   "Subtype",
   "Function.Embedding.toFun",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "Submodule",
   "congrArg",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Finset.min'_mem",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Set.instLE",
   "Mathlib.Tactic.Ring.of_eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "True",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.HarderNarasimhanFiltration.μA_pseudo_strict_anti",
   "Exists.choose",
   "CommRing",
   "Multiset",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "NegZeroClass.toNeg",
   "Submodule.setLike",
   "Int.instSemiring",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Submodule.addCommMonoid",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_26",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (HNFil : HarderNarasimhan.HarderNarasimhanFiltration (HarderNarasimhan.μ R M)) (n : ℕ) (hn : n + 1 < Nat.find ⋯),\n  { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "Not",
   "lt_iff_lt_of_le_iff_le",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "Iff.symm",
   "Iff.intro",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "not_lt",
   "Iff",
   "not_congr",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_iff_le_iff_lt_iff_lt",
  "constType":
  "∀ {α : Type u_2} {β : Type u_5} [inst : LinearOrder α] [inst_1 : LinearOrder β] {a b : α} {c d : β},\n  (a ≤ b ↔ c ≤ d) ↔ (b < a ↔ d < c)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.instFunLike",
   "Module",
   "LocalizedModule.instAddCommMonoid",
   "MulZeroOneClass.toMulOneClass",
   "LocalizedModule.mkLinearMap",
   "Submodule",
   "LinearMap.semilinearMapClass",
   "AddCommMonoid",
   "Subsingleton",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "IsLocalizedModule.subsingleton_iff_ker_eq_top",
   "Eq",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing.toCommSemiring",
   "LinearMap.ker",
   "LocalizedModule",
   "Submodule.instTop",
   "CommSemiring.toSemiring",
   "CommRing",
   "localizedModuleIsLocalizedModule",
   "LinearMap",
   "Submonoid",
   "LocalizedModule.isModule'",
   "Iff",
   "Top.top"],
  "name": "LocalizedModule.subsingleton_iff_ker_eq_top",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {S : Submonoid R}, Subsingleton (LocalizedModule S M) ↔ LinearMap.ker (LocalizedModule.mkLinearMap S M) = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Mul.mk",
   "Subtype",
   "MulZeroClass",
   "Mul",
   "MulZeroClass.toMul",
   "HMul.hMul",
   "Nonneg.mul._proof_8",
   "Subtype.val",
   "OfNat.ofNat",
   "PosMulMono",
   "Preorder",
   "MulZeroClass.toZero",
   "LE.le",
   "instHMul",
   "Zero.toOfNat0",
   "Subtype.mk",
   "Preorder.toLE"],
  "name": "Nonneg.mul",
  "constType":
  "{α : Type u_1} → [inst : MulZeroClass α] → [inst_1 : Preorder α] → [PosMulMono α] → Mul { x // 0 ≤ x }",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "Module",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "Nonempty",
   "CommRing",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration",
   "HarderNarasimhan.CoprimaryFiltration",
   "instNonemptyOfInhabited",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "inferInstance",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instNonemptyCoprimaryFiltration",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  Nonempty (HarderNarasimhan.CoprimaryFiltration R M)",
  "constCategory": "Theorem"},
 {"references":
  ["IsStrictOrderedRing.toCharZero",
   "PartialOrder.toPreorder",
   "IsStrictOrderedRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Preorder.toLT",
   "zero_lt_one",
   "OfNat.ofNat",
   "LT.lt",
   "Semiring.toNonAssocSemiring",
   "One.toOfNat1",
   "MulZeroClass.toZero",
   "PartialOrder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoidWithOne.toOne",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NeZero.charZero_one",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring",
   "IsStrictOrderedRing.toZeroLEOneClass"],
  "name": "Linarith.zero_lt_one",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [inst_1 : PartialOrder α] [IsStrictOrderedRing α], 0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "SMulZeroClass.toSMul",
   "Submodule.span",
   "Subtype.val",
   "Set.Elem",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "iff_self",
   "forall_congr",
   "_private.Init.PropLemmas.0._proof_18",
   "_private.Mathlib.Data.Set.Insert.0._proof_14",
   "Semiring.toModule",
   "Submodule.annihilator",
   "forall_prop_domain_congr",
   "DistribSMul.toSMulZeroClass",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "DistribMulAction.toDistribSMul",
   "Set.instMembership",
   "Iff",
   "Eq.refl",
   "HSMul.hSMul",
   "AddMonoid.toAddZeroClass",
   "Subtype",
   "Module",
   "CommSemiring",
   "AddCommMonoid.toAddMonoid",
   "congrArg",
   "Ideal",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "Eq",
   "True",
   "Set",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Semiring.toMonoidWithZero",
   "Set.instSingletonSet",
   "OfNat.ofNat",
   "_private.Init.Data.Subtype.0._proof_1",
   "Module.toDistribMulAction",
   "Submodule.mem_annihilator_span_singleton._proof_30",
   "of_eq_true",
   "Submodule.setLike",
   "Subtype.mk"],
  "name": "Submodule.mem_annihilator_span_singleton",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (g : M)\n  (r : R), r ∈ (Submodule.span R {g}).annihilator ↔ r • g = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.le_trans",
   "Lattice.toSemilatticeSup",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "CompleteLattice.toLattice",
   "LinearOrder",
   "SemilatticeSup.toPartialOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "LE.le",
   "Preorder.toLE",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_26",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b c : HarderNarasimhan.DedekindMacNeilleCompletion α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakSlopeLike₂.casesOn",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₂.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u → HarderNarasimhan.WeakSlopeLike₂ μ → HarderNarasimhan.WeakSlopeLike₂ μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Ideal.IsPrime",
   "Distrib.toMul",
   "Membership.mem",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "Ideal.IsTwoSided",
   "Iff.intro",
   "Or.casesOn",
   "Semiring.toNonAssocSemiring",
   "Ideal.mul_mem_right",
   "Or",
   "Ideal",
   "Ideal.IsPrime.mem_or_mem",
   "Submodule.setLike",
   "Iff",
   "instHMul",
   "Ideal.mul_mem_left",
   "Semiring.toModule",
   "Semiring"],
  "name": "Ideal.IsPrime.mul_mem_iff_mem_or_mem",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [I.IsTwoSided], I.IsPrime → ∀ {x y : α}, x * y ∈ I ↔ x ∈ I ∨ y ∈ I",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "sup_eq_left",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "inf_le_inf_left",
   "sup_le",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "And.intro",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "le_sup_left",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "HarderNarasimhan.impl.lem2d4₂I",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "sup_le_sup_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "lt_irrefl",
   "HarderNarasimhan.impl.lem2d4₁",
   "Preorder.toLE",
   "Eq",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "LT.lt",
   "Max.max",
   "Min.min",
   "HarderNarasimhan.μA",
   "LE.le",
   "SemilatticeSup.toMax",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.lem2d4₃I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (w : ℒ),\n          HarderNarasimhan.InIntvl I w →\n            ∀ (hxw : ¬x ≤ w) (u : ℒ) (huxw : u ≤ x ⊓ w),\n              HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(w, x ⊔ w), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "HarderNarasimhan.NashEquilibrium.noConfusionType",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.NashEquilibrium.casesOn",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.μBstar",
   "Nontrivial",
   "Lattice",
   "Eq.ndrec",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.NashEquilibrium.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.NashEquilibrium μ} →\n                  v1 = v2 → HarderNarasimhan.NashEquilibrium.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "SemilatticeSup.toPartialOrder",
   "LT.lt",
   "Max.max",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Preorder.toLE",
   "right_lt_sup",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.Lattice.0._proof_15",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, (b < a ⊔ b) = ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "sorryAx",
  "constType": "(α : Sort u) → Bool → α",
  "constCategory": "Axiom"},
 {"references":
  ["HarderNarasimhan.impl.prop3d4₀func._proof_8",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.impl.prop3d4₀func.match_1",
   "HarderNarasimhan.impl.prop3d4₀func._proof_4",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.impl.ℒₛ",
   "And",
   "HarderNarasimhan.impl.prop3d4₀func",
   "BoundedOrder",
   "HarderNarasimhan.impl.prop3d4₀func._proof_3",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "Unit",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "dite",
   "CompleteLattice",
   "HarderNarasimhan.impl.prop3d4₀func._proof_7"],
  "name": "HarderNarasimhan.impl.prop3d4₀func._sunfold",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        [h : WellFoundedGT ℒ] →\n          {S : Type} →\n            [CompleteLattice S] →\n              ({ p // p.1 < p.2 } → S) → (I : { p // p.1 < p.2 }) → ℕ → { p // HarderNarasimhan.InIntvl I p }",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup.sup_le",
   "Lattice.toSemilatticeSup",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "BiheytingAlgebra.toHeytingAlgebra",
   "SemilatticeSup.sup",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "LE.le",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "CompleteLattice.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_32",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b c : HarderNarasimhan.DedekindMacNeilleCompletion α),\n  a ≤ c → b ≤ c → SemilatticeSup.sup a b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "HarderNarasimhan.Interval",
   "HarderNarasimhan.Resμ._proof_19",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.Resμ.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (z : { p // p.1 < p.2 }) {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (p : { p // p.1 < p.2 }),\n  HarderNarasimhan.Resμ z μ p = μ ⟨(↑(↑p).1, ↑(↑p).2), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Nat", "Nat.casesOn", "Nat.succ", "instOfNatNat", "OfNat.ofNat"],
  "name":
  "_private.HarderNarasimhan.JordanHolderFiltration.Impl.0.HarderNarasimhan.impl.JHFil.match_1.splitter",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → motive 0 → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["Ne.symm",
   "Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.InIntvl",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.stableI._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (x : ℒ),\n  HarderNarasimhan.InIntvl I x → x ≠ (↑I).1 → ((↑I).1, x).1 < ((↑I).1, x).2",
  "constCategory": "Theorem"},
 {"references":
  ["MulActionSemiHomClass.map_smulₛₗ",
   "FunLike",
   "SMul",
   "MulActionHomClass",
   "HSMul.hSMul",
   "id",
   "instHSMul",
   "Eq",
   "DFunLike.coe"],
  "name": "map_smul",
  "constType":
  "∀ {F : Type u_8} {M : Type u_9} {X : Type u_10} {Y : Type u_11} [inst : SMul M X] [inst_1 : SMul M Y]\n  [inst_2 : FunLike F X Y] [MulActionHomClass F M X Y] (f : F) (c : M) (x : X), f (c • x) = c • f x",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Set.toFinset_nonempty",
   "Set.toFinset",
   "Eq",
   "Fintype",
   "Finset.Nonempty",
   "propext",
   "Set.Elem"],
  "name": "HarderNarasimhan.impl.μ_nonempty._proof_1",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s], s.toFinset.Nonempty = s.Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Bool.false",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "False.elim",
   "le_of_not_gt",
   "SubNegMonoid.toSub",
   "letFun",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int.instLTInt",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "_private.Mathlib.Order.Basic.0._proof_1",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Ring.toSemiring",
   "Linarith.mul_neg",
   "Nat.find_spec",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "HarderNarasimhan.impl.function_wrapper_prop2",
   "Eq.refl",
   "Antitone",
   "eq_false",
   "AddMonoid.toAddSemigroup",
   "Classical.byContradiction",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Int.negOfNat",
   "Top.top",
   "Int.instCharZero",
   "Eq.mpr",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "Bool",
   "HarderNarasimhan.impl.function_wrapper_prop1",
   "Mathlib.Tactic.Ring.add_mul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.mul_add",
   "Eq",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "instNatCastInt",
   "Nat.le_induction",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "eq_self",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "dite_cond_eq_true",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Ne",
   "neg_neg_of_pos",
   "dite",
   "instHSub",
   "Nat.find_min",
   "Nat.find_min'",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "lt_trans",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Iff.mp",
   "Preorder.toLT",
   "Int.rawCast",
   "HMul.hMul",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Eq.rec",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "of_eq_false",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_zero",
   "Bot.bot",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "lt_of_not_le",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "le_bot_iff",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "Eq.mp",
   "le_trans",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "dite_cond_eq_false",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Nat.lt_of_add_one_le",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "HarderNarasimhan.impl.function_wrapper._proof_6",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Nat.decLe",
   "Mathlib.Tactic.Ring.cast_pos",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "le_of_lt",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "False",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.impl.function_wrapper_prop5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ) (hf0 : f 0 = ⊤)\n  (atf : ∃ k, f k = ⊥) (hfat : Antitone f) (i j : ℕ),\n  i < j →\n    j ≤ Nat.find ⋯ → HarderNarasimhan.impl.function_wrapper f atf j < HarderNarasimhan.impl.function_wrapper f atf i",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "instOfNatNat",
   "instHAdd",
   "Nat.le_of_succ_le_succ",
   "LE.le",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Nat.le_of_lt_add_one",
  "constType": "∀ {n m : ℕ}, n < m + 1 → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "Set.iInter",
   "Subtype.val",
   "DFunLike.coe",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "forall_congr",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "_private.Init.Data.Subtype.0._proof_1",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "_private.Mathlib.Order.SetNotation.0._proof_4",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "Subtype.mk"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_12",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds), T.IsClosed (⋂ a ∈ 𝒮, ↑a)",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "OrderEmbedding.le_iff_le",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "OrderEmbedding",
   "DFunLike.coe",
   "RelEmbedding.instFunLike",
   "propext"],
  "name": "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α ↪o β) {a b : α}, (f a ≤ f b) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "sub_eq_add_neg",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Eq.ndrec",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Ring.toAddCommGroup",
   "eq_self",
   "NegZeroClass.toNeg",
   "AddGroupWithOne.toAddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "of_eq_true",
   "instHSub",
   "AddMonoid.toAddZeroClass",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.sub_pf",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a b c d : R}, -b = c → a + c = d → a - b = d",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references": ["Mul", "MulOneClass"],
  "name": "MulOneClass.toMul",
  "constType": "{M : Type u} → [self : MulOneClass M] → Mul M",
  "constCategory": "Definition"},
 {"references":
  ["instTransEq",
   "Trans.trans",
   "add_lt_add_left",
   "AddZeroClass",
   "AddZeroClass.toZero",
   "instHAdd",
   "AddLeftStrictMono",
   "add_zero",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "AddZeroClass.toAdd",
   "Eq.symm",
   "Zero.toOfNat0",
   "Eq",
   "LT"],
  "name": "lt_add_of_pos_right",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α] [AddLeftStrictMono α] (a : α) {b : α}, 0 < b → a < a + b",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddLeftCancelMonoid.mk",
   "AddGroup.toAddCancelMonoid._proof_16",
   "AddCancelMonoid.mk",
   "AddGroup",
   "AddGroup.toSubNegMonoid",
   "AddGroup.toAddCancelMonoid._proof_15"],
  "name": "AddGroup.toAddCancelMonoid",
  "constType": "{G : Type u_1} → [AddGroup G] → AddCancelMonoid G",
  "constCategory": "Definition"},
 {"references": ["Classical.choose_spec", "Exists", "Exists.choose"],
  "name": "Exists.choose_spec",
  "constType": "∀ {α : Sort u_1} {p : α → Prop} (P : ∃ a, p a), p P.choose",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "ClosureOperator"],
  "name": "ClosureOperator.IsClosed",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → ClosureOperator α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Submodule.Quotient.module",
   "HarderNarasimhan.CoprimaryFiltration.piecewise_coprimary",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "HarderNarasimhan.impl.prop3d12",
   "SMulZeroClass.toSMul",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Submodule.Quotient.instSMul._proof_3",
   "Int.instCommSemiring",
   "Finset.min'",
   "RingHom.id",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "Eq.symm",
   "Module.IsNoetherian.finite",
   "HarderNarasimhan.impl.quot_ntl'",
   "IsCancelAdd.toIsLeftCancelAdd",
   "HarderNarasimhan.S",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "LinearMap",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Int.negOfNat",
   "HarderNarasimhan.CoprimaryFiltration.fin_len",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "RelEmbedding.toEmbedding",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "CommSemiring",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Nat.instSemiring",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "HarderNarasimhan.impl.prop3d11",
   "Eq",
   "instNatCastInt",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Mathlib.Tactic.Ring.neg_zero",
   "LinearExtension",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "Set.toFinset",
   "HPow.hPow",
   "Nat.cast_add",
   "eq_self",
   "Nat.lt_of_succ_lt",
   "Monoid.toNatPow",
   "AddZeroClass.toAdd",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.impl.CP_HN._proof_28",
   "Ne",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "CompleteLattice.toCompleteSemilatticeInf",
   "instHSub",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "HarderNarasimhan.μ",
   "Preorder.toLT",
   "HarderNarasimhan.impl.CP_HN._proof_27",
   "instZeroLEOneClass",
   "GT.gt",
   "Nat.instAddCommMonoid",
   "GE.ge",
   "RelEmbedding.instFunLike",
   "Submodule.subtype",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "eq_of_heq",
   "Int.instLEInt",
   "PrimeSpectrum.instPartialOrder",
   "AddGroup.toSubNegMonoid",
   "Semiring.toModule",
   "Int.ofNat",
   "Eq.rec",
   "HarderNarasimhan.CoprimaryFiltration.monotone",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "DistribSMul.toSMulZeroClass",
   "AddZeroClass.toZero",
   "Nat.instPartialOrder",
   "PrimeSpectrum.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HarderNarasimhan.CoprimaryFiltration.strict_mono_associated_prime",
   "Nat.lt_add_one",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Exists.casesOn",
   "Nat.instCanonicallyOrderedAdd",
   "isNoetherian_submodule'",
   "Nat",
   "Finset.instSingleton",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Nat.cast",
   "Eq.mp",
   "Submodule.module",
   "HarderNarasimhan.CoprimaryFiltration.strict_mono",
   "CommRing.toNonUnitalCommRing",
   "DFunLike.coe",
   "instDistribLatticeOfLinearOrder",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.instLinearOrderS₀",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "isNoetherian_of_isNoetherianRing_of_finite",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Subtype.le",
   "Not",
   "instHAdd",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Distrib.toMul",
   "IsAssociatedPrime._proof_1",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsAssociatedPrime",
   "Mathlib.Tactic.Ring.add_congr",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Submodule.submoduleOf._proof_14",
   "LT.lt",
   "lt_add_one",
   "of_eq_true",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "Submodule.Quotient.nontrivial_of_lt_top",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "False",
   "ExistsUnique.unique",
   "Subtype.mk",
   "LT",
   "OrderTop.toTop",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Finset",
   "Eq.trans",
   "Singleton.singleton",
   "Exists.intro",
   "HarderNarasimhan.impl.quot_ntl",
   "Membership.mem.out",
   "instDistribSMul",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "letFun",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "not_lt_of_le",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_1",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.Coprimary.coprimary",
   "Exists.choose_spec",
   "ClosureOperator.IsClosed",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Submodule.addCommGroup",
   "HarderNarasimhan.S₀_order'",
   "Prod.snd",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "Set.instMembership",
   "Prod",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "Nat.instStarOrderedRing",
   "AddMonoidWithOne.toOne",
   "Finset.instMembership",
   "HEq",
   "AddCommGroup.toAddCommMonoid",
   "Nat.rawCast",
   "CompleteLattice.toBoundedOrder",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "AddMonoid.toAddZeroClass",
   "Linarith.add_lt_of_neg_of_le",
   "Submodule.hasQuotient",
   "HarderNarasimhan.coe'",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "HarderNarasimhan.impl.μ_nonempty",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Submodule.mem_top",
   "ExistsUnique.exists",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "congr",
   "Int.instAdd",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Submodule.instOrderTop",
   "lt_of_not_ge",
   "cast",
   "Distrib.toAdd",
   "Nat.instAddMonoid",
   "Set.mem_toFinset",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Submodule.instTop",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.impl.prop3d13₂",
   "AddCommGroup",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OrderEmbedding",
   "OfNat.ofNat",
   "HarderNarasimhan.impl.prop3d13₁",
   "Int",
   "PrimeSpectrum",
   "HAdd.hAdd",
   "CommRing.toRing",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "HarderNarasimhan.ℒ",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HarderNarasimhan.μA",
   "MulZeroClass.toZero",
   "HarderNarasimhan._μ._proof_2",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nat.le_of_succ_le",
   "Submodule.completeLattice",
   "ExistsUnique",
   "HarderNarasimhan.S₀",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Module.Finite",
   "HarderNarasimhan.CoprimaryFiltration.first_eq_bot",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Ideal.IsPrime",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_11",
   "Prod.mk",
   "Iff.mp",
   "Subtype.preorder",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "HarderNarasimhan.Coprimary",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "AddSemigroup.toAdd",
   "instHPow",
   "SetLike.instMembership",
   "NonUnitalNonAssocSemiring.toDistrib",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "Neg.neg",
   "Nat.instStarRing",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "ConditionallyCompleteLattice.toLattice",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Submodule.submoduleOf",
   "Subtype",
   "Module.Finite.quotient",
   "Function.Embedding.toFun",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "HarderNarasimhan.impl.rmk4d14₂",
   "SubNegZeroMonoid.toNegZeroClass",
   "Submodule",
   "congrArg",
   "Submodule.Quotient.addCommGroup",
   "Nat.instOne",
   "Ideal",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "HarderNarasimhan.Interval",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.cast_zero",
   "Finset.min'_mem",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Set.instLE",
   "Mathlib.Tactic.Ring.of_eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "True",
   "HEq.refl",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "Exists.choose",
   "CommRing",
   "Eq.casesOn",
   "HarderNarasimhan.instNontrivialInterval",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "NegZeroClass.toNeg",
   "Submodule.setLike",
   "Int.instSemiring",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "HarderNarasimhan.impl.ss_iff'",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Submodule.addCommMonoid",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.impl.CP_HN",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (a : HarderNarasimhan.CoprimaryFiltration R M), ∃ HNFil, a.filtration = HNFil.filtration",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder", "Or", "PartialOrder", "LE.le", "Preorder.toLE"],
  "name": "HarderNarasimhan.IsComparable",
  "constType": "{ℒ : Type} → [PartialOrder ℒ] → ℒ → ℒ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Submodule.instNontrivial",
   "Module",
   "HarderNarasimhan.μ",
   "Preorder.toLT",
   "Prod.fst",
   "Or.inl",
   "HarderNarasimhan.instLinearOrderS₀",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "HarderNarasimhan.S",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.IsAttained",
   "AddCommGroup",
   "Prod.snd",
   "HarderNarasimhan.μ_Admissible.mk",
   "CommRing",
   "HarderNarasimhan.impl.prop3d13₁",
   "HarderNarasimhan.instIsTotalDedekindMacNeilleCompletionLe",
   "LT.lt",
   "Prod",
   "IsNoetherianRing",
   "IsTotal",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "Nontrivial",
   "LE.le",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "inferInstance",
   "ConditionallyCompleteLattice.toLattice",
   "HarderNarasimhan.S₀",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  HarderNarasimhan.μ_Admissible (HarderNarasimhan.μ R M)",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_4._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["MulOneClass"],
  "name": "Submonoid",
  "constType": "(M : Type u_3) → [MulOneClass M] → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "LinearMap.instFunLike",
   "Module",
   "Submodule.module",
   "Membership.mem",
   "Submodule.map",
   "eq_true",
   "Submodule",
   "Submodule.subtype",
   "LinearMap.semilinearMapClass",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq",
   "Preorder.toLE",
   "SetLike.instMembership",
   "True",
   "LinearMap",
   "RingHomSurjective.ids",
   "Submodule.setLike",
   "Submodule.map_subtype_le",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Semiring"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_20",
  "constType":
  "∀ {R : Type u_1} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M) (p' : Submodule R ↥p), (Submodule.map p.subtype p' ≤ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "True",
   "ite",
   "LinearOrder",
   "ite_cond_eq_true",
   "min_def",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "eq_self",
   "LinearOrder.toPartialOrder",
   "of_eq_true",
   "LinearOrder.toDecidableLE",
   "Min.min",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "LinearOrder.toMin"],
  "name": "min_self",
  "constType": "∀ {α : Type u_1} [inst : LinearOrder α] (a : α), min a a = a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "instLTNat",
   "Nat.succ_add",
   "Nat.add_le_of_le_sub",
   "Eq.mp",
   "instHAdd",
   "Nat.ge_of_not_lt",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.not_lt_zero",
   "Nat",
   "Nat.sub_eq_zero_of_le",
   "instSubNat",
   "Nat.succ",
   "instOfNatNat",
   "letFun",
   "LE.le",
   "HSub.hSub",
   "instHSub",
   "instLENat",
   "Nat.le_of_lt"],
  "name": "Nat.add_lt_of_lt_sub",
  "constType": "∀ {a b c : ℕ}, a < c - b → a + b < c",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Classical.propDecidable",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "_private.Mathlib.Data.Nat.Find.0._proof_10",
   "MonoidWithZero.toMulZeroOneClass",
   "Subtype.coe_inj",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "Int.instLTInt",
   "Nat.sub_one_add_one",
   "LinearOrderedCommMonoidWithZero.toCommMonoidWithZero",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "le_sup_left",
   "HarderNarasimhan.InIntvl",
   "Nat.le_of_lt_succ",
   "eq_false",
   "Antitone",
   "Int.negOfNat",
   "covariant_swap_add_of_covariant_add",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "instDecidableTrue",
   "HarderNarasimhan.impl.thm4d21",
   "HarderNarasimhan.instSlopeLikeIntervalResμ",
   "List",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Nat.le_sub_one_iff_lt",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "Eq",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_8",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "HarderNarasimhan.impl.JH_pos_len",
   "Ne",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "contravariant_swap_add_of_contravariant_add",
   "HarderNarasimhan.μA._proof_3",
   "CommMonoidWithZero.toMonoidWithZero",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Preorder.toLT",
   "GT.gt",
   "Nat.instAddCommMonoid",
   "IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT",
   "dif_pos",
   "IsCancelAdd.toIsRightCancelAdd",
   "forall_congr",
   "Int.instLEInt",
   "List.TFAE",
   "CompleteLattice.toTop",
   "Eq.rec",
   "sup_le_sup_left",
   "AddZeroClass.toZero",
   "And.right",
   "lt_of_le_of_lt",
   "HarderNarasimhan.JordanHolderFiltration.step_cond₂",
   "Nat.instCanonicallyOrderedAdd",
   "zero_add",
   "Mathlib.Tactic.Ring.atom_pf",
   "sup_of_le_left",
   "Option",
   "Nat.lt_of_lt_pred",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "SemilatticeInf.toMin",
   "Eq.mp",
   "le_trans",
   "DecidablePred",
   "CommRing.toNonUnitalCommRing",
   "dite_congr",
   "neg_eq_zero",
   "instDistribLatticeOfLinearOrder",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "_private.Mathlib.Algebra.Order.Monoid.Canonical.Defs.0._proof_6",
   "AddCommSemigroup.toAddCommMagma",
   "dite_cond_eq_false",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "HarderNarasimhan.instWeakDescendingChainCondition'IntervalResμ",
   "HarderNarasimhan.instWeakDescendingChainConditionOfWeakDescendingChainCondition'",
   "le_top",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Mathlib.Tactic.Ring.add_congr",
   "Eq.mpr_prop",
   "LT.lt",
   "lt_add_one",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "of_eq_true",
   "Nat.succ",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_lt",
   "SemilatticeSup.toMax",
   "False",
   "Subtype.mk",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "_private.Init.Core.0._proof_39",
   "HarderNarasimhan.JordanHolderFiltration.antitone",
   "HarderNarasimhan.SlopeLike",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "LE",
   "Exists.intro",
   "sup_le",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_sup_right",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_9",
   "HarderNarasimhan.NashEquilibrium",
   "sub_eq_zero_of_eq",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "rfl",
   "_private.Mathlib.Algebra.Order.Monoid.Canonical.Defs.0._proof_10",
   "HarderNarasimhan.impl.function_wrapper",
   "Prod.snd",
   "_private.Mathlib.Tactic.Zify.0._proof_1",
   "Set.instMembership",
   "HarderNarasimhan.impl.function_wrapper_prop6",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_15",
   "HarderNarasimhan.impl.function_wrapper_prop2",
   "Eq.refl",
   "Classical.byContradiction",
   "AddMonoidWithOne.toOne",
   "Lattice",
   "Nat.rawCast",
   "HarderNarasimhan.in_TotIntvl",
   "AddMonoid.toAddZeroClass",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_13",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "le_rfl",
   "instOfNatNat",
   "lt_irrefl",
   "congr",
   "Int.instAdd",
   "AddCommMagma.toAdd",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "inf_lt_left",
   "HarderNarasimhan.Affine.affine",
   "Nat.instAddMonoid",
   "HarderNarasimhan.impl.function_wrapper_prop3",
   "Subtype.coe_le_coe",
   "eq_bot_iff",
   "Int",
   "AddCommGroup.toDivisionAddCommMonoid",
   "instDecidableEqNat",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_14",
   "Lean.Name.num",
   "dite",
   "Nat.sub_le",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "lt_trans",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Nat.sub_one_lt",
   "HMul.hMul",
   "HarderNarasimhan.instConvexOfAffine",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddSemigroup.toAdd",
   "instHPow",
   "And",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "lt_of_not_le",
   "Nontrivial",
   "NegZeroClass.toZero",
   "instHMul",
   "HarderNarasimhan.FiniteTotalPayoff.fin_tot_payoff",
   "List.length",
   "Eq.substr",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_19",
   "Subtype",
   "Lean.Name.anonymous",
   "LinearOrderedCommMonoidWithZero.toLinearOrder",
   "Mathlib.Tactic.Ring.neg_mul",
   "HarderNarasimhan.TotIntvl._proof_1",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "List.TFAE.out",
   "HEq.refl",
   "eq_of_le_of_not_lt",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "exists_prop_congr",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "Min.min",
   "LE.le",
   "le_sSup",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "instLENat",
   "lt_iff_not_le",
   "HarderNarasimhan.impl.function_wrapper_prop4",
   "Ring.toNonAssocRing",
   "Bool.false",
   "eq_true",
   "AddGroupWithOne.toAddMonoidWithOne",
   "List.instGetElem?NatLtLength",
   "GetElem?.getElem?",
   "Linarith.lt_of_lt_of_eq",
   "zero_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.JordanHolderFiltration",
   "Eq.symm",
   "sup_eq_right",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "sup_of_le_right",
   "instLTNat",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma.match_2",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_12",
   "Ring.toSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.instWellFoundedGTInterval",
   "StrictMono",
   "HarderNarasimhan.impl.function_wrapper_prop1",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Nat.one_le_iff_ne_zero",
   "HarderNarasimhan.Resμ",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Set",
   "HarderNarasimhan.proposition_2_8",
   "right_eq_sup",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_10",
   "HPow.hPow",
   "lt_of_lt_of_le",
   "Nat.cast_add",
   "eq_self",
   "dite_cond_eq_true",
   "Monoid.toNatPow",
   "AddZeroClass.toAdd",
   "instHSub",
   "CompleteLattice.toCompleteSemilatticeInf",
   "sup_comm",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "CompleteLattice",
   "Nat.find_min'",
   "PartialOrder.toPreorder",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "GE.ge",
   "HarderNarasimhan.μmax",
   "Nat.findGreatest_is_greatest",
   "Semiring.toNonAssocSemiring",
   "Or",
   "Ne.bot_lt'",
   "PartialOrder",
   "eq_of_heq",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "CompleteLinearOrder",
   "Int.ofNat",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HarderNarasimhan.JordanHolderFiltration.strict_anti",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HarderNarasimhan.IsAttained",
   "Bot.bot",
   "Nat.lt_add_one",
   "lt_iff_le_and_ne",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Iff.of_eq",
   "le_bot_iff",
   "GE.ge.le",
   "Nat.cast",
   "lt_of_le_of_ne",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "zero_lt_iff",
   "Nat.find_le",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Subtype.le",
   "HarderNarasimhan.JordanHolderFiltration.first_eq_top",
   "Not",
   "List.nil",
   "HarderNarasimhan.impl.μA_eq_μmin",
   "Nat.findGreatest_le",
   "Nat.add_le_of_le_sub",
   "instHAdd",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_3",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_7",
   "HarderNarasimhan.μmax._proof_2",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "sInf_le",
   "instSubNat",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "lt_self_iff_false",
   "Linarith.natCast_nonneg",
   "OrderTop.toTop",
   "instAddNat",
   "not_strictMono_of_wellFoundedGT",
   "sorryAx",
   "Lean.Name.str",
   "Nat.instAddCommSemigroup",
   "Nat.findGreatest",
   "HarderNarasimhan.impl.function_wrapper_prop5",
   "False.elim",
   "SubNegMonoid.toSub",
   "letFun",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_13",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "Int.instAddGroup",
   "HarderNarasimhan.instAffineIntervalResμ",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Nat.recAux",
   "Nat.findGreatest_spec",
   "HarderNarasimhan.IsComparable",
   "lt_iff_le_not_le",
   "Prod",
   "Nat.find_spec",
   "HEq",
   "min_self",
   "HarderNarasimhan.JordanHolderFiltration.step_cond₁",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "setOf",
   "Linarith.add_lt_of_neg_of_le",
   "Ne.symm",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "HarderNarasimhan.WeakAscendingChainCondition.mk",
   "Int.instAddCommGroup",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_11",
   "le_inf",
   "contravariant_lt_of_covariant_le",
   "WellFoundedGT",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "propext",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Nat.le_add_of_sub_le",
   "Nat.lt_of_lt_of_le",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Max.max",
   "AddGroupWithOne.toAddGroup",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "inferInstance",
   "right_lt_sup",
   "neg_neg_of_pos",
   "bot_lt_top",
   "Nat.find_min",
   "Nat.cast_one",
   "Int.instCommRing",
   "Lattice.toSemilatticeSup",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Lean.Name",
   "Iff.mp",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "add_le_add_right",
   "And.intro",
   "HarderNarasimhan.seesaw_useful",
   "funext",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "forall_prop_domain_congr",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "HarderNarasimhan.TotIntvl",
   "Nat.decLt",
   "Decidable.byContradiction",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_37",
   "Nat.cast_zero",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "id",
   "ConditionallyCompleteLattice.toLattice",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "SemilatticeSup.toPartialOrder",
   "Mathlib.Meta.NormNum.isInt_add",
   "CompleteLattice.toCompleteSemilatticeSup",
   "eq_of_le_of_le",
   "HarderNarasimhan.FiniteTotalPayoff.mk",
   "Nat.instIsOrderedCancelAddMonoid",
   "OrderBot.toBot",
   "HarderNarasimhan.Affine",
   "HarderNarasimhan.Resμ._proof_19",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "bot_lt_iff_ne_bot",
   "True",
   "Mathlib.Tactic.PushNeg.not_lt_eq",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma.match_1",
   "_private.Mathlib.Algebra.Order.Monoid.Unbundled.Basic.0._proof_12",
   "Eq.casesOn",
   "HarderNarasimhan.instNontrivialInterval",
   "DistribLattice.toLattice",
   "Int.instAddMonoid",
   "Nat.le_add_right",
   "lt_sup_of_lt_left"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma",
  "constType":
  "∀ (n : ℕ) (ℒ : Type) (ntl : Nontrivial ℒ) (l : Lattice ℒ) (bo : BoundedOrder ℒ) (wacc : WellFoundedGT ℒ) (S : Type)\n  (clo : CompleteLinearOrder S) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.FiniteTotalPayoff μ →\n    HarderNarasimhan.SlopeLike μ →\n      HarderNarasimhan.Semistable μ →\n        HarderNarasimhan.WeakDescendingChainCondition' μ →\n          HarderNarasimhan.Affine μ →\n            (∃ JH, Nat.find ⋯ ≤ n) → ∀ (JH' : HarderNarasimhan.JordanHolderFiltration μ), Nat.find ⋯ ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Submodule.submoduleOf._at.HarderNarasimhan.impl.f2._spec_2",
   "Submodule.mkQ._at.HarderNarasimhan.impl.f2._spec_7",
   "_neutral"],
  "name": "HarderNarasimhan.impl.f2._rarg._cstage2",
  "constType":
  "_obj → _neutral → _neutral → _neutral → _obj → _obj → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "CompleteLattice.toBot",
   "BoundedOrder",
   "BoundedOrder.mk",
   "CompleteLattice.le_top",
   "CompleteLattice.bot_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderBot.mk",
   "CompleteLattice",
   "OrderTop.mk"],
  "name": "CompleteLattice.toBoundedOrder",
  "constType": "{α : Type u_1} → [inst : CompleteLattice α] → BoundedOrder α",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_right"],
  "name": "inf_le_right",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Setoid", "Setoid.r", "Quot"],
  "name": "Quotient",
  "constType": "{α : Sort u} → Setoid α → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "True",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instOfNatAtLeastTwo",
   "Preorder.toLT",
   "eq_true",
   "OfNat.ofNat",
   "Nat.ofNat_pos",
   "LT.lt",
   "IsOrderedRing",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Semiring.toNonAssocSemiring",
   "Nat.AtLeastTwo",
   "MulZeroClass.toZero",
   "PartialOrder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nontrivial",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring"],
  "name": "_private.Mathlib.Data.Nat.Cast.Order.Ring.0._proof_7",
  "constType":
  "∀ {α : Type u_3} [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] [Nontrivial α] {n : ℕ}\n  [inst_4 : n.AtLeastTwo], (0 < OfNat.ofNat n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient",
   "HasQuotient.mk",
   "Module",
   "Submodule.quotientRel",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "HasQuotient",
   "Submodule",
   "Ring.toSemiring",
   "Ring"],
  "name": "Submodule.hasQuotient",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : _root_.Module R M] → HasQuotient M (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₁.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n    HarderNarasimhan.WeakSlopeLike₁ μ",
  "constCategory": "Other"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Int.instCommRing", "CommRing.toRing", "inferInstance", "Int", "Ring"],
  "name": "Int.instRing",
  "constType": "Ring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Inter.inter",
   "Membership.mem",
   "Set.instInter",
   "Set.instMembership",
   "And.left"],
  "name": "Set.inter_subset_left",
  "constType": "∀ {α : Type u} {s t : Set α}, s ∩ t ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "CompleteLattice.le_sInf",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "CompleteLattice.toInfSet",
   "Set",
   "CompleteLattice.toLattice",
   "Membership.mem",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Set.instMembership",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_39",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (s : Set (HarderNarasimhan.DedekindMacNeilleCompletion α))\n  (a : HarderNarasimhan.DedekindMacNeilleCompletion α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["le_top",
   "True",
   "LE.le",
   "Top.top",
   "LE",
   "eq_true",
   "OrderTop",
   "Eq",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_11",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, (a ≤ ⊤) = True",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "IsNoetherianRing",
   "Module",
   "Nontrivial",
   "CommSemiring.toSemiring",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "CommRing",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration",
  "constType":
  "(R : Type) →\n  [inst : CommRing R] →\n    [IsNoetherianRing R] →\n      (M : Type) →\n        [Nontrivial M] → [inst_3 : AddCommGroup M] → [inst_4 : _root_.Module R M] → [Module.Finite R M] → Type",
  "constCategory": "Other"},
 {"references": ["Ord", "Ordering"],
  "name": "Ord.mk",
  "constType": "{α : Type u} → (α → α → Ordering) → Ord α",
  "constCategory": "Other"},
 {"references": ["IsWellFounded", "GT.gt", "LT"],
  "name": "WellFoundedGT",
  "constType": "(α : Type u_1) → [LT α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "not_lt",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_20",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.WeakSlopeLike₁",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references":
  ["SetLike.instPartialOrder",
   "PartialOrder.toPreorder",
   "SetLike.instMembership",
   "Module",
   "Submodule.instTop",
   "Membership.mem",
   "OrderTop",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "Preorder.toLE",
   "trivial",
   "Semiring",
   "OrderTop.mk"],
  "name": "Submodule.instOrderTop",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → OrderTop (Submodule R M)",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "cast",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.μBstar",
   "Nontrivial",
   "Lattice",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.NashEquilibrium.nash_eq",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.NashEquilibrium μ],\n  HarderNarasimhan.μAstar μ = HarderNarasimhan.μBstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "decidableLTOfDecidableLE",
   "DecidableLE",
   "DecidableLT",
   "Iff",
   "LE.mk",
   "id",
   "And",
   "Preorder.mk",
   "LT.mk"],
  "name":
  "HarderNarasimhan.TotallyOrderedRealVectorSpace.toDecidableLT._inherited_default",
  "constType":
  "{V : Type} →\n  (le lt : V → V → Prop) →\n    (∀ (a : V), le a a) →\n      (∀ (a b c : V), le a b → le b c → le a c) →\n        (∀ (a b : V), lt a b ↔ le a b ∧ ¬le b a) → DecidableLE V → DecidableLT V",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable", "Decidable.casesOn"],
  "name": "ite",
  "constType": "{α : Sort u} → (c : Prop) → [h : Decidable c] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "And",
   "Preorder.toLT",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.Resμ._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        (z : { p // p.1 < p.2 }) → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod",
   "LT.lt",
   "And.intro",
   "Subtype.prop",
   "le_of_lt",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instBoundedOrderInterval._proof_15",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {z : { p // p.1 < p.2 }}, (↑z).1 ≤ (↑z).1 ∧ (↑z).1 ≤ (↑z).2",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.instBoundedOrderInterval._proof_16",
   "Bot.mk",
   "Preorder.toLT",
   "Subtype.val",
   "BoundedOrder.mk",
   "Prod.fst",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "OrderBot.mk",
   "SemilatticeInf.toPartialOrder",
   "OrderTop.mk",
   "Lattice.toSemilatticeInf",
   "And",
   "HarderNarasimhan.instBoundedOrderInterval._proof_15",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "HarderNarasimhan.instBoundedOrderInterval._proof_13",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.instBoundedOrderInterval._proof_14",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.mk",
   "Subtype.mk"],
  "name": "HarderNarasimhan.instBoundedOrderInterval",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → BoundedOrder (HarderNarasimhan.Interval z)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "SetLike.instMembership",
   "Submonoid.instSetLike",
   "Membership.mem",
   "MulOneClass",
   "One.mk",
   "OfNat.ofNat",
   "Submonoid",
   "One.toOfNat1",
   "MulOneClass.toOne",
   "Submonoid.one_mem",
   "One",
   "Subtype.mk"],
  "name": "Submonoid.one",
  "constType":
  "{M : Type u_4} → [inst : MulOneClass M] → (S : Submonoid M) → One ↥S",
  "constCategory": "Definition"},
 {"references": ["Nat", "OfNat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Subtype",
   "Eq.trans",
   "OmegaCompletePartialOrder.toPartialOrder",
   "congrArg",
   "_private.Mathlib.Order.Basic.0._proof_34",
   "iff_self",
   "PartialOrder",
   "forall_congr",
   "Subtype.le",
   "Preorder.toLE",
   "Set.instLE",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "True",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "Set.Iic",
   "implies_true",
   "of_eq_true",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff",
   "LE.le",
   "_private.Mathlib.Order.Interval.Set.Basic.0._proof_11",
   "Subtype.mk"],
  "name": "HarderNarasimhan.coe'._proof_50",
  "constType":
  "∀ {α : Type} [inst : PartialOrder α]\n  (inj : ∀ (x : α), (HarderNarasimhan.DedekindMacNeilleClosureOperator α).IsClosed (Set.Iic x)) (a a_1 : α),\n  ⟨Set.Iic a, ⋯⟩ ≤ ⟨Set.Iic a_1, ⋯⟩ ↔ a ≤ a_1",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "OrderDual.instLT",
   "OrderDual.instTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instLE",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "OrderDual.instPreorder",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.h₂_dual_of_h₂",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1), μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n      (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) z ≤ (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨((↑z).1, ⊤), ⋯⟩ ∨\n        (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨((↑z).2, ⊤), hz⟩ ≤ (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨((↑z).1, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "IsIrrefl",
   "Preorder",
   "Preorder.toLT",
   "IsIrrefl.swap",
   "GT.gt",
   "instIsIrreflLt"],
  "name": "instIsIrreflGt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α], IsIrrefl α fun x1 x2 => x1 > x2",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le_trans", "Nat", "Nat.le_succ", "Nat.succ", "LE.le", "instLENat"],
  "name": "Nat.le_of_succ_le",
  "constType": "∀ {n m : ℕ}, n.succ ≤ m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Function.injective_surjInv",
   "Finite.of_injective",
   "Function.surjInv",
   "Finite",
   "Function.Surjective"],
  "name": "Finite.of_surjective",
  "constType":
  "∀ {α : Sort u_4} {β : Sort u_5} [Finite α] (f : α → β), Function.Surjective f → Finite β",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "HarderNarasimhan.InIntvl",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.ℒₛ._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (x : { p // HarderNarasimhan.InIntvl I p }),\n  (↑I).1 ≠ ↑x → ((↑I).1, ↑x).1 < ((↑I).1, ↑x).2",
  "constCategory": "Theorem"},
 {"references": ["And.intro", "And", "And.rec"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "DFunLike",
  "constType":
  "Sort u_1 → (α : outParam (Sort u_2)) → outParam (α → Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references": ["Prod"],
  "name": "Prod.mk",
  "constType": "{α : Type u} → {β : Type v} → α → β → α × β",
  "constCategory": "Other"},
 {"references":
  ["RingHom",
   "RingHomCompTriple.mk",
   "Eq.trans",
   "True",
   "RingHom.instFunLike",
   "DFunLike.coe",
   "RingHomCompTriple",
   "congrArg",
   "RingHom.ext",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "RingHom.id",
   "RingHom.comp_id",
   "RingHom.comp",
   "Eq",
   "Semiring"],
  "name": "RingHomCompTriple.ids",
  "constType":
  "∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ₁₂ : R₁ →+* R₂},\n  RingHomCompTriple (RingHom.id R₁) σ₁₂ σ₁₂",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Lattice",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty),\n  Exists.choose h₃ ∈ {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "Int.cast",
   "Int",
   "Ring"],
  "name": "Int.rawCast",
  "constType": "{α : Type u} → [Ring α] → ℤ → α",
  "constCategory": "Definition"},
 {"references":
  ["Set.Nonempty",
   "Set",
   "Set.not_nonempty_empty",
   "eq_false",
   "False",
   "Eq",
   "Set.instEmptyCollection",
   "EmptyCollection.emptyCollection"],
  "name": "_private.Mathlib.Data.Set.Basic.0._proof_26",
  "constType": "∀ {α : Type u}, ∅.Nonempty = False",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "AddRightStrictMono",
   "add_ne_add_left",
   "Add",
   "instHAdd",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "CovariantClass.elim",
   "Function.swap",
   "HAdd.hAdd",
   "LT.lt",
   "AddRightMono",
   "Iff.mpr",
   "PartialOrder",
   "LT.lt.ne",
   "LE.le",
   "IsRightCancelAdd",
   "Ne",
   "Preorder.toLE",
   "CovariantClass.mk",
   "LT.lt.le"],
  "name": "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [IsRightCancelAdd N] [inst_2 : PartialOrder N] [AddRightMono N], AddRightStrictMono N",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.id._at.HarderNarasimhan.impl.lift_quot._spec_1",
   "Submodule.comap._at.HarderNarasimhan.impl.lift_quot._spec_17",
   "_obj",
   "Submodule.map._at.HarderNarasimhan.impl.lift_quot._spec_18",
   "Submodule.mkQ._at.HarderNarasimhan.impl.lift_quot._spec_10",
   "Submodule.submoduleOf._at.HarderNarasimhan.impl.lift_quot._spec_4",
   "Submodule.subtype._at.HarderNarasimhan.impl.lift_quot._spec_2",
   "_neutral",
   "RingHom.id._at.HarderNarasimhan.impl.lift_quot._spec_9"],
  "name": "HarderNarasimhan.impl.lift_quot._rarg._cstage2",
  "constType":
  "_obj → _neutral → _neutral → _neutral → _obj → _obj → _neutral → _obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["AddMonoid", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "AddRightMono",
   "instHAdd",
   "Add",
   "LE.le",
   "LE",
   "Function.swap",
   "CovariantClass.elim"],
  "name": "add_le_add_right",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α] [i : AddRightMono α] {b c : α}, b ≤ c → ∀ (a : α), b + a ≤ c + a",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat.to_eq.match_1",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "Unit"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_eq",
  "constType":
  "∀ {α : Type u} [inst : AddMonoidWithOne α] {n : ℕ} {a a' : α}, Mathlib.Meta.NormNum.IsNat a n → ↑n = a' → a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HarderNarasimhan.WeakAscendingChainCondition.wacc",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.WeakAscendingChainCondition μ]\n  (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "AddMonoid.End.instSemiring",
   "Module",
   "RingHom.instFunLike",
   "AddCommMonoid.toAddMonoid",
   "RingHom.ker",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Module.annihilator._proof_29",
   "Ideal",
   "Module.toAddMonoidEnd",
   "AddMonoid.End",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Module.annihilator",
  "constType":
  "(R : Type u_1) → (M : Type u_2) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [_root_.Module R M] → Ideal R",
  "constCategory": "Definition"},
 {"references": ["NonUnitalSemiring", "Semiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.lt",
   "Nat.instMax",
   "instMinNat",
   "DecidableEq",
   "Nat.le_refl",
   "PartialOrder.mk",
   "LT.mk",
   "Nat.instLinearOrder._proof_3",
   "Nat.le",
   "Nat.le_trans",
   "DecidableLE",
   "DecidableLT",
   "LinearOrder",
   "Nat.decLe",
   "LinearOrder.mk",
   "instOrdNat",
   "Nat.le_antisymm",
   "Nat.decLt",
   "Nat",
   "Nat.instLinearOrder._proof_2",
   "Nat.instLinearOrder._proof_1",
   "LE.mk",
   "Nat.le_total",
   "inferInstance",
   "instDecidableEqNat",
   "Preorder.mk",
   "Nat.lt_iff_le_not_le"],
  "name": "Nat.instLinearOrder",
  "constType": "LinearOrder ℕ",
  "constCategory": "Definition"},
 {"references": ["Exists", "And", "Eq", "propext", "exists_eq_right"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_18",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["Inv", "InvOneClass"],
  "name": "InvOneClass.toInv",
  "constType": "{G : Type u_2} → [self : InvOneClass G] → Inv G",
  "constCategory": "Definition"},
 {"references": ["Neg"],
  "name": "Neg.neg",
  "constType": "{α : Type u} → [self : Neg α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.stableI",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.stable",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Module",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Semiring.toNonAssocSemiring",
   "Ideal",
   "Module.annihilator",
   "PrimeSpectrum.asIdeal",
   "Eq",
   "Preorder.toLE",
   "Semiring.toModule",
   "propext",
   "CommRing.toCommSemiring",
   "Module.mem_support_iff_of_finite",
   "Set",
   "Module.support",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup",
   "CommRing",
   "Set.instMembership",
   "PrimeSpectrum",
   "LE.le",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.exists_minimal_prime_contained_supp._proof_4",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  {p : PrimeSpectrum R} [Module.Finite R M], (p ∈ Module.support R M) = (Module.annihilator R M ≤ p.asIdeal)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Eq",
   "Set.instSingletonSet",
   "propext",
   "Set.instMembership"],
  "name": "HarderNarasimhan.impl.rmk4d14₂._proof_15",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "IsScalarTower",
   "Module",
   "AddCommGroup.toAddGroup",
   "Submodule.Quotient.instSMul'._proof_2",
   "SMulZeroClass.toSMul",
   "Submodule",
   "SMul",
   "MonoidWithZero.toMonoid",
   "Quotient.map'",
   "instHSMul",
   "AddGroup.toSubNegMonoid",
   "DistribSMul.toSMulZeroClass",
   "SMul.mk",
   "AddZeroClass.toZero",
   "Submodule.quotientRel",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Ring.toSemiring",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "HSMul.hSMul",
   "AddCommGroup.toAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "Ring"],
  "name": "Submodule.Quotient.instSMul'",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : _root_.Module R M] →\n          {S : Type u_3} →\n            [inst_3 : SMul S R] → [inst_4 : SMul S M] → [IsScalarTower S R M] → (P : Submodule R M) → SMul S (M ⧸ P)",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.SlopeLike",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.impl.thm4d21",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HarderNarasimhan.μmax",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.μmin",
   "List.TFAE",
   "HarderNarasimhan.Interval",
   "OrderBot.toBot",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "Eq",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "List.nil",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "And",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "HarderNarasimhan.instBoundedOrderInterval",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "HarderNarasimhan.instNontrivialInterval",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.theorem_4_21",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ →\n    HarderNarasimhan.WeakAscendingChainCondition μ →\n      HarderNarasimhan.WeakDescendingChainCondition μ →\n        [HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl,\n              HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl,\n              HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl,\n              HarderNarasimhan.NashEquilibrium μ].TFAE ∧\n          (HarderNarasimhan.Semistable μ → HarderNarasimhan.NashEquilibrium μ) ∧\n            ((∀ (x : ℒ) (hx : x ≠ ⊥),\n                HarderNarasimhan.WeakAscendingChainCondition (HarderNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n              HarderNarasimhan.NashEquilibrium μ → HarderNarasimhan.Semistable μ)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Classical.propDecidable",
   "eq_true",
   "ite_cond_eq_true",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Or",
   "IsTotal.total",
   "SemilatticeInf.toPartialOrder",
   "ClosureOperator.IsClosed",
   "CompleteLattice.toLattice",
   "LinearOrder",
   "_private.Mathlib.Order.Lattice.0._proof_20",
   "ite_cond_eq_false",
   "false_or",
   "Set.instCompleteAtomicBooleanAlgebra",
   "eq_false",
   "id",
   "Eq.mpr",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "SemilatticeInf.toMin",
   "Eq.mp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SemilatticeSup.toPartialOrder",
   "Subtype.decidableLE",
   "congrArg",
   "instDistribLatticeOfLinearOrder",
   "congr",
   "Classical.decRel",
   "Subtype.le",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Set.instLE",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "ite",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "HarderNarasimhan.instIsTotalDedekindMacNeilleCompletionLe",
   "eq_self",
   "DistribLattice.toLattice",
   "of_eq_true",
   "Min.min",
   "inf_of_le_left",
   "LE.le",
   "False",
   "dite",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name":
  "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_23",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α),\n  min a b = if a ≤ b then a else b",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.WeakSlopeLike₁.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₁.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakSlopeLike₁ μ → Sort u} →\n                ((wsl₁ :\n                      ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                        μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                    motive ⋯) →\n                  (t : HarderNarasimhan.WeakSlopeLike₁ μ) → motive t",
  "constCategory": "Other"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Preorder",
   "LE.le",
   "Preorder.toLT",
   "OrderEmbedding.lt_iff_lt",
   "Eq",
   "Preorder.toLE",
   "OrderEmbedding",
   "DFunLike.coe",
   "RelEmbedding.instFunLike",
   "propext"],
  "name": "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_12",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α ↪o β) {a b : α}, (f a < f b) = (a < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "SetLike.instMembership",
   "LinearMap.instFunLike",
   "Module",
   "Submodule.module",
   "Membership.mem",
   "LinearMap",
   "Submodule.submoduleOf._proof_14",
   "Submodule.subtype",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap",
   "Submodule.setLike",
   "RingHom.id",
   "Submodule.addCommMonoid",
   "Semiring"],
  "name": "Submodule.submoduleOf",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_5} →\n    [inst : Semiring R] →\n      [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → Submodule R M → (q : Submodule R M) → Submodule R ↥q",
  "constCategory": "Definition"},
 {"references":
  ["absurd",
   "Option.casesOn",
   "Option.none",
   "WithTop.top",
   "Eq.refl",
   "Option",
   "Top.top",
   "WithTop.some",
   "WithTop",
   "Ne",
   "Option.some",
   "Eq"],
  "name": "WithTop.untop.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : (x : WithTop α) → x ≠ ⊤ → Sort u_2) →\n    (x : WithTop α) → (x_1 : x ≠ ⊤) → ((x : α) → (x_2 : ↑x ≠ ⊤) → motive (some x) x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → Coe ({ p // p.1 < p.2 } → S) ({ p // p.1 < p.2 } → Sᵒᵈ)",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "CompleteLattice",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLattice.toTop",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "HarderNarasimhan.WeakDescendingChainCondition'.mk",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition'.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakDescendingChainCondition' μ → Sort u} →\n                ((wdcc' : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) → motive ⋯) →\n                  (t : HarderNarasimhan.WeakDescendingChainCondition' μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Subtype.mk_le_mk",
   "Subtype",
   "LE.le",
   "LE",
   "Subtype.mk",
   "Eq",
   "Subtype.le",
   "propext"],
  "name": "_private.HarderNarasimhan.DedekindMacNeilleCompletion.0._proof_18",
  "constType":
  "∀ {α : Type u_2} [inst : LE α] {p : α → Prop} {x y : α} {hx : p x} {hy : p y}, (⟨x, hx⟩ ≤ ⟨y, hy⟩) = (x ≤ y)",
  "constCategory": "Theorem"},
 {"references": ["SupSet", "CompleteSemilatticeSup"],
  "name": "CompleteSemilatticeSup.toSupSet",
  "constType": "{α : Type u_8} → [self : CompleteSemilatticeSup α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["PosSMulStrictMono",
   "PartialOrder.toPreorder",
   "strictMono_smul_left_of_pos",
   "PosSMulMono.of_pos",
   "Preorder.toLT",
   "SMulZeroClass.toSMul",
   "StrictMono.monotone",
   "SMulWithZero.toSMulZeroClass",
   "OfNat.ofNat",
   "PosSMulMono",
   "LT.lt",
   "PartialOrder",
   "HSMul.hSMul",
   "instHSMul",
   "Zero.toOfNat0",
   "Zero",
   "SMulWithZero"],
  "name": "PosSMulStrictMono.toPosSMulMono",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : PartialOrder α]\n  [inst_4 : PartialOrder β] [PosSMulStrictMono α β], PosSMulMono α β",
  "constCategory": "Theorem"},
 {"references": ["True", "imp_self", "Eq", "propext"],
  "name": "_private.Init.Core.0._proof_25",
  "constType": "∀ {a : Prop}, (a → a) = True",
  "constCategory": "Theorem"},
 {"references": ["Nonempty"],
  "name": "Nonempty.intro",
  "constType": "∀ {α : Sort u} (val : α), Nonempty α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Semiring.toModule",
   "Submodule",
   "Semiring"],
  "name": "Ideal",
  "constType": "(R : Type u) → [Semiring R] → Type u",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Nat",
   "Fin.val",
   "instOfNatNat",
   "instHAdd",
   "Nat.le_of_lt_succ",
   "LE.le",
   "Fin.is_lt",
   "Fin",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Fin.is_le",
  "constType": "∀ {n : ℕ} (i : Fin (n + 1)), ↑i ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "CompleteLattice.toLattice",
   "LinearOrder",
   "SemilatticeSup.toPartialOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "Preorder.le_refl",
   "LE.le",
   "Preorder.toLE",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_25",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a : HarderNarasimhan.DedekindMacNeilleCompletion α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._cstage1",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "FunLike",
   "Exists",
   "SetLike.instMembership",
   "RingHomSurjective",
   "SemilinearMapClass",
   "Module",
   "Submodule.map",
   "Membership.mem",
   "And",
   "DFunLike.coe",
   "Submodule",
   "Submodule.mem_map",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.lift_quot_middle._proof_17",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} [inst_6 : RingHomSurjective σ₁₂] {F : Type u_9} [inst_7 : FunLike F M M₂]\n  [inst_8 : SemilinearMapClass F σ₁₂ M M₂] {f : F} {p : Submodule R M} {x : M₂},\n  (x ∈ Submodule.map f p) = ∃ y ∈ p, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Subtype.lt",
   "Subtype.mk_lt_mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.GCongr.coe_lt_coe",
   "Subtype.prop",
   "Subtype.property",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "lt_iff_le_not_le",
   "LT.lt",
   "Prod",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk"],
  "name": "HarderNarasimhan.Resμ._proof_19",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (z : { p // p.1 < p.2 })\n  (p : { p // p.1 < p.2 }), ↑(↑p).1 < ↑(↑p).2",
  "constCategory": "Theorem"},
 {"references": ["LE", "Bot", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{α : Type u} → {inst : LE α} → [self : OrderBot α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "True",
   "AddZeroClass.toZero",
   "Eq.trans",
   "CommSemiring",
   "CommSemiring.toSemiring",
   "Mathlib.Tactic.Ring.cast_zero.match_1",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "OfNat.ofNat",
   "congrArg",
   "eq_self",
   "AddMonoidWithOne.toNatCast",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "MulZeroClass.toZero",
   "Nat.cast_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.cast_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R}, Mathlib.Meta.NormNum.IsNat a 0 → a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "PartialOrder.le_antisymm"],
  "name": "le_antisymm",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "SemilatticeSup.toPartialOrder",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Max.max",
   "le_sup_right",
   "SemilatticeSup.toMax",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HarderNarasimhan.Interval z), ↑b ≤ ↑a ⊔ ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "Set.subset_toFinset",
   "Finset",
   "HasSubset.Subset",
   "Set",
   "Set.toFinset",
   "Finset.toSet",
   "Finset.instHasSubset",
   "Eq",
   "Fintype",
   "propext",
   "Set.Elem"],
  "name": "HarderNarasimhan.impl.prop3d12p2._proof_5",
  "constType":
  "∀ {α : Type u_1} {t : Set α} {s : Finset α} [inst : Fintype ↑t], (s ⊆ t.toFinset) = (↑s ⊆ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.FiniteTotalPayoff.mk",
   "BoundedOrder.toOrderTop",
   "CompleteLattice.toTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.FiniteTotalPayoff.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S}, μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤ → HarderNarasimhan.FiniteTotalPayoff μ",
  "constCategory": "Definition"},
 {"references": ["LE.le", "DecidableRel", "LE"],
  "name": "DecidableLE",
  "constType": "(α : Type u) → [LE α] → Type (max 0 u)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "LE.le",
   "LE",
   "Subtype.coe_le_coe",
   "Eq",
   "Subtype.le",
   "Subtype.val",
   "propext"],
  "name": "_private.Mathlib.Order.Basic.0._proof_36",
  "constType":
  "∀ {α : Type u_2} [inst : LE α] {p : α → Prop} {x y : Subtype p}, (↑x ≤ ↑y) = (x ≤ y)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Omega.LinearCombo",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["CommSemiring", "Semiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "Submodule.instNontrivial",
   "Module",
   "HarderNarasimhan.μ",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "Nontrivial",
   "Submodule.completeLattice",
   "AddCommGroup.toAddCommMonoid",
   "inferInstance",
   "HarderNarasimhan.Convex",
   "HarderNarasimhan.S₀",
   "ConditionallyCompleteLattice.toLattice",
   "HarderNarasimhan.impl.prop3d11",
   "HarderNarasimhan.S",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Module.Finite"],
  "name": "HarderNarasimhan.proposition_3_11",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  HarderNarasimhan.Convex (HarderNarasimhan.μ R M)",
  "constCategory": "Theorem"},
 {"references": ["DecidableLE", "ite", "LE.mk", "id"],
  "name":
  "HarderNarasimhan.TotallyOrderedRealVectorSpace.min._inherited_default",
  "constType": "{V : Type} → (le : V → V → Prop) → DecidableLE V → V → V → V",
  "constCategory": "Definition"},
 {"references":
  ["Int.decLt",
   "LT.lt",
   "Lean.Omega.Constraint",
   "Bool",
   "Lean.Omega.Constraint.isImpossible.match_1",
   "Bool.false",
   "Int.instLTInt",
   "Decidable.decide",
   "Int"],
  "name": "Lean.Omega.Constraint.isImpossible",
  "constType": "Omega.Constraint → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.toSubMulAction",
   "SetLike.instMembership",
   "Subtype",
   "AddZeroClass.toZero",
   "Module",
   "IsScalarTower",
   "Membership.mem",
   "SubMulAction.isScalarTower'",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "Submodule",
   "Module.toDistribMulAction",
   "AddCommMonoid",
   "SMul",
   "Submodule.setLike",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "Submodule.smul",
   "Semiring",
   "AddMonoid.toAddZeroClass",
   "DistribSMul.toSMulZeroClass"],
  "name": "Submodule.isScalarTower'",
  "constType":
  "∀ {S : Type u'} {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {S' : Type u_1} [inst_2 : SMul S R] [inst_3 : SMul S M] [inst_4 : SMul S' R] [inst_5 : SMul S' M]\n  [inst_6 : SMul S S'] [inst_7 : IsScalarTower S' R M] [IsScalarTower S S' M] [inst_9 : IsScalarTower S R M],\n  IsScalarTower S S' ↥p",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "CompleteSemilatticeInf"],
  "name": "CompleteSemilatticeInf.toInfSet",
  "constType": "{α : Type u_8} → [self : CompleteSemilatticeInf α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "SubNegMonoid.toAddMonoid",
   "Real",
   "AddCommGroup.add_comm",
   "Module",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "Real.semiring"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.toModule",
  "constType":
  "{V : Type} → [self : HarderNarasimhan.TotallyOrderedRealVectorSpace V] → _root_.Module ℝ V",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod.casesOn",
   "And.intro",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "Nontrivial.mk",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "ne_of_lt",
   "le_of_lt",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Ne",
   "Subtype.casesOn",
   "Subtype.mk",
   "Subtype.coe_ne_coe"],
  "name": "HarderNarasimhan.instNontrivialInterval",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }},\n  Nontrivial (HarderNarasimhan.Interval z)",
  "constCategory": "Theorem"},
 {"references": ["Nat", "SizeOf"],
  "name": "SizeOf.sizeOf",
  "constType": "{α : Sort u} → [self : SizeOf α] → α → ℕ",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "AddMonoid"],
  "name": "SubNegMonoid.toAddMonoid",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → AddMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μA_DescendingChainCondition",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nat",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] →\n                    [h : HarderNarasimhan.μ_Admissible μ] → HarderNarasimhan.HarderNarasimhanFiltration μ → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint", "Lean.Omega.UpperBound", "Lean.Omega.LowerBound"],
  "name": "Lean.Omega.Constraint.mk",
  "constType": "Omega.LowerBound → Omega.UpperBound → Omega.Constraint",
  "constCategory": "Other"},
 {"references": ["SupSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toSupSet",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Max.max",
   "PartialOrder.toPreorder",
   "LT.lt.trans_le",
   "SemilatticeSup.toMax",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "SemilatticeSup",
   "le_sup_left"],
  "name": "lt_sup_of_lt_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c < a → c < a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "OrderDual",
   "OrderDual.toDual",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "DFunLike.coe",
   "Equiv",
   "OrderDual.ofDual",
   "PartialOrder",
   "Preorder.toLE",
   "Equiv.instFunLike",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "OmegaCompletePartialOrder",
   "OrderDual.instPreorder",
   "Preorder",
   "CompleteAtomicBooleanAlgebra",
   "lcProof",
   "GaloisConnection.closureOperator",
   "Set.instCompleteAtomicBooleanAlgebra",
   "upperBounds",
   "Iff",
   "lowerBounds",
   "LE.le",
   "CompleteLattice"],
  "name": "HarderNarasimhan.DedekindMacNeilleClosureOperator._cstage1",
  "constType": "(α : Type) → [PartialOrder α] → ClosureOperator (Set α)",
  "constCategory": "Definition"},
 {"references": ["NonAssocSemiring"],
  "name": "RingHom",
  "constType":
  "(α : Type u_5) → (β : Type u_6) → [NonAssocSemiring α] → [NonAssocSemiring β] → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["HarderNarasimhan.instLES₀",
   "Finset",
   "PartialOrder.toPreorder",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Singleton.singleton",
   "instDistribLatticeOfLinearOrder",
   "PrimeSpectrum.instPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lex'Order.Lex'Order_prop",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Exists.choose_spec",
   "CommSemiring.toSemiring",
   "And",
   "LinearOrder",
   "Finset.instHasSubset",
   "CommRing",
   "PrimeSpectrum",
   "LinearOrder.toPartialOrder",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "Finset.instSingleton",
   "HasSubset.Subset",
   "Iff",
   "LE.le",
   "HarderNarasimhan.S₀"],
  "name": "HarderNarasimhan.S₀_order",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R],\n  (∀ (A B : HarderNarasimhan.S₀ R), A ⊆ B → A ≤ B) ∧ ∀ (a b : LinearExtension (PrimeSpectrum R)), a ≤ b ↔ {a} ≤ {b}",
  "constCategory": "Theorem"},
 {"references": ["Inhabited"],
  "name": "Inhabited.mk",
  "constType": "{α : Sort u} → α → Inhabited α",
  "constCategory": "Other"},
 {"references": ["Subsingleton.allEq", "Subsingleton", "Eq"],
  "name": "Subsingleton.elim",
  "constType": "∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Submodule.hasQuotient",
   "Nat.find",
   "Subtype",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.Quotient.module",
   "Submodule.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "HarderNarasimhan.Coprimary",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "instLTNat",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "instHAdd",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "Submodule.addCommGroup",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "AddCommGroup",
   "CommRing",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "CommRing.toRing",
   "Nat",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "HarderNarasimhan.CoprimaryFiltration.fin_len",
   "Submodule.addCommMonoid",
   "Submodule.submoduleOf",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.piecewise_coprimary",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (self : HarderNarasimhan.CoprimaryFiltration R M),\n  ∀ n < Nat.find ⋯,\n    HarderNarasimhan.Coprimary R\n      (↥(self.filtration (n + 1)) ⧸ Submodule.submoduleOf (self.filtration n) (self.filtration (n + 1)))",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Subtype", "Subtype.exists", "Subtype.mk", "Eq", "propext"],
  "name": "HarderNarasimhan.impl.koqcl_iso._proof_12",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "instHAdd",
   "Nat.left_eq_add",
   "Eq",
   "OfNat.ofNat",
   "propext"],
  "name": "_private.Init.Data.Nat.Lemmas.0._proof_13",
  "constType": "∀ {a b : ℕ}, (a = a + b) = (b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable", "Classical.propDecidable._proof_3", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nat",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.JordanHolderFiltration.filtration",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLinearOrder S] →\n              {μ : { p // p.1 < p.2 } → S} → HarderNarasimhan.JordanHolderFiltration μ → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toOne",
   "MonoidWithZero.zero_mul",
   "MulZeroOneClass.mk",
   "Monoid.mul_one",
   "MulZeroOneClass",
   "MonoidWithZero",
   "Semigroup.toMul",
   "MulOneClass.mk",
   "MonoidWithZero.toMonoid",
   "Monoid.one_mul",
   "Monoid.toSemigroup",
   "MonoidWithZero.mul_zero",
   "MonoidWithZero.toZero"],
  "name": "MonoidWithZero.toMulZeroOneClass",
  "constType":
  "{M₀ : Type u} → [self : MonoidWithZero M₀] → MulZeroOneClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "PartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder"],
  "name": "HarderNarasimhan.DedekindMacNeilleCompletion",
  "constType": "(α : Type) → [PartialOrder α] → Type",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HarderNarasimhan.impl.dualμAstar_eq_μBstar",
   "Subtype.val",
   "DFunLike.coe",
   "Equiv",
   "Prod.fst",
   "OrderDual.ofDual",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "OrderDual.instLT",
   "HarderNarasimhan.μBstar",
   "OrderDual.instCompleteLattice",
   "OrderDual.instPartialOrder",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "OrderDual.instBoundedOrder",
   "CompleteLattice"],
  "name": "HarderNarasimhan.dualμAstar_eq_μBstar",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  OrderDual.ofDual\n    ((HarderNarasimhan.μAstar fun p => OrderDual.toDual (μ ⟨((↑p).2, (↑p).1), ⋯⟩)) = HarderNarasimhan.μBstar μ)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Equiv",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["IsScalarTower.left",
   "Module",
   "IsScalarTower",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "AddCommMonoid.toAddMonoid",
   "Monoid.toMulAction",
   "Ring.toSemiring",
   "MulAction.toSMul",
   "Module.toDistribMulAction",
   "MonoidWithZero.toMonoid",
   "AddCommGroup.toAddCommMonoid",
   "DistribMulAction.toMulAction",
   "Ring"],
  "name": "Submodule.Quotient.instSMul._proof_3",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M],\n  IsScalarTower R R M",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Injective.eq_iff",
   "Subtype.coe_injective",
   "Subtype",
   "Iff",
   "Eq",
   "Subtype.val"],
  "name": "Subtype.coe_inj",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, ↑a = ↑b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "instOfNatNat",
   "Eq",
   "OfNat.ofNat",
   "propext",
   "Nat.lt_one_iff"],
  "name": "_private.Init.Data.Nat.Basic.0._proof_16",
  "constType": "∀ {n : ℕ}, (n < 1) = (n = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["instNNRealSemiring",
   "Distrib.toAdd",
   "PartialOrder.toPreorder",
   "Real",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NNReal",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CanonicallyOrderedAdd",
   "Real.instRing",
   "instNNRealPartialOrder",
   "Real.instIsOrderedRing",
   "Semiring.toNonAssocSemiring",
   "Nonneg.canonicallyOrderedAdd",
   "Preorder.toLE",
   "Real.partialOrder"],
  "name": "NNReal.instCanonicallyOrderedAdd",
  "constType": "CanonicallyOrderedAdd NNReal",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Preorder.toLE",
   "GT.gt",
   "le_of_not_lt"],
  "name": "le_of_not_gt",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬a > b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_32",
   "CompleteLattice.toInfSet",
   "BiheytingAlgebra.toHNot",
   "Lattice.mk",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_38",
   "Lattice.inf",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "CompleteLinearOrder",
   "HeytingAlgebra.toOrderBot",
   "BiheytingAlgebra",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_34",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_47",
   "SemilatticeSup.sup",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_46",
   "LinearOrder",
   "LinearOrder.toOrd",
   "LinearOrder.toDecidableLT",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_44",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_36",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_31",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_33",
   "GeneralizedHeytingAlgebra.toHImp",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_39",
   "instDistribLatticeOfLinearOrder",
   "CompleteLinearOrder.mk",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_41",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_42",
   "OrderBot.toBot",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Preorder.toLE",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_30",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Lattice.toSemilatticeInf",
   "CompleteLattice.mk",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_43",
   "BiheytingAlgebra.toSDiff",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_45",
   "LinearOrder.toPartialOrder",
   "LinearOrder.toDecidableEq",
   "DistribLattice.toLattice",
   "LinearOrder.toDecidableLE",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_35",
   "SemilatticeSup.mk",
   "GeneralizedHeytingAlgebra.toLattice",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_37",
   "OrderTop.toTop",
   "HeytingAlgebra.toHasCompl",
   "LinearOrder.toBiheytingAlgebra",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "CompleteLattice",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_40"],
  "name": "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion",
  "constType":
  "{α : Type} → [inst : LinearOrder α] → CompleteLinearOrder (HarderNarasimhan.DedekindMacNeilleCompletion α)",
  "constCategory": "Definition"},
 {"references":
  ["IsNoetherian",
   "AddCommMonoid",
   "Module",
   "Submodule.instTop",
   "Top.top",
   "Module.Finite.mk",
   "IsNoetherian.noetherian",
   "Module.Finite",
   "Submodule",
   "Semiring"],
  "name": "Module.IsNoetherian.finite",
  "constType":
  "∀ (R : Type u_1) (M : Type u_2) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  [IsNoetherian R M], Module.Finite R M",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Ring.toNonAssocRing",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Preorder.toLT",
   "AddGroupWithOne.toAddMonoidWithOne",
   "SMulZeroClass.toSMul",
   "HarderNarasimhan.impl.quot_ntl",
   "AddMonoidWithOne.toAddMonoid",
   "instDistribSMul",
   "Submodule.Quotient.instSMul._proof_3",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Module.IsNoetherian.finite",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DistribSMul.toSMulZeroClass",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Submodule.addCommGroup",
   "isNoetherian_submodule'",
   "Iff.mpr",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "AddMonoid.toAddZeroClass",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "Module",
   "Module.Finite.quotient",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Submodule.nontrivial_iff",
   "isNoetherian_of_isNoetherianRing_of_finite",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "LT.lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.quot_ntl'",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] {N₁ N₂ : HarderNarasimhan.ℒ R M}\n  (hN : N₁ < N₂), Nontrivial (HarderNarasimhan.ℒ R (↥N₂ ⧸ Submodule.submoduleOf N₁ N₂))",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Subtype",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "And",
   "Subtype.partialOrder",
   "ClosureOperator",
   "Subtype.val",
   "Set.instMembership",
   "And.intro",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_8",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B C : T.Closeds), A ≤ B → A ≤ C → ∀ a ∈ ↑A, a ∈ ↑B ∧ a ∈ ↑C",
  "constCategory": "Theorem"},
 {"references": ["DFunLike"],
  "name": "FunLike",
  "constType":
  "Sort u_1 → Sort u_2 → Sort u_3 → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "HarderNarasimhan.S₂I",
   "HarderNarasimhan.S₁I",
   "And.intro",
   "False.elim",
   "Or",
   "HarderNarasimhan.S₁I._proof_1",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "not_lt_of_le",
   "Eq.symm",
   "IsTotal.total",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "eq_of_ge_of_not_gt",
   "Exists",
   "Exists.choose_spec",
   "And.right",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.IsComparable",
   "Set.instMembership",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Or.inr",
   "Subtype",
   "HarderNarasimhan.StI",
   "lt_of_le_of_ne",
   "Prod.fst",
   "le_rfl",
   "Subtype.prop",
   "Or.inl",
   "HarderNarasimhan.impl.prop2d6₃I",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Lattice.toSemilatticeInf",
   "Set",
   "Exists.choose",
   "LT.lt",
   "Or.casesOn",
   "IsTotal",
   "ne_of_lt",
   "le_of_lt",
   "HarderNarasimhan.μA",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d8₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.ConvexI I μ →\n    ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n        ∀ (z : ℒ) (hzI : HarderNarasimhan.InIntvl I z) (hz : (↑I).1 ≠ z),\n          HarderNarasimhan.IsAttained μ ⟨((↑I).1, z), ⋯⟩) →\n      ∀ (x : ℒ) (hxSt : x ∈ HarderNarasimhan.StI μ I) (y : ℒ),\n        HarderNarasimhan.InIntvl I y →\n          ∀ (hxy : x < y), HarderNarasimhan.μA μ ⟨((↑I).1, y), ⋯⟩ = HarderNarasimhan.μA μ ⟨(x, y), hxy⟩",
  "constCategory": "Theorem"},
 {"references":
  ["NeZero",
   "One.toOfNat1",
   "eq_false",
   "One",
   "False",
   "one_ne_zero",
   "Zero.toOfNat0",
   "Zero",
   "Eq",
   "OfNat.ofNat"],
  "name": "_private.Mathlib.Algebra.NeZero.0._proof_2",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [NeZero 1], (1 = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Units.instGroup",
   "Iff.mp",
   "SMulZeroClass.toSMul",
   "MonoidWithZero.toMulZeroOneClass",
   "NoZeroSMulDivisors",
   "Or",
   "GroupWithZero.toMonoidWithZero",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "Eq",
   "Group.toDivInvMonoid",
   "DistribMulAction",
   "Units",
   "DistribSMul.toSMulZeroClass",
   "Not",
   "AddZeroClass.toZero",
   "DistribMulAction.toDistribSMul",
   "Units.mk0",
   "AddMonoid",
   "GroupWithZero",
   "NoZeroSMulDivisors.mk",
   "OfNat.ofNat",
   "Classical.or_iff_not_imp_left",
   "smul_eq_zero_iff_eq",
   "Units.instDistribMulAction",
   "DivInvMonoid.toMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toZero",
   "Iff.mpr",
   "HSMul.hSMul",
   "AddMonoid.toAddZeroClass"],
  "name": "GroupWithZero.toNoZeroSMulDivisors",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : GroupWithZero R] [inst_1 : AddMonoid M] [inst_2 : DistribMulAction R M],\n  NoZeroSMulDivisors R M",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "HarderNarasimhan.impl.JHFil._proof_2",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Int.negOfNat",
   "Top.top",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "setOf",
   "HarderNarasimhan.Semistable",
   "Linarith.add_lt_of_neg_of_le",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Nat.instPreorder",
   "Prod.fst",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "instNatCastInt",
   "lt_of_not_ge",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Set",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "HarderNarasimhan.impl.JHFil",
   "Ne",
   "neg_neg_of_pos",
   "dite",
   "instHSub",
   "bot_lt_top",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLattice.toTop",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "Bot.bot",
   "Unit",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "HarderNarasimhan.impl.JHFil._proof_4",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "Subtype",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.impl.JHFil.match_1",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Exists.choose",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "instLENat",
   "OrderTop.toTop",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.impl.JHFil._sunfold",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [hacc : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_3 : CompleteLinearOrder S] →\n              (μ : { p // p.1 < p.2 } → S) →\n                μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤ →\n                  HarderNarasimhan.SlopeLike μ →\n                    HarderNarasimhan.Semistable μ →\n                      (∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.WeakSlopeLike₁.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₁.rec",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₁.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakSlopeLike₁ μ → Sort u} →\n                (t : HarderNarasimhan.WeakSlopeLike₁ μ) →\n                  ((wsl₁ :\n                        ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                          μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["AddSubsemigroup.carrier",
   "AddSubgroup.instSetLike._proof_69",
   "AddSubgroup",
   "SetLike.mk",
   "AddSubgroup.toAddSubmonoid",
   "SubNegMonoid.toAddMonoid",
   "AddZeroClass.toAdd",
   "AddGroup",
   "SetLike",
   "AddSubmonoid.toAddSubsemigroup",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.toAddZeroClass"],
  "name": "AddSubgroup.instSetLike",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → SetLike (AddSubgroup G) G",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "AddCommMonoid",
   "instHAdd",
   "AddMonoid.toAddSemigroup",
   "AddMonoid",
   "Eq",
   "AddSemigroup.toAdd"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddMonoid : AddMonoid M] → (∀ (a b : M), a + b = b + a) → AddCommMonoid M",
  "constCategory": "Other"},
 {"references": ["Inter"],
  "name": "Inter.inter._@.Mathlib.Data.Set.Operations._hyg.7",
  "constType": "{α : Type u} → [self : Inter α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.instLatticeInterval._proof_11",
   "Preorder.toLT",
   "Lattice.mk",
   "HarderNarasimhan.instLatticeInterval._proof_3",
   "Subtype.val",
   "Prod.fst",
   "PartialOrder.mk",
   "HarderNarasimhan.instLatticeInterval._proof_8",
   "HarderNarasimhan.Interval",
   "LT.mk",
   "Preorder.toLE",
   "HarderNarasimhan.instLatticeInterval._proof_7",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.instLatticeInterval._proof_9",
   "Not",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.instLatticeInterval._proof_6",
   "HarderNarasimhan.instLatticeInterval._proof_4",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.instLatticeInterval._proof_5",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.instLatticeInterval._proof_12",
   "HarderNarasimhan.instLatticeInterval._proof_1",
   "Min.min",
   "HarderNarasimhan.instLatticeInterval._proof_2",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.mk",
   "LE.le",
   "HarderNarasimhan.instLatticeInterval._proof_10",
   "SemilatticeSup.mk",
   "Subtype.mk",
   "Preorder.mk"],
  "name": "HarderNarasimhan.instLatticeInterval",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → Lattice (HarderNarasimhan.Interval z)",
  "constCategory": "Definition"},
 {"references": ["DivisionSemiring", "Semiring"],
  "name": "DivisionSemiring.toSemiring",
  "constType": "{K : Type u_2} → [self : DivisionSemiring K] → Semiring K",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Semistable.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.Semistable.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℒ) (hx : x ≠ ⊥), ¬HarderNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HarderNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩) →\n    HarderNarasimhan.Semistable μ",
  "constCategory": "Definition"},
 {"references":
  ["Set.inter_subset_right",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_5",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Inter.inter",
   "ClosureOperator",
   "Subtype.val",
   "DFunLike.coe",
   "Set.inter_subset_left",
   "ClosureOperator.monotone",
   "And.intro",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "Preorder.toLE",
   "Eq.rec",
   "Eq",
   "Set.instInter",
   "And.left",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "ClosureOperator.IsClosed.closure_eq",
   "Subtype.mk"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_6",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds) ⦃a : α⦄, a ∈ ↑⟨↑A ∩ ↑B, ⋯⟩ → a ∈ ↑A",
  "constCategory": "Theorem"},
 {"references":
  ["Nat", "Nat.succ", "Nat.le.refl", "LE.le", "Nat.le.step", "instLENat"],
  "name": "Nat.le_succ",
  "constType": "∀ (n : ℕ), n ≤ n.succ",
  "constCategory": "Theorem"},
 {"references":
  ["absurd", "Not", "False.elim", "False", "Eq", "propext", "Iff.intro"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references":
  ["SMulMemClass",
   "SMul",
   "SetLike.instMembership",
   "outParam",
   "HSMul.hSMul",
   "Membership.mem",
   "instHSMul",
   "SetLike"],
  "name": "SMulMemClass.smul_mem",
  "constType":
  "∀ {S : Type u_1} {R : outParam (Type u_2)} {M : Type u_3} {inst : SMul R M} {inst_1 : SetLike S M}\n  [self : SMulMemClass S R M] {s : S} (r : R) {m : M}, m ∈ s → r • m ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero",
   "Bot.mk",
   "Set",
   "Module",
   "Singleton.singleton",
   "Submodule.instBot._proof_1",
   "AddSubmonoid.mk",
   "AddCommMonoid.toAddMonoid",
   "Set.instSingletonSet",
   "Bot.bot",
   "OfNat.ofNat",
   "Submodule",
   "AddSubsemigroup.mk",
   "AddCommMonoid",
   "Submodule.instBot._proof_3",
   "AddZeroClass.toAdd",
   "AddSubmonoid",
   "Submodule.mk",
   "AddSubmonoid.instBot",
   "Bot",
   "Zero.toOfNat0",
   "Submodule.instBot._proof_2",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.instBot",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → Bot (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Eq",
   "Set.instSingletonSet",
   "Set.singleton_subset_iff",
   "propext",
   "Set.instMembership"],
  "name": "HarderNarasimhan.impl.prop3d12p2._proof_6",
  "constType": "∀ {α : Type u} {a : α} {s : Set α}, ({a} ⊆ s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "HarderNarasimhan.WeakAscendingChainCondition.mk",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.WeakAscendingChainCondition.rec",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HarderNarasimhan.WeakAscendingChainCondition.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakAscendingChainCondition μ → Sort u} →\n                (t : HarderNarasimhan.WeakAscendingChainCondition μ) →\n                  ((wacc : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Module",
   "RingHom.instFunLike",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "AddHom.toFun",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Eq",
   "DistribSMul.toSMulZeroClass",
   "AddZeroClass.toZero",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "LinearMap",
   "Module.toDistribMulAction",
   "AddCommMonoid.toAddCommSemigroup",
   "HSMul.hSMul",
   "AddHom",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "LinearMap.mk",
  "constType":
  "{R : Type u_14} →\n  {S : Type u_15} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        {σ : R →+* S} →\n          {M : Type u_16} →\n            {M₂ : Type u_17} →\n              [inst_2 : AddCommMonoid M] →\n                [inst_3 : AddCommMonoid M₂] →\n                  [inst_4 : _root_.Module R M] →\n                    [inst_5 : _root_.Module S M₂] →\n                      (toAddHom : M →ₙ+ M₂) →\n                        (∀ (m : R) (x : M), toAddHom.toFun (m • x) = σ m • toAddHom.toFun x) → M →ₛₗ[σ] M₂",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_1",
   "CompleteLattice.instOmegaCompletePartialOrder._rarg"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["GetElem", "outParam"],
  "name": "GetElem.getElem",
  "constType":
  "{coll : Type u} →\n  {idx : Type v} →\n    {elem : outParam (Type w)} →\n      {valid : outParam (coll → idx → Prop)} →\n        [self : GetElem coll idx elem valid] → (xs : coll) → (i : idx) → valid xs i → elem",
  "constCategory": "Definition"},
 {"references":
  ["instLTNat",
   "Nat.le_sub_one_of_lt",
   "OfNat.ofNat",
   "Iff.intro",
   "LT.lt",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "Iff",
   "LE.le",
   "HSub.hSub",
   "instHSub",
   "instLENat",
   "Nat.lt_of_le_sub_one"],
  "name": "Nat.le_sub_one_iff_lt",
  "constType": "∀ {m n : ℕ}, 0 < m → (n ≤ m - 1 ↔ n < m)",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.ext",
   "Semiring.toNonAssocSemiring",
   "SetLike.instMembership",
   "Ideal",
   "Submodule.setLike",
   "Iff",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Membership.mem",
   "Eq",
   "Semiring.toModule",
   "Semiring"],
  "name": "Ideal.ext",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] {I J : Ideal α}, (∀ (x : α), x ∈ I ↔ x ∈ J) → I = J",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Exists.intro",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "le_rfl",
   "And.intro",
   "Subtype.prop",
   "HarderNarasimhan.μmin",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.μmax._proof_2",
   "sInf_le",
   "LT.lt",
   "Prod",
   "ne_of_lt",
   "le_of_lt",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "le_sSup",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.impl.rmk4d10₀",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.μmin μ I ≤ μ I ∧ μ I ≤ HarderNarasimhan.μmax μ I",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "DFunLike.mk",
   "EquivLike.toFunLike._proof_1",
   "EquivLike.coe",
   "EquivLike"],
  "name": "EquivLike.toFunLike",
  "constType":
  "{E : Sort u_1} → {α : Sort u_3} → {β : Sort u_4} → [EquivLike E α β] → FunLike E α β",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommGroupWithZero.zpow_zero'",
   "CommGroupWithZero.mk",
   "LinearOrderedCommGroupWithZero.toDiv",
   "LinearOrderedCommGroupWithZero.zpow_neg'",
   "LinearOrderedCommGroupWithZero.inv_zero",
   "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
   "LinearOrderedCommGroupWithZero.toInv",
   "LinearOrderedCommGroupWithZero.div_eq_mul_inv",
   "CommGroupWithZero",
   "LinearOrderedCommGroupWithZero.zpow_succ'",
   "LinearOrderedCommGroupWithZero.mul_inv_cancel",
   "LinearOrderedCommGroupWithZero",
   "LinearOrderedCommGroupWithZero.zpow",
   "LinearOrderedCommGroupWithZero.toNontrivial",
   "LinearOrderedCommMonoidWithZero.toCommMonoidWithZero"],
  "name": "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommGroupWithZero α] → CommGroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "GT.gt",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Eq.symm",
   "Int.instLEInt",
   "Lean.Omega.tidy_sat",
   "HarderNarasimhan.JordanHolderFiltration",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "Int.add_one_le_of_lt",
   "List.cons",
   "Bool.true",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Bot.bot",
   "Int.instNegInt",
   "Prod",
   "instDecidableEqBool",
   "Nat",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Lean.Omega.Constraint.addEquality_sat",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Bool",
   "Subtype",
   "Nat.cast",
   "Lean.Omega.Constraint.combine_sat'",
   "Option.some",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Prod.fst",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "instNatCastInt",
   "List.nil",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "Int.ofNat_nonneg",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Option.none",
   "instSubNat",
   "LE.le",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Ne",
   "Lean.Omega.Constraint.mk",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "instHSub",
   "instLENat"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_8",
  "constType":
  "∀ (n : ℕ) (ℒ : Type) (ntl : Nontrivial ℒ) (l : Lattice ℒ) (bo : BoundedOrder ℒ) (wacc : WellFoundedGT ℒ) (S : Type)\n  (clo : CompleteLinearOrder S) (μ : { p // p.1 < p.2 } → S) (JHy JHx : HarderNarasimhan.JordanHolderFiltration μ),\n  Nat.find ⋯ ≠ 0 → ¬Nat.find ⋯ = 1 → ¬0 < Nat.find ⋯ - 1 → False",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.not_imp_symm", "Decidable"],
  "name": "Not.decidable_imp_symm",
  "constType": "∀ {a b : Prop} [Decidable a], (¬a → b) → ¬b → a",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "True",
   "Eq.trans",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "OfNat.ofNat",
   "congrArg",
   "Ring.toAddCommGroup",
   "eq_self",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NegZeroClass.toNeg",
   "of_eq_true",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NegZeroClass.toZero",
   "Zero.toOfNat0",
   "neg_zero",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_zero",
  "constType": "∀ {R : Type u_2} [inst : Ring R], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "ClosureOperator",
   "Set.iUnion",
   "DFunLike.coe",
   "Subtype.val",
   "Set.instMembership",
   "ClosureOperator.instFunLike",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "ClosureOperator.isClosed_closure"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_9",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds), T.IsClosed (T (⋃ a ∈ 𝒮, ↑a))",
  "constCategory": "Theorem"},
 {"references":
  ["Ord",
   "LinearOrder.compare_eq_compareOfLessAndEq._autoParam",
   "PartialOrder.toPreorder",
   "DecidableLE",
   "Ord.compare",
   "ite",
   "DecidableLT",
   "DecidableEq",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.max_def._autoParam",
   "Min",
   "compareOfLessAndEq",
   "Ordering",
   "LinearOrder.min_def._autoParam",
   "Max.max",
   "Or",
   "Min.min",
   "PartialOrder",
   "LE.le",
   "autoParam",
   "Eq",
   "Max",
   "Preorder.toLE"],
  "name": "LinearOrder.mk",
  "constType":
  "{α : Type u_2} →\n  [toPartialOrder : PartialOrder α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (toDecidableLE : DecidableLE α) →\n              (toDecidableEq : DecidableEq α) →\n                (toDecidableLT : DecidableLT α) →\n                  autoParam (∀ (a b : α), a ⊓ b = if a ≤ b then a else b) LinearOrder.min_def._autoParam →\n                    autoParam (∀ (a b : α), a ⊔ b = if a ≤ b then b else a) LinearOrder.max_def._autoParam →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b)\n                          LinearOrder.compare_eq_compareOfLessAndEq._autoParam →\n                        LinearOrder α",
  "constCategory": "Other"},
 {"references":
  ["Subtype.exists.match_1",
   "Exists",
   "Subtype",
   "Iff",
   "Exists.intro",
   "Subtype.mk",
   "Subtype.exists.match_2",
   "Iff.intro"],
  "name": "Subtype.exists",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) ↔ ∃ a, ∃ (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.hasQuotient",
   "Submodule.Quotient.mk",
   "SetLike.instMembership",
   "HasQuotient.Quotient",
   "Module",
   "Membership.mem",
   "Submodule.Quotient.instZeroQuotient",
   "AddCommGroup",
   "Submodule.Quotient.mk_eq_zero",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "Submodule",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "Ring"],
  "name": "_private.Mathlib.LinearAlgebra.Quotient.Defs.0._proof_1",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} {x : M} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), (Submodule.Quotient.mk x = 0) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.SlopeLike.rec",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.SlopeLike.mk",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.SlopeLike.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.SlopeLike μ → Sort u} →\n                (t : HarderNarasimhan.SlopeLike μ) →\n                  ((slopelike :\n                        ∀ (x y z : ℒ) (h : x < y ∧ y < z),\n                          (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n                            (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n                              (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n                                (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Singleton.singleton",
   "Iff",
   "Membership.mem",
   "forall_eq",
   "Set.instSingletonSet",
   "Set.instMembership"],
  "name": "Set.singleton_subset_iff",
  "constType": "∀ {α : Type u} {a : α} {s : Set α}, {a} ⊆ s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "Eq.propIntro",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "HarderNarasimhan.HarderNarasimhanFiltration.noConfusion",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "HEq",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "Eq.casesOn",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.mk.injEq",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (filtration : ℕ → ℒ)\n  (monotone : Monotone filtration) (first_eq_bot : filtration 0 = ⊥) (fin_len : ∃ n, filtration n = ⊤)\n  (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j)\n  (piecewise_semistable :\n    ∀ (i : ℕ) (h : i < Nat.find fin_len),\n      HarderNarasimhan.Semistable (HarderNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ))\n  (μA_pseudo_strict_anti :\n    ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n      ¬HarderNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n          HarderNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩)\n  (filtration_1 : ℕ → ℒ) (monotone_1 : Monotone filtration_1) (first_eq_bot_1 : filtration_1 0 = ⊥)\n  (fin_len_1 : ∃ n, filtration_1 n = ⊤)\n  (strict_mono_1 : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len_1 → filtration_1 i < filtration_1 j)\n  (piecewise_semistable_1 :\n    ∀ (i : ℕ) (h : i < Nat.find fin_len_1),\n      HarderNarasimhan.Semistable (HarderNarasimhan.Resμ ⟨(filtration_1 i, filtration_1 (i + 1)), ⋯⟩ μ))\n  (μA_pseudo_strict_anti_1 :\n    ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len_1),\n      ¬HarderNarasimhan.μA μ ⟨(filtration_1 i, filtration_1 (i + 1)), ⋯⟩ ≤\n          HarderNarasimhan.μA μ ⟨(filtration_1 (i + 1), filtration_1 (i + 2)), ⋯⟩),\n  ({ filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot, fin_len := fin_len,\n        strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n        μA_pseudo_strict_anti := μA_pseudo_strict_anti } =\n      { filtration := filtration_1, monotone := monotone_1, first_eq_bot := first_eq_bot_1, fin_len := fin_len_1,\n        strict_mono := strict_mono_1, piecewise_semistable := piecewise_semistable_1,\n        μA_pseudo_strict_anti := μA_pseudo_strict_anti_1 }) =\n    (filtration = filtration_1)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "CommRing.toCommSemiring",
   "IsNoetherianRing",
   "PartialOrder",
   "HarderNarasimhan.instLinearOrderS₀",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.S₀",
   "CommRing"],
  "name": "HarderNarasimhan.instPartialOrderS₀",
  "constType":
  "{R : Type} → [inst : CommRing R] → [inst_1 : IsNoetherianRing R] → PartialOrder (HarderNarasimhan.S₀ R)",
  "constCategory": "Definition"},
 {"references":
  ["PUnit.unit",
   "Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "OfNat.ofNat",
   "Unit"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq.match_1._cstage1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((k : ℕ) → motive k.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "HarderNarasimhan.impl.JHFil._proof_2",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Nat.brecOn",
   "Prod.snd",
   "Ring.toSemiring",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "HarderNarasimhan.impl.JHFil._proof_3",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Int.negOfNat",
   "Top.top",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "setOf",
   "HarderNarasimhan.Semistable",
   "Linarith.add_lt_of_neg_of_le",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Nat.instPreorder",
   "Prod.fst",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "instNatCastInt",
   "lt_of_not_ge",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Set",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "Nat.below",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Ne",
   "neg_neg_of_pos",
   "dite",
   "instHSub",
   "bot_lt_top",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "GT.gt",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLattice.toTop",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "Bot.bot",
   "Unit",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "Subtype",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.impl.JHFil.match_1",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Exists.choose",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Nat.succ",
   "Int.instSemiring",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "instLENat",
   "OrderTop.toTop",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.impl.JHFil",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [hacc : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_3 : CompleteLinearOrder S] →\n              (μ : { p // p.1 < p.2 } → S) →\n                μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤ →\n                  HarderNarasimhan.SlopeLike μ →\n                    HarderNarasimhan.Semistable μ →\n                      (∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.CoprimaryFiltration.rec",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "SizeOf",
   "Set.instMembership",
   "Nat",
   "Submodule.instBot",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "SizeOf.sizeOf",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "instSizeOfDefault",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration._sizeOf_1",
  "constType":
  "{R : Type} →\n  {inst : CommRing R} →\n    {inst_1 : IsNoetherianRing R} →\n      {M : Type} →\n        {inst_2 : Nontrivial M} →\n          {inst_3 : AddCommGroup M} →\n            {inst_4 : _root_.Module R M} →\n              {inst_5 : Module.Finite R M} → [SizeOf R] → [SizeOf M] → HarderNarasimhan.CoprimaryFiltration R M → ℕ",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "le_of_eq", "Preorder.toLE", "Eq"],
  "name": "Eq.le",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "RingHom",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "LinearMap.instFunLike",
   "Module",
   "LinearMap.comp",
   "Eq",
   "LinearMap",
   "DFunLike.coe",
   "RingHomCompTriple",
   "Semiring"],
  "name": "LinearMap.comp_apply",
  "constType":
  "∀ {R₁ : Type u_2} {R₂ : Type u_3} {R₃ : Type u_4} {M₁ : Type u_9} {M₂ : Type u_10} {M₃ : Type u_11} [inst : Semiring R₁]\n  [inst_1 : Semiring R₂] [inst_2 : Semiring R₃] [inst_3 : AddCommMonoid M₁] [inst_4 : AddCommMonoid M₂]\n  [inst_5 : AddCommMonoid M₃] {module_M₁ : _root_.Module R₁ M₁} {module_M₂ : _root_.Module R₂ M₂}\n  {module_M₃ : _root_.Module R₃ M₃} {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃}\n  [inst_6 : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] (f : M₂ →ₛₗ[σ₂₃] M₃) (g : M₁ →ₛₗ[σ₁₂] M₂) (x : M₁), (f ∘ₛₗ g) x = f (g x)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "And.right",
   "Preorder.toLT",
   "And",
   "Prod.snd",
   "lt_of_le_of_ne",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.InIntvl",
   "PartialOrder",
   "LE.le",
   "Ne",
   "Preorder.toLE",
   "And.left"],
  "name": "HarderNarasimhan.μA._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (I : { p // p.1 < p.2 }) (a : ℒ),\n  HarderNarasimhan.InIntvl I a ∧ a ≠ (↑I).2 → (a, (↑I).2).1 < (a, (↑I).2).2",
  "constCategory": "Theorem"},
 {"references": ["Ord", "Ordering"],
  "name": "Ord.compare",
  "constType": "{α : Type u} → [self : Ord α] → α → α → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero",
   "MonoidWithZero.mk",
   "CommMonoidWithZero.mul_zero",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero.toZero",
   "CommMonoidWithZero.toCommMonoid",
   "CommMonoidWithZero.zero_mul",
   "MonoidWithZero"],
  "name": "CommMonoidWithZero.toMonoidWithZero",
  "constType":
  "{M₀ : Type u_2} → [self : CommMonoidWithZero M₀] → MonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Nat.rawCast",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat"],
  "name": "Mathlib.Meta.NormNum.IsNat.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] (n : ℕ), Mathlib.Meta.NormNum.IsNat n.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "sup_le",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "inf_le_left",
   "ConditionallyCompleteLattice.toLattice",
   "setOf",
   "inf_le_right",
   "Or.inr",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "lt_of_le_of_ne",
   "Prod.fst",
   "Or.inl",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.impl.prop2d8₀I",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Lattice.toSemilatticeInf",
   "le_sInf_iff",
   "Set",
   "Or.casesOn",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "Max.max",
   "Min.min",
   "HarderNarasimhan.μA",
   "LE.le",
   "SemilatticeSup.toMax",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "lt_sup_of_lt_left"],
  "name": "HarderNarasimhan.impl.prop2d8₁I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HarderNarasimhan.InIntvl I y →\n            ∀ (u : ℒ),\n              HarderNarasimhan.InIntvl I u →\n                ∀ (h : u < x ∧ u < y),\n                  HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ⊓ HarderNarasimhan.μA μ ⟨(u, y), ⋯⟩ ≤\n                    HarderNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.rawCast",
   "Int",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.IsInt.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : Ring α] (n : ℤ), Mathlib.Meta.NormNum.IsInt n.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionCommMonoid",
   "DivisionMonoid.inv_eq_of_mul",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.toCancelCommMonoidWithZero._proof_12",
   "CommGroupWithZero.zpow_succ'",
   "CommMonoidWithZero.toCommMonoid",
   "CommGroupWithZero.toDiv",
   "CommGroupWithZero.zpow_neg'",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero",
   "DivisionCommMonoid.mk",
   "DivInvMonoid.mk",
   "CommGroupWithZero.toInv",
   "DivisionMonoid.mul_inv_rev",
   "DivisionMonoid",
   "DivisionMonoid.inv_inv",
   "DivisionMonoid.mk",
   "CommGroupWithZero.div_eq_mul_inv",
   "CommGroupWithZero.zpow_zero'",
   "CommGroupWithZero.toGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GroupWithZero.toDivisionMonoid"],
  "name": "CommGroupWithZero.toDivisionCommMonoid",
  "constType":
  "{G₀ : Type u_3} → [CommGroupWithZero G₀] → DivisionCommMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["Nonneg.one",
   "Subtype",
   "PartialOrder.toPreorder",
   "Nonneg.coe_one",
   "Subtype.val",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Preorder.toLE",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "SemilatticeInf.toPartialOrder",
   "Nonneg.semifield._proof_13",
   "Lattice.toSemilatticeInf",
   "IsStrictOrderedRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toSemiring",
   "OfNat.ofNat",
   "DistribLattice.toLattice",
   "One.toOfNat1",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoidWithOne.toOne",
   "LE.le",
   "Semifield",
   "IsStrictOrderedRing.toZeroLEOneClass"],
  "name": "Nonneg.semifield._proof_16",
  "constType":
  "∀ {α : Type u_1} [inst : Semifield α] [inst_1 : LinearOrder α] [inst_2 : IsStrictOrderedRing α], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "AddCommMonoid",
   "SetLike.coe",
   "HasSubset.Subset",
   "Submodule.instInfSet",
   "Submodule.setLike",
   "Set",
   "Module",
   "InfSet.sInf",
   "setOf",
   "Submodule",
   "Semiring"],
  "name": "Submodule.span",
  "constType":
  "(R : Type u_1) →\n  {M : Type u_4} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → Set M → Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["And.intro",
   "Nat",
   "Iff.mpr",
   "LE.le",
   "And",
   "instLEFin",
   "Fin",
   "Fin.le_antisymm_iff",
   "Eq"],
  "name": "Fin.le_antisymm",
  "constType": "∀ {n : ℕ} {x y : Fin n}, x ≤ y → y ≤ x → x = y",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "AddZeroClass.toZero",
   "LocalizedModule",
   "Submonoid.instSetLike",
   "Module",
   "Membership.mem",
   "CommSemiring",
   "CommSemiring.toSemiring",
   "MulZeroOneClass.toMulOneClass",
   "AddCommMonoid.toAddMonoid",
   "LocalizedModule.mk",
   "Submonoid.one",
   "OfNat.ofNat",
   "Submonoid",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "One.toOfNat1",
   "Zero.mk",
   "Zero.toOfNat0",
   "Zero",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddMonoid.toAddZeroClass"],
  "name": "LocalizedModule.instZero",
  "constType":
  "{R : Type u} →\n  [inst : CommSemiring R] →\n    {S : Submonoid R} →\n      {M : Type v} → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → Zero (LocalizedModule S M)",
  "constCategory": "Definition"},
 {"references":
  ["FunLike",
   "DFunLike.mk",
   "RelEmbedding.toEmbedding",
   "Function.Embedding.toFun",
   "RelEmbedding",
   "RelEmbedding.instFunLike._proof_5"],
  "name": "RelEmbedding.instFunLike",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → FunLike (r ↪r s) α β",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "Set.Elem",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ._proof_3",
   "Exists",
   "SetLike.instMembership",
   "Submodule.addCommGroup",
   "PrimeSpectrum.mk",
   "Prod.snd",
   "Fintype",
   "Set.instMembership",
   "Prod",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "setOf",
   "Submodule.submoduleOf",
   "Set.Finite.fintype",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Prod.fst",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "HarderNarasimhan._μ",
   "Eq",
   "CommRing.toCommSemiring",
   "LinearExtension",
   "Set",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "PrimeSpectrum",
   "LT.lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "HarderNarasimhan._μ._proof_2",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] → {I : { z // z.1 < z.2 }} → Fintype ↑(HarderNarasimhan._μ R M I)",
  "constCategory": "Definition"},
 {"references": ["rfl", "funext", "Eq.rec", "Eq"],
  "name": "forall_congr",
  "constType":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references": ["Top", "CompleteLattice"],
  "name": "CompleteLattice.toTop",
  "constType": "{α : Type u_8} → [self : CompleteLattice α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["Semifield.toCommSemiring",
   "Semifield.zpow_neg'",
   "CommSemiring.toSemiring",
   "Semifield.mul_inv_cancel",
   "Semifield.toDiv",
   "Semifield.nnqsmul_def",
   "Semifield.div_eq_mul_inv",
   "Semifield.toInv",
   "Semifield.inv_zero",
   "DivisionSemiring",
   "Semifield.nnqsmul",
   "Semifield.toNNRatCast",
   "DivisionSemiring.mk",
   "Semifield.zpow_zero'",
   "Semifield.zpow",
   "Semifield.toNontrivial",
   "Semifield",
   "Semifield.zpow_succ'",
   "Semifield.nnratCast_def"],
  "name": "Semifield.toDivisionSemiring",
  "constType": "{K : Type u_2} → [self : Semifield K] → DivisionSemiring K",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.S₁I",
   "HarderNarasimhan.S₁I._proof_1",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.μA",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.S₁I.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (x : ℒ)\n  (hxI : HarderNarasimhan.InIntvl I x) (hx : (↑I).1 ≠ x),\n  HarderNarasimhan.S₁I μ I x hxI hx =\n    ∀ (y : ℒ) (hyI : HarderNarasimhan.InIntvl I y) (hy : (↑I).1 ≠ y),\n      ¬HarderNarasimhan.μA μ ⟨((↑I).1, y), ⋯⟩ > HarderNarasimhan.μA μ ⟨((↑I).1, x), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Lattice.inf_le_left",
   "SemilatticeSup.toPartialOrder",
   "Lattice.inf",
   "Lattice.le_inf",
   "GeneralizedHeytingAlgebra.toHImp",
   "Min.min",
   "Iff",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "Preorder.toLE",
   "HImp.himp",
   "SemilatticeInf.mk",
   "GeneralizedHeytingAlgebra.toLattice"],
  "name": "GeneralizedHeytingAlgebra.le_himp_iff",
  "constType":
  "∀ {α : Type u_4} [self : GeneralizedHeytingAlgebra α] (a b c : α), a ≤ b ⇨ c ↔ a ⊓ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instPartialOrder",
   "PartialOrder.toPreorder",
   "Module",
   "Membership.mem",
   "Iff.mp",
   "AddCommMonoid.toAddMonoid",
   "Iff.intro",
   "Submodule",
   "AddCommMonoid",
   "Eq.symm",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "Submodule.instOrderBot",
   "Eq",
   "Eq.rec",
   "Preorder.toLE",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Bot.bot",
   "eq_bot_iff",
   "OfNat.ofNat",
   "Submodule.setLike",
   "Iff",
   "Iff.mpr",
   "LE.le",
   "Submodule.instBot",
   "Submodule.mem_bot",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.eq_bot_iff",
  "constType":
  "∀ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), p = ⊥ ↔ ∀ x ∈ p, x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection.closureOperator._at.HarderNarasimhan.DedekindMacNeilleClosureOperator._spec_1",
   "_obj",
   "_neutral"],
  "name": "HarderNarasimhan.DedekindMacNeilleClosureOperator._cstage2",
  "constType": "_neutral → _obj → _neutral",
  "constCategory": "Definition"},
 {"references": ["Not", "False.elim", "Eq.mp", "False", "Eq"],
  "name": "of_eq_false",
  "constType": "∀ {p : Prop}, p = False → ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "SubNegMonoid.zsmul_succ'._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Real",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Exists", "exists_and_right", "And", "Eq", "propext"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_17",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, p x ∧ b) = ((∃ x, p x) ∧ b)",
  "constCategory": "Theorem"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name": "HarderNarasimhan.TotIntvl._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "LE.le",
   "Lattice",
   "SemilatticeSup.toPartialOrder",
   "Lattice.inf",
   "Preorder.toLE"],
  "name": "Lattice.le_inf",
  "constType":
  "∀ {α : Type u} [self : Lattice α] (a b c : α), a ≤ b → a ≤ c → a ≤ Lattice.inf b c",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "HarderNarasimhan.CoprimaryFiltration._sizeOf_inst",
   "LinearMap",
   "Bot.bot",
   "SizeOf",
   "Set.instMembership",
   "Nat",
   "Eq.refl",
   "Submodule.instBot",
   "Nontrivial",
   "HarderNarasimhan.CoprimaryFiltration.mk",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "HarderNarasimhan.CoprimaryFiltration",
   "instOfNatNat",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "SizeOf.sizeOf",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "instSizeOfDefault",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.mk.sizeOf_spec",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] [inst_6 : SizeOf R]\n  [inst_7 : SizeOf M] (filtration : ℕ → HarderNarasimhan.ℒ R M) (monotone : Monotone filtration)\n  (first_eq_bot : filtration 0 = ⊥) (fin_len : ∃ n, filtration n = ⊤)\n  (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j)\n  (piecewise_coprimary :\n    ∀ n < Nat.find fin_len,\n      HarderNarasimhan.Coprimary R (↥(filtration (n + 1)) ⧸ Submodule.submoduleOf (filtration n) (filtration (n + 1))))\n  (strict_mono_associated_prime :\n    ∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len),\n      { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }),\n  sizeOf\n      { filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot, fin_len := fin_len,\n        strict_mono := strict_mono, piecewise_coprimary := piecewise_coprimary,\n        strict_mono_associated_prime := strict_mono_associated_prime } =\n    1 + sizeOf first_eq_bot + sizeOf fin_len",
  "constCategory": "Theorem"},
 {"references":
  ["associatedPrimes",
   "CommRing.toCommSemiring",
   "Module",
   "Set",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "AddCommGroup",
   "CommRing",
   "HarderNarasimhan.Coprimary.mk",
   "Set.instMembership",
   "HarderNarasimhan.Coprimary.rec",
   "IsNoetherianRing",
   "HarderNarasimhan.Coprimary",
   "Ideal",
   "AddCommGroup.toAddCommMonoid",
   "ExistsUnique"],
  "name": "HarderNarasimhan.Coprimary.recOn",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : AddCommGroup M] →\n          [inst_3 : _root_.Module R M] →\n            {motive : HarderNarasimhan.Coprimary R M → Sort u} →\n              (t : HarderNarasimhan.Coprimary R M) →\n                ((coprimary : ∃! p, p ∈ associatedPrimes R M) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "AddZeroClass.toZero",
   "AddZeroClass.toAdd",
   "AddZeroClass",
   "instHAdd",
   "Zero.toOfNat0",
   "Eq",
   "OfNat.ofNat",
   "AddZeroClass.zero_add"],
  "name": "zero_add",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references": ["_obj", "HarderNarasimhan.Resμ._rarg", "_neutral"],
  "name":
  "HarderNarasimhan.instCoeForallSubtypeProdLtFstSndForallIntervalOfCompleteLattice._cstage2",
  "constType":
  "_neutral → _neutral → _obj → _obj → _obj → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Option",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Submodule.instBot",
   "Nontrivial",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "HarderNarasimhan.CoprimaryFiltration",
   "instOfNatNat",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Submodule.instTop",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.mk",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] →\n                (filtration : ℕ → HarderNarasimhan.ℒ R M) →\n                  Monotone filtration →\n                    filtration 0 = ⊥ →\n                      (fin_len : ∃ n, filtration n = ⊤) →\n                        (∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                          (piecewise_coprimary :\n                              ∀ n < Nat.find fin_len,\n                                HarderNarasimhan.Coprimary R\n                                  (↥(filtration (n + 1)) ⧸ Submodule.submoduleOf (filtration n) (filtration (n + 1)))) →\n                            (∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len),\n                                { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }) →\n                              HarderNarasimhan.CoprimaryFiltration R M",
  "constCategory": "Other"},
 {"references": ["SemilatticeInf", "SemilatticeInf.inf", "Min", "Min.mk"],
  "name": "SemilatticeInf.toMin",
  "constType": "{α : Type u} → [SemilatticeInf α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Set.range_subset_iff",
   "Set",
   "Eq.mp",
   "Membership.mem",
   "Set.Infinite",
   "Set.range",
   "Set.instMembership",
   "congrArg",
   "Set.instHasSubset",
   "Set.infinite_range_of_injective",
   "HasSubset.Subset",
   "Set.Infinite.mono",
   "Eq.symm",
   "Infinite",
   "propext",
   "Function.Injective"],
  "name": "Set.infinite_of_injective_forall_mem",
  "constType":
  "∀ {α : Type u} {β : Type v} [Infinite α] {s : Set β} {f : α → β},\n  Function.Injective f → (∀ (x : α), f x ∈ s) → s.Infinite",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "HarderNarasimhan.SlopeLike",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.impl.prop4d8",
   "Preorder.toLT",
   "GT.gt",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Semiring.toNonAssocSemiring",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "NonUnitalNonAssocSemiring.toDistrib",
   "And.right",
   "NNReal",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "Nontrivial",
   "Lattice",
   "AddCommGroup.toAddCommMonoid",
   "NegZeroClass.toZero",
   "instNNRealSemiring",
   "instNNRealZero",
   "Subtype",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "Prod.fst",
   "instDistribLatticeOfLinearOrder",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Zero.toOfNat0",
   "Eq",
   "Preorder.toLE",
   "Distrib.toAdd",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "OfNat.ofNat",
   "HarderNarasimhan.μQuotient",
   "HAdd.hAdd",
   "LT.lt",
   "DistribLattice.toLattice",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Subtype.mk",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.proposition_4_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {V : Type}\n  [inst_3 : HarderNarasimhan.TotallyOrderedRealVectorSpace V] [Nontrivial V] (r : { p // p.1 < p.2 } → NNReal)\n  (d : { p // p.1 < p.2 } → V),\n  (∀ (x y z : ℒ) (h : x < y ∧ y < z),\n      d ⟨(x, z), ⋯⟩ = d ⟨(x, y), ⋯⟩ + d ⟨(y, z), ⋯⟩ ∧ r ⟨(x, z), ⋯⟩ = r ⟨(x, y), ⋯⟩ + r ⟨(y, z), ⋯⟩) →\n    (∀ (x y : ℒ) (h : x < y), r ⟨(x, y), h⟩ = 0 → d ⟨(x, y), h⟩ > 0) →\n      HarderNarasimhan.SlopeLike (HarderNarasimhan.μQuotient r d)",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "HarderNarasimhan.impl.prop2d6₁I",
   "Preorder.toLT",
   "HarderNarasimhan.impl.prop2d6₀",
   "Prod.fst",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq",
   "Eq.rec",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "inf_eq_left",
   "LT.lt",
   "Prod",
   "le_of_lt",
   "Min.min",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.μA",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop2d6₂I₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HarderNarasimhan.InIntvl I y →\n            ∀ (z : ℒ),\n              HarderNarasimhan.InIntvl I z →\n                ∀ (h : x < y ∧ y < z),\n                  HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩ < HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ →\n                    HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∧\n                      HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Decidable"],
  "name": "DecidablePred",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["DecidableLT",
   "DecidableEq",
   "id",
   "LT.mk",
   "compareOfLessAndEq",
   "Ordering"],
  "name":
  "HarderNarasimhan.TotallyOrderedRealVectorSpace.compare._inherited_default",
  "constType":
  "{V : Type} → (lt : V → V → Prop) → DecidableEq V → DecidableLT V → V → V → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["Not", "Bool", "Decidable", "Bool.false", "Decidable.casesOn", "Bool.true"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) → [h : Decidable p] → Bool",
  "constCategory": "Definition"},
 {"references": ["Exists", "Set", "Eq", "setOf"],
  "name": "Set.range",
  "constType": "{α : Type u} → {ι : Sort u_1} → (ι → α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Or.inr",
   "Decidable",
   "Eq.mpr_not",
   "Decidable.em",
   "Eq.mpr_prop",
   "congrArg",
   "Or.casesOn",
   "dif_pos",
   "Or",
   "Or.inl",
   "Eq.refl",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "dif_neg",
   "Eq.rec",
   "Eq",
   "dite"],
  "name": "dite_congr",
  "constType":
  "∀ {b c : Prop} {α : Sort u_1} {x : Decidable b} [inst : Decidable c] {x_1 : b → α} {u : c → α} {y : ¬b → α} {v : ¬c → α}\n  (h₁ : b = c), (∀ (h : c), x_1 ⋯ = u h) → (∀ (h : ¬c), y ⋯ = v h) → dite b x_1 y = dite c u v",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.neg",
   "Function.Injective.eq_iff'",
   "SubNegZeroMonoid.toNegZeroClass",
   "OfNat.ofNat",
   "SubtractionMonoid.toInvolutiveNeg",
   "NegZeroClass.toNeg",
   "Iff",
   "NegZeroClass.toZero",
   "neg_injective",
   "Zero.toOfNat0",
   "InvolutiveNeg.toNeg",
   "neg_zero",
   "Eq"],
  "name": "neg_eq_zero",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] {a : α}, -a = 0 ↔ a = 0",
  "constCategory": "Theorem"},
 {"references": ["OrderDual", "Nontrivial"],
  "name": "OrderDual.instNontrivial",
  "constType": "∀ {α : Type u_1} [h : Nontrivial α], Nontrivial αᵒᵈ",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakSlopeLike₂.mk",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₂.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakSlopeLike₂ μ → Sort u} →\n                ((wsl₂ :\n                      ∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n                        μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n                    motive ⋯) →\n                  (t : HarderNarasimhan.WeakSlopeLike₂ μ) → motive t",
  "constCategory": "Other"},
 {"references": ["Lean.Omega.Coeffs", "List", "Int"],
  "name": "Lean.Omega.Coeffs.ofList",
  "constType": "List ℤ → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "HarderNarasimhan.HarderNarasimhanFiltration.noConfusion",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.mk.inj",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HarderNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HarderNarasimhan.Convex μ} {h : HarderNarasimhan.μ_Admissible μ} {filtration : ℕ → ℒ}\n  {monotone : Monotone filtration} {first_eq_bot : filtration 0 = ⊥} {fin_len : ∃ n, filtration n = ⊤}\n  {strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j}\n  {piecewise_semistable :\n    ∀ (i : ℕ) (h : i < Nat.find fin_len),\n      HarderNarasimhan.Semistable (HarderNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)}\n  {μA_pseudo_strict_anti :\n    ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n      ¬HarderNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n          HarderNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩}\n  {filtration_1 : ℕ → ℒ} {monotone_1 : Monotone filtration_1} {first_eq_bot_1 : filtration_1 0 = ⊥}\n  {fin_len_1 : ∃ n, filtration_1 n = ⊤}\n  {strict_mono_1 : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len_1 → filtration_1 i < filtration_1 j}\n  {piecewise_semistable_1 :\n    ∀ (i : ℕ) (h : i < Nat.find fin_len_1),\n      HarderNarasimhan.Semistable (HarderNarasimhan.Resμ ⟨(filtration_1 i, filtration_1 (i + 1)), ⋯⟩ μ)}\n  {μA_pseudo_strict_anti_1 :\n    ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len_1),\n      ¬HarderNarasimhan.μA μ ⟨(filtration_1 i, filtration_1 (i + 1)), ⋯⟩ ≤\n          HarderNarasimhan.μA μ ⟨(filtration_1 (i + 1), filtration_1 (i + 2)), ⋯⟩},\n  { filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot, fin_len := fin_len,\n        strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n        μA_pseudo_strict_anti := μA_pseudo_strict_anti } =\n      { filtration := filtration_1, monotone := monotone_1, first_eq_bot := first_eq_bot_1, fin_len := fin_len_1,\n        strict_mono := strict_mono_1, piecewise_semistable := piecewise_semistable_1,\n        μA_pseudo_strict_anti := μA_pseudo_strict_anti_1 } →\n    filtration = filtration_1",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.mk",
   "Monoid.one_mul",
   "MulOneClass",
   "Monoid.toOne",
   "Monoid",
   "Monoid.mul_one",
   "Monoid.toSemigroup",
   "Semigroup.toMul"],
  "name": "Monoid.toMulOneClass",
  "constType": "{M : Type u} → [self : Monoid M] → MulOneClass M",
  "constCategory": "Definition"},
 {"references": ["HarderNarasimhan.μmin._rarg", "_obj", "_neutral"],
  "name": "HarderNarasimhan.μmin._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommSemigroup.add_comm",
   "AddCommSemigroup",
   "AddCommMagma.mk",
   "AddSemigroup.toAdd"],
  "name": "AddCommSemigroup.toAddCommMagma",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddCommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "BoundedOrder",
   "subsingleton_of_bot_eq_top",
   "Bot.bot",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "not_subsingleton",
   "PartialOrder",
   "Nontrivial",
   "Top.top",
   "Ne",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop"],
  "name": "bot_ne_top",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : BoundedOrder α] [Nontrivial α], ⊥ ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "instAddNat",
   "HAdd.hAdd",
   "instLTNat",
   "Nat",
   "instOfNatNat",
   "instHAdd",
   "LE.le",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Nat.lt_of_add_one_le",
  "constType": "∀ {n m : ℕ}, n + 1 ≤ m → n < m",
  "constCategory": "Theorem"},
 {"references":
  ["instNNRealSemiring",
   "instNNRealZero",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "smul_lt_smul_of_pos_left",
   "Preorder.toLT",
   "NNReal.toReal",
   "NNReal.coe_pos",
   "instNNRealPartialOrder",
   "MulAction.toSMul",
   "Real.instLT",
   "MonoidWithZero.toMonoid",
   "NNReal.instMulActionOfReal",
   "Zero.toOfNat0",
   "PosSMulStrictMono",
   "PosSMulStrictMono.mk",
   "Real",
   "NNReal",
   "Semiring.toMonoidWithZero",
   "OfNat.ofNat",
   "LT.lt",
   "Preorder",
   "Real.instZero",
   "MulAction",
   "Real.instMonoid",
   "Iff.mpr"],
  "name": "NNReal.instPosSMulStrictMono",
  "constType":
  "∀ {α : Type u_2} [inst : Preorder α] [inst_1 : MulAction ℝ α] [PosSMulStrictMono ℝ α], PosSMulStrictMono NNReal α",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "Preorder.toLT",
   "Iff.mp",
   "sup_le",
   "HarderNarasimhan.μmax",
   "le_sup_right",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "le_sup_left",
   "Prod",
   "HarderNarasimhan.impl.lem2d4₂I",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "Or.inr",
   "SemilatticeInf.toMin",
   "Subtype",
   "not_le_of_lt",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "Prod.fst",
   "congrArg",
   "le_inf",
   "Or.inl",
   "HarderNarasimhan.impl.lem2d4₁",
   "Preorder.toLE",
   "Eq",
   "sup_le_iff",
   "propext",
   "inf_lt_left",
   "Not",
   "not_and_or",
   "Lattice.toSemilatticeInf",
   "LT.lt",
   "Or.casesOn",
   "Max.max",
   "le_of_lt",
   "HarderNarasimhan.μA",
   "Min.min",
   "SemilatticeSup.toMax",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop2d8₀I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HarderNarasimhan.InIntvl I y →\n            ∀ (u : ℒ) (h : u < x ∧ u < y) (w : ℒ),\n              HarderNarasimhan.InIntvl I w →\n                ∀ (hw : u ≤ w ∧ w < x ⊔ y),\n                  HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HarderNarasimhan.μmax μ ⟨(w, x ⊔ y), ⋯⟩ ∨\n                    HarderNarasimhan.μA μ ⟨(u, y), ⋯⟩ ≤ HarderNarasimhan.μmax μ ⟨(w, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "SupSet.sSup",
   "Set",
   "CompleteLattice.toLattice",
   "LE.le",
   "Membership.mem",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteLattice",
   "Set.instMembership"],
  "name": "CompleteLattice.le_sSup",
  "constType":
  "∀ {α : Type u_8} [self : CompleteLattice α] (s : Set α), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references": ["CompleteAtomicBooleanAlgebra", "CompleteLattice"],
  "name": "CompleteAtomicBooleanAlgebra.toCompleteLattice",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "HarderNarasimhan.JordanHolderFiltration",
   "Int.instLTInt",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.mk",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLinearOrder S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                (filtration : ℕ → ℒ) →\n                  Antitone filtration →\n                    (fin_len : ∃ N, filtration N = ⊥) →\n                      (strict_anti : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration j < filtration i) →\n                        filtration 0 = ⊤ →\n                          (∀ (k : ℕ) (hk : k < Nat.find fin_len),\n                              μ ⟨(filtration (k + 1), filtration k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩) →\n                            (∀ (i : ℕ) (hi : i < Nat.find fin_len) (z : ℒ) (h' : filtration (i + 1) < z),\n                                z < filtration i →\n                                  μ ⟨(filtration (i + 1), z), h'⟩ < μ ⟨(filtration (i + 1), filtration i), ⋯⟩) →\n                              HarderNarasimhan.JordanHolderFiltration μ",
  "constCategory": "Other"},
 {"references":
  ["Setoid",
   "Module",
   "AddCommGroup.toAddGroup",
   "AddCommGroup.toAddCommMonoid",
   "QuotientAddGroup.leftRel",
   "AddCommGroup",
   "Submodule.toAddSubgroup",
   "Submodule",
   "Ring.toSemiring",
   "Ring"],
  "name": "Submodule.quotientRel",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} → [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : _root_.Module R M] → Submodule R M → Setoid M",
  "constCategory": "Definition"},
 {"references":
  ["Nat.sub",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Unit",
   "Nat",
   "instSubNat",
   "Nat.sub_le_sub_right.match_1",
   "instOfNatNat",
   "Nat.succ",
   "LE.le",
   "Nat.below",
   "HSub.hSub",
   "Nat.pred_le_pred",
   "instHSub",
   "instLENat"],
  "name": "Nat.sub_le_sub_right",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∀ (k : ℕ), n - k ≤ m - k",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "Subtype",
   "PartialOrder.toPreorder",
   "le_trans",
   "Preorder.toLT",
   "sup_le",
   "Subtype.val",
   "Prod.fst",
   "And.intro",
   "Subtype.prop",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "le_sup_left",
   "LT.lt",
   "Prod",
   "Max.max",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HarderNarasimhan.Interval z), (↑z).1 ≤ ↑a ⊔ ↑b ∧ ↑a ⊔ ↑b ≤ (↑z).2",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "RingHomSurjective",
   "RingHom.id",
   "CommSemiring.toSemiring",
   "CommRing",
   "RingHomSurjective.ids"],
  "name": "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_7",
  "constType":
  "∀ {R : Type} [inst : CommRing R], RingHomSurjective (RingHom.id R)",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.rec", "Eq"],
  "name": "Eq.mpr_prop",
  "constType": "∀ {p q : Prop}, p = q → q → p",
  "constCategory": "Theorem"},
 {"references":
  ["InfSet",
   "PartialOrder.toPreorder",
   "Bot.mk",
   "Membership.mem",
   "Lattice.mk",
   "InfSet.mk",
   "Set.iUnion",
   "Set.iInter",
   "Subtype.val",
   "PartialOrder",
   "Bot",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_12",
   "Set.instUnion",
   "Set.instInter",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
   "ClosureOperator.IsClosed",
   "Inter.inter._@.Mathlib.Data.Set.Operations._hyg.7",
   "And",
   "OmegaCompletePartialOrder",
   "Set.instMembership",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Lattice",
   "Top.mk",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_5",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Union.union._@.Mathlib.Data.Set.Operations._hyg.4",
   "SupSet.mk",
   "Subtype.partialOrder",
   "ClosureOperator",
   "EmptyCollection.emptyCollection._@.Mathlib.Data.Set.Operations._hyg.16",
   "Set.instEmptyCollection",
   "DFunLike.coe",
   "ClosureOperator.instFunLike",
   "SemilatticeSup",
   "Preorder.toLE",
   "True",
   "CompleteLattice.mk",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_9",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Top",
   "Set.univ",
   "lcProof",
   "CompleteAtomicBooleanAlgebra",
   "ClosureOperator.Closeds",
   "SupSet",
   "LE.le",
   "SemilatticeSup.mk",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_16",
   "Subtype.mk",
   "CompleteLattice"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._cstage1",
  "constType":
  "{α : Type} → [PartialOrder α] → (T : ClosureOperator (Set α)) → CompleteLattice T.Closeds",
  "constCategory": "Definition"},
 {"references": ["OfNat", "OfNat.mk", "One.one", "One"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toAddCommGroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NegZeroClass.toNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Neg.neg",
   "Eq.refl",
   "Eq.symm",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Eq.ndrec",
   "Eq",
   "SubNegZeroMonoid.toNegZeroClass",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_congr",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a a' b : R}, a = a' → -a' = b → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "LE.le",
   "And",
   "Iff.mp",
   "Preorder.toLT",
   "Preorder.toLE",
   "lt_iff_le_not_le",
   "And.left"],
  "name": "le_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "LinearMap.ker",
   "AddZeroClass.toZero",
   "SemilinearMapClass",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "OfNat.ofNat",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "LinearMap.mem_ker",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_3",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {τ₁₂ : R →+* R₂} {F : Type u_11} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F τ₁₂ M M₂] {f : F} {y : M},\n  (y ∈ LinearMap.ker f) = (f y = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Or.inr",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "lt_of_le_of_ne",
   "GE.ge",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "LinearOrder.toDecidableEq",
   "Or",
   "Or.inl",
   "Preorder.toLE",
   "dite",
   "Eq",
   "lt_of_not_ge"],
  "name": "eq_or_lt_of_not_lt",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬a < b → a = b ∨ b < a",
  "constCategory": "Theorem"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{α : Sort u} → {p : α → Prop} → (val : α) → p val → Subtype p",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "Eq.ndrec",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Eq.refl",
   "Nontrivial",
   "Submodule.instBot",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "HarderNarasimhan.CoprimaryFiltration.casesOn",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite",
   "HarderNarasimhan.CoprimaryFiltration.noConfusionType"],
  "name": "HarderNarasimhan.CoprimaryFiltration.noConfusion",
  "constType":
  "{R : Type} →\n  {inst : CommRing R} →\n    {inst_1 : IsNoetherianRing R} →\n      {M : Type} →\n        {inst_2 : Nontrivial M} →\n          {inst_3 : AddCommGroup M} →\n            {inst_4 : _root_.Module R M} →\n              {inst_5 : Module.Finite R M} →\n                {P : Sort u} →\n                  {v1 v2 : HarderNarasimhan.CoprimaryFiltration R M} →\n                    v1 = v2 → HarderNarasimhan.CoprimaryFiltration.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Bot"],
  "name": "Bot.mk",
  "constType": "{α : Type u_1} → α → Bot α",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "CompleteLattice"],
  "name": "CompleteLattice.toInfSet",
  "constType": "{α : Type u_8} → [self : CompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Nat", "Fin.val", "Decidable", "Fin", "instLTFin", "Nat.decLt"],
  "name": "Fin.decLt",
  "constType": "{n : ℕ} → (a b : Fin n) → Decidable (a < b)",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "Module",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "AddHom",
   "LinearMap",
   "Semiring"],
  "name": "LinearMap.toAddHom",
  "constType":
  "{R : Type u_14} →\n  {S : Type u_15} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        {σ : R →+* S} →\n          {M : Type u_16} →\n            {M₂ : Type u_17} →\n              [inst_2 : AddCommMonoid M] →\n                [inst_3 : AddCommMonoid M₂] →\n                  [inst_4 : _root_.Module R M] → [inst_5 : _root_.Module S M₂] → (M →ₛₗ[σ] M₂) → M →ₙ+ M₂",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Iff.rfl",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Iff",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HarderNarasimhan.Interval z), ↑a ≤ ↑b ∧ ¬↑b ≤ ↑a ↔ ↑a ≤ ↑b ∧ ¬↑b ≤ ↑a",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "setOf", "Set.instMembership"],
  "name": "Membership.mem.out",
  "constType": "∀ {α : Type u} {p : α → Prop} {a : α}, a ∈ {x | p x} → p a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "GT.gt",
   "GE.ge",
   "Eq.symm",
   "Int.instLEInt",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nat.lt_of_not_le",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Bool",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Option.some",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Int.instAdd",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_15",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (n : ℕ),\n  n + 1 > Nat.find hffin → ¬n ≥ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "OrderDual",
   "sup_assoc",
   "Min.min",
   "OrderDual.instSemilatticeSup",
   "Eq"],
  "name": "inf_assoc",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a b c : α), a ⊓ b ⊓ c = a ⊓ (b ⊓ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1",
   "Mathlib.Meta.NormNum.IsInt",
   "AddGroupWithOne.toIntCast",
   "Int.rawCast",
   "Eq",
   "Int.cast",
   "Ring",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
  "constType":
  "∀ {α : Type u} {a : α} {n : ℤ} [inst : Ring α], Mathlib.Meta.NormNum.IsInt a n → a = n.rawCast",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.mk",
   "AddCommGroup.add_comm",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "SubNegMonoid.toAddMonoid",
   "NonUnitalNonAssocRing.zero_mul",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.left_distrib"],
  "name": "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup.le_sup_right",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "le_sup_right",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "GT.gt",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Eq.symm",
   "Int.instLEInt",
   "Lean.Omega.tidy_sat",
   "HarderNarasimhan.JordanHolderFiltration",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "CompleteLinearOrder",
   "Int.add_one_le_of_lt",
   "List.cons",
   "Bool.true",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Bot.bot",
   "Int.instNegInt",
   "Prod",
   "instDecidableEqBool",
   "Nat",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Lean.Omega.Constraint.addEquality_sat",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Bool",
   "Subtype",
   "Nat.cast",
   "Lean.Omega.Constraint.combine_sat'",
   "Option.some",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Prod.fst",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "instNatCastInt",
   "List.nil",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "Int.ofNat_nonneg",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Option.none",
   "instSubNat",
   "LE.le",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Ne",
   "Lean.Omega.Constraint.mk",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "instHSub",
   "instLENat"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_9",
  "constType":
  "∀ (n : ℕ) (ℒ : Type) (ntl : Nontrivial ℒ) (l : Lattice ℒ) (bo : BoundedOrder ℒ) (wacc : WellFoundedGT ℒ) (S : Type)\n  (clo : CompleteLinearOrder S) (μ : { p // p.1 < p.2 } → S) (JHy JHx : HarderNarasimhan.JordanHolderFiltration μ),\n  ¬Nat.find ⋯ = 1 → Nat.find ⋯ ≠ 0 → ¬0 < Nat.find ⋯ - 1 → False",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Function.injective_id",
   "CharZero.mk",
   "CharZero",
   "Nat.instAddMonoidWithOne"],
  "name": "Nat.instCharZero",
  "constType": "CharZero ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero",
   "AddZeroClass",
   "outParam",
   "SetLike",
   "AddSubmonoidClass",
   "ZeroMemClass"],
  "name": "AddSubmonoidClass.toZeroMemClass",
  "constType":
  "∀ {S : Type u_3} {M : outParam (Type u_4)} {inst : AddZeroClass M} {inst_1 : SetLike S M}\n  [self : AddSubmonoidClass S M], ZeroMemClass S M",
  "constCategory": "Theorem"},
 {"references":
  ["Lex'Order.Lex'Order_prop",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "Exists",
   "Finset",
   "LinearExtension",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Singleton.singleton",
   "LinearOrder",
   "And",
   "Finset.instHasSubset",
   "CommRing",
   "PrimeSpectrum",
   "instDistribLatticeOfLinearOrder",
   "LinearOrder.toPartialOrder",
   "Finset.instSingleton",
   "DistribLattice.toLattice",
   "HasSubset.Subset",
   "Iff",
   "LE.le",
   "PrimeSpectrum.instPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLinearOrderS₀._proof_1",
  "constType":
  "∀ {R : Type} [inst : CommRing R],\n  ∃ lo,\n    (∀ (A B : Finset (LinearExtension (PrimeSpectrum R))), A ⊆ B → A ≤ B) ∧\n      ∀ (a b : LinearExtension (PrimeSpectrum R)), a ≤ b ↔ {a} ≤ {b}",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.toSubMulAction",
   "Module",
   "AddCommGroup.toAddGroup",
   "SubNegMonoid.toNeg",
   "AddCommGroup",
   "AddCommMonoid.toAddMonoid",
   "NegMemClass.mk",
   "Ring.toSemiring",
   "Submodule",
   "AddSubgroupClass",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoidClass",
   "SubMulAction.neg_mem",
   "Submodule.addSubmonoidClass",
   "AddSubgroupClass.mk",
   "Ring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.addSubgroupClass",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M],\n  AddSubgroupClass (Submodule R M) M",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.NashEquilibrium.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.μBstar",
   "Nontrivial",
   "Lattice",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.NashEquilibrium.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  HarderNarasimhan.μAstar μ = HarderNarasimhan.μBstar μ → HarderNarasimhan.NashEquilibrium μ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HarderNarasimhan.μB",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "HarderNarasimhan.μBstar",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.μBstar.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.μBstar μ = HarderNarasimhan.μB μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "DFunLike.mk",
   "Function.instFunLikeEmbedding._proof_1",
   "Function.Embedding",
   "Function.Embedding.toFun"],
  "name": "Function.instFunLikeEmbedding",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ↪ β) α β",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "Eq.trans",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "strictMono_nat_of_lt_succ",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Exists",
   "Exists.choose_spec",
   "ne_top_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Lattice",
   "Classical.byContradiction",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "lt_top_iff_ne_top",
   "HarderNarasimhan.impl.prop4d1_helper",
   "setOf",
   "StrictMono",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "InfSet.sInf",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "Set",
   "HarderNarasimhan.impl.prop4d1₁_seq",
   "sInf_le_of_le",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "bot_lt_top",
   "CompleteLattice",
   "And.casesOn",
   "lt_trans",
   "HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.preorder",
   "HarderNarasimhan.μmax",
   "And.intro",
   "Or",
   "sSup_le",
   "funext",
   "forall_congr",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "ConditionallyCompleteLattice.toInfSet",
   "And.right",
   "And",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Nat.lt_add_one",
   "Exists.casesOn",
   "Nat",
   "Iff.of_eq",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "HarderNarasimhan.μAstar",
   "Subtype",
   "Eq.mp",
   "lt_of_le_of_ne",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Set.mem_setOf",
   "HarderNarasimhan.μmin",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "le_antisymm",
   "Not",
   "Set.Nonempty",
   "le_top",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Mathlib.Tactic.PushNeg.not_and_eq",
   "Mathlib.Tactic.PushNeg.not_forall_eq",
   "HarderNarasimhan.μmax._proof_2",
   "Exists.choose",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "le_sInf",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.prop4d1₁",
  "constType":
  "∀ (ℒ : Type) [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n        μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n      HarderNarasimhan.μAstar μ = HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.μA_DescendingChainCondition",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "Prod.fst",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nat.below",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (k : ℕ) (x : Nat.below k.succ), ↑x.1 < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toSemiring",
   "Subtype.val",
   "OfNat.ofNat",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "Subtype.coe_injective",
   "DistribLattice.toLattice",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "Semifield",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "Preorder.toLE",
   "Function.Injective",
   "SemilatticeInf.toPartialOrder"],
  "name": "Nonneg.semifield._proof_14",
  "constType":
  "∀ {α : Type u_1} [inst : Semifield α] [inst_1 : LinearOrder α], Function.Injective fun a => ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "Real.instZero",
   "Real",
   "LE.le",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Real.instLE"],
  "name": "NNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "RelEmbedding.toEmbedding",
   "PartialOrder.toPreorder",
   "Set",
   "Coe",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "Coe.mk",
   "Function.Embedding.toFun",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "LE.le",
   "Preorder.toLE",
   "Subtype.le",
   "Set.instLE"],
  "name": "HarderNarasimhan.instCoeDedekindMacNeilleCompletion",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → Coe α (HarderNarasimhan.DedekindMacNeilleCompletion α)",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Tactic.Zify.natCast_eq",
   "Nat",
   "Nat.cast",
   "Eq",
   "propext",
   "instNatCastInt",
   "Int"],
  "name": "_private.Mathlib.Tactic.Zify.0._proof_1",
  "constType": "∀ (a b : ℕ), (a = b) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.WeakSlopeLike₁.wsl₁",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.NashEquilibrium.mk",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "HarderNarasimhan.NashEquilibrium",
   "SupSet.sSup",
   "sSup_le",
   "HarderNarasimhan.WeakAscendingChainCondition.wacc",
   "letFun",
   "HarderNarasimhan.μBstar",
   "funext",
   "Eq.rec",
   "HarderNarasimhan.impl.prop4d1₁",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Iff",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "setOf",
   "HarderNarasimhan.μAstar",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Ne.symm",
   "Subtype",
   "Eq.mp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.TotIntvl._proof_1",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Iff.intro",
   "Prod.fst",
   "eq_of_le_of_le",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.WeakSlopeLike₁",
   "OrderBot.toBot",
   "bot_ne_top",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "bot_lt_iff_ne_bot",
   "HarderNarasimhan.NashEquilibrium.nash_eq",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "HarderNarasimhan.μmax._proof_2",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "le_sSup",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.rmk4d10₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.WeakAscendingChainCondition μ →\n    HarderNarasimhan.WeakSlopeLike₁ μ →\n      (HarderNarasimhan.NashEquilibrium μ ↔\n        ∀ (y : ℒ) (hy : y ≠ ⊥), HarderNarasimhan.μmin μ ⟨(⊥, y), ⋯⟩ ≤ HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl)",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro", "Nonempty", "Inhabited", "Inhabited.default"],
  "name": "instNonemptyOfInhabited",
  "constType": "∀ {α : Sort u} [Inhabited α], Nonempty α",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Order.Lattice.0._proof_15",
   "Lattice.toSemilatticeSup",
   "HarderNarasimhan.ConvexI.convex",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "_private.Init.Core.0._proof_38",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "inf_assoc",
   "And.intro",
   "le_sup_right",
   "not_false_eq_true",
   "sSup_le",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "mt",
   "HarderNarasimhan.InIntvl",
   "eq_false",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "sup_le_sup_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "lt_of_le_of_ne",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Prod.fst",
   "congrArg",
   "le_inf",
   "Preorder.toLE",
   "Eq",
   "le_antisymm",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "inf_idem",
   "inf_le_inf_right",
   "right_eq_sup",
   "gt_of_ge_of_gt",
   "HarderNarasimhan.μmax._proof_2",
   "LT.lt",
   "Max.max",
   "of_eq_true",
   "Min.min",
   "le_of_lt",
   "SemilatticeSup.toMax",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "le_sSup",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.lem2d4₂I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (w : ℒ),\n          HarderNarasimhan.InIntvl I w →\n            ∀ (hxw : ¬x ≤ w) (t : ℒ) (hxwt : x ⊔ w ≤ t),\n              HarderNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩ ≤ HarderNarasimhan.μmax μ ⟨(w, t), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommMonoid",
   "Submodule.nontrivial_iff",
   "Module",
   "Nontrivial",
   "Eq",
   "propext",
   "Submodule",
   "Semiring"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_21",
  "constType":
  "∀ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M],\n  Nontrivial (Submodule R M) = Nontrivial M",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Not", "Decidable.byContradiction", "Classical.propDecidable", "False"],
  "name": "Classical.byContradiction",
  "constType": "∀ {p : Prop}, (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd", "AddZeroClass", "AddSubmonoid", "AddSubsemigroup"],
  "name": "AddSubmonoid.toAddSubsemigroup",
  "constType":
  "{M : Type u_3} → [inst : AddZeroClass M] → AddSubmonoid M → AddSubsemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder.lt_iff_le_not_le._autoParam",
   "Preorder",
   "Iff",
   "LE.le",
   "And",
   "LE",
   "autoParam",
   "LT"],
  "name": "Preorder.mk",
  "constType":
  "{α : Type u_2} →\n  [toLE : LE α] →\n    [toLT : LT α] →\n      (∀ (a : α), a ≤ a) →\n        (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) →\n          autoParam (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) Preorder.lt_iff_le_not_le._autoParam → Preorder α",
  "constCategory": "Other"},
 {"references":
  ["Nat", "AddMonoidWithOne.toNatCast", "Nat.cast", "AddMonoidWithOne"],
  "name": "Nat.rawCast",
  "constType": "{α : Type u} → [AddMonoidWithOne α] → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.zero_add",
   "AddMonoid.toZero",
   "AddMonoid.add_zero",
   "AddZeroClass",
   "AddMonoid.toAddSemigroup",
   "AddMonoid",
   "AddZeroClass.mk",
   "AddSemigroup.toAdd"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeSup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "SemilatticeSup.sup_le",
  "constType":
  "∀ {α : Type u} [self : SemilatticeSup α] (a b c : α), a ≤ c → b ≤ c → SemilatticeSup.sup a b ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Or.elim.match_1", "Or"],
  "name": "Or.elim",
  "constType": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_4._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.NashEquilibrium.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.NashEquilibrium.rec",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.μBstar",
   "Nontrivial",
   "Lattice",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.NashEquilibrium.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.NashEquilibrium μ → Sort u} →\n                (t : HarderNarasimhan.NashEquilibrium μ) →\n                  ((nash_eq : HarderNarasimhan.μAstar μ = HarderNarasimhan.μBstar μ) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "SetLike.instMembership",
   "Module",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Submodule.span",
   "Set.instSingletonSet",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "Submodule.subset_span",
   "Semiring"],
  "name": "Submodule.mem_span_singleton_self",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (x : M),\n  x ∈ Submodule.span R {x}",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.rec", "Eq"],
  "name": "HarderNarasimhan.impl.smart_helper",
  "constType": "∀ {α : Type} {a b c d : α}, a = b → b = c → c = d → a = d",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.LinearCombo", "Lean.Omega.Coeffs", "Int"],
  "name": "Lean.Omega.LinearCombo.mk",
  "constType": "ℤ → Omega.Coeffs → Omega.LinearCombo",
  "constCategory": "Other"},
 {"references":
  ["Lean.Omega.LinearCombo", "Lean.Omega.LinearCombo.sub", "Sub.mk", "Sub"],
  "name": "Lean.Omega.LinearCombo.instSub",
  "constType": "Sub Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references": ["Not", "Exists", "not_exists", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_15",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) = ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "not_strictMono_of_wellFoundedGT",
   "Exists.intro",
   "List.instGetElem?NatLtLength",
   "Subtype.val",
   "GetElem?.getElem?",
   "False.elim",
   "HarderNarasimhan.NashEquilibrium",
   "SupSet.sSup",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.ndrec",
   "CoheytingAlgebra.toOrderTop",
   "instLTNat",
   "Exists",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "lt_top_iff_ne_top",
   "HarderNarasimhan.Semistable",
   "StrictMono",
   "setOf",
   "Ne.symm",
   "HarderNarasimhan.impl.thm4d21",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Order.Coframe.toCoheytingAlgebra",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "List",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instPreorder",
   "HarderNarasimhan.WeakAscendingChainCondition.mk",
   "instOfNatNat",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "propext",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "HarderNarasimhan.instBoundedOrderInterval",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "CompletelyDistribLattice.toCompleteLattice",
   "HAdd.hAdd",
   "inferInstance",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "bot_lt_top",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Iff.mp",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "And.intro",
   "funext",
   "List.TFAE",
   "CompleteLattice.toTop",
   "CompleteLinearOrder",
   "Eq.rec",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Nat.lt_add_one",
   "Nat",
   "Iff.of_eq",
   "Iff.mpr",
   "Option",
   "Nontrivial",
   "id",
   "HarderNarasimhan.FiniteTotalPayoff.fin_tot_payoff",
   "CompleteDistribLattice.toCoframe",
   "List.length",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "not_le_of_lt",
   "HarderNarasimhan.TotIntvl._proof_1",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.FiniteTotalPayoff.mk",
   "HarderNarasimhan.Interval",
   "HarderNarasimhan.Resμ._proof_19",
   "OrderBot.toBot",
   "HarderNarasimhan.instWeakDescendingChainConditionOfWeakDescendingChainCondition'",
   "List.nil",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "le_top",
   "List.TFAE.out",
   "instHAdd",
   "HarderNarasimhan.μmax._proof_2",
   "exists_prop_congr",
   "LT.lt",
   "HarderNarasimhan.instNontrivialInterval",
   "LE.le",
   "le_sSup",
   "False",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name":
  "HarderNarasimhan.instFiniteTotalPayoffIntervalMkProdLtFstSndMkBotResμOfWellFoundedGTOfSlopeLikeOfSemistableOfWeakDescendingChainCondition'",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} [hftp : HarderNarasimhan.FiniteTotalPayoff μ]\n  [hsl : HarderNarasimhan.SlopeLike μ] [hst : HarderNarasimhan.Semistable μ]\n  [hwdcc' : HarderNarasimhan.WeakDescendingChainCondition' μ] {x : ℒ} {hx : ⊥ < x},\n  HarderNarasimhan.FiniteTotalPayoff (HarderNarasimhan.Resμ ⟨(⊥, x), hx⟩ μ)",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Lattice.toSemilatticeSup",
   "HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.ConvexI",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Exists.intro",
   "sup_le",
   "HarderNarasimhan.impl.comparable_iff",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "HarderNarasimhan.impl.prop2d6₀",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.IsComparable",
   "Prod",
   "Exists.casesOn",
   "Classical.or_iff_not_imp_left",
   "HarderNarasimhan.impl.lem2d4₂I",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "setOf",
   "SemilatticeInf.toMin",
   "Or.inr",
   "Subtype",
   "Ne.symm",
   "HarderNarasimhan.impl.prop2d6₂I₂",
   "le_trans",
   "Or.resolve_right",
   "lt_of_le_of_ne",
   "Prod.fst",
   "eq_of_le_of_le",
   "le_inf",
   "Or.inl",
   "HarderNarasimhan.impl.lem2d4₁",
   "Preorder.toLE",
   "Eq",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.IsAttained._proof_4",
   "sInf_le",
   "LT.lt",
   "Or.casesOn",
   "le_of_lt",
   "Min.min",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.impl.prop2d6₂I₁",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop2d6₃I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HarderNarasimhan.InIntvl I y →\n            ∀ (z : ℒ),\n              HarderNarasimhan.InIntvl I z →\n                ∀ (h : x < y ∧ y < z),\n                  HarderNarasimhan.IsComparable (HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩)\n                        (HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩) ∨\n                      HarderNarasimhan.IsAttained μ ⟨(x, z), ⋯⟩ →\n                    HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ = HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∨\n                      HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ∧\n                        HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ < HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "And.intro",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.μBstar",
   "HarderNarasimhan.WeakSlopeLike₁",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.rmk4d10₁",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.impl.rmk4d10₃",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "HarderNarasimhan.impl.rmk4d10₂",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Iff",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.remark_4_10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (HarderNarasimhan.μBstar μ ≤ HarderNarasimhan.μAstar μ ↔\n      ∀ (x : ℒ) (hx : x ≠ ⊤) (y : ℒ) (hy : ⊥ < y),\n        HarderNarasimhan.μmin μ ⟨(⊥, y), hy⟩ ≤ HarderNarasimhan.μmax μ ⟨(x, ⊤), ⋯⟩) ∧\n    (HarderNarasimhan.WeakAscendingChainCondition μ →\n        HarderNarasimhan.WeakSlopeLike₁ μ →\n          (HarderNarasimhan.NashEquilibrium μ ↔\n            ∀ (y : ℒ) (hy : y ≠ ⊥),\n              HarderNarasimhan.μmin μ ⟨(⊥, y), ⋯⟩ ≤ HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl)) ∧\n      (HarderNarasimhan.WeakDescendingChainCondition μ →\n        HarderNarasimhan.WeakSlopeLike₂ μ →\n          (HarderNarasimhan.NashEquilibrium μ ↔\n            ∀ (y : ℒ) (hy : y ≠ ⊤),\n              HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl ≤ HarderNarasimhan.μmax μ ⟨(y, ⊤), ⋯⟩))",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["ZeroHomClass",
   "FunLike",
   "Zero.toOfNat0",
   "Zero",
   "Eq",
   "DFunLike.coe",
   "OfNat.ofNat",
   "ZeroHomClass.map_zero"],
  "name": "map_zero",
  "constType":
  "∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Zero M] [inst_1 : Zero N] [inst_2 : FunLike F M N]\n  [ZeroHomClass F M N] (f : F), f 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "inferInstance",
   "AddMonoid",
   "AddCommMonoid.toAddMonoid",
   "Nat.instAddCommMonoid"],
  "name": "Nat.instAddMonoid",
  "constType": "AddMonoid ℕ",
  "constCategory": "Definition"},
 {"references": ["Function.Embedding", "Function.Injective"],
  "name": "Function.Embedding.mk",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (toFun : α → β) → Function.Injective toFun → α ↪ β",
  "constCategory": "Other"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "True",
   "Membership.mem",
   "eq_true",
   "SetLike",
   "SetLike.coe_mem",
   "Eq",
   "Subtype.val"],
  "name": "HarderNarasimhan.impl.rmk4d14₂._proof_16",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} (x : ↥p), (↑x ∈ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Int.instLTInt",
   "HarderNarasimhan.JordanHolderFiltration",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "HarderNarasimhan.JordanHolderFiltration.casesOn",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLinearOrder S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                Sort u → HarderNarasimhan.JordanHolderFiltration μ → HarderNarasimhan.JordanHolderFiltration μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Set.empty_subset.match_1",
   "Membership.mem",
   "Set.instEmptyCollection",
   "EmptyCollection.emptyCollection",
   "Set.instMembership"],
  "name": "Set.empty_subset",
  "constType": "∀ {α : Type u} (s : Set α), ∅ ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "instHAdd", "Eq.refl", "Int.instAdd", "Eq.ndrec", "Eq", "Int"],
  "name": "Lean.Omega.Int.add_congr",
  "constType": "∀ {a b c d : ℤ}, a = b → c = d → a + c = b + d",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "HarderNarasimhan.ConvexI.casesOn",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq",
   "Eq.ndrec",
   "Preorder.toLE",
   "inf_lt_left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.ConvexI.noConfusionType",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.InIntvl",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.ConvexI.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Lattice ℒ} →\n    {S : Type} →\n      {inst_1 : CompleteLattice S} →\n        {I : { p // p.1 < p.2 }} →\n          {μ : { p // p.1 < p.2 } → S} →\n            {P : Sort u} →\n              {v1 v2 : HarderNarasimhan.ConvexI I μ} → v1 = v2 → HarderNarasimhan.ConvexI.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "SemilinearMapClass",
   "Module",
   "Submodule.module",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Submodule",
   "LinearMap.semilinearMapClass",
   "Submodule.Quotient.addCommGroup",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "CommSemiring.toSemiring",
   "Submodule.addCommGroup",
   "AddCommGroup",
   "CommRing",
   "LinearMap",
   "Ring.toSemiring",
   "CommRing.toRing",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf"],
  "name": "HarderNarasimhan.impl.lift_quot._proof_16",
  "constType":
  "∀ {R : Type} [inst : CommRing R] {M : Type} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  (N₁ N₂ : Submodule R M),\n  SemilinearMapClass (↥N₂ →ₗ[R] ↥N₂ ⧸ N₁.submoduleOf N₂) (RingHom.id R) (↥N₂) (↥N₂ ⧸ N₁.submoduleOf N₂)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "SemilinearMapClass",
   "Submodule.mem_comap",
   "Module",
   "Membership.mem",
   "DFunLike.coe",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_23",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} {x : M} {F : Type u_9} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F σ₁₂ M M₂] {f : F}\n  {p : Submodule R₂ M₂}, (x ∈ Submodule.comap f p) = (f x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Iff.mp",
   "GT.gt",
   "GE.ge",
   "And.intro",
   "False.elim",
   "Or",
   "letFun",
   "Eq.symm",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "imp_iff_or_not",
   "And.right",
   "And",
   "Or.resolve_left",
   "BoundedOrder",
   "Prod.snd",
   "Decidable.not_and_iff_not_or_not'",
   "Prod",
   "Classical.or_iff_not_imp_left",
   "not_lt_of_ge",
   "Eq.refl",
   "Iff",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "imp_iff_not_or",
   "Eq.mpr",
   "HarderNarasimhan.SlopeLike.mk",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "Subtype",
   "Classical.not_not",
   "OmegaCompletePartialOrder.toPartialOrder",
   "not_le_of_lt",
   "Or.resolve_right",
   "congrArg",
   "Iff.intro",
   "Prod.fst",
   "Or.inl",
   "le_of_eq",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "eq_of_le_of_not_lt",
   "Iff.symm",
   "LT.lt",
   "Or.casesOn",
   "le_of_lt",
   "LE.le",
   "Subtype.mk",
   "Decidable.iff_iff_and_or_not_and_not",
   "dite",
   "CompleteLattice",
   "HarderNarasimhan.SlopeLike.slopelike",
   "instDecidableNot",
   "And.casesOn"],
  "name": "HarderNarasimhan.impl.prop4d6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ ↔\n    ∀ (x y z : ℒ) (h : x < y ∧ y < z),\n      μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩ ∨\n        μ ⟨(x, y), ⋯⟩ > μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ > μ ⟨(y, z), ⋯⟩ ∨\n          μ ⟨(x, y), ⋯⟩ = μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ = μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "HarderNarasimhan.μA_DescendingChainCondition.rec",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HarderNarasimhan.μA_DescendingChainCondition.mk",
   "Nat",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μA_DescendingChainCondition.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.μA_DescendingChainCondition μ → Sort u} →\n                (t : HarderNarasimhan.μA_DescendingChainCondition μ) →\n                  ((μ_dcc :\n                        ∀ (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n                          (∀ (n : ℕ), f n > f (n + 1)) →\n                            ∃ N, HarderNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(a, f N), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.injective",
   "Function.Injective.eq_iff",
   "FunLike",
   "EmbeddingLike",
   "Iff",
   "Eq",
   "DFunLike.coe"],
  "name": "EmbeddingLike.apply_eq_iff_eq",
  "constType":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [inst : FunLike F α β] [i : EmbeddingLike F α β] (f : F) {x y : α},\n  f x = f y ↔ x = y",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid",
   "SubtractionMonoid.mk",
   "AddCommGroup.add_comm",
   "SubtractionMonoid.neg_eq_of_add",
   "AddCommGroup.toAddGroup",
   "SubtractionCommMonoid",
   "SubtractionCommMonoid.mk",
   "AddCommGroup",
   "SubtractionMonoid.neg_neg",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.neg_add_rev",
   "AddGroup.toSubtractionMonoid"],
  "name": "AddCommGroup.toDivisionAddCommMonoid",
  "constType": "{G : Type u_1} → [AddCommGroup G] → SubtractionCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "IsNoetherianRing",
   "Module",
   "Nontrivial",
   "CommSemiring.toSemiring",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "CommRing",
   "Submodule",
   "Module.Finite"],
  "name": "HarderNarasimhan.ℒ",
  "constType":
  "(R : Type) →\n  [inst : CommRing R] →\n    [IsNoetherianRing R] →\n      (M : Type) →\n        [Nontrivial M] → [inst_3 : AddCommGroup M] → [inst_4 : _root_.Module R M] → [Module.Finite R M] → Type",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "Submodule.completeLattice._proof_26",
   "PartialOrder.toPreorder",
   "Submodule.instInfSet",
   "Module",
   "Membership.mem",
   "SupSet.mk",
   "Lattice.mk",
   "Submodule.completeLattice._proof_29",
   "Submodule.completeLattice._proof_34",
   "Submodule.completeLattice._proof_30",
   "Submodule",
   "Submodule.completeLattice._proof_32",
   "AddCommMonoid",
   "InfSet.sInf",
   "Submodule.completeLattice._proof_31",
   "OrderBot.toBot",
   "Submodule.instOrderBot",
   "Preorder.toLE",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "OrderBot",
   "Submodule.instOrderTop",
   "Submodule.completeLattice._proof_33",
   "CompleteLattice.mk",
   "Set",
   "And",
   "OrderTop",
   "Submodule.completeLattice._proof_28",
   "Set.instMembership",
   "Submodule.setLike",
   "Min.min",
   "LE.le",
   "Submodule.completeLattice._proof_35",
   "inferInstance",
   "SemilatticeSup.mk",
   "Submodule.instMin",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "Submodule.completeLattice._proof_27",
   "OrderTop.toTop",
   "CompleteLattice",
   "Semiring",
   "setOf"],
  "name": "Submodule.completeLattice",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → CompleteLattice (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "AddZeroClass",
   "AddZeroClass.toZero",
   "Preorder.toLT",
   "CanonicallyOrderedAdd",
   "OfNat.ofNat",
   "LE.le.eq_or_lt",
   "LT.lt",
   "Or",
   "AddZeroClass.toAdd",
   "zero_le",
   "Or.imp_left",
   "PartialOrder",
   "Eq.symm",
   "Zero.toOfNat0",
   "Preorder.toLE",
   "Eq"],
  "name": "eq_zero_or_pos",
  "constType":
  "∀ {α : Type u} [inst : AddZeroClass α] [inst_1 : PartialOrder α] [CanonicallyOrderedAdd α] (a : α), a = 0 ∨ 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "InfSet",
   "Exists",
   "PartialOrder.toPreorder",
   "Subtype",
   "Prod.mk",
   "Set",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.InIntvl",
   "PartialOrder",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μmin._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references": ["Nat", "Lean.Name"],
  "name": "Lean.Name.num",
  "constType": "Name → ℕ → Name",
  "constCategory": "Other"},
 {"references": ["Not", "Decidable", "Decidable.casesOn"],
  "name": "dite",
  "constType":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_trans",
   "Nat.recAux",
   "Nat.le_refl",
   "Nat.pred",
   "OfNat.ofNat",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "LE.le",
   "HSub.hSub",
   "instHSub",
   "instLENat",
   "Nat.pred_le"],
  "name": "Nat.sub_le",
  "constType": "∀ (n m : ℕ), n - m ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.instSingleton",
   "Finset",
   "Finset.singleton_inj",
   "Singleton.singleton",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Data.Finset.Insert.0._proof_3",
  "constType": "∀ {α : Type u_1} {a b : α}, ({a} = {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_2._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["Set.instSupSet", "iSup", "Set"],
  "name": "Set.iUnion",
  "constType": "{α : Type u} → {ι : Sort v} → (ι → Set α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.μmin",
   "SupSet.sSup",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.μmax._proof_2",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μB",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["PrimeSpectrum",
   "Ideal.IsPrime",
   "CommSemiring.toSemiring",
   "CommSemiring",
   "PrimeSpectrum.asIdeal"],
  "name": "PrimeSpectrum.isPrime",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (self : PrimeSpectrum R), self.asIdeal.IsPrime",
  "constCategory": "Theorem"},
 {"references":
  ["instNNRealSemiring",
   "AddCommMonoid",
   "NNReal.toRealHom",
   "Real",
   "Module",
   "NNReal",
   "Real.semiring",
   "Module.compHom"],
  "name": "NNReal.instModuleOfReal",
  "constType":
  "{M : Type u_1} → [inst : AddCommMonoid M] → [_root_.Module ℝ M] → _root_.Module NNReal M",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Semistable.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.Semistable.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.Semistable μ → Sort u} →\n                ((semistable :\n                      ∀ (x : ℒ) (hx : x ≠ ⊥), ¬HarderNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HarderNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩) →\n                    motive ⋯) →\n                  (t : HarderNarasimhan.Semistable μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "SemilinearMapClass",
   "Submodule.mem_comap",
   "Module",
   "Membership.mem",
   "DFunLike.coe",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.assp._proof_3",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} {x : M} {F : Type u_9} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F σ₁₂ M M₂] {f : F}\n  {p : Submodule R₂ M₂}, (x ∈ Submodule.comap f p) = (f x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "SetLike.coe_eq_coe",
   "Membership.mem",
   "SetLike",
   "Eq",
   "Subtype.val",
   "propext"],
  "name": "HarderNarasimhan.impl.submoduleOf_map_subtype._proof_12",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x y : ↥p}, (↑x = ↑y) = (x = y)",
  "constCategory": "Theorem"},
 {"references": ["HSub", "outParam"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "HarderNarasimhan.impl.f1",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Submodule.map",
   "Preorder.toLT",
   "Subtype.val",
   "Submodule.subtype",
   "Semiring.toNonAssocSemiring",
   "Finset.min'",
   "RingHom.id",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "SetLike.instMembership",
   "LinearMap.ker",
   "LocalizedModule",
   "Submodule.addCommGroup",
   "Prod.snd",
   "LinearMap",
   "Prod",
   "LocalizedModule.isModule'",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_9",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "HarderNarasimhan.impl.f2",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "LocalizedModule.instAddCommMonoid",
   "LinearMap.comp",
   "HarderNarasimhan.impl.μ_nonempty",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_10",
   "Prod.fst",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Ideal.primeCompl",
   "PrimeSpectrum.asIdeal",
   "HarderNarasimhan._μ",
   "CommRing.toCommSemiring",
   "LinearExtension",
   "CommSemiring.toSemiring",
   "Set.toFinset",
   "AddCommGroup",
   "CommRing",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_7",
   "LT.lt",
   "PrimeSpectrum",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.f1._proof_4",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_8",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.ker_of_quot_comp_localization",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] → [inst_5 : Module.Finite R M] → { z // z.1 < z.2 } → HarderNarasimhan.ℒ R M",
  "constCategory": "Definition"},
 {"references": ["HPow.mk", "HPow", "Pow", "Pow.pow"],
  "name": "instHPow",
  "constType": "{α : Type u_1} → {β : Type u_2} → [Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references": ["InfSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toInfSet",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["associatedPrimes",
   "CommRing.toCommSemiring",
   "HarderNarasimhan.Coprimary.casesOn",
   "Module",
   "Set",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "AddCommGroup",
   "CommRing",
   "Set.instMembership",
   "IsNoetherianRing",
   "HarderNarasimhan.Coprimary",
   "Ideal",
   "AddCommGroup.toAddCommMonoid",
   "ExistsUnique"],
  "name": "HarderNarasimhan.Coprimary.noConfusionType",
  "constType":
  "{R : Type} →\n  {inst : CommRing R} →\n    {inst_1 : IsNoetherianRing R} →\n      {M : Type} →\n        {inst_2 : AddCommGroup M} →\n          {inst_3 : _root_.Module R M} →\n            Sort u → HarderNarasimhan.Coprimary R M → HarderNarasimhan.Coprimary R M → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "_private.Init.Classical.0._proof_9",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "False.elim",
   "Or",
   "letFun",
   "forall_congr",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_5",
   "Exists",
   "Exists.choose_spec",
   "Or.resolve_left",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Nat",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Lattice",
   "Classical.byContradiction",
   "Top.top",
   "setOf",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "_private.Init.Classical.0._proof_7",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "Prod.fst",
   "congrArg",
   "_private.Init.PropLemmas.0._proof_15",
   "not_lt_top_iff",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "not_true_eq_false",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "_private.Init.Classical.0._proof_13",
   "Exists.choose",
   "exists_prop_congr",
   "LT.lt",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_6",
   "Nat.succ",
   "LE.le",
   "Nat.below",
   "False",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "HarderNarasimhan.impl.prop4d1₁_seq._proof_3",
   "CompleteLattice",
   "And.casesOn"],
  "name": "HarderNarasimhan.impl.prop4d1₁_seq._proof_7",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S),\n  (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n    ∀ (k : ℕ) (x : Nat.below k.succ),\n      ⋯.choose ∈ {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Theorem"},
 {"references": ["exists_prop", "Exists", "And", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_38",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references": ["semiOutParam", "CoeOut"],
  "name": "CoeOut.mk",
  "constType":
  "{α : Sort u} → {β : semiOutParam (Sort v)} → (α → β) → CoeOut α β",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "And.left",
   "HarderNarasimhan.impl.ℒₛ._proof_1",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Exists.choose_spec",
   "Set",
   "HarderNarasimhan.impl.ℒₛ",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.InIntvl",
   "Nat.succ",
   "HarderNarasimhan.impl.prop3d4₀func._proof_5",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.impl.ℒₛ._proof_2",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d4₀func._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ) (x : Nat.below n.succ)\n  (hbot : ¬(↑I).1 = ↑x.1) (hne : (HarderNarasimhan.impl.ℒₛ μ I x.1 hbot).Nonempty), HarderNarasimhan.InIntvl I ⋯.choose",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "Module",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "SizeOf",
   "IsNoetherianRing",
   "HarderNarasimhan.CoprimaryFiltration",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "HarderNarasimhan.CoprimaryFiltration._sizeOf_1",
   "SizeOf.mk",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration._sizeOf_inst",
  "constType":
  "(R : Type) →\n  {inst : CommRing R} →\n    {inst_1 : IsNoetherianRing R} →\n      (M : Type) →\n        {inst_2 : Nontrivial M} →\n          {inst_3 : AddCommGroup M} →\n            {inst_4 : _root_.Module R M} →\n              {inst_5 : Module.Finite R M} → [SizeOf R] → [SizeOf M] → SizeOf (HarderNarasimhan.CoprimaryFiltration R M)",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "AddZeroClass.toZero",
   "AddZeroClass.toAdd",
   "AddZeroClass",
   "instHAdd",
   "AddZeroClass.add_zero",
   "Zero.toOfNat0",
   "Eq",
   "OfNat.ofNat"],
  "name": "add_zero",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["Bool", "DecidableEq", "Bool.decEq"],
  "name": "instDecidableEqBool",
  "constType": "DecidableEq Bool",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₂.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1), μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n    HarderNarasimhan.WeakSlopeLike₂ μ",
  "constCategory": "Other"},
 {"references":
  ["LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "Or.resolve_right",
   "LinearOrder",
   "le_total",
   "Preorder.toLE",
   "LE.le.lt_of_not_le"],
  "name": "lt_of_not_le",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrder α] {a b : α}, ¬b ≤ a → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_left"],
  "name": "inf_le_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_le_succ",
   "instAddNat",
   "HAdd.hAdd",
   "Nat",
   "Nat.AtLeastTwo",
   "instOfNatNat",
   "instHAdd",
   "Nat.AtLeastTwo.mk",
   "Nat.zero_le",
   "OfNat.ofNat"],
  "name": "instNatAtLeastTwo",
  "constType": "∀ {n : ℕ}, (n + 2).AtLeastTwo",
  "constCategory": "Theorem"},
 {"references": ["implies_dep_congr_ctx", "Eq"],
  "name": "implies_congr_ctx",
  "constType":
  "∀ {p₁ p₂ q₁ q₂ : Prop}, p₁ = p₂ → (p₂ → q₁ = q₂) → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA_DescendingChainCondition",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instPreorder",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nat",
   "Monotone",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.monotone",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ]\n  (self : HarderNarasimhan.HarderNarasimhanFiltration μ), Monotone self.filtration",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.μ_Admissible.mk",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.μ_Admissible.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                {motive : HarderNarasimhan.μ_Admissible μ → Sort u} →\n                  ((μ_adm :\n                        (IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n                          ∀ (I : { p // p.1 < p.2 }), HarderNarasimhan.IsAttained μ I) →\n                      motive ⋯) →\n                    (t : HarderNarasimhan.μ_Admissible μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "sub_self",
   "AddZeroClass.toZero",
   "SubNegZeroMonoid.toNegZeroClass",
   "OfNat.ofNat",
   "AddGroup.toSubtractionMonoid",
   "congrArg",
   "Iff.intro",
   "SubNegMonoid.toAddMonoid",
   "eq_of_sub_eq_zero",
   "Iff",
   "Eq.refl",
   "SubNegMonoid.toSub",
   "id",
   "HSub.hSub",
   "NegZeroClass.toZero",
   "AddGroup",
   "Eq.mpr",
   "Zero.toOfNat0",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "instHSub",
   "AddMonoid.toAddZeroClass"],
  "name": "sub_eq_zero",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a - b = 0 ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil",
   "Prod.fst",
   "instOfNatNat",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ], HarderNarasimhan.impl.HNFil μ 0 = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Subtype.lt",
   "Subtype",
   "Eq",
   "Subtype.val",
   "LT",
   "propext",
   "Subtype.coe_lt_coe"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_30",
  "constType":
  "∀ {α : Type u_2} [inst : LT α] {p : α → Prop} {x y : Subtype p}, (↑x < ↑y) = (x < y)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "Preorder",
   "lowerBounds_mono_mem",
   "HasSubset.Subset",
   "Set",
   "lowerBounds",
   "Membership.mem",
   "LE.le",
   "lowerBounds_mono_set",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "lowerBounds_mono",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] ⦃s t : Set α⦄, s ⊆ t → ∀ ⦃a b : α⦄, a ≤ b → b ∈ lowerBounds t → a ∈ lowerBounds s",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "RingHom.toMonoidHom",
   "RingHom",
   "DFunLike.mk",
   "MulOneClass.toOne",
   "NonAssocSemiring",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "RingHom.instFunLike._proof_21",
   "OneHom.toFun",
   "NonAssocSemiring.toMulZeroOneClass"],
  "name": "RingHom.instFunLike",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → FunLike (α →+* β) α β",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "BoundedOrder",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.TotIntvl._proof_1",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ], ⊥ < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.StI",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil._proof_2",
   "Prod.fst",
   "IsGreatest",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "OrderBot.toBot",
   "HarderNarasimhan.impl.HNFil.match_1",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.impl.HNFil._proof_1",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "Nat.brecOn",
   "Exists.choose",
   "Bot.bot",
   "OfNat.ofNat",
   "Unit",
   "LT.lt",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nat.succ",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "Top.top",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              (μ : { p // p.1 < p.2 } → S) →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] → [h : HarderNarasimhan.μ_Admissible μ] → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Module",
   "RingHomInvPair",
   "Semiring"],
  "name": "LinearEquiv",
  "constType":
  "{R : Type u_12} →\n  {S : Type u_13} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        (σ : R →+* S) →\n          {σ' : S →+* R} →\n            [RingHomInvPair σ σ'] →\n              [RingHomInvPair σ' σ] →\n                (M : Type u_14) →\n                  (M₂ : Type u_15) →\n                    [inst_4 : AddCommMonoid M] →\n                      [inst_5 : AddCommMonoid M₂] → [_root_.Module R M] → [_root_.Module S M₂] → Type (max u_14 u_15)",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.toNeg",
   "SubNegZeroMonoid.toSubNegMonoid",
   "NegZeroClass",
   "NegZeroClass.mk",
   "SubNegZeroMonoid",
   "SubNegZeroMonoid.neg_zero"],
  "name": "SubNegZeroMonoid.toNegZeroClass",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → NegZeroClass G",
  "constCategory": "Definition"},
 {"references":
  ["smul_zero",
   "LinearMap.toSpanSingleton",
   "Eq.trans",
   "Module",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "congrArg",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Semiring.toModule",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "DistribSMul.toSMulZeroClass",
   "LinearMap.instZero",
   "True",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "LinearMap.ext_ring",
   "LinearMap",
   "OfNat.ofNat",
   "eq_self",
   "Module.toDistribMulAction",
   "One.toOfNat1",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "HSMul.hSMul",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "LinearMap.toSpanSingleton_zero",
  "constType":
  "∀ (R : Type u_1) (M : Type u_4) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M],\n  LinearMap.toSpanSingleton R M 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["ClosureOperator.instFunLike",
   "Monotone",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "ClosureOperator.toOrderHom",
   "OrderHom.monotone'",
   "ClosureOperator",
   "DFunLike.coe"],
  "name": "ClosureOperator.monotone",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] (c : ClosureOperator α), Monotone ⇑c",
  "constCategory": "Theorem"},
 {"references":
  ["Order.Frame.mk",
   "CompletelyDistribLattice.himp_bot",
   "CompletelyDistribLattice.toHasCompl",
   "CompletelyDistribLattice.toHNot",
   "CompletelyDistribLattice.sdiff_le_iff",
   "CompleteDistribLattice",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompletelyDistribLattice.top_sdiff",
   "CompletelyDistribLattice.toHImp",
   "CompletelyDistribLattice.toSDiff",
   "CompletelyDistribLattice",
   "CompleteDistribLattice.mk",
   "CompletelyDistribLattice.le_himp_iff"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice",
  "constType":
  "{α : Type u} → [CompletelyDistribLattice α] → CompleteDistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.ext",
   "Eq.trans",
   "HarderNarasimhan.impl.koqcl_iso._proof_11",
   "Submodule.Quotient.module",
   "HarderNarasimhan.impl.koqcl_iso._proof_12",
   "Submodule.map",
   "Exists.intro",
   "Membership",
   "Subtype.val",
   "Quotient.out_eq",
   "Submodule.quotientQuotientEquivQuotient",
   "Finset.min'",
   "RingHom.id",
   "letFun",
   "Subtype.coe_eta",
   "Eq.symm",
   "Eq.ndrec",
   "Submodule.coe_mem",
   "LinearMap.ker",
   "Exists",
   "LocalizedModule",
   "Submodule.addCommGroup",
   "Prod.snd",
   "LinearMap",
   "Ring.toSemiring",
   "Prod",
   "LocalizedModule.isModule'",
   "Iff",
   "Eq.refl",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_9",
   "HEq",
   "RingHomInvPair.ids",
   "AddCommGroup.toAddCommMonoid",
   "HarderNarasimhan.impl.f2._proof_6",
   "Eq.mpr",
   "HarderNarasimhan.impl.f2",
   "Quotient.out",
   "AddMonoid.toAddZeroClass",
   "Quotient",
   "Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "LinearMap.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "LocalizedModule.instAddCommMonoid",
   "Submodule.Quotient.instZeroQuotient",
   "AddCommMonoid.toAddMonoid",
   "HarderNarasimhan.impl.μ_nonempty",
   "Prod.fst",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_10",
   "congr",
   "AddCommMagma.toAdd",
   "HarderNarasimhan._μ",
   "Eq",
   "propext",
   "LinearExtension",
   "Set.toFinset",
   "AddCommGroup",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "eq_self",
   "CommRing.toRing",
   "HarderNarasimhan.ℒ",
   "Submodule.completeLattice",
   "LinearMap.comp_apply",
   "And.casesOn",
   "Module.Finite",
   "Quotient.mk''",
   "Submodule.Quotient.mk",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.impl.f1",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "RingHomCompTriple.ids",
   "Membership.mem",
   "AddHom.mk",
   "Preorder.toLT",
   "Quotient.mk",
   "PrimeSpectrum.isPrime",
   "Submodule.subtype",
   "LinearMap.semilinearMapClass",
   "And.intro",
   "Semiring.toNonAssocSemiring",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "eq_of_heq",
   "funext",
   "PrimeSpectrum.instPartialOrder",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "outParam",
   "And",
   "True.intro",
   "Submodule.Quotient.mk_eq_zero",
   "Exists.casesOn",
   "HarderNarasimhan.impl.submoduleOf_map_subtype",
   "Nontrivial",
   "id",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "Submodule.module",
   "LinearMap.comp",
   "LinearEquiv",
   "DFunLike.coe",
   "Iff.intro",
   "Submodule",
   "congrArg",
   "Submodule.Quotient.addCommGroup",
   "Ideal.primeCompl",
   "PrimeSpectrum.asIdeal",
   "Zero.toOfNat0",
   "AddCommSemigroup.toAddCommMagma",
   "HarderNarasimhan.impl.f2._proof_5",
   "Submodule.mkQ",
   "CommRing.toCommSemiring",
   "HEq.refl",
   "True",
   "Submodule.quotientRel",
   "CommSemiring.toSemiring",
   "CommRing",
   "Eq.casesOn",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_7",
   "LinearEquiv.symm",
   "RingHomSurjective.ids",
   "LT.lt",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.f1._proof_4",
   "of_eq_true",
   "AddCommMonoid.toAddCommSemigroup",
   "Submodule.setLike",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_3",
   "Subtype.mk",
   "Submodule.addCommMonoid",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_8",
   "LinearMap.mem_ker"],
  "name": "HarderNarasimhan.impl.koqcl_iso",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  ∃ x, True",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₂.wsl₂",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.WeakSlopeLike₂ μ]\n  (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1), μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "IsTotal",
   "PartialOrder.toPreorder",
   "LE.le",
   "LinearOrder",
   "IsTotal.mk",
   "le_total",
   "Preorder.toLE"],
  "name": "LE.isTotal",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α], IsTotal α fun x1 x2 => x1 ≤ x2",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "Decidable.isFalse", "False", "not_false"],
  "name": "instDecidableFalse",
  "constType": "Decidable False",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddGroup",
   "Ring.toAddGroupWithOne",
   "Eq.refl",
   "SubNegMonoid.toSub",
   "Eq.symm",
   "HSub.hSub",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "instHSub",
   "Eq",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.sub_congr",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a a' b b' c : R}, a = a' → b = b' → a' - b' = c → a - b = c",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid"],
  "name": "AddUnits",
  "constType": "(α : Type u) → [AddMonoid α] → Type u",
  "constCategory": "Other"},
 {"references": ["Preorder", "SMul", "Zero"],
  "name": "PosSMulStrictMono",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → [SMul α β] → [Preorder α] → [Preorder β] → [Zero α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "Bool",
   "Decidable.isFalse",
   "Decidable",
   "Nat.le_of_ble_eq_true",
   "Nat.not_le_of_not_ble_eq_true",
   "instDecidableEqBool",
   "Nat",
   "LE.le",
   "dite",
   "Eq",
   "instLENat",
   "Bool.true",
   "Nat.ble",
   "Decidable.isTrue"],
  "name": "Nat.decLe",
  "constType": "(n m : ℕ) → Decidable (n ≤ m)",
  "constCategory": "Definition"},
 {"references": ["List.isSetoid", "Quotient", "List"],
  "name": "Multiset",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "BiheytingAlgebra.toHNot",
   "HNot.hnot",
   "SemilatticeSup.toPartialOrder",
   "BiheytingAlgebra.top_sdiff",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "instDistribLatticeOfLinearOrder",
   "Eq",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "Lattice.toSemilatticeInf",
   "BiheytingAlgebra.toHeytingAlgebra",
   "LinearOrder",
   "BiheytingAlgebra.toSDiff",
   "DistribLattice.toLattice",
   "SDiff.sdiff",
   "Top.top",
   "CompleteLattice.toBoundedOrder",
   "OrderTop.toTop",
   "GeneralizedHeytingAlgebra.toLattice",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_45",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a : HarderNarasimhan.DedekindMacNeilleCompletion α), ⊤ \\ a = ￢a",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Ker.0._proof_1",
   "RingHom",
   "LinearMap.instFunLike",
   "Eq.trans",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "Submodule",
   "LinearMap.semilinearMapClass",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "Eq",
   "LinearMap.instZero",
   "LinearMap.ker",
   "SetLike.instMembership",
   "True",
   "AddZeroClass.toZero",
   "Submodule.instTop",
   "Submodule.eq_top_iff'",
   "LinearMap",
   "OfNat.ofNat",
   "eq_self",
   "of_eq_true",
   "Submodule.setLike",
   "Iff.mpr",
   "Top.top",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "LinearMap.ker_zero",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {τ₁₂ : R →+* R₂}, LinearMap.ker 0 = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "exists_prop_congr.match_1",
   "Iff.mpr",
   "Iff",
   "Iff.mp",
   "Exists.intro",
   "exists_prop_congr.match_2",
   "Iff.intro"],
  "name": "exists_prop_congr",
  "constType":
  "∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q ↔ ∃ (h : p'), q' ⋯",
  "constCategory": "Theorem"},
 {"references": ["Neg", "NegZeroClass"],
  "name": "NegZeroClass.toNeg",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Neg G",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._rarg",
   "_obj",
   "_neutral"],
  "name":
  "HarderNarasimhan.impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.toAddSubmonoid",
   "Module",
   "AddCommMonoid.toAddMonoid",
   "Submodule",
   "Submodule.setLike._proof_1",
   "AddSubsemigroup.carrier",
   "SetLike.mk",
   "AddCommMonoid",
   "AddZeroClass.toAdd",
   "AddSubmonoid.toAddSubsemigroup",
   "SetLike",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.setLike",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → SetLike (Submodule R M) M",
  "constCategory": "Definition"},
 {"references":
  ["Int.instCommSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Int",
   "Semiring"],
  "name": "Int.instSemiring",
  "constType": "Semiring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeSup.le_sSup",
   "PartialOrder.toPreorder",
   "SupSet.sSup",
   "Set",
   "LE.le",
   "Membership.mem",
   "CompleteSemilatticeSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "le_sSup",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, a ∈ s → a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references":
  ["SMul",
   "IsScalarTower",
   "HSMul.hSMul",
   "instHSMul",
   "Eq",
   "IsScalarTower.smul_assoc"],
  "name": "smul_assoc",
  "constType":
  "∀ {α : Type u_5} {M : Type u_9} {N : Type u_10} [inst : SMul M N] [inst_1 : SMul N α] [inst_2 : SMul M α]\n  [IsScalarTower M N α] (x : M) (y : N) (z : α), (x • y) • z = x • y • z",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Or.inr",
   "Decidable",
   "And",
   "Iff.mp",
   "iff_of_false",
   "And.rec",
   "Iff.intro",
   "And.intro",
   "Or.rec",
   "mt",
   "Or",
   "Or.inl",
   "Iff",
   "Iff.mpr",
   "iff_of_true",
   "dite"],
  "name": "Decidable.iff_iff_and_or_not_and_not",
  "constType": "∀ {a b : Prop} [Decidable b], (a ↔ b) ↔ a ∧ b ∨ ¬a ∧ ¬b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "le_sInf_iff",
   "Set",
   "Membership.mem",
   "CompleteSemilatticeInf",
   "Set.instMembership",
   "CompleteSemilatticeInf.toInfSet",
   "LE.le",
   "CompleteSemilatticeInf.toPartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.CompleteLattice.Defs.0._proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, (a ≤ sInf s) = ∀ b ∈ s, a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.SlopeLike.slopelike",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.SlopeLike μ] (x y z : ℒ)\n  (h : x < y ∧ y < z),\n  (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n    (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n      (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n        (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "LinearMap.ker",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "SemilinearMapClass",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "OfNat.ofNat",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Iff",
   "Submodule.mem_bot",
   "Zero.toOfNat0",
   "Eq",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "LinearMap.mem_ker",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {τ₁₂ : R →+* R₂} {F : Type u_11} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F τ₁₂ M M₂] {f : F} {y : M},\n  y ∈ LinearMap.ker f ↔ f y = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "Iff",
   "lt_of_not_le",
   "not_le_of_lt",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Preorder.toLE",
   "Iff.intro"],
  "name": "lt_iff_not_le",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrder α] {a b : α}, a < b ↔ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype.mk.injEq",
   "Eq.trans",
   "Nat.add_lt_add_right",
   "Fin.decLt",
   "_private.Init.Data.Nat.Lemmas.0._proof_13",
   "Nat.lt_succ_of_le",
   "Classical.propDecidable",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "Finite.of_fintype",
   "HarderNarasimhan.impl.function_wrapper_prop5",
   "False.elim",
   "letFun",
   "Eq.symm",
   "rfl",
   "instLTNat",
   "_private.Mathlib.Algebra.NeZero.0._proof_2",
   "Nat.lt_add_right",
   "Exists",
   "Exists.choose_spec",
   "Function.not_injective_iff",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Set.instMembership",
   "Fintype.card_lt_of_surjective_not_injective",
   "Nat.find_spec",
   "BoundedOrder.toOrderBot",
   "Antitone",
   "Classical.byContradiction",
   "Lattice",
   "Top.top",
   "setOf",
   "SetCoe.ext",
   "Set.Finite.fintype",
   "Nat.find",
   "Fintype.card_le_of_injective",
   "HarderNarasimhan.impl.function_wrapper_prop1",
   "instLTFin",
   "Fin.fintype",
   "Nat.instPreorder",
   "Nat.instNeZeroSucc",
   "le_rfl",
   "Fintype.card",
   "instOfNatNat",
   "Fin.mk",
   "Eq",
   "Preorder.toLE",
   "Set",
   "Function.Surjective",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Fin.instLinearOrder",
   "LinearOrder.toPartialOrder",
   "MulZeroClass.toZero",
   "Ne",
   "Finite.of_surjective",
   "dite",
   "le_of_not_lt",
   "And.casesOn",
   "Function.Injective",
   "PartialOrder.toPreorder",
   "Nat.succ_lt_succ_iff",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "Fin",
   "Fin.le_antisymm",
   "GE.ge",
   "And.intro",
   "not_false_eq_true",
   "Fin.val",
   "Nat.instMulZeroClass",
   "Eq.rec",
   "Nat.instLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "Fintype",
   "Bot.bot",
   "Exists.casesOn",
   "Nat",
   "Fin.mk.injEq",
   "Iff.mpr",
   "Nontrivial",
   "Mathlib.Tactic.PushNeg.not_le_eq",
   "le_bot_iff",
   "instDecidableAnd",
   "Eq.mp",
   "HarderNarasimhan.impl.function_wrapper_prop0'",
   "congrArg",
   "Set.mem_setOf",
   "Fintype.card_fin",
   "Nat.instOne",
   "Fin.is_le",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "Nat.decLe",
   "Exists.choose",
   "LT.lt",
   "ne_of_lt",
   "of_eq_true",
   "Nat.succ",
   "le_of_lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "lt_self_iff_false",
   "OrderTop.toTop",
   "instLENat"],
  "name": "HarderNarasimhan.impl.function_wrapper_prop4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ) (hf0 : f 0 = ⊤)\n  (atf : ∃ k, f k = ⊥) (hfat : Antitone f) (k : ℕ), f k = ⊥ → (∃ N, N + 1 ≤ k ∧ f N = f (N + 1)) → Nat.find ⋯ ≠ k",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.intCast_ofNat",
   "Ring.toSub",
   "AddGroup.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.zsmul_succ'",
   "Ring.toNonUnitalRing._proof_13",
   "AddCommMonoid.toAddMonoid",
   "Ring.intCast_negSucc",
   "Ring.zsmul_zero'",
   "Ring.sub_eq_add_neg",
   "Semiring.toNatCast",
   "AddCommGroup.mk",
   "Ring.toNonAssocRing._proof_18",
   "SubNegMonoid.mk",
   "Semiring.toNonUnitalSemiring",
   "Ring.toNeg",
   "Semiring.toOne",
   "Ring.toNonAssocRing._proof_17",
   "Ring.zsmul",
   "Ring.toNonUnitalRing._proof_14",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocRing",
   "Ring.zsmul_neg'",
   "Ring.neg_add_cancel",
   "NonUnitalNonAssocRing.mk",
   "Ring.toSemiring",
   "Ring.toNonUnitalRing._proof_10",
   "Ring.toNonUnitalRing._proof_12",
   "Ring.toIntCast",
   "Ring.toNonUnitalRing._proof_11",
   "Ring.toNonAssocRing._proof_16",
   "Ring.toNonAssocRing._proof_19",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocRing.mk",
   "Ring"],
  "name": "Ring.toNonAssocRing",
  "constType": "{α : Type u} → [Ring α] → NonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Nat",
   "Nat.instSuccAddOrder._proof_1",
   "Nat.instOne",
   "SuccAddOrder",
   "SuccAddOrder.mk",
   "Nat.instSuccOrder",
   "Nat.instPreorder"],
  "name": "Nat.instSuccAddOrder",
  "constType": "SuccAddOrder ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop → Type",
  "constCategory": "Other"},
 {"references":
  ["instLTNat",
   "Finset.range",
   "Finset.card",
   "Finset.card_range",
   "Fintype",
   "Finset.card_le_univ",
   "Nat.instPreorder",
   "Fintype.card",
   "Nat",
   "Nat.succ",
   "Eq.symm",
   "Nat.lt_succ_self",
   "Infinite.of_not_fintype",
   "Infinite",
   "LE.le.not_lt",
   "LT.lt.trans_eq"],
  "name": "instInfiniteNat",
  "constType": "Infinite ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "SubNegMonoid.zsmul_zero'._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Submodule.toAddSubmonoid",
   "SemilinearMapClass",
   "RingHomSurjective",
   "Module",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "Submodule.map._proof_4",
   "Submodule",
   "AddSubsemigroup.mk",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.map._proof_3",
   "Submodule.map._proof_1",
   "FunLike",
   "AddSubmonoid.mk",
   "Submodule.map._proof_2",
   "Set.image",
   "SetLike.coe",
   "AddZeroClass.toAdd",
   "AddSubmonoid",
   "Submodule.mk",
   "Submodule.setLike",
   "AddSubmonoid.map",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "Submodule.map",
  "constType":
  "{R : Type u_1} →\n  {R₂ : Type u_3} →\n    {M : Type u_5} →\n      {M₂ : Type u_7} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                [inst_4 : _root_.Module R M] →\n                  [inst_5 : _root_.Module R₂ M₂] →\n                    {σ₁₂ : R →+* R₂} →\n                      [RingHomSurjective σ₁₂] →\n                        {F : Type u_9} →\n                          [inst_7 : FunLike F M M₂] →\n                            [SemilinearMapClass F σ₁₂ M M₂] → F → Submodule R M → Submodule R₂ M₂",
  "constCategory": "Definition"},
 {"references": ["Add", "LE"],
  "name": "CanonicallyOrderedAdd",
  "constType": "(α : Type u_1) → [Add α] → [LE α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Semistable.rec",
   "HarderNarasimhan.Semistable.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.Semistable.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.Semistable μ → Sort u} →\n                (t : HarderNarasimhan.Semistable μ) →\n                  ((semistable :\n                        ∀ (x : ℒ) (hx : x ≠ ⊥),\n                          ¬HarderNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HarderNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "funext",
   "forall_congr",
   "Eq.symm",
   "sInf_le_sInf",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "_private.Mathlib.Data.Set.Basic.0._proof_18",
   "Prod.snd",
   "Prod",
   "HasSubset.Subset",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "Subtype",
   "Prod.fst",
   "congrArg",
   "congr",
   "_private.Init.PropLemmas.0._proof_12",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "lt_of_lt_of_le",
   "exists_prop_congr",
   "LT.lt",
   "Set.instHasSubset",
   "HarderNarasimhan.μA",
   "le_of_lt",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop2d6₀",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (x y z : ℒ) (h : x < y ∧ y < z),\n  HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "PartialOrder.toPreorder",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "LinearMap.mk",
   "Submodule.Quotient.module",
   "AddHom.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.map",
   "LinearEquiv",
   "DFunLike.coe",
   "Submodule",
   "LinearMap.semilinearMapClass",
   "Submodule.Quotient.addCommGroup",
   "Semiring.toNonAssocSemiring",
   "Submodule.quotientQuotientEquivQuotient._proof_17",
   "LinearMap.quotKerEquivRange._proof_6",
   "RingHom.id",
   "LinearEquiv.mk",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Preorder.toLE",
   "Submodule.quotientQuotientEquivQuotient._proof_20",
   "Submodule.mkQ",
   "Submodule.quotientQuotientEquivQuotientAux",
   "AddCommGroup",
   "LinearMap",
   "Submodule.quotientQuotientEquivQuotient._proof_19",
   "Submodule.quotientQuotientEquivQuotientAux._proof_14",
   "RingHomSurjective.ids",
   "Ring.toSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "LE.le",
   "RingHomInvPair.ids",
   "Submodule.mapQ",
   "Submodule.quotientQuotientEquivQuotient._proof_18",
   "Submodule.completeLattice",
   "AddCommGroup.toAddCommMonoid",
   "LinearMap.quotKerEquivRange._proof_3",
   "Submodule.quotientQuotientEquivQuotient._proof_21",
   "Ring"],
  "name": "Submodule.quotientQuotientEquivQuotient",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : _root_.Module R M] → (S T : Submodule R M) → S ≤ T → ((M ⧸ S) ⧸ Submodule.map S.mkQ T) ≃ₗ[R] M ⧸ T",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.mk_le_mk",
   "Subtype",
   "LE.le",
   "LE",
   "Subtype.mk",
   "Eq",
   "Subtype.le",
   "propext"],
  "name": "_private.Mathlib.Order.Basic.0._proof_34",
  "constType":
  "∀ {α : Type u_2} [inst : LE α] {p : α → Prop} {x y : α} {hx : p x} {hy : p y}, (⟨x, hx⟩ ≤ ⟨y, hy⟩) = (x ≤ y)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "SemilatticeSup.toPartialOrder",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "sup_le",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Max.max",
   "SemilatticeSup.toMax",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b c : HarderNarasimhan.Interval z), ↑a ≤ ↑c → ↑b ≤ ↑c → ↑a ⊔ ↑b ≤ ↑c",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidHom.mk",
   "RingHom",
   "RingHom.id._proof_31",
   "RingHom.id._proof_30",
   "MulZeroOneClass.toMulOneClass",
   "OneHom.mk",
   "MulOneClass.toOne",
   "NonAssocSemiring",
   "id",
   "RingHom.mk",
   "RingHom.id._proof_29",
   "RingHom.id._proof_28",
   "NonAssocSemiring.toMulZeroOneClass"],
  "name": "RingHom.id",
  "constType": "(α : Type u_5) → [inst : NonAssocSemiring α] → α →+* α",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddHom"],
  "name": "AddHom.toFun",
  "constType":
  "{M : Type u_10} → {N : Type u_11} → [inst : Add M] → [inst_1 : Add N] → (M →ₙ+ N) → M → N",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "Set.instHasSubset",
   "PartialOrder.toPreorder",
   "HasSubset.Subset",
   "Set",
   "LE.le",
   "InfSet.sInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "IsGLB.mono",
   "Preorder.toLE",
   "isGLB_sInf",
   "CompleteSemilatticeInf"],
  "name": "sInf_le_sInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s t : Set α}, s ⊆ t → sInf t ≤ sInf s",
  "constCategory": "Theorem"},
 {"references": ["_obj", "HarderNarasimhan.impl.lift_quot._rarg", "_neutral"],
  "name": "HarderNarasimhan.impl.lift_quot._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "GeneralizedCoheytingAlgebra.toLattice",
   "PartialOrder.toPreorder",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "OrderTop",
   "Preorder.toLE",
   "CoheytingAlgebra"],
  "name": "CoheytingAlgebra.toOrderTop",
  "constType": "{α : Type u_4} → [self : CoheytingAlgebra α] → OrderTop α",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakSlopeLike₂.casesOn",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "HarderNarasimhan.WeakSlopeLike₂.noConfusionType"],
  "name": "HarderNarasimhan.WeakSlopeLike₂.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.WeakSlopeLike₂ μ} →\n                  v1 = v2 → HarderNarasimhan.WeakSlopeLike₂.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["FunLike", "outParam"],
  "name": "EmbeddingLike",
  "constType":
  "(F : Sort u_1) → (α : outParam (Sort u_2)) → (β : outParam (Sort u_3)) → [FunLike F α β] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Iff.trans",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "And",
   "and_true",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "SemilatticeInf",
   "le_antisymm_iff",
   "iff_self",
   "of_eq_true",
   "Min.min",
   "congr",
   "Iff",
   "_private.Mathlib.Order.Lattice.0._proof_17",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "_private.Mathlib.Order.Lattice.0._proof_18",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_eq_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Bot.bot",
   "OfNat.ofNat",
   "Nat",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.function_wrapper.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ) (atf : ∃ k, f k = ⊥),\n  HarderNarasimhan.impl.function_wrapper f atf 0 = ⊤",
  "constCategory": "Theorem"},
 {"references": ["True", "eq_true", "Eq", "trivial"],
  "name": "implies_true",
  "constType": "∀ (α : Sort u), (∀ (a : α), True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "HarderNarasimhan.μA_DescendingChainCondition.rec",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HarderNarasimhan.μA_DescendingChainCondition.mk",
   "Nat",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μA_DescendingChainCondition.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.μA_DescendingChainCondition μ → Sort u} →\n                (t : HarderNarasimhan.μA_DescendingChainCondition μ) →\n                  ((μ_dcc :\n                        ∀ (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n                          (∀ (n : ℕ), f n > f (n + 1)) →\n                            ∃ N, HarderNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(a, f N), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.WeakAscendingChainCondition.casesOn",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HarderNarasimhan.WeakAscendingChainCondition.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u →\n                HarderNarasimhan.WeakAscendingChainCondition μ → HarderNarasimhan.WeakAscendingChainCondition μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "Exists",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "Module",
   "Submodule.instTop",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "IsNoetherianRing",
   "Nat",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.CoprimaryFiltration",
   "Nontrivial",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Eq",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.fin_len",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (self : HarderNarasimhan.CoprimaryFiltration R M), ∃ n, self.filtration n = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instCommRing",
   "CommRing.toRing",
   "Nat",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toAddMonoidWithOne",
   "CharZero.mk",
   "CharZero",
   "Int.ofNat.inj",
   "Int"],
  "name": "Int.instCharZero",
  "constType": "CharZero ℤ",
  "constCategory": "Theorem"},
 {"references":
  ["ClosureOperator.isClosed_iff",
   "ClosureOperator.instFunLike",
   "OrderHom.toFun",
   "PartialOrder.toPreorder",
   "ClosureOperator.IsClosed",
   "PartialOrder",
   "Iff.mp",
   "ClosureOperator.toOrderHom",
   "ClosureOperator",
   "Eq",
   "DFunLike.coe"],
  "name": "ClosureOperator.IsClosed.closure_eq",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {c : ClosureOperator α} {x : α}, c.IsClosed x → c x = x",
  "constCategory": "Theorem"},
 {"references": ["Lean.Syntax"],
  "name": "autoParam",
  "constType": "Sort u → Syntax → Sort u",
  "constCategory": "Definition"},
 {"references": ["Set", "Finite", "Set.Elem"],
  "name": "Set.Finite",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["Quotient", "Setoid", "Setoid.r", "Quot.out"],
  "name": "Quotient.out",
  "constType": "{α : Sort u_1} → {s : Setoid α} → Quotient s → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "Iff",
   "LE.le",
   "And",
   "Preorder.toLT",
   "Preorder.toLE"],
  "name": "Preorder.lt_iff_le_not_le",
  "constType":
  "∀ {α : Type u_2} [self : Preorder α] (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakDescendingChainCondition.mk",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    HarderNarasimhan.WeakDescendingChainCondition μ",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Bool.false",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "Ring.toSemiring",
   "HarderNarasimhan.impl.HNFil_of_fin_len",
   "Linarith.mul_neg",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Top.top",
   "Int.negOfNat",
   "Int.instCharZero",
   "lt_top_iff_ne_top",
   "Nat.find",
   "Mathlib.Tactic.Ring.add_mul",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "HarderNarasimhan.impl.HNFil_is_strict_mono",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Preorder.toLT",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_zero",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "HarderNarasimhan.StI",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "le_top",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "le_of_lt",
   "HarderNarasimhan.Convex_of_Convex_large",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Bool",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "WellFoundedGT",
   "Mathlib.Tactic.Ring.mul_add",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "HarderNarasimhan.impl.prop3d7₂",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HarderNarasimhan.μA",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "Nat.find_min",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Mathlib.Tactic.Ring.zero_mul",
   "lt_trans",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "bot_le",
   "HMul.hMul",
   "Int.rawCast",
   "HarderNarasimhan.impl.HNFil_prop_of_def",
   "AddMonoidWithOne.toAddMonoid",
   "And.intro",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "HarderNarasimhan.TotIntvl",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "upperBounds",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "HarderNarasimhan.impl.HNFil",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.impl.HNFil_μA_pseudo_strict_anti",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (i : ℕ) (hi : i + 1 < Nat.find ⋯),\n  ¬HarderNarasimhan.μA μ ⟨(HarderNarasimhan.impl.HNFil μ i, HarderNarasimhan.impl.HNFil μ (i + 1)), ⋯⟩ ≤\n      HarderNarasimhan.μA μ ⟨(HarderNarasimhan.impl.HNFil μ (i + 1), HarderNarasimhan.impl.HNFil μ (i + 2)), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.μ_Admissible.mk",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.μ_Admissible.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨ ∀ (I : { p // p.1 < p.2 }), HarderNarasimhan.IsAttained μ I) →\n    HarderNarasimhan.μ_Admissible μ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "LinearOrder.min_def._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Subsingleton", "Subsingleton.intro", "Subsingleton.elim", "funext"],
  "name": "Pi.instSubsingleton",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} [∀ (a : α), Subsingleton (β a)], Subsingleton ((a : α) → β a)",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "RingHomCompTriple.ids",
   "CommSemiring.toSemiring",
   "CommRing",
   "RingHomCompTriple"],
  "name": "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_10",
  "constType":
  "∀ {R : Type} [inst : CommRing R], RingHomCompTriple (RingHom.id R) (RingHom.id R) (RingHom.id R)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "Preorder.le_trans",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "SemilatticeSup.toPartialOrder",
   "compareOfLessAndEq",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "instDistribLatticeOfLinearOrder",
   "PartialOrder.mk",
   "decidableLTOfDecidableLE",
   "Preorder.le_refl",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_25",
   "Classical.decRel",
   "LT.mk",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_28",
   "Lattice.toSemilatticeInf",
   "CompleteLattice.toLattice",
   "LinearOrder",
   "decidableEqOfDecidableLE",
   "Ordering",
   "PartialOrder.le_antisymm",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_27",
   "LT.lt",
   "DistribLattice.toLattice",
   "Eq.refl",
   "LE.mk",
   "LE.le",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_26",
   "Preorder.mk",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Preorder.lt_iff_le_not_le"],
  "name":
  "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_29",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α),\n  compareOfLessAndEq a b = compareOfLessAndEq a b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "Lean.Omega.combo_sat'",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "HarderNarasimhan.impl.instμ_Admissible",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "Option.none",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "instHSub",
   "PartialOrder.toPreorder",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "Nat.lt_of_not_le",
   "Nontrivial",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.cast",
   "instDecidableAnd",
   "Subtype",
   "HarderNarasimhan.impl.HNFil",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HarderNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HarderNarasimhan.Convex μ) (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (n : ℕ)\n  (h₂ : ∃ N ≥ n + 1, HarderNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n  Nat.find h₂ ≤ Nat.find hffin → ¬Nat.find h₂ - 1 ≤ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "True",
   "Membership.mem",
   "eq_true",
   "SetLike",
   "SetLike.coe_mem",
   "Eq",
   "Subtype.val"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_32",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} (x : ↥p), (↑x ∈ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "OrderTop",
   "LT.lt",
   "PartialOrder",
   "Iff",
   "Top.top",
   "Preorder.toLE",
   "Eq",
   "lt_top_iff_ne_top",
   "Iff.not_left",
   "OrderTop.toTop"],
  "name": "not_lt_top_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, ¬a < ⊤ ↔ a = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["IsStrictOrderedRing",
   "Lattice.toSemilatticeInf",
   "Int.instSemiring",
   "Int.instNontrivial",
   "Int.instIsOrderedAddMonoid",
   "Int.mul_pos",
   "IsStrictOrderedRing.of_mul_pos",
   "Int.instZeroLEOneClass",
   "Int.instRing",
   "instLatticeInt",
   "SemilatticeInf.toPartialOrder",
   "Int"],
  "name": "Int.instIsStrictOrderedRing",
  "constType": "IsStrictOrderedRing ℤ",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "And.intro",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "sInf_le_sInf",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "setOf",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "Prod.fst",
   "le_rfl",
   "Preorder.toLE",
   "Eq",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "sInf_le",
   "LT.lt",
   "ne_of_lt",
   "HarderNarasimhan.μA",
   "Min.min",
   "le_of_lt",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.lem2d4₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (x w : ℒ) (hxw : ¬x ≤ w) (u : ℒ) (huxw : u ≤ x ⊓ w),\n  HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HarderNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._proof_11",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "HarderNarasimhan.S₀_order",
   "Finset",
   "Eq.trans",
   "Submodule.Quotient.module",
   "Singleton.singleton",
   "Set.toFinset_subset_toFinset",
   "LinearMap.toAddHom",
   "Exists.intro",
   "SMulZeroClass.toSMul",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Subtype.val",
   "AssociatePrimes.mem_iff",
   "RingHom.id",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "AddHom.toFun",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_1",
   "HarderNarasimhan.S",
   "LinearMap.ker",
   "Exists",
   "ClosureOperator.IsClosed",
   "Submodule.addCommGroup",
   "Prod.snd",
   "LinearMap",
   "Ring.toSemiring",
   "Set.instMembership",
   "Prod",
   "Submodule.comap",
   "HarderNarasimhan.InIntvl",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LinearMap.quotientInfEquivSupQuotient",
   "Eq.refl",
   "Iff",
   "RingHomInvPair.ids",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "Submodule.instMin",
   "CompleteLattice.toBoundedOrder",
   "AddMonoid.toAddZeroClass",
   "setOf",
   "DFinsupp.instEquivLikeLinearEquiv",
   "Submodule.hasQuotient",
   "RelEmbedding.toEmbedding",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.Quotient.instZeroQuotient",
   "HarderNarasimhan.coe'",
   "AddCommMonoid.toAddMonoid",
   "and_true",
   "Prod.fst",
   "SemilinearEquivClass.instSemilinearMapClass",
   "Ideal.ext",
   "EquivLike.toFunLike",
   "AddCommMagma.toAdd",
   "HarderNarasimhan._μ",
   "map_zero",
   "LinearEquiv.instEquivLike",
   "Preorder.toLE",
   "Eq",
   "propext",
   "CompleteLattice.toConditionallyCompleteLattice",
   "inf_lt_left",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "LinearExtension",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Set.toFinset",
   "LinearEquiv.toLinearMap",
   "AddCommGroup",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "eq_self",
   "CommRing.toRing",
   "Module.toDistribMulAction",
   "Max.max",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan._μ._proof_2",
   "Submodule.completeLattice",
   "HarderNarasimhan.S₀",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Module.Finite",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.instLES₀",
   "Ideal.IsPrime",
   "Prod.mk",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "Subtype.preorder",
   "Submodule.subtype",
   "DistribMulActionSemiHomClass.toAddMonoidHomClass",
   "LinearMap.semilinearMapClass",
   "And.intro",
   "Semiring.toNonAssocSemiring",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "HarderNarasimhan.Convex",
   "Semiring.toModule",
   "DistribSMul.toSMulZeroClass",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "And.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "DistribMulAction.toDistribSMul",
   "And",
   "HarderNarasimhan.TotIntvl",
   "Exists.casesOn",
   "LinearEquiv.instSemilinearEquivClass",
   "Finset.instSingleton",
   "Iff.of_eq",
   "HasSubset.Subset",
   "Iff.mpr",
   "HSMul.hSMul",
   "Nontrivial",
   "id",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "SemilatticeInf.toMin",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Subtype",
   "Eq.mp",
   "LinearEquiv.map_smul",
   "Submodule.module",
   "SemilatticeSup.toPartialOrder",
   "Function.Embedding.toFun",
   "RingHom.instFunLike",
   "HarderNarasimhan.ConvexI.mk",
   "LinearEquiv",
   "DFunLike.coe",
   "Iff.intro",
   "congrArg",
   "Submodule",
   "LinearEquiv.map_eq_zero_iff",
   "Submodule.Quotient.addCommGroup",
   "instDistribLatticeOfLinearOrder",
   "Ideal",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "AddCommSemigroup.toAddCommMagma",
   "Subtype.le",
   "Set.instLE",
   "Not",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "True",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_2",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "CommSemiring.toSemiring",
   "AddMonoidHomClass.toZeroHomClass",
   "IsAssociatedPrime._proof_1",
   "Semiring.toMonoidWithZero",
   "Finset.instHasSubset",
   "IsAssociatedPrime",
   "CommRing",
   "exists_prop_congr",
   "LT.lt",
   "Set.instHasSubset",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "of_eq_true",
   "AddCommMonoid.toAddCommSemigroup",
   "Min.min",
   "Submodule.setLike",
   "SemilatticeSup.toMax",
   "LE.le",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_3",
   "Subtype.mk",
   "Submodule.addCommMonoid",
   "SemilinearMapClass.distribMulActionSemiHomClass",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.impl.prop3d11",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  HarderNarasimhan.Convex (HarderNarasimhan.μ R M)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Unique",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toSemilatticeInf",
   "Finset",
   "True",
   "Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "LinearOrder",
   "Finset.singleton_nonempty",
   "congrArg",
   "eq_self",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "Finset.instSingleton",
   "Finset.min'",
   "of_eq_true",
   "Eq.refl",
   "Finset.instMembership",
   "id",
   "Finset.inf'_congr",
   "Eq.rec",
   "Eq",
   "Finset.Nonempty",
   "Finset.inf'"],
  "name": "Finset.min'_singleton",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrder α] (a : α), {a}.min' ⋯ = a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "CompleteLattice",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLattice.toTop",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "HarderNarasimhan.WeakDescendingChainCondition'.rec",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "HarderNarasimhan.WeakDescendingChainCondition'.mk",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition'.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakDescendingChainCondition' μ → Sort u} →\n                (t : HarderNarasimhan.WeakDescendingChainCondition' μ) →\n                  ((wdcc' : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.find",
   "PartialOrder.toPreorder",
   "Classical.propDecidable",
   "Preorder.toLT",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Exists",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.impl.function_wrapper._proof_6",
   "HarderNarasimhan.impl.JHFil.match_1",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Bot.bot",
   "Unit",
   "LT.lt",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "dite",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.function_wrapper._sunfold",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [inst_1 : BoundedOrder ℒ] → (f : ℕ → ℒ) → (∃ k, f k = ⊥) → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["Nat", "OfNat", "Nat.cast", "OfNat.mk", "Nat.AtLeastTwo", "NatCast"],
  "name": "instOfNatAtLeastTwo",
  "constType":
  "{R : Type u_1} → {n : ℕ} → [NatCast R] → [n.AtLeastTwo] → OfNat R n",
  "constCategory": "Definition"},
 {"references": ["List.nil", "List.Chain"],
  "name": "List.Chain.nil",
  "constType": "∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []",
  "constCategory": "Other"},
 {"references":
  ["RingHom",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Module",
   "LinearMap",
   "LinearEquiv",
   "RingHomInvPair",
   "Semiring"],
  "name": "LinearEquiv.toLinearMap",
  "constType":
  "{R : Type u_12} →\n  {S : Type u_13} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        {σ : R →+* S} →\n          {σ' : S →+* R} →\n            [inst_2 : RingHomInvPair σ σ'] →\n              [inst_3 : RingHomInvPair σ' σ] →\n                {M : Type u_14} →\n                  {M₂ : Type u_15} →\n                    [inst_4 : AddCommMonoid M] →\n                      [inst_5 : AddCommMonoid M₂] →\n                        [inst_6 : _root_.Module R M] → [inst_7 : _root_.Module S M₂] → (M ≃ₛₗ[σ] M₂) → M →ₛₗ[σ] M₂",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.impl.prop2d8₁I",
   "Prod.mk",
   "Preorder.toLT",
   "HarderNarasimhan.impl.prop2d8₂I",
   "GE.ge",
   "Prod.fst",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "HarderNarasimhan.IsComparable",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "SemilatticeSup.toMax",
   "HarderNarasimhan.in_TotIntvl",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "lt_sup_of_lt_left",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_2_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Convex μ →\n    ∀ (x y u : ℒ) (h : u < x ∧ u < y),\n      HarderNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩ ≥ HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ⊓ HarderNarasimhan.μA μ ⟨(u, y), ⋯⟩ ∧\n        (HarderNarasimhan.IsComparable (HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩) (HarderNarasimhan.μA μ ⟨(u, y), ⋯⟩) ∨\n            HarderNarasimhan.IsAttained μ ⟨(u, x ⊔ y), ⋯⟩ →\n          HarderNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩ ≥ HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ∨\n            HarderNarasimhan.μA μ ⟨(u, x ⊔ y), ⋯⟩ ≥ HarderNarasimhan.μA μ ⟨(u, y), ⋯⟩)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "le_of_lt",
   "not_le_of_lt",
   "le_trans",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLT",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Top.top", "LE", "OrderTop", "OrderTop.toTop"],
  "name": "OrderTop.le_top",
  "constType":
  "∀ {α : Type u} {inst : LE α} [self : OrderTop α] (a : α), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["True",
   "Eq.trans",
   "instHAdd",
   "add_sub_cancel_right",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "of_eq_true",
   "SubNegMonoid.toSub",
   "Eq.symm",
   "HSub.hSub",
   "AddGroup",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "instHSub",
   "AddMonoid.toAddZeroClass"],
  "name": "eq_sub_of_add_eq",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, a + c = b → a = b - c",
  "constCategory": "Theorem"},
 {"references": ["rfl", "True", "eq_true", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references": ["SDiff"],
  "name": "SDiff.sdiff",
  "constType": "{α : Type u} → [self : SDiff α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Singleton.singleton",
   "AddCommGroup.toAddGroup",
   "Membership.mem",
   "Submodule.span",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "iff_self",
   "forall_congr",
   "funext",
   "AddGroup.toSubNegMonoid",
   "Semiring.toModule",
   "Submodule.annihilator",
   "DistribSMul.toSMulZeroClass",
   "Module.mem_support_iff_exists_annihilator._proof_3",
   "Module.mem_support_iff_exists_annihilator._proof_2",
   "Exists",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "DistribMulAction.toDistribSMul",
   "Set.instMembership",
   "Eq.refl",
   "Iff",
   "HSMul.hSMul",
   "id",
   "NegZeroClass.toZero",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass",
   "SetLike.instPartialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddCommMonoid.toAddMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Ideal",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "PrimeSpectrum.asIdeal",
   "Zero.toOfNat0",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Module.mem_support_iff'",
   "Not",
   "CommRing.toCommSemiring",
   "True",
   "Set",
   "Module.support",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "CommRing",
   "Set.instSingletonSet",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "Module.toDistribMulAction",
   "of_eq_true",
   "AddCommGroup.toDivisionAddCommMonoid",
   "SubNegMonoid.toAddMonoid",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Ne",
   "Module.mem_support_iff_exists_annihilator._proof_4"],
  "name": "Module.mem_support_iff_exists_annihilator",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  {p : PrimeSpectrum R}, p ∈ Module.support R M ↔ ∃ m, (Submodule.span R {m}).annihilator ≤ p.asIdeal",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.μB",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "And.intro",
   "SupSet.sSup",
   "HarderNarasimhan.μBstar",
   "letFun",
   "sSup_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "HarderNarasimhan.in_TotIntvl",
   "lt_top_iff_ne_top",
   "setOf",
   "HarderNarasimhan.μAstar",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Ne.symm",
   "Subtype",
   "le_trans",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.TotIntvl._proof_1",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Prod.fst",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.impl.rmk4d10₀",
   "InfSet.sInf",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.μmax._proof_2",
   "sInf_le",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "HarderNarasimhan.μA",
   "LE.le",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.impl.prop4d11₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl →\n    HarderNarasimhan.μBstar μ ≤ HarderNarasimhan.μAstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition'",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Module",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Eq",
   "DistribSMul.toSMulZeroClass",
   "Distrib.toAdd",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "HAdd.hAdd",
   "Module.toDistribMulAction",
   "AddCommMonoid.toAddCommSemigroup",
   "HSMul.hSMul",
   "Module.add_smul",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "add_smul",
  "constType":
  "∀ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (r s : R)\n  (x : M), (r + s) • x = r • x + s • x",
  "constCategory": "Theorem"},
 {"references": ["Quotient", "Setoid", "Quotient.mk"],
  "name": "Quotient.mk''",
  "constType": "{α : Sort u_1} → {s₁ : Setoid α} → α → Quotient s₁",
  "constCategory": "Definition"},
 {"references":
  ["Quotient.mk''",
   "Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.quotientRel",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "Submodule",
   "Ring.toSemiring",
   "Ring"],
  "name": "Submodule.Quotient.mk",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : _root_.Module R M] → {p : Submodule R M} → M → M ⧸ p",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Eq.rec", "Eq", "LT"],
  "name": "lt_of_lt_of_eq",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LT α], a < b → b = c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "RingHom",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Module",
   "outParam",
   "Semiring"],
  "name": "SemilinearMapClass",
  "constType":
  "(F : Type u_14) →\n  {R : outParam (Type u_15)} →\n    {S : outParam (Type u_16)} →\n      [inst : Semiring R] →\n        [inst_1 : Semiring S] →\n          outParam (R →+* S) →\n            (M : outParam (Type u_17)) →\n              (M₂ : outParam (Type u_18)) →\n                [inst_2 : AddCommMonoid M] →\n                  [inst_3 : AddCommMonoid M₂] → [_root_.Module R M] → [_root_.Module S M₂] → [FunLike F M M₂] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "AddZeroClass.toZero",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "zero_add",
   "AddZeroClass.toAdd",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_pf_zero_add",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 + b = b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "Exists",
   "SetLike.instMembership",
   "RingHomSurjective",
   "SemilinearMapClass",
   "Module",
   "Submodule.map",
   "Membership.mem",
   "And",
   "DFunLike.coe",
   "Submodule",
   "Submodule.mem_map",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_22",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} [inst_6 : RingHomSurjective σ₁₂] {F : Type u_9} [inst_7 : FunLike F M M₂]\n  [inst_8 : SemilinearMapClass F σ₁₂ M M₂] {f : F} {p : Submodule R M} {x : M₂},\n  (x ∈ Submodule.map f p) = ∃ y ∈ p, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "Subtype.val",
   "Set.range",
   "Set.Elem",
   "congrArg",
   "_private.Init.Data.Subtype.0._proof_2",
   "letFun",
   "Subtype.property",
   "funext",
   "Eq",
   "Finite",
   "propext",
   "Exists",
   "Set",
   "Set.finite_range",
   "exists_prop_congr",
   "Set.instMembership",
   "Set.Finite.to_subtype",
   "Iff.of_eq",
   "Iff.mpr",
   "Eq.refl",
   "Subtype.mk",
   "Set.Finite",
   "setOf"],
  "name": "Set.Finite.dependent_image",
  "constType":
  "∀ {α : Type u} {β : Type v} {s : Set α},\n  s.Finite → ∀ (F : (i : α) → i ∈ s → β), {y | ∃ x, ∃ (hx : x ∈ s), F x hx = y}.Finite",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteLattice.toTop",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.cor3d3",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.corollary_3_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Convex μ →\n    (∀ (f : ℕ → ℒ) (h : ∀ (n : ℕ), f n > f (n + 1)), ∃ N, HarderNarasimhan.μA μ ⟨(f (N + 1), f N), ⋯⟩ = ⊤) →\n      HarderNarasimhan.μA_DescendingChainCondition μ",
  "constCategory": "Theorem"},
 {"references":
  ["StarRing",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "HMul.hMul",
   "MulZeroOneClass.toMulOneClass",
   "StarMul.toInvolutiveStar",
   "AddCommMonoid.toAddMonoid",
   "StarOrderedRing",
   "StarRing.toStarAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "MulOneClass.toOne",
   "PartialOrder",
   "star_one",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "MulOneClass.toMul",
   "Preorder.toLE",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring.toNonUnitalSemiring",
   "NonAssocSemiring.toMulZeroOneClass",
   "Star.star",
   "NonUnitalNonAssocSemiring.toDistrib",
   "StarAddMonoid.toInvolutiveStar",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "ZeroLEOneClass.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "mul_one",
   "star_mul_self_nonneg",
   "OfNat.ofNat",
   "ZeroLEOneClass",
   "One.toOfNat1",
   "StarRing.toStarMul",
   "MulZeroClass.toZero",
   "InvolutiveStar.toStar",
   "AddMonoidWithOne.toOne",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "instHMul",
   "Semiring"],
  "name": "instZeroLEOneClass",
  "constType":
  "∀ {R : Type u} [inst : Semiring R] [inst_1 : PartialOrder R] [inst_2 : StarRing R] [StarOrderedRing R], ZeroLEOneClass R",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "SemilinearMapClass",
   "Submodule.mem_comap",
   "Module",
   "Membership.mem",
   "DFunLike.coe",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.CP_HN._proof_27",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} {x : M} {F : Type u_9} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F σ₁₂ M M₂] {f : F}\n  {p : Submodule R₂ M₂}, (x ∈ Submodule.comap f p) = (f x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_2",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_4",
   "CompleteLattice.mk",
   "_obj",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Lattice.mk",
   "Subtype.partialOrder",
   "SemilatticeSup.mk",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_1",
   "_neutral",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_3",
   "CompleteLattice.instOmegaCompletePartialOrder._rarg"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Or.inr",
   "Or.rec",
   "Or.imp_right",
   "Or.inl",
   "Or",
   "Or.imp_left",
   "Iff",
   "Function.comp",
   "Iff.intro"],
  "name": "or_assoc",
  "constType": "∀ {a b c : Prop}, (a ∨ b) ∨ c ↔ a ∨ b ∨ c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Exists",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.fin_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ]\n  (self : HarderNarasimhan.HarderNarasimhanFiltration μ), ∃ n, self.filtration n = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Finset",
   "instCommutativeMin_mathlib",
   "OrderTop",
   "instAssociativeMin_mathlib",
   "SemilatticeInf",
   "Min.min",
   "Finset.fold",
   "Top.top",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "Finset.inf",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : SemilatticeInf α] → [OrderTop α] → Finset β → (β → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "SemilinearMapClass",
   "LinearMap.instFunLike",
   "Module",
   "LinearMap.toAddHom",
   "RingHom.instFunLike",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "SemilinearMapClass.mk",
   "DFunLike.coe",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "LinearMap.map_smul'",
   "DistribSMul.toSMulZeroClass",
   "AddZeroClass.toZero",
   "outParam",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "LinearMap",
   "Module.toDistribMulAction",
   "AddHom.map_add'",
   "AddCommMonoid.toAddCommSemigroup",
   "MulActionSemiHomClass.mk",
   "AddHomClass.mk",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "LinearMap.semilinearMapClass",
  "constType":
  "∀ {R : Type u_1} {S : Type u_5} {M : Type u_8} {M₃ : Type u_11} [inst : Semiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₃] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module S M₃]\n  {σ : R →+* S}, SemilinearMapClass (M →ₛₗ[σ] M₃) σ M M₃",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.natCast_succ",
   "Semiring.mul_one",
   "Semiring.natCast_zero",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "NonAssocSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNonUnitalSemiring",
   "Semiring.one_mul",
   "Semiring"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["Sub"],
  "name": "Sub.mk",
  "constType": "{α : Type u} → (α → α → α) → Sub α",
  "constCategory": "Other"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LT α",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "AddGroup"],
  "name": "AddGroup.toSubNegMonoid",
  "constType": "{A : Type u} → [self : AddGroup A] → SubNegMonoid A",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompleteLinearOrder",
  "constType": "Type u_8 → Type u_8",
  "constCategory": "Other"},
 {"references":
  ["rfl",
   "Set",
   "Membership.mem",
   "Exists.intro",
   "Eq",
   "Set.range",
   "Set.instMembership"],
  "name": "Set.mem_range_self",
  "constType":
  "∀ {α : Type u} {ι : Sort u_1} {f : ι → α} (i : ι), f i ∈ Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Subtype.mk_lt_mk",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.μB",
   "Subtype.val",
   "Subtype.coe_inj",
   "And.intro",
   "Subtype.GCongr.coe_lt_coe",
   "SupSet.sSup",
   "funext",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "lt_iff_le_not_le",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Iff.of_eq",
   "HarderNarasimhan.μB_res_intvl._proof_20",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Set.ext",
   "HarderNarasimhan.μmin_res_intvl",
   "Eq.mpr",
   "setOf",
   "Subtype",
   "Subtype.lt",
   "le_trans",
   "and_true",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "HarderNarasimhan.Resμ",
   "Iff.intro",
   "Prod.fst",
   "congrArg",
   "Subtype.prop",
   "HarderNarasimhan.μmin",
   "congr",
   "Subtype.property",
   "HarderNarasimhan.Interval",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "HarderNarasimhan.instBoundedOrderInterval",
   "HarderNarasimhan.μmax._proof_2",
   "exists_prop_congr",
   "LT.lt",
   "eq_self",
   "HarderNarasimhan.instNontrivialInterval",
   "SupSet",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μB_res_intvl",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {I : { p // p.1 < p.2 }} {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} {J : { p // p.1 < p.2 }},\n  HarderNarasimhan.μB (HarderNarasimhan.Resμ I μ) J = HarderNarasimhan.μB μ ⟨(↑(↑J).1, ↑(↑J).2), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "Preorder.lt_iff_le_not_le._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "CompleteLattice.toLattice",
   "LinearOrder",
   "SemilatticeSup.toPartialOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "PartialOrder.le_antisymm",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_28",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "LinearMap.instFunLike",
   "Module",
   "Membership.mem",
   "Iff.mp",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "Submodule",
   "Iff.intro",
   "LinearMap.semilinearMapClass",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "LinearMap.ext",
   "Eq.symm",
   "Zero.toOfNat0",
   "Eq.rec",
   "Eq",
   "LinearMap.instZero",
   "LinearMap.ker",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Submodule.instTop",
   "LinearMap",
   "LinearMap.ker_zero",
   "OfNat.ofNat",
   "Submodule.setLike",
   "Iff",
   "Top.top",
   "trivial",
   "LinearMap.mem_ker",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "LinearMap.ker_eq_top",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂}, LinearMap.ker f = ⊤ ↔ f = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring.toDistrib",
   "True",
   "Eq.trans",
   "Distrib.toMul",
   "CommSemiring",
   "MulZeroClass.toMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "OfNat.ofNat",
   "congrArg",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Zero.toOfNat0",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.mul_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "HarderNarasimhan.CoprimaryFiltration.piecewise_coprimary",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Submodule.addCommGroup",
   "PrimeSpectrum.mk",
   "LinearMap",
   "Set.instMembership",
   "Nat",
   "Nontrivial",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "HarderNarasimhan.CoprimaryFiltration.fin_len",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "Submodule.hasQuotient",
   "Nat.find",
   "associatedPrimes",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "ExistsUnique.exists",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "instDistribLatticeOfLinearOrder",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "instHAdd",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Submodule.instTop",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "CommRing",
   "Exists.choose",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "PrimeSpectrum",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.strict_mono_associated_prime",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (self : HarderNarasimhan.CoprimaryFiltration R M) (n : ℕ) (hn : n + 1 < Nat.find ⋯),\n  { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.impl.instμ_Admissible",
   "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration",
   "Preorder.toLT",
   "Unique.mk",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Unique",
   "HarderNarasimhan.instUniqueHarderNarasimhanFiltration._proof_3",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Lattice",
   "Nontrivial"],
  "name": "HarderNarasimhan.instUniqueHarderNarasimhanFiltration",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLinearOrder S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] → Unique (HarderNarasimhan.HarderNarasimhanFiltration μ)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Preorder",
   "LE.le",
   "Preorder.toLT",
   "OrderEmbedding.lt_iff_lt",
   "Eq",
   "Preorder.toLE",
   "OrderEmbedding",
   "DFunLike.coe",
   "RelEmbedding.instFunLike",
   "propext"],
  "name": "_private.Mathlib.Order.Hom.Basic.0._proof_51",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α ↪o β) {a b : α}, (f a < f b) = (a < b)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "instOfNatNat",
   "instHAdd",
   "Nat.lt.base",
   "OfNat.ofNat"],
  "name": "Nat.lt_add_one",
  "constType": "∀ (n : ℕ), n < n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "HarderNarasimhan.semistableI",
   "Exists.intro",
   "Membership.mem.out",
   "HarderNarasimhan.S₂I",
   "Subtype.val",
   "HarderNarasimhan.S₁I",
   "SupSet.sSup",
   "HarderNarasimhan.S₁I._proof_1",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Subtype.coe_eta",
   "Eq.symm",
   "Eq.ndrec",
   "rfl",
   "Exists",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "Set.setOf_app_iff",
   "Set.instMembership",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Iff",
   "Eq.refl",
   "Lattice",
   "Set.ext",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "HarderNarasimhan.Semistable",
   "setOf",
   "HarderNarasimhan.impl.smart_helper",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "le_rfl",
   "congr",
   "InfSet.sInf",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Set",
   "HarderNarasimhan.instBoundedOrderInterval",
   "lt_of_eq_of_lt",
   "HarderNarasimhan.μA",
   "SupSet",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "And.casesOn",
   "HarderNarasimhan.μA._proof_3",
   "InfSet",
   "PartialOrder.toPreorder",
   "lt_of_lt_of_eq",
   "Set.mem_def",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Iff.mp",
   "GT.gt",
   "HarderNarasimhan.μmax",
   "And.intro",
   "PartialOrder",
   "forall_congr",
   "funext",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "HarderNarasimhan.TotIntvl",
   "Exists.casesOn",
   "Subtype.coe_eq_of_eq_mk",
   "Iff.of_eq",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "HarderNarasimhan.StI",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Iff.intro",
   "congrArg",
   "Subtype.prop",
   "HarderNarasimhan.Interval",
   "HarderNarasimhan.Resμ._proof_19",
   "HarderNarasimhan.impl.semistable_iff",
   "Not",
   "Lattice.toSemilatticeInf",
   "Prod.mk.eta",
   "HarderNarasimhan.μmax._proof_2",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "HarderNarasimhan.instNontrivialInterval",
   "ne_of_lt",
   "le_of_lt",
   "LE.le",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39",
   "Subtype.coe_ne_coe"],
  "name": "HarderNarasimhan.impl.semistableI_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.semistableI μ I ↔ HarderNarasimhan.Semistable (HarderNarasimhan.Resμ I μ)",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.rec", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p), (∀ (w : α) (h : p w), motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references": ["Unique", "Unique.toInhabited", "Eq", "Inhabited.default"],
  "name": "Unique.uniq",
  "constType": "∀ {α : Sort u} (self : Unique α) (a : α), a = default",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "Subtype.property",
   "Subtype.ext",
   "Subtype.mk",
   "Eq.rec",
   "Eq",
   "Subtype.val"],
  "name": "Subtype.coe_eq_of_eq_mk",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a : { a // p a }} {b : α} (h : ↑a = b), a = ⟨b, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.instSingleton",
   "Finset.mk",
   "Finset",
   "Singleton.singleton",
   "Singleton.mk",
   "Multiset.nodup_singleton",
   "Multiset",
   "Singleton"],
  "name": "Finset.instSingleton",
  "constType": "{α : Type u_1} → Singleton α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Real.instMonoidWithZero",
   "Real",
   "MonoidWithZero.toMonoid",
   "Monoid",
   "inferInstance"],
  "name": "Real.instMonoid",
  "constType": "Monoid ℝ",
  "constCategory": "Definition"},
 {"references":
  ["LE.le.le_iff_eq",
   "PartialOrder.toPreorder",
   "Iff",
   "PartialOrder",
   "LE.le",
   "bot_le",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "Bot.bot",
   "OrderBot"],
  "name": "le_bot_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, a ≤ ⊥ ↔ a = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "SubNegMonoid.sub_eq_add_neg._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["instLTNat",
   "Iff.mp",
   "Nat.le_pred_iff_lt",
   "Nat.pred",
   "OfNat.ofNat",
   "LT.lt",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "LE.le",
   "HSub.hSub",
   "instHSub",
   "instLENat"],
  "name": "Nat.lt_of_le_sub_one",
  "constType": "∀ {m n : ℕ}, 0 < m → n ≤ m - 1 → n < m",
  "constCategory": "Theorem"},
 {"references":
  ["GroupWithZero.mk",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.inv_zero",
   "CommGroupWithZero.mul_inv_cancel",
   "CommGroupWithZero.toNontrivial",
   "CommGroupWithZero.zpow_succ'",
   "CommMonoidWithZero.toCommMonoid",
   "CommGroupWithZero.toDiv",
   "GroupWithZero",
   "CommGroupWithZero.zpow_neg'",
   "CommMonoidWithZero.zero_mul",
   "CommGroupWithZero",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero.toInv",
   "MonoidWithZero.mk",
   "CommMonoidWithZero.mul_zero",
   "CommMonoidWithZero.toZero",
   "CommGroupWithZero.div_eq_mul_inv",
   "CommGroupWithZero.zpow_zero'",
   "CommGroupWithZero.toCommMonoidWithZero"],
  "name": "CommGroupWithZero.toGroupWithZero",
  "constType":
  "{G₀ : Type u_2} → [self : CommGroupWithZero G₀] → GroupWithZero G₀",
  "constCategory": "Definition"},
 {"references":
  ["DivInvMonoid.toInv",
   "GroupWithZero.toDivInvMonoid",
   "GroupWithZero.toDivisionMonoid._proof_12",
   "GroupWithZero.toDiv",
   "GroupWithZero.toDivisionMonoid._proof_13",
   "GroupWithZero.zpow_zero'",
   "GroupWithZero",
   "GroupWithZero.zpow_succ'",
   "GroupWithZero.zpow_neg'",
   "DivInvMonoid.mk",
   "DivisionMonoid",
   "_private.Mathlib.Algebra.GroupWithZero.Basic.0.inv_eq_of_mul",
   "GroupWithZero.zpow",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.toMonoidWithZero",
   "DivisionMonoid.mk",
   "GroupWithZero.div_eq_mul_inv"],
  "name": "GroupWithZero.toDivisionMonoid",
  "constType": "{G₀ : Type u_2} → [GroupWithZero G₀] → DivisionMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "CompleteLattice.toInfSet",
   "Set",
   "CompleteLattice.toLattice",
   "InfSet.sInf",
   "LE.le",
   "Membership.mem",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteLattice",
   "Set.instMembership"],
  "name": "CompleteLattice.le_sInf",
  "constType":
  "∀ {α : Type u_8} [self : CompleteLattice α] (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references": ["Nat", "NatCast.natCast", "NatCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableAnd._proof_3",
   "Not",
   "And.intro",
   "instDecidableAnd._proof_2",
   "Decidable.isFalse",
   "Decidable",
   "And",
   "instDecidableAnd.match_1",
   "Decidable.isTrue"],
  "name": "instDecidableAnd",
  "constType":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∧ q)",
  "constCategory": "Definition"},
 {"references": ["SupSet", "CompleteLattice"],
  "name": "CompleteLattice.toSupSet",
  "constType": "{α : Type u_8} → [self : CompleteLattice α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Subtype.val",
   "IsGreatest",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.Convex",
   "HarderNarasimhan.impl.prop3d8₁'",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "Or.inr",
   "HarderNarasimhan.StI",
   "Subtype",
   "lt_of_le_of_ne",
   "Prod.fst",
   "Or.inl",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_top",
   "HarderNarasimhan.μ_Admissible",
   "HarderNarasimhan.impl.HNFil._proof_1",
   "HarderNarasimhan.μ_Admissible.μ_adm",
   "LT.lt",
   "Or.casesOn",
   "IsTotal",
   "Nat.succ",
   "HarderNarasimhan.Convex_of_Convex_large",
   "Nat.below",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (n : ℕ) (x : Nat.below n.succ)\n  (htop : ¬x.1 = ⊤), ∃ s, IsGreatest (HarderNarasimhan.StI μ ⟨(x.1, ⊤), ⋯⟩) s",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Neg.neg",
   "instHAdd",
   "AddMonoid.toAddSemigroup",
   "Neg",
   "AddMonoid",
   "AddSemigroup.toAdd"],
  "name": "SubNegMonoid.sub'",
  "constType": "{G : Type u} → [AddMonoid G] → [Neg G] → G → G → G",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Subtype", "Subtype.exists", "Subtype.mk", "Eq", "propext"],
  "name": "HarderNarasimhan.impl.test._proof_18",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["le_refl",
   "Nat.find",
   "Exists",
   "Nat.find_le_iff",
   "And",
   "DecidablePred",
   "Exists.intro",
   "Nat.instPreorder",
   "And.intro",
   "Nat",
   "Iff.mpr",
   "LE.le",
   "instLENat"],
  "name": "Nat.find_le",
  "constType":
  "∀ {n : ℕ} {p : ℕ → Prop} [inst : DecidablePred p] {h : ∃ n, p n}, p n → Nat.find h ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.find",
   "Subtype",
   "PartialOrder.toPreorder",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HarderNarasimhan.HarderNarasimhanFiltration.fin_len",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "OrderTop.toTop",
   "instLENat",
   "CompleteLattice"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.strict_mono",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ]\n  (self : HarderNarasimhan.HarderNarasimhanFiltration μ) (i j : ℕ),\n  i < j → j ≤ Nat.find ⋯ → self.filtration i < self.filtration j",
  "constCategory": "Theorem"},
 {"references": ["WellFounded", "IsWellFounded"],
  "name": "IsWellFounded.wf",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [self : IsWellFounded α r], WellFounded r",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "True",
   "Eq.trans",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "add_assoc",
   "AddMonoid.toAddSemigroup",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddSemigroup.toAdd"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_lt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₂ b c : R} (a₁ : R), a₂ + b = c → a₁ + a₂ + b = a₁ + c",
  "constCategory": "Theorem"},
 {"references": ["SMul", "CommSemiring", "Algebra", "Semiring"],
  "name": "Algebra.toSMul",
  "constType":
  "{R : Type u} → {A : Type v} → {inst : CommSemiring R} → {inst_1 : Semiring A} → [self : Algebra R A] → SMul R A",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._rarg",
   "_neutral"],
  "name": "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.Semistable.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℒ) (hx : x ≠ ⊥), ¬HarderNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HarderNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩) →\n    HarderNarasimhan.Semistable μ",
  "constCategory": "Other"},
 {"references": ["LE.le", "LE"],
  "name": "IsMax",
  "constType": "{α : Type u_1} → [LE α] → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PrimeSpectrum", "Ideal", "CommSemiring.toSemiring", "CommSemiring"],
  "name": "PrimeSpectrum.asIdeal",
  "constType":
  "{R : Type u_1} → [inst : CommSemiring R] → PrimeSpectrum R → Ideal R",
  "constCategory": "Definition"},
 {"references":
  ["PosSMulStrictMono",
   "smul_lt_smul_of_pos_left",
   "Preorder.toLT",
   "OfNat.ofNat",
   "Iff.intro",
   "LT.lt",
   "SMul",
   "Preorder",
   "Iff",
   "PosSMulReflectLT",
   "HSMul.hSMul",
   "instHSMul",
   "Zero.toOfNat0",
   "Zero",
   "lt_of_smul_lt_smul_left",
   "LT.lt.le"],
  "name": "smul_lt_smul_iff_of_pos_left",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {a : α} {b₁ b₂ : β} [inst : SMul α β] [inst_1 : Preorder α] [inst_2 : Preorder β]\n  [inst_3 : Zero α] [PosSMulStrictMono α β] [PosSMulReflectLT α β], 0 < a → (a • b₁ < a • b₂ ↔ b₁ < b₂)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring",
   "CommRing",
   "Semiring",
   "Ring"],
  "name": "RingHom.id._at.HarderNarasimhan.impl.lift_quot._spec_9",
  "constType":
  "(R : Type) →\n  (inst : CommRing R) →\n    let _x_1 := inst.1;\n    let _x_2 := _x_1.1;\n    let _x_20 := Semiring.toNonAssocSemiring;\n    let _y_2 := _x_20;\n    R →+* R",
  "constCategory": "Axiom"},
 {"references":
  ["instAddNat",
   "lt_trans",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Subtype.val",
   "Equiv",
   "Or",
   "HarderNarasimhan.μBstar",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.impl.prop4d1₂",
   "Bot.bot",
   "Nat.lt_add_one",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Lattice",
   "OrderDual.instBoundedOrder",
   "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "HarderNarasimhan.μAstar",
   "OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "OrderDual.instLattice",
   "HarderNarasimhan.impl.dualμAstar_eq_μBstar",
   "DFunLike.coe",
   "Nat.instPreorder",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "instOfNatNat",
   "OrderDual.instLT",
   "OrderDual.instCompleteLattice",
   "OrderBot.toBot",
   "OrderDual.instPartialOrder",
   "Eq",
   "Preorder.toLE",
   "HarderNarasimhan.impl.h₁_dual_of_h₁",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "instHAdd",
   "HarderNarasimhan.impl.dualμBstar_eq_μAstar",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "HarderNarasimhan.impl.h₂_dual_of_h₂",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop4d3₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n        μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n      HarderNarasimhan.μAstar μ ≤ HarderNarasimhan.μBstar μ",
  "constCategory": "Theorem"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.nil",
  "constType": "{α : Type u} → List α",
  "constCategory": "Other"},
 {"references":
  ["Finset.instSingleton",
   "Finset",
   "Finset.singleton_inj",
   "Singleton.singleton",
   "Eq",
   "propext"],
  "name": "HarderNarasimhan.impl.rmk4d14₂._proof_19",
  "constType": "∀ {α : Type u_1} {a b : α}, ({a} = {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.mkQ._proof_20",
   "Submodule.Quotient.mk",
   "Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "Module",
   "LinearMap.mk",
   "Submodule.Quotient.module",
   "AddHom.mk",
   "AddCommGroup",
   "LinearMap",
   "Ring.toSemiring",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Submodule.mkQ._proof_21",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "RingHom.id",
   "AddCommGroup.toAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Ring"],
  "name": "Submodule.mkQ",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : _root_.Module R M] → (p : Submodule R M) → M →ₗ[R] M ⧸ p",
  "constCategory": "Definition"},
 {"references":
  ["Preorder",
   "OrderEmbedding.le_iff_le",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "OrderEmbedding",
   "DFunLike.coe",
   "RelEmbedding.instFunLike",
   "propext"],
  "name": "_private.Mathlib.Order.Hom.Basic.0._proof_50",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α ↪o β) {a b : α}, (f a ≤ f b) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "Nat.add_le_of_le_sub.match_1",
   "congrArg",
   "Nat.eq_add_of_sub_eq",
   "congr",
   "HSub.hSub",
   "Eq.symm",
   "Eq",
   "Nat.le.intro",
   "Exists",
   "True",
   "instHAdd",
   "Nat.add_comm",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "instSubNat",
   "of_eq_true",
   "Nat.le.dest",
   "LE.le",
   "id",
   "Eq.mpr",
   "instHSub",
   "instLENat",
   "Nat.add_left_comm"],
  "name": "Nat.add_le_of_le_sub",
  "constType": "∀ {a b c : ℕ}, b ≤ c → a ≤ c - b → a + b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["le_top",
   "True",
   "LE.le",
   "Top.top",
   "LE",
   "eq_true",
   "OrderTop",
   "Eq",
   "OrderTop.toTop"],
  "name": "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_3",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, (a ≤ ⊤) = True",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroHomClass",
   "FunLike",
   "AddZeroClass.toZero",
   "AddZeroClass",
   "outParam",
   "AddMonoidHomClass"],
  "name": "AddMonoidHomClass.toZeroHomClass",
  "constType":
  "∀ {F : Type u_10} {M : outParam (Type u_11)} {N : outParam (Type u_12)} {inst : AddZeroClass M}\n  {inst_1 : AddZeroClass N} {inst_2 : FunLike F M N} [self : AddMonoidHomClass F M N], ZeroHomClass F M N",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "True",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "Mathlib.Tactic.Ring.cast_pos.match_1",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.cast_pos",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = n.rawCast + 0",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.toSpanSingleton",
   "CommRing.toCommSemiring",
   "Exists",
   "LinearMap.ker",
   "LinearMap.instFunLike",
   "Module",
   "Ideal.IsPrime",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsAssociatedPrime._proof_1",
   "And",
   "AddCommGroup",
   "LinearMap",
   "CommRing",
   "Semiring.toNonAssocSemiring",
   "Ideal",
   "RingHom.id",
   "AddCommGroup.toAddCommMonoid",
   "Semiring.toModule",
   "Eq"],
  "name": "IsAssociatedPrime",
  "constType":
  "{R : Type u_1} → [inst : CommRing R] → Ideal R → (M : Type u_2) → [inst_1 : AddCommGroup M] → [_root_.Module R M] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "And.right",
   "Preorder.toLT",
   "And",
   "Prod.snd",
   "lt_of_le_of_ne",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.InIntvl",
   "PartialOrder",
   "LE.le",
   "Ne",
   "Preorder.toLE",
   "And.left"],
  "name": "HarderNarasimhan.μmax._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (I : { p // p.1 < p.2 }) (u : ℒ),\n  HarderNarasimhan.InIntvl I u ∧ (↑I).1 ≠ u → ((↑I).1, u).1 < ((↑I).1, u).2",
  "constCategory": "Theorem"},
 {"references":
  ["contravariant_swap_add_of_contravariant_add",
   "PartialOrder.toPreorder",
   "le_of_add_le_add_left",
   "instHAdd",
   "IsCancelAdd",
   "le_of_add_le_add_right",
   "AddCommMonoid.toAddMonoid",
   "Eq.ge",
   "HAdd.hAdd",
   "AddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "AddZeroClass.toAdd",
   "PartialOrder",
   "IsCancelAdd.mk",
   "LE.le",
   "IsOrderedCancelAddMonoid.toAddLeftReflectLE",
   "LE.le.antisymm",
   "IsLeftCancelAdd.mk",
   "Preorder.toLE",
   "Eq",
   "Eq.le",
   "IsRightCancelAdd.mk",
   "IsOrderedCancelAddMonoid",
   "AddMonoid.toAddZeroClass"],
  "name": "IsOrderedCancelAddMonoid.toIsCancelAdd",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : PartialOrder α] [IsOrderedCancelAddMonoid α], IsCancelAdd α",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instCommSemiring",
   "Real",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring"],
  "name": "Real.semiring",
  "constType": "Semiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "SetLike.instMembership",
   "LinearMap.instFunLike",
   "SemilinearMapClass",
   "Module",
   "Submodule.module",
   "Membership.mem",
   "LinearMap",
   "Submodule",
   "LinearMap.semilinearMapClass",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "RingHom.id",
   "Submodule.addCommMonoid",
   "Semiring"],
  "name": "Submodule.submoduleOf._proof_14",
  "constType":
  "∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (q : Submodule R M), SemilinearMapClass (↥q →ₗ[R] M) (RingHom.id R) (↥q) M",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.sInf_le",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Membership.mem",
   "Preorder.toLE",
   "Set.instMembership",
   "CompleteSemilatticeInf"],
  "name": "sInf_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, a ∈ s → sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection.lowerAdjoint",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "LowerAdjoint.toFun",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Equiv",
   "Or",
   "letFun",
   "funext",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "ClosureOperator.IsClosed",
   "CompleteLattice.toLattice",
   "And.right",
   "LinearOrder",
   "And",
   "Set.not_subset_iff_exists_mem_not_mem",
   "_private.HarderNarasimhan.DedekindMacNeilleCompletion.0._proof_21",
   "Set.instMembership",
   "Exists.casesOn",
   "Classical.or_iff_not_imp_left",
   "OrderDual.instPreorder",
   "Iff.of_eq",
   "HasSubset.Subset",
   "Set.instCompleteAtomicBooleanAlgebra",
   "upperBounds",
   "Eq.refl",
   "Iff.mpr",
   "lowerBounds",
   "Classical.byContradiction",
   "id",
   "Eq.mpr",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "Eq.mp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SemilatticeSup.toPartialOrder",
   "lowerBounds_mono",
   "IsTotal.mk",
   "_private.HarderNarasimhan.DedekindMacNeilleCompletion.0._proof_18",
   "DFunLike.coe",
   "OrderDual.ofDual",
   "congrArg",
   "HarderNarasimhan.DedekindMacNeilleConnection",
   "instDistribLatticeOfLinearOrder",
   "congr",
   "Preorder.toLE",
   "Eq",
   "Subtype.le",
   "_private.HarderNarasimhan.DedekindMacNeilleCompletion.0._proof_19",
   "propext",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Not",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "exists_prop_congr",
   "Set.instHasSubset",
   "LT.lt",
   "eq_self",
   "LinearOrder.toPartialOrder",
   "IsTotal",
   "upperBounds_mono",
   "DistribLattice.toLattice",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "Subtype.casesOn",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.instIsTotalDedekindMacNeilleCompletionLe",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α], IsTotal (HarderNarasimhan.DedekindMacNeilleCompletion α) LE.le",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name": "HarderNarasimhan.instCoeDedekindMacNeilleCompletion._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "not_lt_of_ge",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "Iff",
   "le_of_not_gt",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Preorder.toLE",
   "Iff.intro"],
  "name": "not_lt",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬a < b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.Quotient.mk",
   "Submodule.hasQuotient",
   "PartialOrder.toPreorder",
   "HasQuotient.Quotient",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "Submodule.Quotient.instZeroQuotient",
   "Preorder.toLT",
   "Exists.intro",
   "congrArg",
   "Submodule",
   "SetLike.exists_of_lt",
   "Zero.toOfNat0",
   "Eq",
   "Nontrivial.mk",
   "Not",
   "SetLike.instMembership",
   "Exists",
   "Submodule.instTop",
   "And",
   "AddCommGroup",
   "_private.Mathlib.LinearAlgebra.Quotient.Defs.0._proof_1",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "LT.lt",
   "Exists.casesOn",
   "Submodule.setLike",
   "Nontrivial",
   "id",
   "Top.top",
   "Submodule.completeLattice",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "Ne",
   "And.casesOn",
   "Ring"],
  "name": "Submodule.Quotient.nontrivial_of_lt_top",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M],\n  ∀ p < ⊤, Nontrivial (M ⧸ p)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.SlopeLike",
   "Or.inr",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "not_le_of_lt",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "And.intro",
   "Or.inl",
   "Or",
   "BoundedOrder.toOrderTop",
   "letFun",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Bot.bot",
   "Or.casesOn",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "HarderNarasimhan.SlopeLike.slopelike",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.rmk4d15",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ →\n    ∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      μ ⟨(⊥, x), ⋯⟩ ≤ μ HarderNarasimhan.TotIntvl ∨ ¬μ HarderNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.SlopeLike",
   "Nat.find",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Nat.instPreorder",
   "Prod.fst",
   "eq_of_le_of_le",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "OrderBot.toBot",
   "CompleteLinearOrder",
   "HarderNarasimhan.Affine",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Lattice.toSemilatticeInf",
   "Nat.instPartialOrder",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat",
   "BoundedOrder.toOrderBot",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "inferInstance",
   "HarderNarasimhan.impl.looooooooooooooooog_lemma",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "Eq.le",
   "instLENat",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.remark_4_26",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} [HarderNarasimhan.FiniteTotalPayoff μ]\n  [HarderNarasimhan.SlopeLike μ] [HarderNarasimhan.Semistable μ] [HarderNarasimhan.WeakDescendingChainCondition' μ]\n  [HarderNarasimhan.Affine μ] (JH1 JH2 : HarderNarasimhan.JordanHolderFiltration μ), Nat.find ⋯ = Nat.find ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["One.toOfNat1",
   "AddZeroClass.toZero",
   "AddZeroClass.toAdd",
   "AddZeroClass",
   "zero_le",
   "ZeroLEOneClass.mk",
   "One",
   "LE",
   "CanonicallyOrderedAdd",
   "OfNat.ofNat",
   "ZeroLEOneClass"],
  "name": "CanonicallyOrderedAdd.toZeroLeOneClass",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α] [CanonicallyOrderedAdd α] [inst_3 : One α], ZeroLEOneClass α",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.StI",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil",
   "Prod.fst",
   "IsGreatest",
   "HarderNarasimhan.impl.HNFil._proof_3",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HarderNarasimhan.impl.HNFil._proof_4",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil.eq_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (n : ℕ),\n  HarderNarasimhan.impl.HNFil μ n.succ =\n    if htop : HarderNarasimhan.impl.HNFil μ n = ⊤ then ⊤\n    else\n      let I' := ⟨(HarderNarasimhan.impl.HNFil μ n, ⊤), ⋯⟩;\n      ⋯.choose",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "False.elim",
   "lt_irrefl",
   "Iff",
   "Preorder.toLT",
   "False",
   "Iff.intro"],
  "name": "lt_self_iff_false",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] (x : α), x < x ↔ False",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "Eq.trans",
   "Membership.mem",
   "Subtype.val",
   "Set.Elem",
   "funext",
   "forall_congr",
   "Classical.indefiniteDescription",
   "Eq.ndrec",
   "Set.mem_range_self",
   "And.left",
   "WellFounded",
   "Exists",
   "Exists.choose_spec",
   "IsEmpty.mk",
   "And.right",
   "And",
   "Nonempty",
   "Set.instMembership",
   "Exists.casesOn",
   "Nat",
   "instNonemptyOfInhabited",
   "Nat.rec",
   "Iff",
   "Eq.refl",
   "id",
   "Eq.mpr",
   "instInhabitedNat",
   "Mathlib.Tactic.PushNeg.not_implies_eq",
   "Subtype",
   "WellFounded.wellFounded_iff_no_descending_seq.match_1",
   "Set.range",
   "Iff.intro",
   "congrArg",
   "IsEmpty",
   "Nonempty.intro",
   "WellFounded.wellFounded_iff_has_min",
   "instOfNatNat",
   "Subtype.property",
   "Eq",
   "propext",
   "Not",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "Set.Nonempty",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "instHAdd",
   "Set",
   "Mathlib.Tactic.PushNeg.not_and_eq",
   "Mathlib.Tactic.PushNeg.not_forall_eq",
   "Function.comp",
   "Exists.choose",
   "OfNat.ofNat",
   "Mathlib.Tactic.Contrapose.mtr",
   "HAdd.hAdd",
   "not_isEmpty_iff",
   "Set.range_nonempty",
   "False",
   "Subtype.mk",
   "And.casesOn"],
  "name": "WellFounded.wellFounded_iff_no_descending_seq",
  "constType":
  "∀ {α : Type u_1} {r : α → α → Prop}, WellFounded r ↔ IsEmpty { f // ∀ (n : ℕ), r (f (n + 1)) (f n) }",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "Subtype",
   "Zero.mk",
   "LE.le",
   "Zero.toOfNat0",
   "Nonneg.zero._proof_1",
   "Subtype.mk",
   "Zero",
   "Preorder.toLE",
   "OfNat.ofNat"],
  "name": "Nonneg.zero",
  "constType":
  "{α : Type u_1} → [inst : Zero α] → [inst_1 : Preorder α] → Zero { x // 0 ≤ x }",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan",
   "PartialOrder",
   "inferInstance",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "CompleteLattice"],
  "name": "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → CompleteLattice (HarderNarasimhan.DedekindMacNeilleCompletion α)",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Exists.intro",
   "Subtype.val",
   "HarderNarasimhan.NashEquilibrium",
   "SupSet.sSup",
   "HarderNarasimhan.μBstar",
   "letFun",
   "Eq.symm",
   "HarderNarasimhan.impl.prop4d1₁",
   "Exists",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Set.ext",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "setOf",
   "HarderNarasimhan.Semistable",
   "Ne.symm",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.Resμ",
   "HarderNarasimhan.impl.smart_helper",
   "Prod.fst",
   "congr",
   "InfSet.sInf",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "HarderNarasimhan.NashEquilibrium.nash_eq",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "Set",
   "HarderNarasimhan.instBoundedOrderInterval",
   "eq_self",
   "HarderNarasimhan.μA",
   "SupSet",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "bot_lt_top",
   "CompleteLattice",
   "LE.le.not_lt",
   "HarderNarasimhan.μA._proof_3",
   "InfSet",
   "HarderNarasimhan.WeakSlopeLike₁.wsl₁",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Iff.mp",
   "bot_le",
   "HarderNarasimhan.μB",
   "HarderNarasimhan.μmax",
   "And.intro",
   "HarderNarasimhan.WeakAscendingChainCondition.wacc",
   "funext",
   "forall_congr",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Exists.casesOn",
   "Iff.of_eq",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "HarderNarasimhan.μAstar",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "HarderNarasimhan.TotIntvl._proof_1",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Iff.intro",
   "congrArg",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Semistable.mk",
   "HarderNarasimhan.Interval",
   "_private.Init.PropLemmas.0._proof_12",
   "OrderBot.toBot",
   "HarderNarasimhan.Resμ._proof_19",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μmax._proof_2",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "HarderNarasimhan.instNontrivialInterval",
   "of_eq_true",
   "LE.le",
   "le_sSup",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "OrderTop.toTop",
   "Subtype.coe_ne_coe"],
  "name": "HarderNarasimhan.impl.prop4d20",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥), HarderNarasimhan.WeakAscendingChainCondition (HarderNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n    (∀ (x : ℒ) (hx : x ≠ ⊥), HarderNarasimhan.WeakSlopeLike₁ (HarderNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n      HarderNarasimhan.NashEquilibrium μ → HarderNarasimhan.Semistable μ",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "List.rec",
   "List.getLastD",
   "List.getLastD_mem_cons",
   "_private.Batteries.Data.List.Lemmas.0._proof_13",
   "List.Mem.head",
   "Eq.trans",
   "Eq.mp",
   "Iff.mp",
   "eq_true",
   "List",
   "and_true",
   "List.getLast?",
   "List.tfae_of_cycle._proof_4",
   "Iff.intro",
   "congrArg",
   "_private.Batteries.Data.List.Lemmas.0._proof_12",
   "And.intro",
   "List.Chain",
   "letFun",
   "congr",
   "forall_congr",
   "List.TFAE",
   "List.tfae_of_cycle._proof_5",
   "Eq",
   "List.getLastD_cons",
   "List.cons",
   "List.getLastD_eq_getLast?",
   "List.nil",
   "_private.Mathlib.Data.List.TFAE.0._proof_1",
   "True",
   "And.right",
   "And",
   "Option.getD",
   "Function.comp",
   "List.tfae_of_cycle._proof_3",
   "implies_true",
   "and_self",
   "of_eq_true",
   "Iff",
   "Eq.refl",
   "id",
   "Eq.mpr",
   "implies_congr_ctx",
   "And.casesOn"],
  "name": "List.tfae_of_cycle",
  "constType":
  "∀ {a b : Prop} {l : List Prop}, List.Chain (fun x1 x2 => x1 → x2) a (b :: l) → (l.getLastD b → a) → (a :: b :: l).TFAE",
  "constCategory": "Theorem"},
 {"references": ["Set", "iInf", "Set.instInfSet"],
  "name": "Set.iInter",
  "constType": "{α : Type u} → {ι : Sort v} → (ι → Set α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.SlopeLike.mk",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.SlopeLike.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.SlopeLike μ → Sort u} →\n                ((slopelike :\n                      ∀ (x y z : ℒ) (h : x < y ∧ y < z),\n                        (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n                          (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n                            (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n                              (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) →\n                    motive ⋯) →\n                  (t : HarderNarasimhan.SlopeLike μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "HarderNarasimhan.WeakDescendingChainCondition.wdcc",
   "And.intro",
   "HarderNarasimhan.μBstar",
   "HarderNarasimhan.WeakSlopeLike₂.wsl₂",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.impl.prop4d3₂",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop4d3₁",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "HarderNarasimhan.TotIntvl",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_4_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.WeakDescendingChainCondition μ →\n    HarderNarasimhan.WeakSlopeLike₂ μ →\n      HarderNarasimhan.μBstar μ = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl ∧\n        HarderNarasimhan.μAstar μ ≤ HarderNarasimhan.μBstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "HEq.refl",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "Module",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "Eq.casesOn",
   "Iff.intro",
   "HarderNarasimhan.CoprimaryFiltration.ext",
   "IsNoetherianRing",
   "Nat",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.CoprimaryFiltration",
   "Iff",
   "Eq.refl",
   "Nontrivial",
   "Eq.symm",
   "HEq",
   "AddCommGroup.toAddCommMonoid",
   "Eq.ndrec",
   "Eq",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.ext_iff",
  "constType":
  "∀ {R : Type} {inst : CommRing R} {inst_1 : IsNoetherianRing R} {M : Type} {inst_2 : Nontrivial M}\n  {inst_3 : AddCommGroup M} {inst_4 : _root_.Module R M} {inst_5 : Module.Finite R M}\n  {x y : HarderNarasimhan.CoprimaryFiltration R M}, x = y ↔ x.filtration = y.filtration",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le_trans", "Nat", "Nat.le_succ", "Nat.succ", "LE.le", "instLENat"],
  "name": "Nat.le_succ_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n ≤ m.succ",
  "constCategory": "Theorem"},
 {"references": ["Set", "SupSet"],
  "name": "SupSet.sSup",
  "constType": "{α : Type u_1} → [self : SupSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "not_le_of_lt",
   "imp_not_comm",
   "LE.le",
   "Preorder.toLT",
   "Iff.mp",
   "Preorder.toLE"],
  "name": "not_lt_of_le",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "CommSemiring",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "instOfNatNat",
   "congr",
   "MonoidWithZero.toMonoid",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHPow",
   "Distrib.toAdd",
   "True",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.mul_zero",
   "HPow.hPow",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "of_eq_true",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "Nat.cast_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero._proof_1",
   "Distrib.leftDistribClass",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b : R} (x : R) (e : ℕ),\n  Mathlib.Meta.NormNum.IsNat (a + b) 0 → Mathlib.Meta.NormNum.IsNat (x ^ e * a + x ^ e * b) 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "Unit.unit",
   "OfNat.ofNat",
   "Unit"],
  "name": "HarderNarasimhan.impl.HNFil.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Eq.mpr_not",
   "Classical.propDecidable",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "GT.gt",
   "le_of_not_gt",
   "letFun",
   "Eq.symm",
   "Eq.rec",
   "Nat.instLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "of_eq_false",
   "Exists",
   "Nat.instPartialOrder",
   "lt_of_le_of_lt",
   "Nat.recAux",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Bot.bot",
   "Exists.casesOn",
   "Nat.find_spec",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nat.le_succ",
   "Antitone",
   "eq_false",
   "Eq.refl",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Mathlib.Tactic.PushNeg.not_le_eq",
   "Eq.mpr",
   "le_bot_iff",
   "Nat.find",
   "Ne.symm",
   "Eq.mp",
   "lt_of_le_of_ne",
   "Nat.instPreorder",
   "congrArg",
   "dite_congr",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "instDecidableFalse",
   "dite_cond_eq_false",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "HarderNarasimhan.impl.function_wrapper._proof_6",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "False",
   "lt_self_iff_false",
   "dite",
   "OrderTop.toTop",
   "Nat.find_min"],
  "name": "HarderNarasimhan.impl.function_wrapper_prop0",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ) (atf : ∃ k, f k = ⊥),\n  Antitone f → f 0 = ⊤ → ∀ (i : ℕ), ∃ j, f i = HarderNarasimhan.impl.function_wrapper f atf j",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Iff.trans",
   "PartialOrder.toPreorder",
   "or_comm",
   "Or",
   "Iff",
   "PartialOrder",
   "LE.le",
   "Preorder.toLT",
   "Eq",
   "Preorder.toLE",
   "le_iff_lt_or_eq"],
  "name": "le_iff_eq_or_lt",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≤ b ↔ a = b ∨ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "HarderNarasimhan.Affine.mk",
   "HarderNarasimhan.Interval",
   "HarderNarasimhan.Affine",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HarderNarasimhan.Affine.affine",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "HarderNarasimhan.instBoundedOrderInterval",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.instNontrivialInterval",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "CompleteLattice"],
  "name": "HarderNarasimhan.instAffineIntervalResμ",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [haff : HarderNarasimhan.Affine μ] {I : { p // p.1 < p.2 }},\n  HarderNarasimhan.Affine (HarderNarasimhan.Resμ I μ)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "LinearMap.instZero._proof_37",
   "AddZeroClass.toZero",
   "Module",
   "LinearMap.mk",
   "LinearMap.instZero._proof_38",
   "AddHom.mk",
   "AddCommMonoid.toAddMonoid",
   "LinearMap",
   "OfNat.ofNat",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Zero.mk",
   "AddCommMonoid.toAddCommSemigroup",
   "Zero.toOfNat0",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Zero",
   "AddMonoid.toAddZeroClass",
   "Pi.instZero",
   "Semiring"],
  "name": "LinearMap.instZero",
  "constType":
  "{R₁ : Type u_2} →\n  {R₂ : Type u_3} →\n    {M : Type u_8} →\n      {M₂ : Type u_10} →\n        [inst : Semiring R₁] →\n          [inst_1 : Semiring R₂] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                [inst_4 : _root_.Module R₁ M] →\n                  [inst_5 : _root_.Module R₂ M₂] → {σ₁₂ : R₁ →+* R₂} → Zero (M →ₛₗ[σ₁₂] M₂)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "PartialOrder.toPreorder",
   "not_bot_lt_iff",
   "PartialOrder",
   "Preorder.toLT",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "Bot.bot",
   "propext",
   "OrderBot"],
  "name": "HarderNarasimhan.impl.rmk4d14₂._proof_14",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, (¬⊥ < a) = (a = ⊥)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero",
   "Neg.neg",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "add_neg_cancel",
   "OfNat.ofNat",
   "congrArg",
   "sub_eq_add_neg",
   "HAdd.hAdd",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "Eq.refl",
   "SubNegMonoid.toSub",
   "id",
   "HSub.hSub",
   "AddGroup",
   "Eq.mpr",
   "Zero.toOfNat0",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "instHSub",
   "AddMonoid.toAddZeroClass"],
  "name": "sub_self",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), a - a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "lt_sup_of_lt_right",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "sup_le",
   "Membership.mem.out",
   "Subtype.val",
   "HarderNarasimhan.S₂I",
   "Set.Elem",
   "HarderNarasimhan.S₁I",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "IsTotal.total",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "Exists.choose_spec",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.IsComparable",
   "Set.instMembership",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Or.inr",
   "Subtype",
   "HarderNarasimhan.StI",
   "SemilatticeSup.toPartialOrder",
   "IsTotal.mk",
   "lt_of_le_of_ne",
   "HarderNarasimhan.impl.prop2d8₂I",
   "Prod.fst",
   "le_rfl",
   "Subtype.prop",
   "Or.inl",
   "WellFoundedGT",
   "sup_le_iff",
   "Eq",
   "Preorder.toLE",
   "Subtype.le",
   "Lattice.toSemilatticeInf",
   "eq_of_le_of_not_lt",
   "Set",
   "Exists.choose",
   "le_sup_of_le_left",
   "Or.casesOn",
   "LT.lt",
   "IsTotal",
   "Max.max",
   "ne_of_lt",
   "le_of_lt",
   "HarderNarasimhan.μA",
   "LE.le",
   "SemilatticeSup.toMax",
   "Ne",
   "Subtype.mk",
   "Subtype.casesOn",
   "CompleteLattice.toCompleteSemilatticeInf",
   "lt_sup_of_lt_left",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d8₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.ConvexI I μ →\n    ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n        ∀ (z : ℒ) (hzI : HarderNarasimhan.InIntvl I z) (hz : (↑I).1 ≠ z),\n          HarderNarasimhan.IsAttained μ ⟨((↑I).1, z), ⋯⟩) →\n      IsTotal ↑(HarderNarasimhan.StI μ I) fun x1 x2 => x1 ≤ x2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.Embedding",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references": ["Not", "Set", "Set.Finite"],
  "name": "Set.Infinite",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.rfl", "setOf"],
  "name": "Set.setOf_app_iff",
  "constType": "∀ {α : Type u} {p : α → Prop} {x : α}, {x | p x} x ↔ p x",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "Iff",
   "LE.le",
   "And",
   "Preorder.toLT",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "lt_iff_le_not_le",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.FiniteTotalPayoff.mk",
   "BoundedOrder.toOrderTop",
   "CompleteLattice.toTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "HarderNarasimhan.FiniteTotalPayoff.rec",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.FiniteTotalPayoff.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.FiniteTotalPayoff μ → Sort u} →\n                (t : HarderNarasimhan.FiniteTotalPayoff μ) →\n                  ((fin_tot_payoff : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "FunLike",
   "Exists",
   "SetLike.instMembership",
   "RingHomSurjective",
   "SemilinearMapClass",
   "Module",
   "Submodule.map",
   "Membership.mem",
   "And",
   "Iff.rfl",
   "DFunLike.coe",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Iff",
   "Eq",
   "Semiring"],
  "name": "Submodule.mem_map",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} [inst_6 : RingHomSurjective σ₁₂] {F : Type u_9} [inst_7 : FunLike F M M₂]\n  [inst_8 : SemilinearMapClass F σ₁₂ M M₂] {f : F} {p : Submodule R M} {x : M₂},\n  x ∈ Submodule.map f p ↔ ∃ y ∈ p, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "AddSubmonoid.closure",
   "Singleton.singleton",
   "Membership.mem",
   "eq_top_mono",
   "Nat.instMulOneClass",
   "Exists.intro",
   "HMul.hMul",
   "StarOrderedRing",
   "_private.Mathlib.Algebra.Group.Submonoid.Defs.0._proof_29",
   "StarRing.toStarAddMonoid",
   "iff_self",
   "letFun",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "AddSubmonoid.instCompleteLattice",
   "Exists",
   "AddSubmonoid.instTop",
   "SetLike.instMembership",
   "_private.Mathlib.Algebra.Order.Star.Basic.0._proof_14",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Nat.instPartialOrder",
   "StarAddMonoid.toInvolutiveStar",
   "AddSubmonoid.instSetLike",
   "And",
   "Nat.instStarRing",
   "Nat.instNonUnitalSemiring",
   "true_and",
   "Set.instMembership",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "HasSubset.Subset",
   "Iff.mpr",
   "Iff",
   "InvolutiveStar.toStar",
   "Top.top",
   "instHMul",
   "one_mul",
   "CompleteLattice.toBoundedOrder",
   "AddMonoid.toAddZeroClass",
   "StarOrderedRing.mk",
   "AddCommMonoid.toAddMonoid",
   "Nat.addSubmonoid_closure_one",
   "Set.range",
   "congrArg",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "congr",
   "instMulNat",
   "Preorder.toLE",
   "Eq",
   "Star.star",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "True",
   "instHAdd",
   "Set",
   "TrivialStar.star_trivial",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Distrib.toMul",
   "Nat.instTrivialStar",
   "Set.instSingletonSet",
   "Set.singleton_subset_iff",
   "OfNat.ofNat",
   "Set.instHasSubset",
   "HAdd.hAdd",
   "of_eq_true",
   "AddSubmonoid",
   "AddSubmonoid.closure_mono",
   "LE.le",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.mem_range"],
  "name": "Nat.instStarOrderedRing",
  "constType": "StarOrderedRing ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "LE.le", "Membership.mem", "LE", "Set.instMembership", "setOf"],
  "name": "lowerBounds",
  "constType": "{α : Type u_1} → [LE α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Not", "Or", "Iff", "Classical.propDecidable", "Decidable.imp_iff_not_or"],
  "name": "imp_iff_not_or",
  "constType": "∀ {a b : Prop}, a → b ↔ ¬a ∨ b",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Iff",
   "funext",
   "Membership.mem",
   "Eq",
   "propext",
   "Set.instMembership"],
  "name": "Set.ext",
  "constType":
  "∀ {α : Type u} {a b : Set α}, (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Subtype",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "Set.subset_biUnion_of_mem",
   "Set.iUnion",
   "ClosureOperator",
   "DFunLike.coe",
   "Subtype.val",
   "Set.instMembership",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Subtype.property",
   "Eq.symm",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq",
   "Eq.rec"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_10",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds), ∀ A ∈ 𝒮, ∀ x ∈ ↑A, x ∈ T (⋃ x ∈ 𝒮, ↑x)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "Subtype",
   "Module",
   "Submodule.module",
   "Membership.mem",
   "CommSemiring.toSemiring",
   "CommSemiring",
   "AddCommGroup",
   "LinearMap",
   "CommRing",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "RingHom.id",
   "NonAssocSemiring",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.addCommMonoid",
   "Semiring"],
  "name": "Submodule.subtype._at.HarderNarasimhan.impl.lift_quot._spec_2",
  "constType":
  "(R : Type) →\n  (inst : CommRing R) →\n    (M : Type) →\n      (inst_1 : AddCommGroup M) →\n        (inst_2 : _root_.Module R M) →\n          let _x_3 := CommRing.toCommSemiring;\n          let _x_6 := _x_3.1;\n          let _x_9 := AddCommGroup.toAddCommMonoid;\n          let _y_3 := _x_6;\n          let _y_4 := _x_9;\n          let _y_5 := inst_2;\n          (p : Submodule R M) →\n            let _x_1 := Semiring.toNonAssocSemiring;\n            let _x_2 := RingHom.id R;\n            let _x_3 := p.addCommMonoid;\n            let _x_4 := p.module;\n            ↥p →ₛₗ[_x_2] M",
  "constCategory": "Axiom"},
 {"references": ["Add"],
  "name": "AddHom",
  "constType":
  "(M : Type u_10) → (N : Type u_11) → [Add M] → [Add N] → Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Preorder.toLT",
   "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "AddMonoidWithOne.toAddMonoid",
   "Semiring.toNonAssocSemiring",
   "IsCancelAdd.toIsRightCancelAdd",
   "PartialOrder",
   "Zero.toOfNat0",
   "add_lt_of_neg_of_le",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Preorder.toLE",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "IsStrictOrderedRing.toIsOrderedCancelAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "IsStrictOrderedRing.toIsOrderedRing",
   "instHAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsOrderedAddMonoid.toAddLeftMono",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "AddCommMonoid.toAddCommSemigroup",
   "AddZeroClass.toAdd",
   "MulZeroClass.toZero",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "covariant_swap_add_of_covariant_add",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Linarith.add_lt_of_neg_of_le",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [inst_1 : PartialOrder α] [IsStrictOrderedRing α] {a b c : α},\n  a < 0 → b ≤ c → a + b < c",
  "constCategory": "Theorem"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "GeneralizedCoheytingAlgebra.mk",
   "PartialOrder.toPreorder",
   "CompleteLattice.toBot",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toPartialOrder",
   "Order.Coframe.toSDiff",
   "Order.Coframe.toHNot",
   "CompleteLattice.le_top",
   "Order.Coframe.toCompleteLattice",
   "CoheytingAlgebra.mk",
   "Order.Coframe",
   "CompleteLattice.bot_le",
   "Order.Coframe.top_sdiff",
   "Order.Coframe.sdiff_le_iff",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "OrderBot.mk",
   "CoheytingAlgebra",
   "OrderTop.mk"],
  "name": "Order.Coframe.toCoheytingAlgebra",
  "constType": "{α : Type u_1} → [self : Order.Coframe α] → CoheytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Algebra.Module.LocalizedModule.Basic.0.LocalizedModule.add_comm'",
   "Module",
   "LocalizedModule.instAdd",
   "CommSemiring",
   "MulZeroOneClass.toMulOneClass",
   "LocalizedModule.instZero",
   "_private.Mathlib.Algebra.Module.LocalizedModule.Basic.0.LocalizedModule.zero_add'",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "_private.Mathlib.Algebra.Module.LocalizedModule.Basic.0.LocalizedModule.add_assoc'",
   "instHSMul",
   "Zero.toOfNat0",
   "_private.Mathlib.Algebra.Module.LocalizedModule.Basic.0.LocalizedModule.nsmul_zero'",
   "AddSemigroup.mk",
   "NonAssocSemiring.toMulZeroOneClass",
   "LocalizedModule",
   "instHAdd",
   "CommSemiring.toSemiring",
   "AddCommMonoid.mk",
   "OfNat.ofNat",
   "AddMonoid.mk",
   "Submonoid",
   "HAdd.hAdd",
   "Nat",
   "Zero.mk",
   "_private.Mathlib.Algebra.Module.LocalizedModule.Basic.0.LocalizedModule.nsmul_succ'",
   "HSMul.hSMul",
   "Add.mk",
   "_private.Mathlib.Algebra.Module.LocalizedModule.Basic.0.LocalizedModule.add_zero'",
   "LocalizedModule.hasNatSMul"],
  "name": "LocalizedModule.instAddCommMonoid",
  "constType":
  "{R : Type u} →\n  [inst : CommSemiring R] →\n    {S : Submonoid R} →\n      {M : Type v} → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → AddCommMonoid (LocalizedModule S M)",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "HarderNarasimhan.WeakDescendingChainCondition'.casesOn",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "CompleteLattice",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLattice.toTop",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition'.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u →\n                HarderNarasimhan.WeakDescendingChainCondition' μ →\n                  HarderNarasimhan.WeakDescendingChainCondition' μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Nat.find",
   "Subtype",
   "PartialOrder.toPreorder",
   "Classical.propDecidable",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.impl.HNFil_of_fin_len",
   "LT.lt",
   "Prod",
   "Nat",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNlen",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              (μ : { p // p.1 < p.2 } → S) →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] → [h : HarderNarasimhan.μ_Admissible μ] → ℕ",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "Submodule.Quotient.module",
   "Membership.mem",
   "associatedPrimes.nonempty",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "HarderNarasimhan.impl.μ_nonempty._proof_1",
   "Submodule.subtype",
   "LinearMap.semilinearMapClass",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Semiring.toModule",
   "Finset.Nonempty",
   "And.left",
   "rfl",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "Prod.snd",
   "LinearMap",
   "Set.instMembership",
   "Ring.toSemiring",
   "Exists.casesOn",
   "Prod",
   "Submodule.comap",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Classical.byContradiction",
   "AddCommGroup.toAddCommMonoid",
   "id",
   "Top.top",
   "Eq.mpr",
   "setOf",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Prod.fst",
   "Submodule",
   "Set.mem_setOf",
   "Submodule.comap_subtype_eq_top",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "not_lt_top_iff",
   "Subtype.prop",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "Eq",
   "Submodule.instOrderTop",
   "Not",
   "CommRing.toCommSemiring",
   "Set.Nonempty",
   "LinearExtension",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "Set.toFinset",
   "AddCommGroup",
   "IsAssociatedPrime",
   "CommRing",
   "lt_of_lt_of_le",
   "PrimeSpectrum",
   "LT.lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "ne_of_lt",
   "HarderNarasimhan.ℒ",
   "Submodule.Quotient.nontrivial_of_lt_top",
   "Submodule.setLike",
   "HarderNarasimhan._μ._proof_2",
   "LE.le",
   "Submodule.completeLattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Submodule.addCommMonoid",
   "OrderTop.toTop",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.μ_nonempty",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  (HarderNarasimhan._μ R M I).toFinset.Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "add_add_add_comm",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "instOfNatNat",
   "Mathlib.Meta.NormNum.IsNat.out",
   "Zero.toOfNat0",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq.ndrec",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "Eq.refl",
   "Nat.cast_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "id",
   "Eq.mpr",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b₁ b₂ c : R},\n  Mathlib.Meta.NormNum.IsNat (a₁ + b₁) 0 → a₂ + b₂ = c → a₁ + a₂ + (b₁ + b₂) = c",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HarderNarasimhan.WeakAscendingChainCondition.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n    HarderNarasimhan.WeakAscendingChainCondition μ",
  "constCategory": "Other"},
 {"references": ["LT.lt", "instLTNat", "Nat", "Fin"],
  "name": "Fin.mk",
  "constType": "{n : ℕ} → (val : ℕ) → val < n → Fin n",
  "constCategory": "Other"},
 {"references":
  ["OrderDual",
   "CompleteLattice.le_sInf",
   "PartialOrder.toPreorder",
   "OrderDual.instCompleteLattice._proof_29",
   "OrderDual.instLattice",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "OrderDual.instCompleteLattice._proof_30",
   "OrderDual.supSet",
   "BoundedOrder.toOrderTop",
   "OrderDual.infSet",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.sSup_le",
   "OrderDual.instLE",
   "OrderBot.toBot",
   "Preorder.toLE",
   "CompleteLattice.sInf_le",
   "CompleteLattice.le_sSup",
   "CompleteLattice.mk",
   "CompleteLattice.toLattice",
   "BoundedOrder",
   "CompleteSemilatticeInf.toInfSet",
   "BoundedOrder.toOrderBot",
   "OrderDual.instBoundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toBoundedOrder",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "OrderDual.instCompleteLattice",
  "constType": "{α : Type u_1} → [CompleteLattice α] → CompleteLattice αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["ConditionallyCompleteLinearOrder.compare_eq_compareOfLessAndEq",
   "ConditionallyCompleteLinearOrder.toLinearOrder._proof_3",
   "Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "ConditionallyCompleteLinearOrder.toLinearOrder._proof_4",
   "Lattice.toSemilatticeInf",
   "ConditionallyCompleteLinearOrder.toDecidableLE",
   "ConditionallyCompleteLinearOrder",
   "LinearOrder",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder.mk",
   "ConditionallyCompleteLinearOrder.le_total",
   "ConditionallyCompleteLinearOrder.toDecidableEq",
   "ConditionallyCompleteLinearOrder.toDecidableLT",
   "ConditionallyCompleteLinearOrder.toOrd",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "SemilatticeSup.toMax",
   "ConditionallyCompleteLattice.toLattice"],
  "name": "ConditionallyCompleteLinearOrder.toLinearOrder",
  "constType":
  "{α : Type u_1} → [ConditionallyCompleteLinearOrder α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Coe",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_18",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Interval",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_17",
   "Lattice.toSemilatticeInf",
   "Coe.mk",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top"],
  "name": "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → Coe ℒ (HarderNarasimhan.Interval ⟨(⊥, ⊤), ⋯⟩)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "CommSemiring",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "Eq.ndrec",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddZeroClass.toZero",
   "instHAdd",
   "mul_add",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Distrib.leftDistribClass",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.mul_add",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₁ b₂ c₁ c₂ d : R},\n  a * b₁ = c₁ → a * b₂ = c₂ → c₁ + 0 + c₂ = d → a * (b₁ + b₂) = d",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Nat.add_sub_assoc",
   "Eq.mp",
   "Nat.le_add_left",
   "congrArg",
   "Nat.eq_add_of_sub_eq",
   "Or",
   "Nat.le_add_of_sub_le.match_1",
   "letFun",
   "HSub.hSub",
   "Eq.symm",
   "Eq",
   "Nat.le.intro",
   "Nat.le_trans",
   "Exists",
   "instHAdd",
   "Nat.add_comm",
   "HAdd.hAdd",
   "Nat",
   "instSubNat",
   "Eq.refl",
   "Nat.le.dest",
   "LE.le",
   "id",
   "Nat.le_total",
   "Eq.mpr",
   "instHSub",
   "instLENat"],
  "name": "Nat.le_add_of_sub_le",
  "constType": "∀ {a b c : ℕ}, a - b ≤ c → a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.ConvexI",
   "Preorder.toLT",
   "HarderNarasimhan.ConvexI.mk",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "le_rfl",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.impl.lem2d4₂I",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.rmk2d5₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ → HarderNarasimhan.ConvexI I (HarderNarasimhan.μmax μ)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.toDual",
   "OrderDual",
   "Exists",
   "Equiv.instFunLike",
   "OrderDual.exists",
   "Eq",
   "DFunLike.coe",
   "Equiv",
   "propext"],
  "name": "_private.Mathlib.Order.Synonym.0._proof_6",
  "constType":
  "∀ {α : Type u_1} {p : αᵒᵈ → Prop}, (∃ a, p a) = ∃ a, p (OrderDual.toDual a)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "SetLike.coe_eq_coe",
   "Membership.mem",
   "SetLike",
   "Eq",
   "Subtype.val",
   "propext"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_24",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x y : ↥p}, (↑x = ↑y) = (x = y)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.WeakAscendingChainCondition",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references": ["Not", "Classical.not_imp", "And", "Eq", "propext"],
  "name": "_private.Init.Classical.0._proof_13",
  "constType": "∀ {a b : Prop}, (¬(a → b)) = (a ∧ ¬b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.find",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
   "PartialOrder.toPreorder",
   "Submodule.instNontrivial",
   "Module",
   "HarderNarasimhan.μ",
   "Preorder.toLT",
   "Classical.propDecidable",
   "HarderNarasimhan.HarderNarasimhanFiltration.strict_mono",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.S",
   "HarderNarasimhan.impl.prop3d11",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "HarderNarasimhan.impl.prop3d13₂",
   "CommRing",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "HarderNarasimhan.impl.prop3d13₁",
   "LT.lt",
   "Nat",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "LE.le",
   "Nontrivial",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_20",
   "ConditionallyCompleteLattice.toLattice",
   "HarderNarasimhan.S₀",
   "OrderTop.toTop",
   "instLENat",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_21",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (HNFil : HarderNarasimhan.HarderNarasimhanFiltration (HarderNarasimhan.μ R M)) (i j : ℕ),\n  i < j → j ≤ Nat.find ⋯ → HNFil.filtration i < HNFil.filtration j",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "CommRing.toCommSemiring",
   "PartialOrder.toPreorder",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CommSemiring.toSemiring",
   "Preorder.toLT",
   "AddCommGroup",
   "CommRing",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "wellFoundedGT",
   "isNoetherian_of_isNoetherianRing_of_finite",
   "Nontrivial",
   "Submodule.completeLattice",
   "AddCommGroup.toAddCommMonoid",
   "WellFoundedGT",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.prop3d13₁",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  WellFoundedGT (HarderNarasimhan.ℒ R M)",
  "constCategory": "Theorem"},
 {"references": ["CommSemiring"],
  "name": "PrimeSpectrum",
  "constType": "(R : Type u_1) → [CommSemiring R] → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["AddGroupWithOne.zsmul_succ'",
   "AddGroupWithOne.sub_eq_add_neg",
   "AddGroupWithOne.zsmul",
   "AddGroup.mk",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroupWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toSub",
   "AddGroupWithOne.zsmul_neg'",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne.neg_add_cancel",
   "AddGroup",
   "AddGroupWithOne.zsmul_zero'",
   "SubNegMonoid.mk"],
  "name": "AddGroupWithOne.toAddGroup",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddGroup R",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "Nat.cast",
   "Iff.mpr",
   "Int.instLTInt",
   "Int.ofNat_lt",
   "instNatCastInt",
   "Int"],
  "name": "Lean.Omega.Int.ofNat_lt_of_lt",
  "constType": "∀ {x y : ℕ}, x < y → ↑x < ↑y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SupSet",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "True",
   "Membership.mem",
   "eq_true",
   "SetLike",
   "SetLike.coe_mem",
   "Eq",
   "Subtype.val"],
  "name": "_private.Mathlib.Data.SetLike.Basic.0._proof_5",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} (x : ↥p), (↑x ∈ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MulZeroClass.mk",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → MulZeroClass α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "HarderNarasimhan.WeakDescendingChainCondition'.noConfusionType",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "HarderNarasimhan.WeakDescendingChainCondition'.casesOn",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "CompleteLattice",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLattice.toTop",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition'.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.WeakDescendingChainCondition' μ} →\n                  v1 = v2 → HarderNarasimhan.WeakDescendingChainCondition'.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Exists", "And", "Eq"],
  "name": "ExistsUnique",
  "constType": "{α : Sort u_1} → (α → Prop) → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{α : Sort u} → [i : α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Subtype",
   "Prod.mk",
   "Set",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.μmax._proof_2",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.InIntvl",
   "PartialOrder",
   "SupSet",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.μmax._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "HarderNarasimhan.μmin",
   "Or",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HarderNarasimhan.impl.prop4d12",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_4_12",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      ¬μ ⟨(⊥, x), ⋯⟩ ≤ μ HarderNarasimhan.TotIntvl ∨ μ HarderNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩) →\n    HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl →\n      HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.ConvexI.mk",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.InIntvl",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "HarderNarasimhan.ConvexI.rec",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.ConvexI.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Lattice ℒ] →\n    {S : Type} →\n      [inst_1 : CompleteLattice S] →\n        {I : { p // p.1 < p.2 }} →\n          {μ : { p // p.1 < p.2 } → S} →\n            {motive : HarderNarasimhan.ConvexI I μ → Sort u} →\n              (t : HarderNarasimhan.ConvexI I μ) →\n                ((convex :\n                      ∀ (x y : ℒ),\n                        HarderNarasimhan.InIntvl I x →\n                          HarderNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩) →\n                    motive ⋯) →\n                  motive t",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Preorder.toLT",
   "BoundedOrder",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Iff.mpr",
   "Nontrivial",
   "Top.top",
   "Ne",
   "OrderBot.toBot",
   "bot_ne_top",
   "lt_top_iff_ne_top",
   "Preorder.toLE",
   "OrderTop.toTop"],
  "name": "bot_lt_top",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : BoundedOrder α] [Nontrivial α], ⊥ < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "instLTNat",
   "Nat.find",
   "Nat",
   "Exists",
   "Subtype.property",
   "And.right",
   "And",
   "Nat.findX",
   "DecidablePred",
   "Subtype.val"],
  "name": "Nat.find_min",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n) {m : ℕ}, m < Nat.find H → ¬p m",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "Module",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "Bot.bot",
   "OfNat.ofNat",
   "Nat",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "instOfNatNat",
   "HarderNarasimhan.CoprimaryFiltration",
   "Submodule.instBot",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Eq",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.first_eq_bot",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (self : HarderNarasimhan.CoprimaryFiltration R M), self.filtration 0 = ⊥",
  "constCategory": "Theorem"},
 {"references": ["Lattice", "SemilatticeSup"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeSup α",
  "constCategory": "Definition"},
 {"references":
  ["Int.instMonoid",
   "Int.mul_add",
   "NonUnitalNonAssocSemiring.mk",
   "AddCommGroup.toAddGroup",
   "Int.instCommRing._proof_3",
   "Int.instCommRing._proof_10",
   "Int.one_mul",
   "Int.instCommRing._proof_12",
   "SubNegMonoid.toSub",
   "AddGroup.toSubNegMonoid",
   "CommSemigroup",
   "instHPow",
   "CommRing.mk",
   "SubNegMonoid.zsmul",
   "AddCommMonoid.mk",
   "Int.instCommRing._proof_4",
   "Int.mul_zero",
   "NatCast.mk",
   "Nat",
   "Int.instCommRing._proof_8",
   "Int.mul_one",
   "Nat.cast",
   "Int.instCommSemigroup",
   "Semigroup.toMul",
   "Int.zero_mul",
   "Int.instAddCommGroup",
   "MulOneClass.toOne",
   "Monoid.toMulOneClass",
   "Int.instCommRing._proof_5",
   "Int.instCommRing._proof_6",
   "Ring.mk",
   "instNatCastInt",
   "NonUnitalSemiring.mk",
   "AddCommGroup.add_comm",
   "SubNegMonoid.toNeg",
   "Int.instCommRing._proof_7",
   "Int.instCommRing._proof_9",
   "Int.instCommRing._proof_1",
   "Semiring.mk",
   "AddCommGroup",
   "Int.instCommRing._proof_2",
   "CommRing",
   "HPow.hPow",
   "Int",
   "Int.add_mul",
   "CommSemigroup.mul_comm",
   "Int.instCommRing._proof_11",
   "SubNegMonoid.toAddMonoid",
   "Monoid.toNatPow",
   "CommSemigroup.toSemigroup",
   "IntCast.mk"],
  "name": "Int.instCommRing",
  "constType": "CommRing ℤ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Subtype.lt", "Subtype", "Iff", "Subtype.mk", "Iff.rfl", "LT"],
  "name": "Subtype.mk_lt_mk",
  "constType":
  "∀ {α : Type u_2} [inst : LT α] {p : α → Prop} {x y : α} {hx : p x} {hy : p y}, ⟨x, hx⟩ < ⟨y, hy⟩ ↔ x < y",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → Coe ({ p // p.1 < p.2 } → S) ({ p // p.1 < p.2 } → Sᵒᵈ)",
  "constCategory": "Definition"},
 {"references":
  ["Finset", "Set", "Membership.mem", "Finset.instMembership", "setOf"],
  "name": "Finset.toSet",
  "constType": "{α : Type u_1} → Finset α → Set α",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references":
  ["CommRing.toCommSemiring",
   "IsNoetherianRing",
   "Module",
   "CommSemiring.toSemiring",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "CommRing"],
  "name": "HarderNarasimhan.Coprimary",
  "constType":
  "(R : Type) →\n  [inst : CommRing R] → [IsNoetherianRing R] → (M : Type) → [inst_2 : AddCommGroup M] → [_root_.Module R M] → Prop",
  "constCategory": "Other"},
 {"references":
  ["HarderNarasimhan.JordanHolderFiltration.ext",
   "Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "Prod.fst",
   "Iff.intro",
   "HarderNarasimhan.JordanHolderFiltration",
   "Eq.symm",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "BoundedOrder",
   "Prod.snd",
   "Eq.casesOn",
   "LT.lt",
   "Prod",
   "Nat",
   "Iff",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "HEq"],
  "name": "HarderNarasimhan.JordanHolderFiltration.ext_iff",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLinearOrder S} {μ : { p // p.1 < p.2 } → S} {x y : HarderNarasimhan.JordanHolderFiltration μ},\n  x = y ↔ x.filtration = y.filtration",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd",
   "Int.add_assoc",
   "Eq.trans",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Coeffs",
   "congrArg",
   "Int",
   "Lean.Omega.LinearCombo.mk",
   "HAdd.hAdd",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "Eq.refl",
   "congr",
   "Lean.Omega.IntList.instAdd",
   "Int.instAdd",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Eq.mpr",
   "Eq.rec",
   "Int.add_left_comm",
   "Lean.Omega.LinearCombo.casesOn",
   "Eq",
   "Lean.Omega.LinearCombo.instAdd",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.add_eval",
  "constType":
  "∀ (l₁ l₂ : Omega.LinearCombo) (v : Omega.Coeffs), (l₁ + l₂).eval v = l₁.eval v + l₂.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["IsOrderedAddMonoid.mk",
   "PartialOrder.toPreorder",
   "Nat.instPartialOrder",
   "instHAdd",
   "Nat.add_le_add_left",
   "Nat.instAddCommMonoid",
   "congrArg",
   "HAdd.hAdd",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "IsOrderedAddMonoid",
   "LE.le",
   "id",
   "Eq.mpr",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Eq",
   "Preorder.toLE",
   "add_comm"],
  "name": "Nat.instIsOrderedAddMonoid",
  "constType": "IsOrderedAddMonoid ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.toSpanSingleton",
   "CommRing.toCommSemiring",
   "Exists",
   "LinearMap.ker",
   "LinearMap.instFunLike",
   "Module",
   "Ideal.IsPrime",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "LinearMap",
   "CommRing",
   "IsAssociatedPrime",
   "Semiring.toNonAssocSemiring",
   "Ideal",
   "RingHom.id",
   "AddCommGroup.toAddCommMonoid",
   "Semiring.toModule",
   "Eq",
   "And.left"],
  "name": "IsAssociatedPrime.isPrime",
  "constType":
  "∀ {R : Type u_1} [inst : CommRing R] {I : Ideal R} {M : Type u_2} [inst_1 : AddCommGroup M]\n  [inst_2 : _root_.Module R M], IsAssociatedPrime I M → I.IsPrime",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "CompleteLattice.toInfSet",
   "Set",
   "CompleteLattice.toLattice",
   "InfSet.sInf",
   "LE.le",
   "Membership.mem",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteLattice",
   "Set.instMembership"],
  "name": "CompleteLattice.sInf_le",
  "constType":
  "∀ {α : Type u_8} [self : CompleteLattice α] (s : Set α), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Subtype.partialOrder",
   "ClosureOperator",
   "Set.iInter",
   "Subtype.val",
   "DFunLike.coe",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "forall_congr",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_12",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "_private.Init.Data.Subtype.0._proof_1",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "_private.Mathlib.Order.SetNotation.0._proof_4",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Eq.mpr",
   "Subtype.mk"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_14",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds) (A : T.Closeds),\n  (∀ b ∈ 𝒮, A ≤ b) → ∀ ⦃x : α⦄, x ∈ ↑A → x ∈ ↑⟨⋂ a ∈ 𝒮, ↑a, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring.right_distrib",
   "NonUnitalNonAssocSemiring.toMul",
   "AddMonoid.toAddSemigroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Distrib",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.left_distrib",
   "Distrib.mk",
   "NonUnitalNonAssocSemiring",
   "AddSemigroup.toAdd"],
  "name": "NonUnitalNonAssocSemiring.toDistrib",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Distrib α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
   "Submodule.Quotient.module",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Classical.propDecidable",
   "HarderNarasimhan.HarderNarasimhanFiltration.fin_len",
   "HarderNarasimhan.S",
   "HarderNarasimhan.Coprimary.coprimary",
   "instLTNat",
   "Exists",
   "SetLike.instMembership",
   "Submodule.addCommGroup",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.impl.piecewise_coprimary",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Set.instMembership",
   "Nat",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_20",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.toBoundedOrder",
   "Submodule.submoduleOf",
   "Submodule.hasQuotient",
   "Nat.find",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Subtype",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "Submodule",
   "ExistsUnique.exists",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.impl.prop3d11",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "CommRing.toCommSemiring",
   "instHAdd",
   "Set",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "HarderNarasimhan.impl.prop3d13₂",
   "AddCommGroup",
   "CommRing",
   "HarderNarasimhan.impl.prop3d13₁",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Submodule.completeLattice",
   "HarderNarasimhan.S₀",
   "Submodule.addCommMonoid",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_24",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (HNFil : HarderNarasimhan.HarderNarasimhanFiltration (HarderNarasimhan.μ R M)) (n : ℕ),\n  n + 1 < Nat.find ⋯ →\n    ∃ x,\n      x ∈\n        associatedPrimes R\n          (↥(HNFil.filtration (n + 1)) ⧸ Submodule.submoduleOf (HNFil.filtration n) (HNFil.filtration (n + 1)))",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "instAddNat",
   "HAdd.hAdd",
   "instLTNat",
   "Nat",
   "instOfNatNat",
   "instHAdd",
   "Iff",
   "LE.le",
   "Iff.rfl",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Nat.add_one_le_iff",
  "constType": "∀ {n m : ℕ}, n + 1 ≤ m ↔ n < m",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Nat.instPreorder",
   "Prod.fst",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.impl.JHFil._proof_2",
   "WellFoundedGT",
   "CompleteLattice.toTop",
   "CompleteLinearOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "HarderNarasimhan.impl.JHFil",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.impl.JHFil.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hacc : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤)\n  (hμsl : HarderNarasimhan.SlopeLike μ) (hst : HarderNarasimhan.Semistable μ)\n  (hdc : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤),\n  HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc 0 = ⊤",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Fintype",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "AddRightStrictMono",
   "sub_pos",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubtractionMonoid",
   "OfNat.ofNat",
   "LT.lt",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "NegZeroClass.toZero",
   "AddGroup",
   "Zero.toOfNat0",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "instHSub",
   "LT",
   "propext",
   "AddMonoid.toAddZeroClass"],
  "name": "_private.Mathlib.Algebra.Order.Group.Unbundled.Basic.0._proof_51",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α] [AddRightStrictMono α] {a b : α}, (0 < a - b) = (b < a)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Preorder.toLT",
   "Classical.propDecidable",
   "IsGreatest",
   "HarderNarasimhan.impl.HNFil._proof_3",
   "letFun",
   "HarderNarasimhan.Convex",
   "Nat.instLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "HarderNarasimhan.impl.HNFil_of_fin_len",
   "Nat",
   "Nat.find_spec",
   "Iff",
   "Nontrivial",
   "Lattice",
   "Classical.byContradiction",
   "Top.top",
   "Subtype",
   "HarderNarasimhan.StI",
   "Eq.mp",
   "HarderNarasimhan.impl.HNFil",
   "HarderNarasimhan.impl.HNlen",
   "congrArg",
   "Iff.intro",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Nat.le_induction",
   "HarderNarasimhan.impl.HNFil._proof_4",
   "Lattice.toSemilatticeInf",
   "True",
   "HarderNarasimhan.μ_Admissible",
   "Mathlib.Tactic.PushNeg.not_lt_eq",
   "Exists.choose",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "eq_self",
   "dite_cond_eq_true",
   "of_eq_true",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop",
   "instLENat",
   "Nat.find_min",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil_ne_top_iff_lt_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (n : ℕ),\n  HarderNarasimhan.impl.HNFil μ n ≠ ⊤ ↔ n < HarderNarasimhan.impl.HNlen μ",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "instLTNat", "Nat", "Decidable", "Nat.succ", "Nat.decLe"],
  "name": "Nat.decLt",
  "constType": "(n m : ℕ) → Decidable (n < m)",
  "constCategory": "Definition"},
 {"references":
  ["Finset",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "LinearOrder",
   "Finset.Nonempty.mono",
   "Finset.instHasSubset",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "HasSubset.Subset",
   "Finset.min'",
   "LE.le",
   "Preorder.toLE",
   "Finset.Nonempty",
   "Finset.min'_mem",
   "Finset.min'_le",
   "SemilatticeInf.toPartialOrder"],
  "name": "Finset.min'_subset",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrder α] {s t : Finset α} (H : s.Nonempty) (hst : s ⊆ t), t.min' ⋯ ≤ s.min' H",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsWellOrder",
  "constType": "(α : Type u) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "top_ne_bot",
   "BoundedOrder",
   "Bot.bot",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "eq_false",
   "Nontrivial",
   "Top.top",
   "False",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop"],
  "name": "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_37",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : BoundedOrder α] [Nontrivial α], (⊤ = ⊥) = False",
  "constCategory": "Theorem"},
 {"references":
  ["PUnit.unit",
   "Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "OfNat.ofNat",
   "Unit"],
  "name": "HarderNarasimhan.impl.JHFil.match_1._cstage1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddZeroClass.toZero",
   "instOfNatNat",
   "AddMonoidWithOne.natCast_zero",
   "Zero.toOfNat0",
   "AddMonoidWithOne.toAddMonoid",
   "Eq",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Nat.cast_zero",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSMul"],
  "name": "HSMul.hSMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["HarderNarasimhan.μB._rarg", "_obj", "_neutral"],
  "name": "HarderNarasimhan.μB._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "AddMonoid.nsmul_zero._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.Quotient.isScalarTower",
   "Submodule.hasQuotient",
   "Ring.toNonAssocRing",
   "HasQuotient.Quotient",
   "IsScalarTower",
   "Module",
   "Submodule.Quotient.module",
   "AddCommGroup.toAddGroup",
   "AddGroupWithOne.toAddMonoidWithOne",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "instDistribSMul",
   "AddMonoidWithOne.toAddMonoid",
   "Submodule.Quotient.instSMul._proof_3",
   "Submodule",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "MulAction.toSMul",
   "Submodule.Quotient.addCommGroup",
   "SMul",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "RingHom.id",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "LinearMap.restrictScalars",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DistribSMul.toSMulZeroClass",
   "Submodule.mkQ",
   "Submodule.Quotient.module'",
   "AddZeroClass.toZero",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Submodule.mkQ_surjective",
   "RingHomSurjective.ids",
   "Ring.toSemiring",
   "Module.Finite.of_surjective",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "LinearMap.IsScalarTower.compatibleSMul",
   "AddCommGroup.toAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "Ring",
   "Semiring",
   "Module.Finite"],
  "name": "Module.Finite.quotient",
  "constType":
  "∀ (R : Type u_6) {A : Type u_7} {M : Type u_8} [inst : Semiring R] [inst_1 : AddCommGroup M] [inst_2 : Ring A]\n  [inst_3 : _root_.Module A M] [inst_4 : _root_.Module R M] [inst_5 : SMul R A] [inst_6 : IsScalarTower R A M]\n  [Module.Finite R M] (N : Submodule A M), Module.Finite R (M ⧸ N)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Ring.toNonAssocRing",
   "Classical.propDecidable",
   "eq_true",
   "AddGroupWithOne.toAddMonoidWithOne",
   "List.instGetElem?NatLtLength",
   "Int.instCommSemiring",
   "GetElem?.getElem?",
   "CompleteSemilatticeInf.toPartialOrder",
   "Nat.sub_one_add_one",
   "Eq.symm",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "ne_of_gt",
   "Or.resolve_left",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Ring.toSemiring",
   "instOfNat",
   "HarderNarasimhan.InIntvl",
   "eq_false",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "Eq.mpr",
   "HarderNarasimhan.Semistable",
   "StrictMono",
   "instDecidableTrue",
   "HarderNarasimhan.impl.thm4d21",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Classical.not_and_iff_not_or_not",
   "List",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Or.inl",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Int.instIsOrderedAddMonoid",
   "HPow.hPow",
   "lt_of_lt_of_le",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "eq_self",
   "dite_cond_eq_true",
   "Monoid.toNatPow",
   "HarderNarasimhan.impl.JHFil",
   "Ne",
   "instHSub",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "WellFounded.has_min",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "HarderNarasimhan.μmax",
   "Semiring.toNonAssocSemiring",
   "Or",
   "_private.Init.SimpLemmas.0._proof_5",
   "forall_congr",
   "Int.instLEInt",
   "List.TFAE",
   "CompleteLattice.toTop",
   "AddGroup.toSubNegMonoid",
   "CompleteLinearOrder",
   "Eq.rec",
   "Int.ofNat",
   "List.cons",
   "HarderNarasimhan.impl.JHFil_prop₁",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "lt_of_le_of_lt",
   "And.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.lt_add_one",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Iff.of_eq",
   "Option",
   "HarderNarasimhan.impl.JHFil._proof_4",
   "_private.Init.PropLemmas.0._proof_24",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Nat.cast",
   "Eq.mp",
   "Or.resolve_right",
   "lt_of_le_of_ne",
   "CommRing.toNonUnitalCommRing",
   "dite_congr",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "IsWellFounded.wf",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "dite_cond_eq_false",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "HarderNarasimhan.instWeakDescendingChainConditionOfWeakDescendingChainCondition'",
   "Not",
   "List.nil",
   "Set.Nonempty",
   "le_top",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "HarderNarasimhan.μmax._proof_2",
   "Mathlib.Tactic.Ring.add_congr",
   "Eq.mpr_prop",
   "LT.lt",
   "instSubNat",
   "of_eq_true",
   "ne_of_lt",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "False",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "HarderNarasimhan.SlopeLike",
   "not_strictMono_of_wellFoundedGT",
   "Eq.trans",
   "_private.Init.SimpLemmas.0._proof_4",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "False.elim",
   "HarderNarasimhan.NashEquilibrium",
   "SupSet.sSup",
   "SubNegMonoid.toSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "letFun",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "Exists.choose_spec",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "_private.Mathlib.Order.Basic.0._proof_1",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Classical.byContradiction",
   "AddMonoidWithOne.toOne",
   "Lattice",
   "HarderNarasimhan.in_TotIntvl",
   "Nat.rawCast",
   "setOf",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Ne.symm",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "EmptyCollection.emptyCollection",
   "Int.instRing",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "HarderNarasimhan.WeakAscendingChainCondition.mk",
   "_private.Init.PropLemmas.0._proof_15",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "not_true_eq_false",
   "WellFoundedGT",
   "Preorder.toLE",
   "Set.eq_empty_iff_forall_not_mem",
   "Linarith.lt_irrefl",
   "propext",
   "lt_of_not_ge",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.impl.prop4d6",
   "HarderNarasimhan.instBoundedOrderInterval",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "HarderNarasimhan.impl.JHFil_anti_mono",
   "instDecidableEqNat",
   "inferInstance",
   "dite",
   "neg_neg_of_pos",
   "bot_lt_top",
   "lt_trans",
   "Nat.cast_one",
   "Int.instCommRing",
   "Prod.mk",
   "Iff.mp",
   "bot_le",
   "Int.rawCast",
   "HMul.hMul",
   "_private.Mathlib.Data.Set.Basic.0._proof_26",
   "AddMonoidWithOne.toAddMonoid",
   "And.intro",
   "Set.not_nonempty_iff_eq_empty",
   "Ring.toAddGroupWithOne",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "not_lt_of_lt",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "And",
   "HarderNarasimhan.TotIntvl",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "List.length",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "HarderNarasimhan.TotIntvl._proof_1",
   "CompleteSemilatticeSup.toSupSet",
   "Set.instEmptyCollection",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "instDecidableFalse",
   "_private.Init.PropLemmas.0._proof_12",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "HarderNarasimhan.Interval",
   "OrderBot.toBot",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "List.TFAE.out",
   "True",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Exists.choose",
   "exists_prop_congr",
   "StrictAnti",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "le_sSup",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Mathlib.Tactic.PushNeg.not_nonempty_eq",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.impl.JHFil_prop₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hacc : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S)\n  [hwdcc' : HarderNarasimhan.WeakDescendingChainCondition' μ] (hμ : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤)\n  (hμsl : HarderNarasimhan.SlopeLike μ) (hst : HarderNarasimhan.Semistable μ)\n  (hdc : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) (k : ℕ)\n  (hk : HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc k > ⊥) (z : ℒ)\n  (h' : HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc (k + 1) < z),\n  z < HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc k →\n    μ ⟨(HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc (k + 1), z), h'⟩ <\n      μ ⟨(HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc (k + 1), HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc k), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name":
  "HarderNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.coe_injective",
   "Subtype",
   "PartialOrder",
   "PartialOrder.lift",
   "Subtype.val"],
  "name": "Subtype.partialOrder",
  "constType":
  "{α : Type u_2} → [PartialOrder α] → (p : α → Prop) → PartialOrder (Subtype p)",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references": ["_obj", "_neutral"],
  "name": "HarderNarasimhan.μB._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Fintype.card", "Nat", "Fin", "List.length_finRange", "Eq", "Fin.fintype"],
  "name": "Fintype.card_fin",
  "constType": "∀ (n : ℕ), Fintype.card (Fin n) = n",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "bot_lt_iff_ne_bot",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Bot.bot",
   "LT.lt",
   "PartialOrder",
   "Iff",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Iff.not_left",
   "OrderBot"],
  "name": "not_bot_lt_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, ¬⊥ < a ↔ a = ⊥",
  "constCategory": "Theorem"},
 {"references": ["One", "MulOneClass"],
  "name": "MulOneClass.toOne",
  "constType": "{M : Type u} → [self : MulOneClass M] → One M",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Ideal.IsPrime",
   "CommSemiring",
   "CommSemiring.toSemiring",
   "OmegaCompletePartialOrder.toPartialOrder",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "Minimal",
   "Semiring.toNonAssocSemiring",
   "Ideal",
   "LE.le",
   "Submodule.completeLattice",
   "Semiring.toModule",
   "Preorder.toLE",
   "setOf"],
  "name": "Ideal.minimalPrimes",
  "constType":
  "{R : Type u_1} → [inst : CommSemiring R] → Ideal R → Set (Ideal R)",
  "constCategory": "Definition"},
 {"references":
  ["IsOrderedAddMonoid.mk",
   "PartialOrder.toPreorder",
   "IsOrderedCancelAddMonoid.mk",
   "Eq.mp",
   "Nat.le_of_add_le_add_left",
   "Nat.instPartialOrder",
   "instHAdd",
   "Nat.add_le_add_left",
   "Nat.instAddCommMonoid",
   "congrArg",
   "HAdd.hAdd",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "LE.le",
   "id",
   "AddCommSemigroup.toAddCommMagma",
   "Eq.mpr",
   "AddCommMagma.toAdd",
   "Eq",
   "Preorder.toLE",
   "add_comm",
   "IsOrderedCancelAddMonoid"],
  "name": "Nat.instIsOrderedCancelAddMonoid",
  "constType": "IsOrderedCancelAddMonoid ℕ",
  "constCategory": "Theorem"},
 {"references": ["SMul", "HSMul", "SMul.smul", "HSMul.mk"],
  "name": "instHSMul",
  "constType": "{α : Type u_1} → {β : Type u_2} → [SMul α β] → HSMul α β β",
  "constCategory": "Definition"},
 {"references":
  ["RelEmbedding.toEmbedding",
   "EmbeddingLike",
   "Function.Embedding.inj'",
   "RelEmbedding",
   "RelEmbedding.instFunLike",
   "EmbeddingLike.mk"],
  "name": "RelEmbedding.instEmbeddingLike",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop}, EmbeddingLike (r ↪r s) α β",
  "constCategory": "Theorem"},
 {"references": ["OrderDual", "LE.le", "LE.mk", "LE"],
  "name": "OrderDual.instLE",
  "constType": "(α : Type u_5) → [LE α] → LE αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.Affine",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "CompleteSemilatticeSup",
   "Membership.mem",
   "isLUB_sSup",
   "CompleteSemilatticeSup.toSupSet",
   "Set.instMembership",
   "SupSet.sSup",
   "Iff",
   "isLUB_le_iff",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sSup_le_iff",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, sSup s ≤ a ↔ ∀ b ∈ s, b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Subtype.val",
   "IsGreatest",
   "HarderNarasimhan.impl.HNFil._proof_3",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.Convex",
   "HarderNarasimhan.impl.prop3d8₁'",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "Or.inr",
   "HarderNarasimhan.StI",
   "Subtype",
   "HarderNarasimhan.impl.HNFil",
   "lt_of_le_of_ne",
   "Prod.fst",
   "Or.inl",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_top",
   "HarderNarasimhan.μ_Admissible",
   "HarderNarasimhan.μ_Admissible.μ_adm",
   "LT.lt",
   "Or.casesOn",
   "IsTotal",
   "HarderNarasimhan.Convex_of_Convex_large",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (n : ℕ)\n  (htop : ¬HarderNarasimhan.impl.HNFil μ n = ⊤),\n  ∃ s, IsGreatest (HarderNarasimhan.StI μ ⟨(HarderNarasimhan.impl.HNFil μ n, ⊤), ⋯⟩) s",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "And.intro",
   "Or",
   "sSup_le",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Classical.not_not",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Or.resolve_right",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Prod.fst",
   "le_rfl",
   "eq_of_le_of_le",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.impl.rmk4d10₀",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.μmax._proof_2",
   "sInf_le",
   "LT.lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "OrderTop.toTop",
   "CompleteLattice",
   "And.casesOn"],
  "name": "HarderNarasimhan.impl.prop4d14",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      μ ⟨(⊥, x), ⋯⟩ ≤ μ HarderNarasimhan.TotIntvl ∨ ¬μ HarderNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩) →\n    HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = μ HarderNarasimhan.TotIntvl →\n      HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Subtype", "Subtype.exists", "Subtype.mk", "Eq", "propext"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_16",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "Subtype.partialOrder",
   "ClosureOperator",
   "Union.union",
   "Subtype.val",
   "DFunLike.coe",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "ClosureOperator.isClosed_closure",
   "Preorder.toLE",
   "Set.instUnion",
   "Eq.rec",
   "Eq",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Set.union_subset",
   "Set.instMembership",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Subtype.mk"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_4",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B C : T.Closeds),\n  A ≤ C → B ≤ C → ∀ ⦃a : α⦄, a ∈ ↑⟨T (↑A ∪ ↑B), ⋯⟩ → a ∈ ↑C",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "DFunLike.mk",
   "Equiv.instFunLike._proof_2",
   "Equiv.toFun",
   "Equiv"],
  "name": "Equiv.instFunLike",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ≃ β) α β",
  "constCategory": "Definition"},
 {"references": ["Preorder", "Iff", "LE.le", "Preorder.toLE"],
  "name": "GaloisConnection",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → (β → α) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "HarderNarasimhan.instCoeOutInterval._rarg", "_neutral"],
  "name": "HarderNarasimhan.instCoeOutInterval._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.semistableI",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Iff.mp",
   "HarderNarasimhan.impl.HNFil_prop_of_def",
   "Nat.instAddCommMonoid",
   "HarderNarasimhan.Convex",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Nat.instIsOrderedAddMonoid",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Nat.instPartialOrder",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Prod.snd",
   "Set.instMembership",
   "HarderNarasimhan.impl.semistableI_iff",
   "Prod",
   "HarderNarasimhan.impl.HNFil_of_fin_len",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "upperBounds",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "lt_top_iff_ne_top",
   "HarderNarasimhan.Semistable",
   "AddMonoid.toAddZeroClass",
   "Nat.find",
   "HarderNarasimhan.StI",
   "Subtype",
   "HarderNarasimhan.impl.HNFil",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Nat.instOne",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Nat.instIsOrderedCancelAddMonoid",
   "WellFoundedGT",
   "HarderNarasimhan.Interval",
   "Eq",
   "Preorder.toLE",
   "Nat.instAddMonoid",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.μ_Admissible",
   "instHAdd",
   "HarderNarasimhan.instBoundedOrderInterval",
   "HarderNarasimhan.impl.HNFil_is_strict_mono'",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "HarderNarasimhan.instNontrivialInterval",
   "lt_add_one",
   "AddZeroClass.toAdd",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Ne",
   "Subtype.mk",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "OrderTop.toTop",
   "Nat.find_min",
   "HarderNarasimhan.impl.prop3d7₁",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil_piecewise_semistable",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (i : ℕ) (h_1 : i < Nat.find ⋯),\n  HarderNarasimhan.Semistable\n    (HarderNarasimhan.Resμ ⟨(HarderNarasimhan.impl.HNFil μ i, HarderNarasimhan.impl.HNFil μ (i + 1)), ⋯⟩ μ)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Lean.Name.anonymous",
   "sorryAx",
   "PartialOrder.toPreorder",
   "Lean.Name",
   "Module",
   "Lean.Name.str",
   "Bool.false",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "Minimal",
   "Semiring.toNonAssocSemiring",
   "Ideal",
   "instOfNatNat",
   "PrimeSpectrum.instPartialOrder",
   "PrimeSpectrum.asIdeal",
   "Preorder.toLE",
   "Semiring.toModule",
   "CommRing.toCommSemiring",
   "Set",
   "Module.support",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup",
   "CommRing",
   "OfNat.ofNat",
   "Set.instMembership",
   "PrimeSpectrum",
   "Nat",
   "IsNoetherianRing",
   "Iff",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "Lean.Name.num",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.min_associated_prime_iff_min_supp",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [IsNoetherianRing R] {M : Type} [inst_2 : AddCommGroup M] [inst_3 : _root_.Module R M]\n  [Module.Finite R M] {I : PrimeSpectrum R},\n  Minimal (fun J => J ∈ associatedPrimes R M) I.asIdeal ↔ Minimal (fun J => J ∈ Module.support R M) I",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq.rec", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a ⋯ → motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Int.instSub",
   "Eq.mp",
   "instHAdd",
   "Neg.neg",
   "Int.instNegInt",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "Int.add_right_neg",
   "Int.add_le_add_right",
   "HAdd.hAdd",
   "instOfNat",
   "letFun",
   "LE.le",
   "Int.instAdd",
   "Int.instLEInt",
   "HSub.hSub",
   "instHSub"],
  "name": "Int.sub_nonneg_of_le",
  "constType": "∀ {a b : ℤ}, b ≤ a → 0 ≤ a - b",
  "constCategory": "Theorem"},
 {"references":
  ["Unique",
   "CommRing.toCommSemiring",
   "Module",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "CommRing",
   "HarderNarasimhan.impl.instUniqueCoprimaryFiltration",
   "IsNoetherianRing",
   "HarderNarasimhan.CoprimaryFiltration",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "inferInstance",
   "Module.Finite"],
  "name": "HarderNarasimhan.theorem_3_15₂",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] → Unique (HarderNarasimhan.CoprimaryFiltration R M)",
  "constCategory": "Definition"},
 {"references":
  ["Int.instSub",
   "True",
   "Eq.trans",
   "instHAdd",
   "Neg.neg",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Coeffs",
   "Int.instNegInt",
   "congrArg",
   "Int",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.LinearCombo.instSub",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.sub_eq_add_neg",
   "Lean.Omega.LinearCombo.instNeg",
   "of_eq_true",
   "Int.instAdd",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.LinearCombo.instAdd",
   "Eq",
   "instHSub"],
  "name": "Lean.Omega.LinearCombo.sub_eval",
  "constType":
  "∀ (l₁ l₂ : Omega.LinearCombo) (v : Omega.Coeffs), (l₁ - l₂).eval v = l₁.eval v - l₂.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommMonoid",
   "AddCommSemigroup.mk",
   "AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "ClosureOperator.IsClosed",
   "PartialOrder",
   "ClosureOperator"],
  "name": "ClosureOperator.Closeds",
  "constType":
  "{α : Type u_1} → [inst : PartialOrder α] → ClosureOperator α → Type (max 0 u_1)",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection.lowerAdjoint",
   "Preorder",
   "PartialOrder.toPreorder",
   "GaloisConnection",
   "PartialOrder",
   "LowerAdjoint.closureOperator",
   "ClosureOperator"],
  "name": "GaloisConnection.closureOperator",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_4} →\n    [inst : PartialOrder α] →\n      [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisConnection l u → ClosureOperator α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "rfl",
   "Nat",
   "Nat.cast",
   "instHAdd",
   "Int.instAdd",
   "Eq",
   "instNatCastInt",
   "Int"],
  "name": "Int.natCast_add",
  "constType": "∀ (n m : ℕ), ↑(n + m) = ↑n + ↑m",
  "constCategory": "Theorem"},
 {"references": ["PartialOrder", "CompleteSemilatticeSup"],
  "name": "CompleteSemilatticeSup.toPartialOrder",
  "constType":
  "{α : Type u_8} → [self : CompleteSemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "True", "exists_true_left", "True.intro", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_14",
  "constType": "∀ {p : True → Prop}, Exists p = p True.intro",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommMonoid",
   "SetLike.instMembership",
   "Submodule.setLike",
   "Module",
   "Iff",
   "Membership.mem",
   "Eq",
   "SetLike.ext",
   "Submodule",
   "Semiring"],
  "name": "Submodule.ext",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  {p q : Submodule R M}, (∀ (x : M), x ∈ p ↔ x ∈ q) → p = q",
  "constCategory": "Theorem"},
 {"references": ["AddGroup", "AddCommGroup"],
  "name": "AddCommGroup.toAddGroup",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddGroup G",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.hasQuotient",
   "Ring.toNonAssocRing",
   "Submodule.Quotient.module'",
   "HasQuotient.Quotient",
   "AddZeroClass.toZero",
   "Module",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddCommGroup",
   "SMulZeroClass.toSMul",
   "instDistribSMul",
   "AddMonoidWithOne.toAddMonoid",
   "Submodule.Quotient.instSMul._proof_3",
   "Ring.toSemiring",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "AddCommGroup.toAddCommMonoid",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DistribSMul.toSMulZeroClass",
   "Ring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.Quotient.module",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] → [inst_2 : _root_.Module R M] → (P : Submodule R M) → _root_.Module R (M ⧸ P)",
  "constCategory": "Definition"},
 {"references":
  ["of_decide_eq_self_eq_true",
   "instBEqOfDecidableEq",
   "ReflBEq.mk",
   "LawfulBEq",
   "DecidableEq",
   "LawfulBEq.mk",
   "Eq",
   "of_decide_eq_true"],
  "name": "instLawfulBEq",
  "constType": "∀ {α : Type u_1} [inst : DecidableEq α], LawfulBEq α",
  "constCategory": "Theorem"},
 {"references": ["Unique", "Eq", "Inhabited", "Inhabited.default"],
  "name": "Unique.mk",
  "constType":
  "{α : Sort u} → (toInhabited : Inhabited α) → (∀ (a : α), a = default) → Unique α",
  "constCategory": "Other"},
 {"references":
  ["Nat.find_eq_zero",
   "Nat.find",
   "Nat",
   "Exists",
   "instOfNatNat",
   "DecidablePred",
   "Eq",
   "OfNat.ofNat",
   "propext"],
  "name": "_private.Mathlib.Data.Nat.Find.0._proof_10",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (h : ∃ n, p n), (Nat.find h = 0) = p 0",
  "constCategory": "Theorem"},
 {"references":
  ["LocalizedModule.r.setoid",
   "Subtype",
   "SetLike.instMembership",
   "LocalizedModule",
   "Prod.mk",
   "Module",
   "Submonoid.instSetLike",
   "CommSemiring",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "MulZeroOneClass.toMulOneClass",
   "Prod",
   "Submonoid",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Quotient.mk'",
   "NonAssocSemiring.toMulZeroOneClass"],
  "name": "LocalizedModule.mk",
  "constType":
  "{R : Type u} →\n  [inst : CommSemiring R] →\n    {S : Submonoid R} →\n      {M : Type v} → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → M → ↥S → LocalizedModule S M",
  "constCategory": "Definition"},
 {"references":
  ["FunLike",
   "EmbeddingLike.apply_eq_iff_eq",
   "EmbeddingLike",
   "Eq",
   "DFunLike.coe",
   "propext"],
  "name": "HarderNarasimhan.impl.rmk4d14₂._proof_18",
  "constType":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [inst : FunLike F α β] [i : EmbeddingLike F α β] (f : F) {x y : α},\n  (f x = f y) = (x = y)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.S₀_order",
   "Finset",
   "Eq.trans",
   "Singleton.singleton",
   "Set.toFinset_subset_toFinset",
   "HarderNarasimhan.impl.prop3d12",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Finset.min'",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.S",
   "ClosureOperator.IsClosed",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff",
   "Submodule.instBot",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "Eq.mpr",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.Semistable",
   "RelEmbedding.toEmbedding",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "HarderNarasimhan.impl.μ_nonempty",
   "Prod.fst",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.impl.rmk4d14₁._proof_14",
   "CompleteLattice.toConditionallyCompleteLattice",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "LinearExtension",
   "Set",
   "Submodule.instTop",
   "Set.toFinset",
   "AddCommGroup",
   "HarderNarasimhan.impl.assinc",
   "HarderNarasimhan.impl.rmk4d14₁._proof_15",
   "lt_of_lt_of_le",
   "PrimeSpectrum",
   "LinearOrder.toPartialOrder",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.instPartialOrderS₀",
   "Submodule.completeLattice",
   "Ne",
   "HarderNarasimhan.S₀",
   "CompleteLattice.toCompleteSemilatticeInf",
   "bot_lt_top",
   "Module.Finite",
   "le_refl",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.instLES₀",
   "Prod.mk",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Membership.mem",
   "HarderNarasimhan.μ",
   "Subtype.preorder",
   "Preorder.toLT",
   "Iff.mp",
   "GT.gt",
   "RelEmbedding.instFunLike",
   "HarderNarasimhan.impl.rmk4d14₁._proof_16",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "SetLike.instMembership",
   "And.right",
   "True.intro",
   "Bot.bot",
   "Finset.min'_subset",
   "Finset.instSingleton",
   "HasSubset.Subset",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_12",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.instNontrivial",
   "Eq.mp",
   "Function.Embedding.toFun",
   "DFunLike.coe",
   "Submodule",
   "Iff.intro",
   "congrArg",
   "HarderNarasimhan.impl.rmk4d14₁._proof_18",
   "HarderNarasimhan.impl.rmk4d14₁._proof_17",
   "instDistribLatticeOfLinearOrder",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.instLinearOrderS₀",
   "HarderNarasimhan.Semistable.mk",
   "RelEmbedding.instEmbeddingLike",
   "OrderBot.toBot",
   "Subtype.le",
   "Submodule.instOrderBot",
   "RelEmbedding",
   "Set.instLE",
   "Not",
   "CommRing.toCommSemiring",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.Semistable.semistable",
   "Finset.instHasSubset",
   "CommRing",
   "Set.instHasSubset",
   "LT.lt",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "Submodule.setLike",
   "LE.le",
   "Subtype.mk",
   "OrderTop.toTop",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.impl.rmk4d14₁",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  HarderNarasimhan.Semistable (HarderNarasimhan.μ R M) ↔\n    ∀ (N : HarderNarasimhan.ℒ R M) (hN : ⊥ < N),\n      HarderNarasimhan.μA (HarderNarasimhan.μ R M) ⟨(⊥, N), hN⟩ =\n        HarderNarasimhan.coe'.toFun {(HarderNarasimhan._μ R M ⟨(⊥, ⊤), ⋯⟩).toFinset.min' ⋯}",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZero",
   "Real",
   "NNReal",
   "LE.le",
   "Subtype.instLinearOrder",
   "LinearOrder",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "OfNat.ofNat",
   "Real.instLE"],
  "name": "NNReal.instLinearOrder",
  "constType": "LinearOrder NNReal",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "MulAction.toSMul",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.casesOn",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Preorder.toLE",
   "AddSemigroup.toAdd",
   "PosSMulStrictMono",
   "Real",
   "instHAdd",
   "AddCommGroup.add_comm",
   "LinearOrder",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "AddMonoid.toAddSemigroup",
   "LE.le",
   "HEq"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.noConfusionType",
  "constType":
  "{V : Type} →\n  Sort u → HarderNarasimhan.TotallyOrderedRealVectorSpace V → HarderNarasimhan.TotallyOrderedRealVectorSpace V → Sort u",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_refl",
  "constType": "∀ {α : Type u_2} [self : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.μB",
   "Prod.snd",
   "Bot.bot",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Nontrivial",
   "Top.top",
   "OrderBot.toBot",
   "Subtype.mk",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μBstar",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → S",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.noConfusionType",
   "MulAction.toSMul",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.casesOn",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "Eq.ndrec",
   "Eq",
   "AddSemigroup.toAdd",
   "PosSMulStrictMono",
   "HEq.refl",
   "Real",
   "instHAdd",
   "AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "LinearOrder",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "Eq.refl",
   "AddMonoid.toAddSemigroup",
   "LE.le",
   "HEq"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.noConfusion",
  "constType":
  "{V : Type} →\n  {P : Sort u} →\n    {v1 v2 : HarderNarasimhan.TotallyOrderedRealVectorSpace V} →\n      v1 = v2 → HarderNarasimhan.TotallyOrderedRealVectorSpace.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["OrderDual", "Top", "Bot", "Top.mk", "Bot.bot"],
  "name": "OrderDual.instTop",
  "constType": "(α : Type u) → [Bot α] → Top αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "Nat.recAux",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "absurd",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "Eq.refl",
   "HSub.hSub",
   "Ne",
   "Eq",
   "instHSub"],
  "name": "Nat.sub_one_add_one",
  "constType": "∀ {a : ℕ}, a ≠ 0 → a - 1 + 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "Subtype",
   "LinearMap.instFunLike",
   "SemilinearMapClass",
   "Module",
   "Submodule.module",
   "Membership.mem",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "FunLike",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "CommSemiring.toSemiring",
   "Submodule.addCommGroup",
   "AddCommGroup",
   "CommRing",
   "LinearMap",
   "Ring.toSemiring",
   "RingHom.id._at.HarderNarasimhan.impl.lift_quot._spec_1",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.addCommMonoid",
   "Semiring",
   "Ring"],
  "name": "Submodule.map._at.HarderNarasimhan.impl.lift_quot._spec_18",
  "constType":
  "(R : Type) →\n  (inst : CommRing R) →\n    (M : Type) →\n      (inst_1 : AddCommGroup M) →\n        (inst_2 : _root_.Module R M) →\n          (N₂ : Submodule R M) →\n            (_x_1 : Ring R) →\n              let _x_2 := _x_1.1;\n              (_x_6 : Semiring R) →\n                let _x_7 := N₂.addCommGroup;\n                let _x_8 := AddCommGroup.toAddCommMonoid;\n                (_x_9 : AddCommMonoid M) →\n                  let _x_10 := N₂.module;\n                  let _x_12 := RingHom.id._at.HarderNarasimhan.impl.lift_quot._spec_1 R inst;\n                  let _x_13 := N₂.addCommMonoid;\n                  let _x_14 := LinearMap.instFunLike;\n                  let _y_5 := _x_2;\n                  let _y_6 := _x_6;\n                  let _y_7 := _x_8;\n                  let _y_8 := _x_9;\n                  let _y_9 := _x_10;\n                  let _y_10 := inst_2;\n                  let _y_13 := _x_14;\n                  {σ₁₂ : R →+* R} →\n                    SemilinearMapClass (↥N₂ →ₗ[R] M) σ₁₂ (↥N₂) M → (↥N₂ →ₗ[R] M) → Submodule R ↥N₂ → Submodule R M",
  "constCategory": "Axiom"},
 {"references":
  ["Set.image",
   "Set.Nonempty",
   "Set.Nonempty.image.match_1",
   "Set",
   "Membership.mem",
   "Exists.intro",
   "Set.mem_image_of_mem",
   "Set.instMembership"],
  "name": "Set.Nonempty.image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) {s : Set α}, s.Nonempty → (f '' s).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toPartialOrder",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Preorder.toLE",
   "HeytingAlgebra",
   "GeneralizedHeytingAlgebra.toLattice",
   "OrderBot"],
  "name": "HeytingAlgebra.toOrderBot",
  "constType": "{α : Type u_4} → [self : HeytingAlgebra α] → OrderBot α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "Lattice.inf_le_right",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "BiheytingAlgebra.toHeytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder",
   "Lattice.inf",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "LE.le",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "GeneralizedHeytingAlgebra.toLattice",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_34",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α), Lattice.inf a b ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Quotient",
   "LocalizedModule.r.setoid",
   "Subtype",
   "SetLike.instMembership",
   "Submonoid.instSetLike",
   "Module",
   "CommSemiring",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "MulZeroOneClass.toMulOneClass",
   "Submonoid",
   "Prod",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toMulZeroOneClass"],
  "name": "LocalizedModule",
  "constType":
  "{R : Type u} →\n  [inst : CommSemiring R] →\n    Submonoid R → (M : Type v) → [inst_1 : AddCommMonoid M] → [_root_.Module R M] → Type (max u v)",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μ_Admissible.rec",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.μ_Admissible.mk",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.μ_Admissible.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                {motive : HarderNarasimhan.μ_Admissible μ → Sort u} →\n                  (t : HarderNarasimhan.μ_Admissible μ) →\n                    ((μ_adm :\n                          (IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n                            ∀ (I : { p // p.1 < p.2 }), HarderNarasimhan.IsAttained μ I) →\n                        motive ⋯) →\n                      motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "HarderNarasimhan.ConvexI.casesOn",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.InIntvl",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.ConvexI.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Lattice ℒ} →\n    {S : Type} →\n      {inst_1 : CompleteLattice S} →\n        {I : { p // p.1 < p.2 }} →\n          {μ : { p // p.1 < p.2 } → S} → Sort u → HarderNarasimhan.ConvexI I μ → HarderNarasimhan.ConvexI I μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "Nat.cast",
   "LE.le",
   "Int.instLEInt",
   "Eq",
   "instLENat",
   "propext",
   "Mathlib.Tactic.Zify.natCast_le",
   "instNatCastInt",
   "Int"],
  "name": "_private.Mathlib.Tactic.Zify.0._proof_2",
  "constType": "∀ (a b : ℕ), (a ≤ b) = (↑a ≤ ↑b)",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "BoundedOrder",
  "constType": "(α : Type u) → [LE α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["FunLike",
   "EmbeddingLike.apply_eq_iff_eq",
   "EmbeddingLike",
   "Eq",
   "DFunLike.coe",
   "propext"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_17",
  "constType":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [inst : FunLike F α β] [i : EmbeddingLike F α β] (f : F) {x y : α},\n  (f x = f y) = (x = y)",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "Set", "LE.le", "Preorder.toLE", "setOf"],
  "name": "Set.Iic",
  "constType": "{α : Type u_1} → [Preorder α] → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Eq",
   "Set.instSingletonSet",
   "propext",
   "Set.instMembership"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_12",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["DivInvMonoid.toInv",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "MulZeroClass.toMul",
   "Preorder.toLT",
   "HMul.hMul",
   "MonoidWithZero.toMulZeroOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "not_false_eq_true",
   "PartialOrder",
   "letFun",
   "Eq.rec",
   "MulOneClass.toMul",
   "InvOneClass.toInv",
   "InvolutiveInv.toInv",
   "MulZeroClass.zero_mul",
   "lt_of_mul_lt_mul_right",
   "MulZeroOneClass.toMulZeroClass",
   "DivInvMonoid.toMonoid",
   "Iff",
   "eq_false",
   "id",
   "instHMul",
   "Eq.mpr",
   "one_mul",
   "DivisionMonoid.toDivInvOneMonoid",
   "GroupWithZero.toDivisionMonoid",
   "DivisionMonoid.toInvolutiveInv",
   "MulZeroOneClass.toMulOneClass",
   "Iff.intro",
   "congrArg",
   "LT.lt.ne'",
   "congr",
   "MulOneClass.toOne",
   "GroupWithZero.toMonoidWithZero",
   "Monoid.toMulOneClass",
   "MonoidWithZero.toMonoid",
   "Zero.toOfNat0",
   "Eq",
   "LT.lt.le",
   "Not",
   "Inv.inv",
   "True",
   "IsUnit",
   "GroupWithZero",
   "MulPosReflectLT",
   "OfNat.ofNat",
   "LT.lt",
   "inv_inv",
   "DivInvOneMonoid.toInvOneClass",
   "One.toOfNat1",
   "of_eq_true",
   "MulZeroClass.toZero",
   "False",
   "Ne",
   "_private.Mathlib.Algebra.GroupWithZero.Units.Basic.0._proof_8",
   "IsUnit.inv_mul_cancel"],
  "name": "Right.inv_pos",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] [inst_1 : PartialOrder G₀] [MulPosReflectLT G₀] {a : G₀}, 0 < a⁻¹ ↔ 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "_neutral", "HarderNarasimhan.instLatticeInterval._rarg"],
  "name": "HarderNarasimhan.instLatticeInterval._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Prod",
   "PartialOrder.toPreorder",
   "Subtype",
   "PartialOrder",
   "LE.le",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Preorder.toLE",
   "Subtype.val",
   "Prod.fst"],
  "name": "HarderNarasimhan.InIntvl",
  "constType":
  "{ℒ : Type} → [inst : PartialOrder ℒ] → { p // p.1 < p.2 } → ℒ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "Iff",
   "Membership.mem",
   "Subtype.ext_iff_val",
   "SetLike",
   "Eq",
   "Subtype.val",
   "Iff.symm"],
  "name": "SetLike.coe_eq_coe",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x y : ↥p}, ↑x = ↑y ↔ x = y",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Antitone",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilinearMapClass",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "PrimeSpectrum.isPrime",
   "LinearMap.semilinearMapClass",
   "Semiring.toNonAssocSemiring",
   "Finset.min'",
   "RingHom.id",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "SetLike.instMembership",
   "LocalizedModule",
   "Submodule.addCommGroup",
   "Prod.snd",
   "LinearMap",
   "Prod",
   "LocalizedModule.isModule'",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "LocalizedModule.instAddCommMonoid",
   "HarderNarasimhan.impl.μ_nonempty",
   "Prod.fst",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Ideal.primeCompl",
   "PrimeSpectrum.asIdeal",
   "HarderNarasimhan._μ",
   "CommRing.toCommSemiring",
   "LinearExtension",
   "CommSemiring.toSemiring",
   "Set.toFinset",
   "AddCommGroup",
   "CommRing",
   "LT.lt",
   "PrimeSpectrum",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.f1._proof_4",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_9",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  SemilinearMapClass\n    (↥(↑I).2 →ₗ[R]\n      LocalizedModule ((HarderNarasimhan._μ R M I).toFinset.min' ⋯).asIdeal.primeCompl\n        (↥(↑I).2 ⧸ Submodule.submoduleOf (↑I).1 (↑I).2))\n    (RingHom.id R) (↥(↑I).2)\n    (LocalizedModule ((HarderNarasimhan._μ R M I).toFinset.min' ⋯).asIdeal.primeCompl\n      (↥(↑I).2 ⧸ Submodule.submoduleOf (↑I).1 (↑I).2))",
  "constCategory": "Theorem"},
 {"references":
  ["HEq.refl",
   "Ideal.IsPrime",
   "CommSemiring",
   "CommSemiring.toSemiring",
   "PrimeSpectrum.mk",
   "Eq.casesOn",
   "PrimeSpectrum",
   "Ideal",
   "Eq.refl",
   "Eq.symm",
   "HEq",
   "PrimeSpectrum.ext.match_1",
   "PrimeSpectrum.asIdeal",
   "Eq",
   "Eq.ndrec"],
  "name": "PrimeSpectrum.ext",
  "constType":
  "∀ {R : Type u_1} {inst : CommSemiring R} {x y : PrimeSpectrum R}, x.asIdeal = y.asIdeal → x = y",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instMembership",
   "Set.mem_singleton_iff",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "Bot.bot",
   "OfNat.ofNat",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "Iff",
   "Submodule.instBot",
   "Zero.toOfNat0",
   "Eq",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.mem_bot",
  "constType":
  "∀ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  x ∈ ⊥ ↔ x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "CovariantClass",
   "covariant_flip_iff",
   "AddCommSemigroup",
   "CovariantClass.elim",
   "Function.swap",
   "AddCommMagma.to_isCommutative",
   "flip",
   "HAdd.hAdd",
   "Iff.mpr",
   "Covariant",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "CovariantClass.mk"],
  "name": "covariant_swap_add_of_covariant_add",
  "constType":
  "∀ (N : Type u_2) (r : N → N → Prop) [inst : AddCommSemigroup N] [CovariantClass N N (fun x1 x2 => x1 + x2) r],\n  CovariantClass N N (Function.swap fun x1 x2 => x1 + x2) r",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.Semistable",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "Subtype.eq",
   "Membership.mem",
   "Eq",
   "Subtype.val",
   "Set.Elem",
   "Set.instMembership"],
  "name": "SetCoe.ext",
  "constType": "∀ {α : Type u} {s : Set α} {a b : ↑s}, ↑a = ↑b → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "instLTNat",
   "Nat",
   "Exists",
   "And",
   "Nat.findX",
   "DecidablePred",
   "Subtype.val"],
  "name": "Nat.find",
  "constType": "{p : ℕ → Prop} → [DecidablePred p] → (∃ n, p n) → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Lattice.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "LE",
   "Subtype.val",
   "Prod.fst",
   "PartialOrder.mk",
   "PartialOrder",
   "SemilatticeSup",
   "HarderNarasimhan.Interval",
   "LT.mk",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Preorder",
   "lcProof",
   "Min.min",
   "Iff",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.mk",
   "LE.le",
   "Lattice.toSemilatticeInf._elambda_1",
   "SemilatticeSup.mk",
   "Subtype.mk",
   "Preorder.mk",
   "LT"],
  "name": "HarderNarasimhan.instLatticeInterval._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → Lattice (HarderNarasimhan.Interval z)",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.HarderNarasimhanFiltration.monotone",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
   "PartialOrder.toPreorder",
   "Submodule.instNontrivial",
   "Module",
   "HarderNarasimhan.μ",
   "Nat.instPreorder",
   "Monotone",
   "HarderNarasimhan.S",
   "HarderNarasimhan.impl.prop3d11",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "HarderNarasimhan.impl.prop3d13₂",
   "CommRing",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "HarderNarasimhan.impl.prop3d13₁",
   "Nat",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "ConditionallyCompleteLattice.toLattice",
   "HarderNarasimhan.S₀",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_18",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (HNFil : HarderNarasimhan.HarderNarasimhanFiltration (HarderNarasimhan.μ R M)), Monotone HNFil.filtration",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.SlopeLike",
   "Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "And.intro",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "HarderNarasimhan.instBoundedOrderInterval",
   "lt_iff_le_not_le",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.instNontrivialInterval",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.SlopeLike.mk",
   "CompleteLattice",
   "HarderNarasimhan.SlopeLike.slopelike"],
  "name": "HarderNarasimhan.instSlopeLikeIntervalResμ",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hsl : HarderNarasimhan.SlopeLike μ]\n  {z : { p // p.1 < p.2 }}, HarderNarasimhan.SlopeLike (HarderNarasimhan.Resμ z μ)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "List",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "OfNat.ofNat",
   "Submodule",
   "Submodule.mk_eq_zero",
   "AddCommMonoid",
   "Submodule.setLike",
   "Zero.toOfNat0",
   "Submodule.zero",
   "Subtype.mk",
   "Eq",
   "propext",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_27",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x ∈ p), (⟨x, h⟩ = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["Finset.univ", "Nat", "Finset.card", "Fintype"],
  "name": "Fintype.card",
  "constType": "(α : Type u_4) → [Fintype α] → ℕ",
  "constCategory": "Definition"},
 {"references": ["Preorder", "PartialOrder", "LE.le", "Eq", "Preorder.toLE"],
  "name": "PartialOrder.mk",
  "constType":
  "{α : Type u_2} → [toPreorder : Preorder α] → (∀ (a b : α), a ≤ b → b ≤ a → a = b) → PartialOrder α",
  "constCategory": "Other"},
 {"references":
  ["Exists", "Subtype", "Subtype.exists", "Subtype.mk", "Eq", "propext"],
  "name": "_private.Init.Data.Subtype.0._proof_2",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["ConditionallyCompleteLinearOrderBot",
   "CompleteLinearOrder.toDecidableLE",
   "Lattice.toSemilatticeSup",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_5",
   "CompleteLinearOrder.toDecidableEq",
   "CompleteLattice.toBot",
   "PartialOrder.toPreorder",
   "ConditionallyCompleteLinearOrder.mk",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_7",
   "SemilatticeSup.toPartialOrder",
   "CompleteLinearOrder.toDecidableLT",
   "CompleteLinearOrder.compare_eq_compareOfLessAndEq",
   "ConditionallyCompleteLinearOrderBot.mk",
   "CompleteLinearOrder.le_total",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_8",
   "ConditionallyCompleteLattice",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_6",
   "CompleteLinearOrder.toCompleteLattice",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "CompleteLinearOrder.toOrd",
   "OrderBot.mk",
   "CompleteLattice.toConditionallyCompleteLattice"],
  "name": "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
  "constType":
  "{α : Type u_5} → [h : CompleteLinearOrder α] → ConditionallyCompleteLinearOrderBot α",
  "constCategory": "Definition"},
 {"references": ["Subtype", "Subtype.val"],
  "name": "Subtype.property",
  "constType": "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self",
  "constCategory": "Theorem"},
 {"references":
  ["SMulZeroClass.mk",
   "MulActionWithZero.zero_smul",
   "MonoidWithZero.toMulZeroOneClass",
   "MonoidWithZero",
   "MulActionWithZero.smul_zero",
   "MulAction.toSMul",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toZero",
   "MulActionWithZero",
   "MonoidWithZero.toMonoid",
   "Zero",
   "SMulWithZero",
   "SMulWithZero.mk",
   "MulActionWithZero.toMulAction"],
  "name": "MulActionWithZero.toSMulWithZero",
  "constType":
  "(M₀ : Type u_12) →\n  (A : Type u_13) → {x : MonoidWithZero M₀} → {x_1 : Zero A} → [m : MulActionWithZero M₀ A] → SMulWithZero M₀ A",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Or",
   "Eq.refl",
   "PartialOrder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.IsComparable"],
  "name": "HarderNarasimhan.IsComparable.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (x y : ℒ), HarderNarasimhan.IsComparable x y = (x ≤ y ∨ y ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["AddCommMonoid", "NonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "Lean.Omega.combo_sat'",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "HarderNarasimhan.impl.instμ_Admissible",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "Option.none",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "instHSub",
   "PartialOrder.toPreorder",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GT.gt",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "Nontrivial",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "instDecidableAnd",
   "Subtype",
   "Nat.cast",
   "HarderNarasimhan.impl.HNFil",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_13",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HarderNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HarderNarasimhan.Convex μ) (f : ℕ → ℒ),\n  (∃ n, f n = ⊤) →\n    ∀ (n : ℕ) (h₂ : ∃ N ≥ n + 1, HarderNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n      Nat.find h₂ > 0 → n + 1 < Nat.find h₂ → ¬n < Nat.find h₂ - 1 → False",
  "constCategory": "Theorem"},
 {"references": ["Iff.mpr", "Iff", "Iff.mp", "Iff.intro"],
  "name": "Iff.symm",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (b ↔ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "And",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "SemilatticeInf",
   "le_antisymm_iff",
   "iff_self",
   "of_eq_true",
   "Min.min",
   "congr",
   "Iff",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "_private.Mathlib.Order.Lattice.0._proof_18",
   "_private.Mathlib.Order.Lattice.0._proof_16",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_eq_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = a ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["True", "Set", "setOf"],
  "name": "Set.univ",
  "constType": "{α : Type u} → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Prod.fst",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.lem2d4₁",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "inf_lt_left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "gt_of_ge_of_gt",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.impl.lem2d4₂I",
   "HarderNarasimhan.μA",
   "Min.min",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax",
   "HarderNarasimhan.in_TotIntvl",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "HarderNarasimhan.impl.lem2d4₃I"],
  "name": "HarderNarasimhan.lemma_2_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Convex μ →\n    ∀ (x w : ℒ) (hxw : ¬x ≤ w) (u t : ℒ) (huxw : u ≤ x ⊓ w) (hxwt : x ⊔ w ≤ t),\n      (HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HarderNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩ ∧\n          HarderNarasimhan.μmax μ ⟨(x ⊓ w, x), ⋯⟩ ≤ HarderNarasimhan.μmax μ ⟨(w, t), ⋯⟩) ∧\n        HarderNarasimhan.μA μ ⟨(u, x), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(w, x ⊔ w), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.StI",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil_prop_of_def",
   "HarderNarasimhan.impl.HNFil",
   "lt_of_le_of_ne",
   "Subtype.val",
   "Prod.fst",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Set",
   "instHAdd",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "Set.instMembership",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "Nat",
   "upperBounds",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil_is_strict_mono",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (n : ℕ),\n  HarderNarasimhan.impl.HNFil μ n ≠ ⊤ → HarderNarasimhan.impl.HNFil μ n < HarderNarasimhan.impl.HNFil μ (n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.zero", "Real", "Zero.mk", "Zero"],
  "name": "Real.instZero",
  "constType": "Zero ℝ",
  "constCategory": "Definition"},
 {"references": ["PUnit", "Nat", "Nat.rec", "PProd"],
  "name": "Nat.below",
  "constType": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "HarderNarasimhan.Affine.rec",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.Affine.mk",
   "HarderNarasimhan.Affine",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HarderNarasimhan.Affine.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.Affine μ → Sort u} →\n                (t : HarderNarasimhan.Affine μ) →\n                  ((affine : ∀ (a b : ℒ) (h : ¬a ≤ b), μ ⟨(a ⊓ b, a), ⋯⟩ = μ ⟨(b, a ⊔ b), ⋯⟩) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references": ["HImp"],
  "name": "HImp.himp",
  "constType": "{α : Type u_1} → [self : HImp α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Finset",
   "Ring.toNonAssocRing",
   "Submodule.Quotient.module",
   "Exists.intro",
   "AddGroupWithOne.toAddMonoidWithOne",
   "SMulZeroClass.toSMul",
   "Membership.mem.out",
   "instDistribSMul",
   "Subtype.val",
   "Submodule.Quotient.instSMul._proof_3",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Minimal",
   "Finset.min'",
   "RingHom.id",
   "letFun",
   "Eq.symm",
   "Module.IsNoetherian.finite",
   "Finset.min'_le",
   "LinearMap.ker",
   "Exists",
   "Submodule.addCommGroup",
   "Prod.snd",
   "LinearMap",
   "Set.instMembership",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Finset.instMembership",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass",
   "Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.impl.μ_nonempty",
   "Prod.fst",
   "HarderNarasimhan._μ",
   "Eq",
   "Preorder.toLE",
   "propext",
   "LinearExtension",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "toLinearExtension",
   "Set.toFinset",
   "AddCommGroup",
   "PrimeSpectrum",
   "CommRing.toRing",
   "HarderNarasimhan.impl.exists_minimal_prime_contained_supp",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan._μ._proof_2",
   "Submodule.completeLattice",
   "Module.Finite",
   "And.casesOn",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Membership.mem",
   "Preorder.toLT",
   "HarderNarasimhan.impl.support_quotient_mono",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "Semiring.toModule",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "DistribSMul.toSMulZeroClass",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "PrimeSpectrum.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "Exists.casesOn",
   "isNoetherian_submodule'",
   "Nontrivial",
   "id",
   "Submodule.submoduleOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "LinearMap.toSpanSingleton",
   "associatedPrimes",
   "Subtype",
   "Eq.mp",
   "Module.Finite.quotient",
   "Submodule.module",
   "le_trans",
   "congrArg",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "instDistribLatticeOfLinearOrder",
   "Ideal",
   "isNoetherian_of_isNoetherianRing_of_finite",
   "OrderHom.monotone'",
   "PrimeSpectrum.asIdeal",
   "HarderNarasimhan.impl.prop3d12p1._proof_4",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "Module.support",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "HarderNarasimhan.impl.mem_support_of_mem_associatedPrimes",
   "HarderNarasimhan.impl.min_associated_prime_iff_min_supp",
   "CommRing",
   "IsAssociatedPrime",
   "LT.lt",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "Submodule.setLike",
   "LE.le",
   "Submodule.addCommMonoid"],
  "name": "HarderNarasimhan.impl.prop3d12p1",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 })\n  (N'' : HarderNarasimhan.ℒ R M),\n  HarderNarasimhan.InIntvl I N'' →\n    ∀ (q : Ideal R) (hq : q ∈ associatedPrimes R (↥(↑I).2 ⧸ Submodule.submoduleOf N'' (↑I).2)),\n      { asIdeal := q, isPrime := ⋯ } ≥ (HarderNarasimhan._μ R M I).toFinset.min' ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLT",
   "not_lt_of_le",
   "Preorder.toLE"],
  "name": "LE.le.not_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder", "GaloisConnection", "LowerAdjoint", "LowerAdjoint.mk"],
  "name": "GaloisConnection.lowerAdjoint",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_4} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisConnection l u → LowerAdjoint u",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_trans",
  "constType":
  "∀ {α : Type u_2} [self : Preorder α] (a b c : α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "InfSet",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Subtype.mk_lt_mk",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "Subtype.coe_inj",
   "And.intro",
   "Subtype.GCongr.coe_lt_coe",
   "funext",
   "Eq.symm",
   "HarderNarasimhan.μmax_res_intvl",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "lt_iff_le_not_le",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Set.ext",
   "Eq.mpr",
   "setOf",
   "Subtype",
   "Subtype.lt",
   "le_trans",
   "and_true",
   "HarderNarasimhan.Resμ",
   "HarderNarasimhan.μA_res_intvl._proof_20",
   "Iff.intro",
   "Prod.fst",
   "congrArg",
   "Subtype.prop",
   "congr",
   "Subtype.property",
   "InfSet.sInf",
   "HarderNarasimhan.Interval",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "HarderNarasimhan.instBoundedOrderInterval",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "eq_self",
   "HarderNarasimhan.instNontrivialInterval",
   "HarderNarasimhan.μA",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μA_res_intvl",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {I : { p // p.1 < p.2 }} {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} {J : { p // p.1 < p.2 }},\n  HarderNarasimhan.μA (HarderNarasimhan.Resμ I μ) J = HarderNarasimhan.μA μ ⟨(↑(↑J).1, ↑(↑J).2), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["not_le",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "_private.Mathlib.Order.Defs.LinearOrder.0._proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (¬a ≤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₁.wsl₁",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.WeakSlopeLike₁ μ]\n  (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Iff", "Membership.mem", "Iff.rfl", "Set.instMembership"],
  "name": "Set.mem_def",
  "constType": "∀ {α : Type u} {a : α} {s : Set α}, a ∈ s ↔ s a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "GT.gt",
   "HarderNarasimhan.impl.JHFil._proof_2",
   "CompleteLattice.toTop",
   "CompleteLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "HarderNarasimhan.impl.JHFil._proof_4",
   "HarderNarasimhan.Semistable",
   "setOf",
   "Subtype",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "WellFoundedGT",
   "OrderBot.toBot",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Set",
   "instHAdd",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "CompletelyDistribLattice.toCompleteLattice",
   "HAdd.hAdd",
   "StrictAnti",
   "Nat.succ",
   "HarderNarasimhan.impl.JHFil",
   "Ne",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.JHFil.eq_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hacc : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤)\n  (hμsl : HarderNarasimhan.SlopeLike μ) (hst : HarderNarasimhan.Semistable μ)\n  (hdc : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) (n : ℕ),\n  HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc n.succ =\n    if h𝒮 :\n        {p |\n            ∃ (h : ⊥ < p),\n              p < HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc n ∧ μ ⟨(⊥, p), h⟩ = μ ⟨(⊥, ⊤), ⋯⟩}.Nonempty then\n      ⋯.choose\n    else ⊥",
  "constCategory": "Theorem"},
 {"references": ["Exists", "And", "Eq", "propext", "exists_eq_right"],
  "name": "HarderNarasimhan.impl.test._proof_20",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["not_imp_not",
   "WellFounded",
   "Not",
   "WellFounded.has_min.match_1",
   "Set.Nonempty",
   "Exists",
   "Set",
   "Membership.mem",
   "Iff.mp",
   "And",
   "Exists.intro",
   "Set.instMembership",
   "Acc",
   "And.intro",
   "letFun",
   "Acc.recOn",
   "WellFounded.apply"],
  "name": "WellFounded.has_min",
  "constType":
  "∀ {α : Type u_4} {r : α → α → Prop}, WellFounded r → ∀ (s : Set α), s.Nonempty → ∃ a ∈ s, ∀ x ∈ s, ¬r x a",
  "constCategory": "Theorem"},
 {"references": ["semiOutParam"],
  "name": "Coe",
  "constType": "semiOutParam (Sort u) → Sort v → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references": ["SMul.mk", "SMul", "Mul", "instHMul", "HMul.hMul"],
  "name": "Mul.toSMul",
  "constType": "(α : Type u_9) → [Mul α] → SMul α α",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Fin",
  "constType": "ℕ → Type",
  "constCategory": "Other"},
 {"references": ["exists_prop", "Exists", "And", "Eq", "propext"],
  "name": "HarderNarasimhan.impl.assinc._proof_1",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Submodule.instNontrivial",
   "Module",
   "HarderNarasimhan.μ",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "And.intro",
   "WellFoundedGT",
   "HarderNarasimhan.S",
   "CompleteLattice.toConditionallyCompleteLattice",
   "CommRing.toCommSemiring",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "CommSemiring.toSemiring",
   "And",
   "HarderNarasimhan.impl.prop3d13₂",
   "AddCommGroup",
   "CommRing",
   "HarderNarasimhan.impl.prop3d13₁",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "inferInstance",
   "ConditionallyCompleteLattice.toLattice",
   "HarderNarasimhan.S₀",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.proposition_3_13",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  WellFoundedGT (HarderNarasimhan.ℒ R M) ∧ HarderNarasimhan.μA_DescendingChainCondition (HarderNarasimhan.μ R M)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.impl.JHFil.eq_2",
   "Prod.mk",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "_private.HarderNarasimhan.JordanHolderFiltration.Impl.0.HarderNarasimhan.impl.JHFil.match_1.splitter",
   "GT.gt",
   "Eq.symm",
   "HarderNarasimhan.impl.JHFil._proof_2",
   "CompleteLattice.toTop",
   "CompleteLinearOrder",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.impl.JHFil.eq_1",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Unit",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "HarderNarasimhan.impl.JHFil._proof_4",
   "HarderNarasimhan.Semistable",
   "setOf",
   "Subtype",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "WellFoundedGT",
   "OrderBot.toBot",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Set",
   "HarderNarasimhan.impl.JHFil.match_1",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "CompletelyDistribLattice.toCompleteLattice",
   "HAdd.hAdd",
   "StrictAnti",
   "Nat.succ",
   "HarderNarasimhan.impl.JHFil",
   "Ne",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.JHFil.eq_def",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hacc : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤)\n  (hμsl : HarderNarasimhan.SlopeLike μ) (hst : HarderNarasimhan.Semistable μ)\n  (hdc : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) (k : ℕ),\n  HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc k =\n    match k with\n    | 0 => ⊤\n    | n.succ =>\n      let 𝒮 := {p | ∃ (h : ⊥ < p), p < HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc n ∧ μ ⟨(⊥, p), h⟩ = μ ⟨(⊥, ⊤), ⋯⟩};\n      if h𝒮 : 𝒮.Nonempty then ⋯.choose else ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "HarderNarasimhan.WeakAscendingChainCondition.mk",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.WeakAscendingChainCondition.rec",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HarderNarasimhan.WeakAscendingChainCondition.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakAscendingChainCondition μ → Sort u} →\n                (t : HarderNarasimhan.WeakAscendingChainCondition μ) →\n                  ((wacc : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.mp",
   "eq_comm",
   "Preorder.toLT",
   "or_assoc",
   "HarderNarasimhan.IsComparable",
   "congrArg",
   "LT.lt",
   "or_self",
   "or_comm",
   "Or",
   "PartialOrder",
   "LE.le",
   "Eq.symm",
   "Eq",
   "Preorder.toLE",
   "le_iff_eq_or_lt",
   "propext"],
  "name": "HarderNarasimhan.impl.comparable_iff",
  "constType":
  "∀ {L : Type} [inst : PartialOrder L] (x y : L), HarderNarasimhan.IsComparable x y → x < y ∨ y ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Nat.cast",
   "Int.ofNat_le",
   "Iff.mpr",
   "LE.le",
   "Int.instLEInt",
   "instLENat",
   "instNatCastInt",
   "Int"],
  "name": "Lean.Omega.Int.ofNat_le_of_le",
  "constType": "∀ {x y : ℕ}, x ≤ y → ↑x ≤ ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom", "Semiring.toNonAssocSemiring", "outParam", "Semiring"],
  "name": "RingHomCompTriple",
  "constType":
  "{R₁ : Type u_1} →\n  {R₂ : Type u_2} →\n    {R₃ : Type u_3} →\n      [inst : Semiring R₁] →\n        [inst_1 : Semiring R₂] → [inst_2 : Semiring R₃] → (R₁ →+* R₂) → (R₂ →+* R₃) → outParam (R₁ →+* R₃) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "SetLike.instMembership",
   "Module",
   "LinearMap.mk",
   "Submodule.module",
   "AddHom.mk",
   "Membership.mem",
   "LinearMap",
   "Subtype.val",
   "Submodule.subtype._proof_3",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "RingHom.id",
   "Submodule.setLike",
   "Submodule.subtype._proof_4",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Submodule.addCommMonoid",
   "Semiring"],
  "name": "Submodule.subtype",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → {module_M : _root_.Module R M} → (p : Submodule R M) → ↥p →ₗ[R] M",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instLTNat",
   "instHAdd",
   "Nat.lt_succ_of_le",
   "OfNat.ofNat",
   "Iff.intro",
   "LT.lt",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "Iff",
   "Nat.le_of_lt_succ",
   "LE.le",
   "instLENat"],
  "name": "Nat.lt_add_one_iff",
  "constType": "∀ {m n : ℕ}, m < n + 1 ↔ m ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Finset.Insert.0._proof_1",
   "Finset",
   "_private.Mathlib.Data.Finset.Defs.0._proof_5",
   "True",
   "Eq.trans",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Finset.toSet",
   "Set.instSingletonSet",
   "congrArg",
   "Set.instMembership",
   "Finset.instSingleton",
   "iff_self",
   "of_eq_true",
   "congr",
   "Iff",
   "Finset.instMembership",
   "Set.ext",
   "_private.Mathlib.Data.Set.Insert.0._proof_14",
   "Eq"],
  "name": "Finset.coe_singleton",
  "constType": "∀ {α : Type u_1} (a : α), ↑{a} = {a}",
  "constCategory": "Theorem"},
 {"references": ["Add", "IsCancelAdd", "IsRightCancelAdd"],
  "name": "IsCancelAdd.toIsRightCancelAdd",
  "constType":
  "∀ {G : Type u} {inst : Add G} [self : IsCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Ring.toNonAssocRing",
   "Bool.false",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "HarderNarasimhan.S₂I",
   "HarderNarasimhan.S₁I",
   "Int.instCommSemiring",
   "HarderNarasimhan.S₁I._proof_1",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "Subtype.coe_eta",
   "Eq.symm",
   "Nat.sub_one_add_one",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "HarderNarasimhan.impl.prop3d4₀func_defprop3₀",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "inf_eq_right",
   "HarderNarasimhan.impl.prop3d4₀func_defprop1",
   "ne_of_gt",
   "BoundedOrder",
   "HarderNarasimhan.impl.prop3d4₀func_helper",
   "Ring.toSemiring",
   "Linarith.mul_neg",
   "instOfNat",
   "HarderNarasimhan.InIntvl",
   "eq_false",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "Int.instCharZero",
   "Nat.find",
   "Mathlib.Tactic.Ring.add_mul",
   "Nat.le_refl",
   "Nat.one_le_iff_ne_zero",
   "Prod.fst",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.mul_congr",
   "lt_of_lt_of_le",
   "Nat.cast_add",
   "eq_self",
   "Monoid.toNatPow",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "HarderNarasimhan.impl.prop2d8₁I",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "HarderNarasimhan.ConvexI",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "not_false_eq_true",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "PartialOrder",
   "forall_congr",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "And.right",
   "lt_of_le_of_lt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_zero",
   "HarderNarasimhan.impl.prop3d4₀func_strict_decreasing",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "ge_of_eq",
   "Nat.lt_of_le_sub_one",
   "SemilatticeInf.toMin",
   "HarderNarasimhan.StI",
   "Nat.cast",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "CommRing.toNonUnitalCommRing",
   "HarderNarasimhan.impl.prop3d4₀func_len_nonzero",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "Set.Nonempty",
   "instHAdd",
   "Prod.mk.eta",
   "HarderNarasimhan.impl.prop3d4₀func_defprop3",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "ne_of_lt",
   "instSubNat",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_lt",
   "Linarith.zero_lt_one",
   "SemilatticeSup.toMax",
   "False",
   "Subtype.mk",
   "ge_trans",
   "Linarith.natCast_nonneg",
   "_private.Init.Core.0._proof_39",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Exists.intro",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "letFun",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Nat.decreasingInduction",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Nat.recAux",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "instNonemptyOfInhabited",
   "HarderNarasimhan.impl.prop3d4₀func_fin_len",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.add_lt_of_lt_sub",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Bool",
   "_private.Init.PropLemmas.0._proof_17",
   "HarderNarasimhan.impl.prop3d4₀func_defprop2",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Nat.instPreorder",
   "le_rfl",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Mathlib.Tactic.Ring.mul_add",
   "sup_le_iff",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Max.max",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HarderNarasimhan.μA",
   "MulZeroClass.toZero",
   "instIsIrreflGt",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nat.le_of_succ_le",
   "neg_neg_of_pos",
   "right_lt_sup",
   "dite",
   "Nat.find_min",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Lattice.toSemilatticeSup",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "_private.Init.Core.0._proof_38",
   "Nat.sub_one_lt",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "And.intro",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "Nat.sub_add_cancel",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.zero_lt_of_ne_zero",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "And",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "ConditionallyCompleteLattice.toLattice",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "SemilatticeSup.toPartialOrder",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "irrefl",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "HarderNarasimhan.impl.prop3d4₀func_len",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "True",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.impl.prop3d4₀func",
   "Semiring.toMonoidWithZero",
   "gt_of_ge_of_gt",
   "NegZeroClass.toNeg",
   "Min.min",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "instLENat",
   "Int.instAddMonoid",
   "instInhabitedTrue"],
  "name": "HarderNarasimhan.impl.prop3d4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.μA_DescendingChainCondition μ →\n    ∀ (I : { p // p.1 < p.2 }), HarderNarasimhan.ConvexI I μ → (HarderNarasimhan.StI μ I).Nonempty",
  "constCategory": "Theorem"},
 {"references": ["Int.le", "LE.mk", "LE", "Int"],
  "name": "Int.instLEInt",
  "constType": "LE ℤ",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a ⋯ → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "SemilinearMapClass",
   "Submodule.mem_comap",
   "Module",
   "Membership.mem",
   "DFunLike.coe",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.lift_quot_middle._proof_18",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} {x : M} {F : Type u_9} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F σ₁₂ M M₂] {f : F}\n  {p : Submodule R₂ M₂}, (x ∈ Submodule.comap f p) = (f x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "AddRightMono",
   "instHAdd",
   "Add",
   "LE.le",
   "LE",
   "Eq",
   "add_le_add_iff_right",
   "propext",
   "AddRightReflectLE"],
  "name": "_private.Mathlib.Algebra.Order.Monoid.Unbundled.Basic.0._proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α] [AddRightMono α] [AddRightReflectLE α] (a : α) {b c : α},\n  (b + a ≤ c + a) = (b ≤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeInf._elambda_1._rarg",
   "HarderNarasimhan.instLatticeInterval._rarg._lambda_1",
   "_obj",
   "LE.mk",
   "Lattice.mk",
   "SemilatticeSup.mk",
   "Preorder.mk",
   "LT.mk",
   "_neutral"],
  "name": "HarderNarasimhan.instLatticeInterval._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PrimeSpectrum",
   "Ideal",
   "Ideal.IsPrime",
   "CommSemiring.toSemiring",
   "CommSemiring"],
  "name": "PrimeSpectrum.mk",
  "constType":
  "{R : Type u_1} → [inst : CommSemiring R] → (asIdeal : Ideal R) → asIdeal.IsPrime → PrimeSpectrum R",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "Subtype.ext",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Eq",
   "Preorder.toLE",
   "le_antisymm",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HarderNarasimhan.Interval z), ↑a ≤ ↑b → ↑b ≤ ↑a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "Exists",
   "SetLike.instMembership",
   "RingHomSurjective",
   "SemilinearMapClass",
   "Module",
   "Submodule.map",
   "Membership.mem",
   "And",
   "DFunLike.coe",
   "Submodule",
   "Submodule.mem_map",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "Eq",
   "propext",
   "Semiring"],
  "name": "HarderNarasimhan.impl.test._proof_17",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} [inst_6 : RingHomSurjective σ₁₂] {F : Type u_9} [inst_7 : FunLike F M M₂]\n  [inst_8 : SemilinearMapClass F σ₁₂ M M₂] {f : F} {p : Submodule R M} {x : M₂},\n  (x ∈ Submodule.map f p) = ∃ y ∈ p, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Nat.find",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "Classical.propDecidable",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "instOfNatNat",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "HarderNarasimhan.JordanHolderFiltration.strict_anti",
   "instLTNat",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OfNat.ofNat",
   "Nat.decLt",
   "CompletelyDistribLattice.toCompleteLattice",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "Decidable.byContradiction",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "HarderNarasimhan.JordanHolderFiltration.fin_len"],
  "name": "HarderNarasimhan.JordanHolderFiltration.step_cond₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} (self : HarderNarasimhan.JordanHolderFiltration μ)\n  (i : ℕ) (hi : i < Nat.find ⋯) (z : ℒ) (h' : self.filtration (i + 1) < z),\n  z < self.filtration i → μ ⟨(self.filtration (i + 1), z), h'⟩ < μ ⟨(self.filtration (i + 1), self.filtration i), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Decidable",
   "Eq.trans",
   "True",
   "ite",
   "congrArg",
   "ite_congr",
   "eq_self",
   "of_eq_true",
   "Eq.refl",
   "False",
   "instDecidableFalse",
   "Eq"],
  "name": "ite_cond_eq_false",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} (a b : α), c = False → (if c then a else b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Unique",
   "CommRing.toCommSemiring",
   "Module",
   "CommSemiring.toSemiring",
   "Unique.mk",
   "AddCommGroup",
   "CommRing",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration",
   "HarderNarasimhan.CoprimaryFiltration",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "HarderNarasimhan.impl.instUniqueCoprimaryFiltration._proof_27",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instUniqueCoprimaryFiltration",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] → Unique (HarderNarasimhan.CoprimaryFiltration R M)",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Nat.exists_eq_add_of_le",
   "Nat",
   "CanonicallyOrderedAdd.mk",
   "ExistsAddOfLE.mk",
   "CanonicallyOrderedAdd",
   "Nat.le_add_right",
   "instLENat"],
  "name": "Nat.instCanonicallyOrderedAdd",
  "constType": "CanonicallyOrderedAdd ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "IsNoetherian",
   "PartialOrder.toPreorder",
   "Subtype",
   "SetLike.instMembership",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "IsNoetherian.noetherian",
   "Submodule.FG",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "Iff.mpr",
   "LE.le",
   "Submodule.completeLattice",
   "Preorder.toLE",
   "Submodule.addCommMonoid",
   "isNoetherian_submodule",
   "Semiring"],
  "name": "isNoetherian_submodule'",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  [IsNoetherian R M] (N : Submodule R M), IsNoetherian R ↥N",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "Subtype.ext_iff_val",
   "AddCommMonoid.toAddMonoid",
   "OfNat.ofNat",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "Iff",
   "Zero.toOfNat0",
   "Subtype.mk",
   "Submodule.zero",
   "Eq",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "Submodule.mk_eq_zero",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (h : x ∈ p), ⟨x, h⟩ = 0 ↔ x = 0",
  "constCategory": "Theorem"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["ContravariantClass.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "mulPosReflectLT_iff_contravariant_pos",
   "Eq.mp",
   "MulZeroClass.toMul",
   "Preorder.toLT",
   "HMul.hMul",
   "Subtype.val",
   "False.elim",
   "PartialOrder",
   "le_of_mul_le_mul_of_pos_right",
   "Subtype.property",
   "MulPosReflectLE",
   "Zero.toOfNat0",
   "Eq",
   "Eq.ndrec",
   "LT.lt.le",
   "MulZeroClass",
   "LE.le.lt_of_ne",
   "_private.Mathlib.Order.Basic.0._proof_1",
   "MulPosReflectLT",
   "OfNat.ofNat",
   "ContravariantClass",
   "LT.lt",
   "MulZeroClass.toZero",
   "Iff.mpr",
   "False",
   "instHMul"],
  "name": "MulPosReflectLE.toMulPosReflectLT",
  "constType":
  "∀ {α : Type u_1} [inst : MulZeroClass α] [inst_1 : PartialOrder α] [MulPosReflectLE α], MulPosReflectLT α",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{α : Type u} → (α → α → α) → Add α",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Min.min",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "inf_le_left",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instLatticeInterval._proof_10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a b : HarderNarasimhan.Interval z), ↑a ⊓ ↑b ≤ ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instPreorder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Subtype.lt",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.val",
   "Set.Elem",
   "Set.range",
   "Prod.fst",
   "Monotone",
   "Real.instLT",
   "CompleteLattice.toTop",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakDescendingChainCondition.mk",
   "Lattice.toSemilatticeInf",
   "Real",
   "Set",
   "BoundedOrder",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Prod.snd",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "IsWellOrder",
   "HarderNarasimhan.impl.rmk4d4",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "CompleteLattice"],
  "name": "HarderNarasimhan.remark_4_4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (r : ℒ → ℝ),\n  Monotone r →\n    (IsWellOrder ↑(Set.range r) fun x1 x2 => x1 < x2) →\n      (∀ (z : { p // p.1 < p.2 }), r (↑z).1 = r (↑z).2 → μ z = ⊤) → HarderNarasimhan.WeakDescendingChainCondition μ",
  "constCategory": "Theorem"},
 {"references": ["HarderNarasimhan.μBstar._rarg", "_obj", "_neutral"],
  "name": "HarderNarasimhan.μBstar._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.CoprimaryFiltration.noConfusion",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "Monotone",
   "HarderNarasimhan.Coprimary",
   "RingHom.id",
   "Eq.symm",
   "PrimeSpectrum.instPartialOrder",
   "Eq.ndrec",
   "Semiring.toModule",
   "And.left",
   "HarderNarasimhan.Coprimary.coprimary",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "Submodule.addCommGroup",
   "LinearMap",
   "Bot.bot",
   "Set.instMembership",
   "Nat",
   "Eq.refl",
   "Submodule.instBot",
   "Nontrivial",
   "HEq",
   "HarderNarasimhan.CoprimaryFiltration.mk",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Nat.find",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ExistsUnique.exists",
   "Nat.instPreorder",
   "Submodule",
   "Eq.propIntro",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "HarderNarasimhan.CoprimaryFiltration",
   "instOfNatNat",
   "Eq",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "LinearExtension",
   "Set",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Submodule.instTop",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "Exists.choose",
   "CommRing",
   "Eq.casesOn",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "instLENat",
   "Module.Finite"],
  "name": "HarderNarasimhan.CoprimaryFiltration.mk.injEq",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (filtration : ℕ → HarderNarasimhan.ℒ R M) (monotone : Monotone filtration) (first_eq_bot : filtration 0 = ⊥)\n  (fin_len : ∃ n, filtration n = ⊤)\n  (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j)\n  (piecewise_coprimary :\n    ∀ n < Nat.find fin_len,\n      HarderNarasimhan.Coprimary R (↥(filtration (n + 1)) ⧸ Submodule.submoduleOf (filtration n) (filtration (n + 1))))\n  (strict_mono_associated_prime :\n    ∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len),\n      { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ })\n  (filtration_1 : ℕ → HarderNarasimhan.ℒ R M) (monotone_1 : Monotone filtration_1) (first_eq_bot_1 : filtration_1 0 = ⊥)\n  (fin_len_1 : ∃ n, filtration_1 n = ⊤)\n  (strict_mono_1 : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len_1 → filtration_1 i < filtration_1 j)\n  (piecewise_coprimary_1 :\n    ∀ n < Nat.find fin_len_1,\n      HarderNarasimhan.Coprimary R\n        (↥(filtration_1 (n + 1)) ⧸ Submodule.submoduleOf (filtration_1 n) (filtration_1 (n + 1))))\n  (strict_mono_associated_prime_1 :\n    ∀ (n : ℕ) (hn : n + 1 < Nat.find fin_len_1),\n      { asIdeal := ⋯.choose, isPrime := ⋯ } < { asIdeal := ⋯.choose, isPrime := ⋯ }),\n  ({ filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot, fin_len := fin_len,\n        strict_mono := strict_mono, piecewise_coprimary := piecewise_coprimary,\n        strict_mono_associated_prime := strict_mono_associated_prime } =\n      { filtration := filtration_1, monotone := monotone_1, first_eq_bot := first_eq_bot_1, fin_len := fin_len_1,\n        strict_mono := strict_mono_1, piecewise_coprimary := piecewise_coprimary_1,\n        strict_mono_associated_prime := strict_mono_associated_prime_1 }) =\n    (filtration = filtration_1)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.smulRight",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "Module",
   "LinearMap.toSpanSingleton._proof_12",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "LinearMap",
   "Semiring.toModule",
   "LinearMap.id",
   "Semiring"],
  "name": "LinearMap.toSpanSingleton",
  "constType":
  "(R : Type u_1) →\n  (M : Type u_4) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → M → R →ₗ[R] M",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder._proof_17",
   "CompleteSemilatticeSup.toSupSet",
   "OmegaCompletePartialOrder",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "CompleteLattice.instOmegaCompletePartialOrder._proof_16",
   "Nat",
   "iSup",
   "CompleteSemilatticeInf.toPartialOrder",
   "OmegaCompletePartialOrder.Chain.instFunLikeNat",
   "OmegaCompletePartialOrder.Chain",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OmegaCompletePartialOrder.mk",
   "CompleteLattice"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder",
  "constType":
  "{α : Type u_2} → [CompleteLattice α] → OmegaCompletePartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakDescendingChainCondition.mk",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakDescendingChainCondition.rec",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakDescendingChainCondition μ → Sort u} →\n                (t : HarderNarasimhan.WeakDescendingChainCondition μ) →\n                  ((wdcc : ∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references": ["Union"],
  "name": "Union.union._@.Mathlib.Data.Set.Operations._hyg.4",
  "constType": "{α : Type u} → [self : Union α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["WithTop", "Option.some"],
  "name": "WithTop.some",
  "constType": "{α : Type u_1} → α → WithTop α",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toNonUnitalCommRing._proof_27",
   "AddGroup.mk",
   "Ring.toSub",
   "NonUnitalNonAssocSemiring.toMul",
   "CommRing.toNonUnitalCommRing._proof_33",
   "AddCommMonoid.toAddMonoid",
   "CommRing.toNonUnitalCommRing._proof_32",
   "CommRing.toNonUnitalCommRing._proof_31",
   "NonUnitalCommRing",
   "CommRing.toNonUnitalCommRing._proof_28",
   "AddCommGroup.mk",
   "CommRing.toNonUnitalCommRing._proof_29",
   "CommRing.toNonUnitalCommRing._proof_36",
   "CommRing.toNonUnitalCommRing._proof_34",
   "SubNegMonoid.mk",
   "CommRing.toNonUnitalCommRing._proof_35",
   "Semiring.toNonUnitalSemiring",
   "Ring.toNeg",
   "Ring.zsmul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommRing",
   "NonUnitalNonAssocRing.mk",
   "NonUnitalCommRing.mk",
   "Ring.toSemiring",
   "CommRing.toNonUnitalCommRing._proof_30",
   "CommRing.toRing",
   "NonUnitalRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toNonUnitalCommRing._proof_26",
   "CommRing.mul_comm"],
  "name": "CommRing.toNonUnitalCommRing",
  "constType": "{α : Type u} → [s : CommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "HarderNarasimhan.InIntvl",
   "Min.min",
   "Iff.mpr",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.ConvexI.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {S : Type} [inst_1 : CompleteLattice S] {I : { p // p.1 < p.2 }}\n  {μ : { p // p.1 < p.2 } → S},\n  (∀ (x y : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        HarderNarasimhan.InIntvl I y → ∀ (h : ¬x ≤ y), μ ⟨(x ⊓ y, x), ⋯⟩ ≤ μ ⟨(y, x ⊔ y), ⋯⟩) →\n    HarderNarasimhan.ConvexI I μ",
  "constCategory": "Other"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.Convex",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop3d2",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "HarderNarasimhan.in_TotIntvl",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_3_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Convex μ →\n    ∀ (x z : ℒ) (h : x < z),\n      HarderNarasimhan.μA μ ⟨(x, z), h⟩ = ⊤ →\n        ∀ (a : ℒ) (hax : a < x), HarderNarasimhan.μA μ ⟨(a, x), hax⟩ ≤ HarderNarasimhan.μA μ ⟨(a, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "AddZeroClass.toZero",
   "Module",
   "AddCommMonoid.toAddMonoid",
   "LinearEquiv",
   "DFunLike.coe",
   "LinearEquiv.toAddEquiv",
   "OfNat.ofNat",
   "AddEquiv.map_eq_zero_iff",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "EquivLike.toFunLike",
   "Zero.toOfNat0",
   "LinearEquiv.instEquivLike",
   "RingHomInvPair",
   "Eq",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "LinearEquiv.map_eq_zero_iff",
  "constType":
  "∀ {R : Type u_1} {S : Type u_5} {M : Type u_6} {M₂ : Type u_8} [inst : Semiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] {module_M : _root_.Module R M}\n  {module_S_M₂ : _root_.Module S M₂} {σ : R →+* S} {σ' : S →+* R} {re₁ : RingHomInvPair σ σ'}\n  {re₂ : RingHomInvPair σ' σ} (e : M ≃ₛₗ[σ] M₂) {x : M}, e x = 0 ↔ x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instDistribLatticeOfLinearOrder._proof_54",
   "LinearOrder",
   "DistribLattice.mk",
   "DistribLattice",
   "LinearOrder.toLattice"],
  "name": "instDistribLatticeOfLinearOrder",
  "constType": "{α : Type u} → [LinearOrder α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "SetLike.coe",
   "Set",
   "Iff",
   "Membership.mem",
   "SetLike",
   "Iff.rfl",
   "Set.instMembership"],
  "name": "SetLike.mem_coe",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, x ∈ ↑p ↔ x ∈ p",
  "constCategory": "Theorem"},
 {"references": ["Not", "Or", "Iff", "And", "False", "or_imp"],
  "name": "not_or",
  "constType": "∀ {p q : Prop}, ¬(p ∨ q) ↔ ¬p ∧ ¬q",
  "constCategory": "Theorem"},
 {"references":
  ["Finset",
   "PartialOrder.toPreorder",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Singleton.singleton",
   "instDistribLatticeOfLinearOrder",
   "HarderNarasimhan.instLinearOrderS₀._proof_1",
   "PrimeSpectrum.instPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "LinearExtension",
   "CommSemiring.toSemiring",
   "And",
   "LinearOrder",
   "Finset.instHasSubset",
   "Exists.choose",
   "CommRing",
   "PrimeSpectrum",
   "LinearOrder.toPartialOrder",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "Finset.instSingleton",
   "HasSubset.Subset",
   "Iff",
   "LE.le",
   "HarderNarasimhan.S₀"],
  "name": "HarderNarasimhan.instLinearOrderS₀",
  "constType":
  "{R : Type} → [inst : CommRing R] → [inst_1 : IsNoetherianRing R] → LinearOrder (HarderNarasimhan.S₀ R)",
  "constCategory": "Definition"},
 {"references":
  ["Quotient",
   "Setoid",
   "Exists",
   "Setoid.r",
   "Quotient.mk",
   "Quot.exists_rep",
   "Eq"],
  "name": "Quotient.exists_rep",
  "constType": "∀ {α : Sort u} {s : Setoid α} (q : Quotient s), ∃ a, ⟦a⟧ = q",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Classical.propDecidable",
   "HarderNarasimhan.HarderNarasimhanFiltration.fin_len",
   "Nat.instAddCommMonoid",
   "HarderNarasimhan.Convex",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Nat.instIsOrderedAddMonoid",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Nat.instPartialOrder",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Prod.snd",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Prod",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "HarderNarasimhan.Semistable",
   "AddMonoid.toAddZeroClass",
   "Nat.find",
   "Subtype",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "HarderNarasimhan.HarderNarasimhanFiltration.strict_mono",
   "Nat.instOne",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Nat.instIsOrderedCancelAddMonoid",
   "WellFoundedGT",
   "HarderNarasimhan.Interval",
   "Eq",
   "Preorder.toLE",
   "Nat.instAddMonoid",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "instHAdd",
   "HarderNarasimhan.instBoundedOrderInterval",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "HarderNarasimhan.instNontrivialInterval",
   "lt_add_one",
   "AddZeroClass.toAdd",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.piecewise_semistable",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ]\n  (self : HarderNarasimhan.HarderNarasimhanFiltration μ) (i : ℕ) (h_1 : i < Nat.find ⋯),\n  HarderNarasimhan.Semistable (HarderNarasimhan.Resμ ⟨(self.filtration i, self.filtration (i + 1)), ⋯⟩ μ)",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "Not",
   "Bool",
   "Decidable",
   "Eq",
   "decide_eq_false",
   "of_decide_eq_true.match_1",
   "Bool.true",
   "Decidable.decide",
   "ne_true_of_eq_false"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_2._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Inv"],
  "name": "Inv.inv",
  "constType": "{α : Type u} → [self : Inv α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.le_top", "LE.le", "Top.top", "LE", "OrderTop", "OrderTop.toTop"],
  "name": "le_top",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references": ["_obj", "HarderNarasimhan.TotIntvl._rarg", "_neutral"],
  "name": "HarderNarasimhan.TotIntvl._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Distrib.toAdd",
   "Semiring.toNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Eq.refl",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Eq.symm",
   "Eq.ndrec",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.add_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' + b' = c → a + b = c",
  "constCategory": "Theorem"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Prod.fst",
   "Iff.intro",
   "HarderNarasimhan.HarderNarasimhanFiltration.ext",
   "Eq.symm",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "Eq.ndrec",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HEq.refl",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "Eq.casesOn",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "LT.lt",
   "Prod",
   "Nat",
   "Iff",
   "Eq.refl",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Lattice",
   "Nontrivial",
   "HEq",
   "CompleteLattice"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.ext_iff",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {inst_3 : WellFoundedGT ℒ} {S : Type}\n  {inst_4 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} {hμ : HarderNarasimhan.μA_DescendingChainCondition μ}\n  {hμcvx : HarderNarasimhan.Convex μ} {h : HarderNarasimhan.μ_Admissible μ}\n  {x y : HarderNarasimhan.HarderNarasimhanFiltration μ}, x = y ↔ x.filtration = y.filtration",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "Bool",
   "BEq",
   "Subtype.val",
   "LawfulBEq.toReflBEq",
   "Subtype.instReflBEq",
   "LawfulBEq",
   "Subtype.eq",
   "LawfulBEq.mk",
   "LawfulBEq.eq_of_beq",
   "Subtype.instBEq",
   "Eq",
   "BEq.beq",
   "Bool.true"],
  "name": "Subtype.instLawfulBEq",
  "constType":
  "∀ {α : Type u} {p : α → Prop} [inst : BEq α] [LawfulBEq α], LawfulBEq { x // p x }",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakDescendingChainCondition.mk",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakDescendingChainCondition μ → Sort u} →\n                ((wdcc : ∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n                    motive ⋯) →\n                  (t : HarderNarasimhan.WeakDescendingChainCondition μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Field.toNontrivial",
   "Field.toNNRatCast",
   "Field.toCommRing",
   "Field.nnqsmul_def",
   "Field.inv_zero",
   "Field.zpow",
   "Field",
   "Field.toDiv",
   "Field.zpow_succ'",
   "Field.nnratCast_def",
   "Field.div_eq_mul_inv",
   "Field.zpow_neg'",
   "CommSemiring.mk",
   "Field.nnqsmul",
   "Ring.toSemiring",
   "CommRing.toRing",
   "Field.toSemifield._proof_1",
   "Field.zpow_zero'",
   "Field.toInv",
   "Semifield",
   "Semifield.mk",
   "Field.mul_inv_cancel"],
  "name": "Field.toSemifield",
  "constType": "{K : Type u_1} → [Field K] → Semifield K",
  "constCategory": "Definition"},
 {"references": ["Preorder", "le_trans", "Preorder.toLE", "GE.ge"],
  "name": "ge_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≥ b → b ≥ c → a ≥ c",
  "constCategory": "Theorem"},
 {"references": ["True", "True.intro"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.JordanHolderFiltration",
   "WellFoundedGT",
   "OrderBot.toBot",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.JordanHolderFiltration.fin_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] {μ : { p // p.1 < p.2 } → S} (self : HarderNarasimhan.JordanHolderFiltration μ),\n  ∃ N, self.filtration N = ⊥",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LT",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LT.lt", "gt_iff_lt", "Eq", "GT.gt", "LT", "propext"],
  "name": "_private.Init.Core.0._proof_39",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "Nat.succ",
   "Iff",
   "LE.le",
   "Iff.rfl",
   "instLENat"],
  "name": "Nat.succ_le",
  "constType": "∀ {n m : ℕ}, n.succ ≤ m ↔ n < m",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "HarderNarasimhan.impl.rmk2d5₂",
   "sInf_le_sInf",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "Subtype",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "le_rfl",
   "eq_of_le_of_le",
   "Preorder.toLE",
   "Eq",
   "Lattice.toSemilatticeInf",
   "Set",
   "LT.lt",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.Convex_of_Convex_large",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.rmk2d5₃",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ → HarderNarasimhan.μA μ I = HarderNarasimhan.μA (HarderNarasimhan.μmax μ) I",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "_private.Mathlib.Order.Lattice.0._proof_9",
   "And",
   "SemilatticeSup.toPartialOrder",
   "and_true",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "Max.max",
   "le_antisymm_iff",
   "iff_self",
   "_private.Mathlib.Order.Lattice.0._proof_7",
   "of_eq_true",
   "congr",
   "Iff",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Eq",
   "Preorder.toLE"],
  "name": "sup_eq_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = a ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["SMul"],
  "name": "IsScalarTower",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → (α : Type u_11) → [SMul M N] → [SMul N α] → [SMul M α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["LT.lt",
   "Nat.succ_le_succ",
   "instLTNat",
   "Nat",
   "Nat.succ",
   "LE.le",
   "instLENat"],
  "name": "Nat.lt_succ_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n < m.succ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LE",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "Membership",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "DecidableLE",
   "Decidable",
   "Decidable.isFalse",
   "DecidableLT",
   "Preorder.toLT",
   "decidableLTOfDecidableLE._proof_2",
   "decidableLTOfDecidableLE.match_1",
   "LT.lt",
   "not_le_of_gt",
   "Preorder",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLE",
   "dite",
   "Decidable.isTrue"],
  "name": "decidableLTOfDecidableLE",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → [DecidableLE α] → DecidableLT α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Prod",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "Subtype",
   "Subtype.prop",
   "Lattice",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._proof_11",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (p : { p // p.1 < p.2 }), (↑p).1 < (↑p).2",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "instHAdd",
   "AddMonoid.toAddSemigroup",
   "AddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "AddSemigroup.toAdd"],
  "name": "AddCommGroup.mk",
  "constType":
  "{G : Type u} → [toAddGroup : AddGroup G] → (∀ (a b : G), a + b = b + a) → AddCommGroup G",
  "constCategory": "Other"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "sub_self",
   "AddZeroClass.toZero",
   "SubNegZeroMonoid.toNegZeroClass",
   "OfNat.ofNat",
   "AddGroup.toSubtractionMonoid",
   "congrArg",
   "Iff.intro",
   "SubNegMonoid.toAddMonoid",
   "eq_of_sub_eq_zero",
   "Eq.refl",
   "Iff.mpr",
   "SubNegMonoid.toSub",
   "id",
   "HSub.hSub",
   "NegZeroClass.toZero",
   "AddGroup",
   "Eq.mpr",
   "Zero.toOfNat0",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "instHSub",
   "AddMonoid.toAddZeroClass"],
  "name": "sub_eq_zero_of_eq",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a = b → a - b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["GroupWithZero.mk",
   "DivInvMonoid.toInv",
   "DivInvMonoid",
   "DivInvMonoid.toZPow",
   "GroupWithZero.toDivInvMonoid",
   "MulZeroClass.toMul",
   "HMul.hMul",
   "MonoidWithZero.toMulZeroOneClass",
   "MulZeroOneClass.toMulOneClass",
   "instHDiv",
   "Function.Injective.groupWithZero._proof_7",
   "HDiv.hDiv",
   "Inv",
   "MulOneClass.toOne",
   "DivInvMonoid.zpow_neg'",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.toMonoidWithZero",
   "Pow",
   "One",
   "DivInvMonoid.zpow",
   "Zero.toOfNat0",
   "Zero",
   "Eq",
   "Div",
   "instHPow",
   "Function.Injective.groupWithZero._proof_8",
   "Inv.inv",
   "Mul",
   "GroupWithZero",
   "HPow.hPow",
   "MonoidWithZero",
   "DivInvMonoid.toDiv",
   "OfNat.ofNat",
   "Int",
   "Function.Injective.divInvMonoid",
   "Nat",
   "Monoid.toNatPow",
   "MulZeroOneClass.toMulZeroClass",
   "One.toOfNat1",
   "DivInvMonoid.zpow_succ'",
   "MulZeroClass.toZero",
   "Nontrivial",
   "Function.Injective.groupWithZero._proof_9",
   "DivInvMonoid.zpow_zero'",
   "Function.Injective.monoidWithZero",
   "instHMul",
   "DivInvMonoid.div_eq_mul_inv",
   "Function.Injective"],
  "name": "Function.Injective.groupWithZero",
  "constType":
  "{G₀ : Type u_2} →\n  {G₀' : Type u_4} →\n    [inst : GroupWithZero G₀] →\n      [inst_1 : Zero G₀'] →\n        [inst_2 : Mul G₀'] →\n          [inst_3 : One G₀'] →\n            [inst_4 : Inv G₀'] →\n              [inst_5 : Div G₀'] →\n                [inst_6 : Pow G₀' ℕ] →\n                  [inst_7 : Pow G₀' ℤ] →\n                    (f : G₀' → G₀) →\n                      Function.Injective f →\n                        f 0 = 0 →\n                          f 1 = 1 →\n                            (∀ (x y : G₀'), f (x * y) = f x * f y) →\n                              (∀ (x : G₀'), f x⁻¹ = (f x)⁻¹) →\n                                (∀ (x y : G₀'), f (x / y) = f x / f y) →\n                                  (∀ (x : G₀') (n : ℕ), f (x ^ n) = f x ^ n) →\n                                    (∀ (x : G₀') (n : ℤ), f (x ^ n) = f x ^ n) → GroupWithZero G₀'",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMonoid",
   "SetLike.instMembership",
   "Subtype",
   "Ideal",
   "Submodule.setLike",
   "Module",
   "Submodule.module",
   "Membership.mem",
   "Module.annihilator",
   "Submodule.addCommMonoid",
   "Submodule",
   "Semiring"],
  "name": "Submodule.annihilator",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → Submodule R M → Ideal R",
  "constCategory": "Definition"},
 {"references": ["Set", "SDiff", "Set.diff", "SDiff.mk"],
  "name": "Set.instSDiff",
  "constType": "{α : Type u} → SDiff (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["associatedPrimes",
   "CommRing.toCommSemiring",
   "Module",
   "Set",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "AddCommGroup",
   "CommRing",
   "Set.instMembership",
   "IsNoetherianRing",
   "HarderNarasimhan.Coprimary",
   "Ideal",
   "AddCommGroup.toAddCommMonoid",
   "ExistsUnique"],
  "name": "HarderNarasimhan.Coprimary.coprimary",
  "constType":
  "∀ {R : Type} {inst : CommRing R} {inst_1 : IsNoetherianRing R} {M : Type} {inst_2 : AddCommGroup M}\n  {inst_3 : _root_.Module R M} [self : HarderNarasimhan.Coprimary R M], ∃! p, p ∈ associatedPrimes R M",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SubtractionMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "True",
   "instOfNatNat",
   "instHAdd",
   "eq_true",
   "Eq",
   "Nat.lt_add_one",
   "OfNat.ofNat"],
  "name": "_private.Init.Data.Nat.Basic.0._proof_6",
  "constType": "∀ (n : ℕ), (n < n + 1) = True",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_11",
   "PartialOrder.toPreorder",
   "Bot.mk",
   "Inter.inter",
   "Membership.mem",
   "Lattice.mk",
   "InfSet.mk",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_7",
   "Set.iUnion",
   "Union.union",
   "Set.iInter",
   "Subtype.val",
   "PartialOrder",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_12",
   "Set.instUnion",
   "Set.instInter",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_8",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_1",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_14",
   "ClosureOperator.IsClosed",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_6",
   "Set.instMembership",
   "Set.instCompleteAtomicBooleanAlgebra",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_10",
   "Top.mk",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_13",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_5",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SupSet.mk",
   "Subtype.partialOrder",
   "ClosureOperator",
   "EmptyCollection.emptyCollection",
   "Set.instEmptyCollection",
   "DFunLike.coe",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_2",
   "ClosureOperator.instFunLike",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_3",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_4",
   "CompleteLattice.mk",
   "Set",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_9",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_15",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Set.univ",
   "ClosureOperator.Closeds",
   "SemilatticeSup.mk",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_17",
   "Subtype.mk",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_16",
   "trivial",
   "CompleteLattice"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan",
  "constType":
  "{α : Type} → [PartialOrder α] → (T : ClosureOperator (Set α)) → CompleteLattice T.Closeds",
  "constCategory": "Definition"},
 {"references": ["Iff", "Eq.comm", "Eq"],
  "name": "eq_comm",
  "constType": "∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "Submodule.setLike",
   "Module",
   "AddSubgroup.toAddCommGroup",
   "Membership.mem",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "Submodule.toAddSubgroup",
   "Submodule",
   "Ring.toSemiring",
   "Ring"],
  "name": "Submodule.addCommGroup",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → {module_M : _root_.Module R M} → (p : Submodule R M) → AddCommGroup ↥p",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "Or",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.impl.prop4d6",
   "LT.lt",
   "Prod",
   "Iff",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_4_6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ ↔\n    ∀ (x y z : ℒ) (h : x < y ∧ y < z),\n      μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩ ∨\n        μ ⟨(x, y), ⋯⟩ > μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ > μ ⟨(y, z), ⋯⟩ ∨\n          μ ⟨(x, y), ⋯⟩ = μ ⟨(x, z), ⋯⟩ ∧ μ ⟨(x, z), ⋯⟩ = μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Exists",
   "instOfNatNat",
   "Nontrivial",
   "Exists.intro",
   "Ne",
   "Nontrivial.mk",
   "OfNat.ofNat",
   "Nat.zero_ne_one"],
  "name": "Nat.instNontrivial",
  "constType": "Nontrivial ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.find",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Classical.propDecidable",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "HarderNarasimhan.impl.function_wrapper._proof_5",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Exists",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.impl.JHFil.match_1",
   "BoundedOrder",
   "Nat.brecOn",
   "Bot.bot",
   "OfNat.ofNat",
   "Unit",
   "LT.lt",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nat.succ",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "Top.top",
   "dite",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.function_wrapper",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [inst_1 : BoundedOrder ℒ] → (f : ℕ → ℒ) → (∃ k, f k = ⊥) → ℕ → ℒ",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Min.min",
   "inf_eq_right",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "propext",
   "SemilatticeInf.toPartialOrder"],
  "name": "_private.Mathlib.Order.Lattice.0._proof_20",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, (a ⊓ b = b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.snd",
  "constType": "{α : Type u} → {β : Type v} → α × β → β",
  "constCategory": "Definition"},
 {"references":
  ["GroupWithZero.mk",
   "DivisionSemiring.mul_inv_cancel",
   "Semiring.mul_one",
   "AddMonoid.toZero",
   "DivisionSemiring.inv_zero",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.zero_mul",
   "DivisionSemiring.zpow_succ'",
   "AddCommMonoid.toAddMonoid",
   "DivisionSemiring.toDiv",
   "DivisionSemiring.div_eq_mul_inv",
   "Semigroup.mk",
   "MonoidWithZero.mk",
   "DivisionSemiring.zpow_neg'",
   "Semiring.npow_zero",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalSemiring.mul_assoc",
   "Semiring.toOne",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DivisionSemiring.zpow",
   "GroupWithZero",
   "DivisionSemiring.toSemiring",
   "DivisionSemiring.toInv",
   "Semiring.one_mul",
   "DivisionSemiring",
   "Semiring.npow_succ",
   "DivisionSemiring.toNontrivial",
   "DivisionSemiring.zpow_zero'",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Monoid.mk",
   "Semiring.npow"],
  "name": "DivisionSemiring.toGroupWithZero",
  "constType": "{K : Type u_2} → [self : DivisionSemiring K] → GroupWithZero K",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Set",
   "HasCompl.mk",
   "Membership.mem",
   "HasCompl",
   "Set.instMembership",
   "setOf"],
  "name": "Set.instHasCompl",
  "constType": "{α : Type u} → HasCompl (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Lattice.toSemilatticeSup",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "CompleteLattice.toLattice",
   "And",
   "Preorder.toLT",
   "LinearOrder",
   "SemilatticeSup.toPartialOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "LT.lt",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "Iff",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion._proof_27",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a b : HarderNarasimhan.DedekindMacNeilleCompletion α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Or.inl", "Or", "or_self.match_1", "Eq", "propext", "Iff.intro"],
  "name": "or_self",
  "constType": "∀ (p : Prop), (p ∨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Decidable",
   "Subsingleton.elim",
   "Bool.false",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "_private.Mathlib.Data.Nat.Find.0._proof_10",
   "Int.instCommSemiring",
   "_private.Init.Data.Nat.Basic.0._proof_16",
   "Linarith.lt_of_lt_of_eq",
   "le_of_not_gt",
   "Nat.sub_one_add_one",
   "Eq.symm",
   "Int.instLTInt",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "BoundedOrder",
   "Ring.toSemiring",
   "Linarith.mul_neg",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Antitone",
   "eq_false",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Top.top",
   "Int.negOfNat",
   "Int.instCharZero",
   "Eq.mpr",
   "Nat.sub_eq_iff_eq_add",
   "Nat.find",
   "HarderNarasimhan.impl.function_wrapper_prop1",
   "Mathlib.Tactic.Ring.add_mul",
   "Pi.instSubsingleton",
   "Prod.fst",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Nat.lt_succ_self",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "lt_of_lt_of_le",
   "Mathlib.Tactic.Ring.mul_congr",
   "Nat.cast_add",
   "Monoid.toNatPow",
   "Ne",
   "instHSub",
   "Nat.find_min'",
   "PartialOrder.toPreorder",
   "lt_of_lt_of_eq",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Ne.bot_lt'",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "of_eq_false",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "lt_of_le_of_lt",
   "Mathlib.Tactic.Ring.mul_zero",
   "Bot.bot",
   "Exists.casesOn",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Mathlib.Tactic.PushNeg.not_le_eq",
   "Nat.cast",
   "Eq.mp",
   "HarderNarasimhan.impl.function_wrapper_prop0'",
   "DecidablePred",
   "CommRing.toNonUnitalCommRing",
   "lt_of_le_of_ne",
   "neg_eq_zero",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "dite_cond_eq_false",
   "instSubsingletonDecidable",
   "Not",
   "le_top",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "instSubNat",
   "Nat.succ",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "False",
   "lt_self_iff_false",
   "Subtype.mk",
   "OrderTop.toTop",
   "Nat.succ_le",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Exists.intro",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "HarderNarasimhan.impl.function_wrapper_prop5",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "False.elim",
   "sub_eq_zero_of_eq",
   "SubNegMonoid.toSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "letFun",
   "not_lt_of_le",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.sub_pf",
   "Int.instAddGroup",
   "rfl",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "HarderNarasimhan.impl.function_wrapper",
   "Prod.snd",
   "_private.Mathlib.Tactic.Zify.0._proof_1",
   "Prod",
   "Nat.find_spec",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "AddMonoidWithOne.toOne",
   "Lattice",
   "Classical.byContradiction",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Bool",
   "Ne.symm",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "Mathlib.Tactic.Ring.mul_add",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.le_induction",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "not_le_of_gt",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "dite",
   "neg_neg_of_pos",
   "le_of_not_lt",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "And.casesOn",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Iff.mp",
   "bot_le",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "funext",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "And",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "NegZeroClass.toZero",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.impl.function_wrapper._proof_6",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.impl.function_wrapper_prop6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ) (hf0 : f 0 = ⊤)\n  (atf : ∃ k, f k = ⊥) (hfat : Antitone f) (P : { z // z.1 < z.2 } → Prop),\n  (∀ i < Nat.find atf, ∀ (hfi : f (i + 1) < f i), P ⟨(f (i + 1), f i), hfi⟩) →\n    ∀ (i : ℕ) (hi : i < Nat.find ⋯),\n      P ⟨(HarderNarasimhan.impl.function_wrapper f atf (i + 1), HarderNarasimhan.impl.function_wrapper f atf i), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.impl.μ_nonempty",
   "Prod.fst",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "HarderNarasimhan._μ",
   "Finset.Nonempty",
   "CommRing.toCommSemiring",
   "LinearExtension",
   "CommSemiring.toSemiring",
   "Set.toFinset",
   "AddCommGroup",
   "Prod.snd",
   "CommRing",
   "Prod",
   "LT.lt",
   "PrimeSpectrum",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "Module.Finite"],
  "name": "HarderNarasimhan.μ_nonempty",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  (HarderNarasimhan._μ R M I).toFinset.Nonempty",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{α : Type u} → α → Zero α",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder",
   "Set.instCompleteAtomicBooleanAlgebra._proof_4",
   "Set.instCompleteAtomicBooleanAlgebra._proof_12",
   "BooleanAlgebra.toHImp",
   "Set.instCompleteAtomicBooleanAlgebra._proof_11",
   "InfSet.sInf",
   "BooleanAlgebra.toTop",
   "Set.instCompleteAtomicBooleanAlgebra._proof_10",
   "Set.instCompleteAtomicBooleanAlgebra._proof_5",
   "Preorder.toLE",
   "Set.instBooleanAlgebra",
   "Set.instSupSet",
   "BooleanAlgebra",
   "CompleteLattice.mk",
   "Set",
   "Set.instCompleteAtomicBooleanAlgebra._proof_9",
   "Set.instCompleteAtomicBooleanAlgebra._proof_14",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra.toSDiff",
   "Set.instMembership",
   "Set.instCompleteAtomicBooleanAlgebra._proof_2",
   "CompleteAtomicBooleanAlgebra.mk",
   "CompleteAtomicBooleanAlgebra",
   "DistribLattice.toLattice",
   "LE.le",
   "Set.instCompleteAtomicBooleanAlgebra._proof_13",
   "Set.instInfSet",
   "Set.instCompleteAtomicBooleanAlgebra._proof_3",
   "BooleanAlgebra.toHasCompl"],
  "name": "Set.instCompleteAtomicBooleanAlgebra",
  "constType": "{α : Type u_1} → CompleteAtomicBooleanAlgebra (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Eq.symm",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "of_eq_false",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Bot.bot",
   "Nat.find_spec",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Antitone",
   "eq_false",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "Nat.find",
   "le_trans",
   "Nat.instPreorder",
   "congrArg",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "le_rfl",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "congr",
   "OrderBot.toBot",
   "dite_cond_eq_false",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Nat.le_induction",
   "Lattice.toSemilatticeInf",
   "le_top",
   "True",
   "instHAdd",
   "HarderNarasimhan.impl.function_wrapper._proof_6",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "dite_cond_eq_true",
   "le_of_lt",
   "LE.le",
   "instDecidableEqNat",
   "dite",
   "instLENat"],
  "name": "HarderNarasimhan.impl.function_wrapper_prop2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ) (atf : ∃ k, f k = ⊥),\n  Antitone (HarderNarasimhan.impl.function_wrapper f atf)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mk",
   "Finset",
   "Finset.val",
   "Membership.mem",
   "Membership",
   "Multiset",
   "Multiset.instMembership"],
  "name": "Finset.instMembership",
  "constType": "{α : Type u_1} → Membership α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.add_comm",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid"],
  "name": "AddCommGroup.toAddCommMonoid",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "PartialOrder.toPreorder",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.Quotient.module",
   "Submodule.module",
   "LinearMap.mk",
   "AddHom.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "Preorder.toLT",
   "DFunLike.coe",
   "Subtype.val",
   "Submodule",
   "Prod.fst",
   "Submodule.Quotient.addCommGroup",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "HarderNarasimhan.impl.f2._proof_5",
   "Submodule.mkQ",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "Submodule.addCommGroup",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "Prod.snd",
   "LinearMap",
   "CommRing",
   "Ring.toSemiring",
   "LT.lt",
   "Prod",
   "CommRing.toRing",
   "IsNoetherianRing",
   "AddCommMonoid.toAddCommSemigroup",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "HarderNarasimhan.impl.f2._proof_6",
   "Submodule.addCommMonoid",
   "Submodule.submoduleOf",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.f2",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [inst_5 : Module.Finite R M] →\n                (I : { z // z.1 < z.2 }) → ↥(↑I).2 →ₗ[R] ↥(↑I).2 ⧸ Submodule.submoduleOf (↑I).1 (↑I).2",
  "constCategory": "Definition"},
 {"references":
  ["le_top",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "bot_le",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "And.intro",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.in_TotIntvl",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (x : ℒ),\n  HarderNarasimhan.InIntvl HarderNarasimhan.TotIntvl x",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype.ofFinset",
   "Finset.instSingleton",
   "Finset",
   "Set",
   "Singleton.singleton",
   "Fintype",
   "Set.instSingletonSet",
   "Set.Elem",
   "Set.fintypeSingleton._proof_22"],
  "name": "Set.fintypeSingleton",
  "constType": "{α : Type u} → (a : α) → Fintype ↑{a}",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.FiniteTotalPayoff.mk",
   "BoundedOrder.toOrderTop",
   "CompleteLattice.toTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "HarderNarasimhan.FiniteTotalPayoff.rec",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.FiniteTotalPayoff.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.FiniteTotalPayoff μ → Sort u} →\n                (t : HarderNarasimhan.FiniteTotalPayoff μ) →\n                  ((fin_tot_payoff : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references": ["Exists", "Nontrivial", "Ne"],
  "name": "Nontrivial.exists_pair_ne",
  "constType": "∀ {α : Type u_3} [self : Nontrivial α], ∃ x y, x ≠ y",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "Nat",
   "Preorder",
   "PartialOrder.toPreorder",
   "inferInstance",
   "Nat.instLinearOrder"],
  "name": "Nat.instPreorder",
  "constType": "Preorder ℕ",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "SemilinearMapClass",
   "Module",
   "RingHom.instFunLike",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "SemilinearEquivClass.map_smulₛₗ",
   "SemilinearMapClass.mk",
   "DFunLike.coe",
   "SemilinearEquivClass",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "EquivLike.toFunLike",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "EquivLike",
   "DistribSMul.toSMulZeroClass",
   "AddZeroClass.toZero",
   "outParam",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "AddEquivClass.map_add",
   "SemilinearEquivClass.toAddEquivClass",
   "Module.toDistribMulAction",
   "AddCommMonoid.toAddCommSemigroup",
   "MulActionSemiHomClass.mk",
   "RingHomInvPair",
   "AddHomClass.mk",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "SemilinearEquivClass.instSemilinearMapClass",
  "constType":
  "∀ {R : Type u_1} {S : Type u_5} {M : Type u_6} {M₂ : Type u_8} (F : Type u_12) [inst : Semiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module S M₂]\n  {σ : R →+* S} {σ' : S →+* R} [inst_6 : RingHomInvPair σ σ'] [inst_7 : RingHomInvPair σ' σ] [inst_8 : EquivLike F M M₂]\n  [s : SemilinearEquivClass F σ M M₂], SemilinearMapClass F σ M M₂",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "HarderNarasimhan.HarderNarasimhanFiltration._sizeOf_inst",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "instSizeOfDefault",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "SizeOf",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "SizeOf.sizeOf",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.mk.sizeOf_spec",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] [inst_5 : SizeOf ℒ] [inst_6 : SizeOf S]\n  (filtration : ℕ → ℒ) (monotone : Monotone filtration) (first_eq_bot : filtration 0 = ⊥)\n  (fin_len : ∃ n, filtration n = ⊤)\n  (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j)\n  (piecewise_semistable :\n    ∀ (i : ℕ) (h : i < Nat.find fin_len),\n      HarderNarasimhan.Semistable (HarderNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ))\n  (μA_pseudo_strict_anti :\n    ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n      ¬HarderNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n          HarderNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩),\n  sizeOf\n      { filtration := filtration, monotone := monotone, first_eq_bot := first_eq_bot, fin_len := fin_len,\n        strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n        μA_pseudo_strict_anti := μA_pseudo_strict_anti } =\n    1 + sizeOf first_eq_bot + sizeOf fin_len",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemilatticeSup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LT.lt", "Not", "Preorder", "lt_irrefl", "Preorder.toLT"],
  "name": "Linarith.lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, ¬a < a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "le_of_not_ge",
   "Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "lt_of_le_not_le",
   "Preorder.toLT",
   "LinearOrder",
   "Preorder.toLE",
   "GE.ge"],
  "name": "lt_of_not_ge",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬a ≥ b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.Affine",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HarderNarasimhan.Affine.affine",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.Affine μ] (a b : ℒ) (h : ¬a ≤ b),\n  μ ⟨(a ⊓ b, a), ⋯⟩ = μ ⟨(b, a ⊔ b), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Nat",
   "Nat.le_succ_of_le",
   "instOfNatNat",
   "instHAdd",
   "Nat.leRec",
   "LE.le",
   "Nat.le_refl",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Nat.le_induction",
  "constType":
  "∀ {m : ℕ} {P : (n : ℕ) → m ≤ n → Prop},\n  P m ⋯ → (∀ (n : ℕ) (hmn : m ≤ n), P n hmn → P (n + 1) ⋯) → ∀ (n : ℕ) (hmn : m ≤ n), P n hmn",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "FunLike",
   "SetLike.instMembership",
   "SemilinearMapClass",
   "Module",
   "Membership.mem",
   "Iff.rfl",
   "DFunLike.coe",
   "Submodule",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap",
   "Submodule.setLike",
   "Iff",
   "Semiring"],
  "name": "Submodule.mem_comap",
  "constType":
  "∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]\n  {σ₁₂ : R →+* R₂} {x : M} {F : Type u_9} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F σ₁₂ M M₂] {f : F}\n  {p : Submodule R₂ M₂}, x ∈ Submodule.comap f p ↔ f x ∈ p",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "le_trans",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Membership.mem",
   "Preorder.toLE",
   "sInf_le",
   "Set.instMembership",
   "CompleteSemilatticeInf"],
  "name": "sInf_le_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a b : α}, b ∈ s → b ≤ a → sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Int",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["DecidableEq", "LinearOrder"],
  "name": "LinearOrder.toDecidableEq",
  "constType": "{α : Type u_2} → [self : LinearOrder α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompleteAtomicBooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Finset.instSingleton",
   "Finset",
   "Finset.singleton_inj",
   "Singleton.singleton",
   "Eq",
   "propext"],
  "name": "HarderNarasimhan.impl.prop3d12._proof_14",
  "constType": "∀ {α : Type u_1} {a b : α}, ({a} = {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "IsWellFounded.wf",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.impl.ℒₛ",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "Nat.succ",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d4₀func._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ) (x : Nat.below n.succ)\n  (hbot : ¬(↑I).1 = ↑x.1),\n  (HarderNarasimhan.impl.ℒₛ μ I x.1 hbot).Nonempty →\n    ∃ a ∈ HarderNarasimhan.impl.ℒₛ μ I x.1 hbot, ∀ x_1 ∈ HarderNarasimhan.impl.ℒₛ μ I x.1 hbot, ¬x_1 > a",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Submodule.map",
   "Submodule.subtype",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "HarderNarasimhan.impl.lift_quot._proof_15",
   "Submodule.mkQ",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "CommSemiring.toSemiring",
   "Submodule.addCommGroup",
   "HarderNarasimhan.impl.lift_quot._proof_16",
   "AddCommGroup",
   "LinearMap",
   "CommRing",
   "Ring.toSemiring",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.lift_quot._proof_14",
   "Submodule.comap",
   "Submodule.setLike",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.addCommMonoid",
   "Module.Finite",
   "Submodule.submoduleOf"],
  "name": "HarderNarasimhan.impl.lift_quot",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [IsNoetherianRing R] →\n      {M : Type} →\n        [Nontrivial M] →\n          [inst_3 : AddCommGroup M] →\n            [inst_4 : _root_.Module R M] →\n              [Module.Finite R M] → (N₁ N₂ : Submodule R M) → Submodule R (↥N₂ ⧸ N₁.submoduleOf N₂) → Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Module",
   "AddCommGroup.toAddGroup",
   "Membership.mem",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Submodule",
   "sub_eq_add_neg",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "propext",
   "SetLike.instMembership",
   "instHAdd",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "AddCommGroup",
   "Iff.rfl",
   "Ring.toSemiring",
   "HAdd.hAdd",
   "NegZeroClass.toNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Submodule.add_mem_iff_right",
   "AddCommMonoid.toAddCommSemigroup",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "Submodule.neg_mem_iff",
   "Submodule.setLike",
   "Iff",
   "AddCommGroup.toAddCommMonoid",
   "id",
   "Eq.mpr",
   "instHSub",
   "Ring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.sub_mem_iff_right",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] {module_M : _root_.Module R M} (p : Submodule R M)\n  {x y : M}, x ∈ p → (x - y ∈ p ↔ y ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCoeForallSubtypeProdLtFstSndForallIntervalOfCompleteLattice",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {z : { p // p.1 < p.2 }} →\n          {S : Type} → [CompleteLattice S] → Coe ({ p // p.1 < p.2 } → S) ({ p // p.1 < p.2 } → S)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.StI",
   "Prod.mk",
   "HarderNarasimhan.semistableI",
   "le_trans",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "lt_of_le_of_ne",
   "Membership.mem.out",
   "HarderNarasimhan.S₂I",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.S₁I",
   "le_rfl",
   "And.intro",
   "HarderNarasimhan.S₁I._proof_1",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Exists.casesOn",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.InIntvl",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "And.casesOn"],
  "name": "HarderNarasimhan.impl.prop3d7₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (x : ℒ)\n  (hxSt : x ∈ HarderNarasimhan.StI μ I), HarderNarasimhan.semistableI μ ⟨((↑I).1, x), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["AddCommMonoid", "Module", "Semiring"],
  "name": "Module.Finite",
  "constType":
  "(R : Type u_1) → (M : Type u_4) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [_root_.Module R M] → Prop",
  "constCategory": "Other"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "Nat.cast",
   "Int.instLTInt",
   "Eq",
   "Mathlib.Tactic.Zify.natCast_lt",
   "propext",
   "instNatCastInt",
   "Int"],
  "name": "_private.Mathlib.Tactic.Zify.0._proof_3",
  "constType": "∀ (a b : ℕ), (a < b) = (↑a < ↑b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "InfSet",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.FiniteTotalPayoff.casesOn",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteLattice.toTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HarderNarasimhan.FiniteTotalPayoff.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u → HarderNarasimhan.FiniteTotalPayoff μ → HarderNarasimhan.FiniteTotalPayoff μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "sSup_le_sSup_of_forall_exists_le.match_1",
   "CompleteSemilatticeSup",
   "Membership.mem",
   "And",
   "CompleteSemilatticeSup.toSupSet",
   "LE.le.trans",
   "Set.instMembership",
   "le_sSup_iff",
   "upperBounds",
   "SupSet.sSup",
   "sSup_le",
   "Iff.mpr",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sSup_le_sSup_of_forall_exists_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s t : Set α}, (∀ x ∈ s, ∃ y ∈ t, x ≤ y) → sSup s ≤ sSup t",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.FiniteTotalPayoff",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "True",
   "instHAdd",
   "List",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_3",
  "constType":
  "∀ {a0 a1 a2 a3 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 3).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: t)) = a3",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "instHAdd", "Add", "AddHom", "Eq"],
  "name": "AddHom.mk",
  "constType":
  "{M : Type u_10} →\n  {N : Type u_11} →\n    [inst : Add M] → [inst_1 : Add N] → (toFun : M → N) → (∀ (x y : M), toFun (x + y) = toFun x + toFun y) → M →ₙ+ N",
  "constCategory": "Other"},
 {"references": ["Quotient", "Setoid", "Setoid.r", "Quot.mk"],
  "name": "Quotient.mk",
  "constType": "{α : Sort u} → (s : Setoid α) → α → Quotient s",
  "constCategory": "Definition"},
 {"references": ["HMul", "outParam"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Preorder",
   "Iff",
   "RelEmbedding.map_rel_iff",
   "LE.le",
   "Preorder.toLT",
   "OrderEmbedding.ltEmbedding",
   "Preorder.toLE",
   "OrderEmbedding",
   "DFunLike.coe",
   "RelEmbedding.instFunLike"],
  "name": "OrderEmbedding.lt_iff_lt",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α ↪o β) {a b : α}, f a < f b ↔ a < b",
  "constCategory": "Theorem"},
 {"references": ["Exists", "exists_and_right", "And", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_25",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, p x ∧ b) = ((∃ x, p x) ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddSemigroup.toAdd",
   "PosSMulStrictMono",
   "Real",
   "AddCommGroup.add_comm",
   "instHAdd",
   "LinearOrder",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.mk",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "AddMonoid.toAddSemigroup",
   "LE.le"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.rec",
  "constType":
  "{V : Type} →\n  {motive : HarderNarasimhan.TotallyOrderedRealVectorSpace V → Sort u} →\n    ([toAddCommGroup : AddCommGroup V] →\n        [toModule : _root_.Module ℝ V] →\n          [toLinearOrder : LinearOrder V] →\n            [toPosSMulStrictMono : PosSMulStrictMono ℝ V] →\n              (elim_AddLeftMono : ∀ {y z : V} (x : V), y ≤ z → x + y ≤ x + z) →\n                motive\n                  { toAddCommGroup := toAddCommGroup, toModule := toModule, toLinearOrder := toLinearOrder,\n                    toPosSMulStrictMono := toPosSMulStrictMono, elim_AddLeftMono := elim_AddLeftMono }) →\n      (t : HarderNarasimhan.TotallyOrderedRealVectorSpace V) → motive t",
  "constCategory": "Other"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "AddCommGroup.toAddGroup",
   "eq_true",
   "ite_cond_eq_true",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "AddGroup.toSubtractionMonoid",
   "letFun",
   "SubNegMonoid.toSub",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion",
   "IsCancelAdd.toIsLeftCancelAdd",
   "CoheytingAlgebra.toOrderTop",
   "lt_add_of_pos_right",
   "Exists",
   "AddGroup.toAddCancelMonoid",
   "ClosureOperator.IsClosed",
   "Or.resolve_left",
   "LinearOrder.toDecidableLT",
   "Set.instCompleteAtomicBooleanAlgebra",
   "eq_false",
   "Classical.byContradiction",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "covariant_swap_add_of_covariant_add",
   "AddMonoid.toAddZeroClass",
   "Nontrivial.exists_pair_ne",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "Order.Coframe.toCoheytingAlgebra",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "HarderNarasimhan.instAddLeftMono_harderNarasimhan",
   "ite",
   "Set",
   "OrderEmbedding",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddZeroClass.toAdd",
   "Ne",
   "instHSub",
   "dite",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "PartialOrder.toPreorder",
   "Iff.mp",
   "Preorder.toLT",
   "Subtype.preorder",
   "OrderEmbedding.lt_iff_lt",
   "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
   "GT.gt",
   "RelEmbedding.instFunLike",
   "IsCancelAdd.toIsRightCancelAdd",
   "HSub.hSub",
   "CompleteLattice.toTop",
   "AddGroup.toSubNegMonoid",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "_private.Mathlib.Algebra.Order.Group.Unbundled.Basic.0._proof_51",
   "ite_cond_eq_false",
   "Exists.casesOn",
   "Iff.mpr",
   "Nontrivial",
   "NegZeroClass.toZero",
   "id",
   "CompleteDistribLattice.toCoframe",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype.lt",
   "Eq.mp",
   "Subtype.partialOrder",
   "SubNegZeroMonoid.toNegZeroClass",
   "DFunLike.coe",
   "congrArg",
   "instDistribLatticeOfLinearOrder",
   "not_top_lt",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "AddCancelMonoid.toIsCancelAdd",
   "Zero.toOfNat0",
   "Subtype.le",
   "Set.instLE",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "Mathlib.Tactic.PushNeg.not_lt_eq",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "LT.lt",
   "DistribLattice.toLattice",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "LE.le",
   "top_le_iff",
   "eq_or_lt_of_not_lt",
   "OrderTop.toTop",
   "_private.Init.Core.0._proof_39",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name":
  "HarderNarasimhan.impl.not_top_of_Nontrivial_TotallyOrderedRealVectorSpace",
  "constType":
  "∀ {V : Type} [inst : HarderNarasimhan.TotallyOrderedRealVectorSpace V] [hnt : Nontrivial V] (v : V),\n  HarderNarasimhan.coe' v < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.μA_DescendingChainCondition.casesOn",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μA_DescendingChainCondition.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u →\n                HarderNarasimhan.μA_DescendingChainCondition μ → HarderNarasimhan.μA_DescendingChainCondition μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Nat.zero_lt_of_ne_zero.match_1",
   "instLTNat",
   "instHAdd",
   "Nat.zero_lt_succ",
   "OfNat.ofNat",
   "LT.lt",
   "absurd",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "Eq.refl",
   "Ne",
   "Eq"],
  "name": "Nat.zero_lt_of_ne_zero",
  "constType": "∀ {a : ℕ}, a ≠ 0 → 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Preorder.toLT",
   "Exists.intro",
   "Eq.symm",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Exists.choose_spec",
   "BoundedOrder",
   "Exists.choose",
   "Bot.bot",
   "LT.lt",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nat.succ",
   "Iff.mpr",
   "Nat.below",
   "Lattice",
   "Ne"],
  "name": "HarderNarasimhan.impl.function_wrapper._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (f : ℕ → ℒ),\n  (∃ k, f k = ⊥) → ∀ (n : ℕ) (x : Nat.below n.succ), ¬x.1 = ⊥ → ∃ k, f k < x.1",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.mk",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] →\n                    [h : HarderNarasimhan.μ_Admissible μ] →\n                      (filtration : ℕ → ℒ) →\n                        Monotone filtration →\n                          filtration 0 = ⊥ →\n                            (fin_len : ∃ n, filtration n = ⊤) →\n                              (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                (∀ (i : ℕ) (h : i < Nat.find fin_len),\n                                    HarderNarasimhan.Semistable\n                                      (HarderNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)) →\n                                  (∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n                                      ¬HarderNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n                                          HarderNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩) →\n                                    HarderNarasimhan.HarderNarasimhanFiltration μ",
  "constCategory": "Other"},
 {"references": ["exists_prop", "Exists", "And", "Eq", "propext"],
  "name": "HarderNarasimhan.μmax_res_intvl._proof_20",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "And.intro",
   "False.elim",
   "SupSet.sSup",
   "HarderNarasimhan.μBstar",
   "funext",
   "forall_congr",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Exists",
   "_private.Mathlib.Order.Basic.0._proof_1",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Iff",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "lt_top_iff_ne_top",
   "setOf",
   "HarderNarasimhan.μAstar",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "Aesop.BuiltinRules.not_intro",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Iff.intro",
   "Prod.fst",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "InfSet.sInf",
   "_private.Init.PropLemmas.0._proof_12",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "sSup_le_iff",
   "bot_lt_iff_ne_bot",
   "le_sInf_iff",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.μmax._proof_2",
   "exists_prop_congr",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "ne_of_lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "_private.Mathlib.Order.CompleteLattice.Defs.0._proof_2",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top",
   "And.casesOn"],
  "name": "HarderNarasimhan.impl.rmk4d10₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.μBstar μ ≤ HarderNarasimhan.μAstar μ ↔\n    ∀ (x : ℒ) (hx : x ≠ ⊤) (y : ℒ) (hy : ⊥ < y),\n      HarderNarasimhan.μmin μ ⟨(⊥, y), hy⟩ ≤ HarderNarasimhan.μmax μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mk",
   "SetLike.coe",
   "Set",
   "Membership.mem",
   "SetLike",
   "Membership",
   "Set.instMembership"],
  "name": "SetLike.instMembership",
  "constType":
  "{A : Type u_1} → {B : Type u_2} → [i : SetLike A B] → Membership B A",
  "constCategory": "Definition"},
 {"references": ["Lattice", "CompleteLattice"],
  "name": "CompleteLattice.toLattice",
  "constType": "{α : Type u_8} → [self : CompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.StI",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Set",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.St",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Set ℒ",
  "constCategory": "Definition"},
 {"references":
  ["not_and_of_not_or_not",
   "Not",
   "And.intro",
   "Or.inr",
   "Or.inl",
   "Or",
   "Decidable",
   "Iff",
   "And",
   "dite",
   "Iff.intro"],
  "name": "Decidable.not_and_iff_not_or_not'",
  "constType": "∀ {b a : Prop} [Decidable b], ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "∀ {a b : Prop}, (a → b) → ¬b → ¬a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Set",
   "Membership.mem",
   "And",
   "Eq",
   "Set.instMembership",
   "setOf"],
  "name": "Set.image",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Set α → Set β",
  "constCategory": "Definition"},
 {"references":
  ["Set", "LE.le", "Membership.mem", "LE", "Set.instMembership", "setOf"],
  "name": "upperBounds",
  "constType": "{α : Type u_1} → [LE α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.ext",
   "Subtype",
   "Eq.trans",
   "LinearMap.instFunLike",
   "Eq.mp",
   "Module",
   "Submodule.module",
   "Membership.mem",
   "Submodule.map",
   "Exists.intro",
   "and_true",
   "Subtype.val",
   "DFunLike.coe",
   "congrArg",
   "Submodule",
   "Submodule.subtype",
   "Iff.intro",
   "LinearMap.semilinearMapClass",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "congr",
   "HarderNarasimhan.impl.submoduleOf_map_subtype._proof_12",
   "Eq.rec",
   "Eq",
   "HarderNarasimhan.impl.submoduleOf_map_subtype._proof_11",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "True",
   "Set",
   "CommSemiring.toSemiring",
   "And",
   "AddCommGroup",
   "CommRing",
   "LinearMap",
   "Set.instMembership",
   "RingHomSurjective.ids",
   "Exists.casesOn",
   "eq_self",
   "SetLike.coe",
   "Submodule.setLike",
   "Nontrivial",
   "id",
   "AddCommGroup.toAddCommMonoid",
   "Eq.mpr",
   "Submodule.addCommMonoid",
   "And.casesOn",
   "Submodule.submoduleOf"],
  "name": "HarderNarasimhan.impl.submoduleOf_map_subtype",
  "constType":
  "∀ {R : Type} [inst : CommRing R] {M : Type} [Nontrivial M] [inst_2 : AddCommGroup M] [inst_3 : _root_.Module R M]\n  (N : Submodule R M) (N' : Submodule R ↥N), N' = (Submodule.map N.subtype N').submoduleOf N",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._cstage1",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "PartialOrder.toPreorder",
   "Finset",
   "Eq.trans",
   "_private.Mathlib.Data.Finset.Lattice.Fold.0._proof_4",
   "Membership.mem",
   "WithTop",
   "WithTop.some",
   "_private.Init.Classical.0._proof_9",
   "_private.Init.Classical.0._proof_7",
   "congrArg",
   "Finset.inf",
   "_private.Init.Core.0._proof_26",
   "WithTop.orderTop",
   "WithTop.top",
   "funext",
   "forall_congr",
   "Preorder.toLE",
   "Eq",
   "Finset.Nonempty",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Exists",
   "Function.comp",
   "_private.Mathlib.Order.WithBot.0._proof_52",
   "SemilatticeInf",
   "WithTop.semilatticeInf",
   "Eq.refl",
   "Top.top",
   "Finset.instMembership",
   "id",
   "False",
   "Ne",
   "Eq.mpr",
   "OrderTop.toTop"],
  "name": "Finset.inf'._proof_13",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : SemilatticeInf α] (s : Finset β),\n  s.Nonempty → ∀ (f : β → α), s.inf (WithTop.some ∘ f) ≠ ⊤",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 → Prop",
  "constCategory": "Other"},
 {"references": ["HMul", "HMul.mk", "Mul", "Mul.mul"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "Subtype.property",
   "Membership.mem",
   "SetLike",
   "Subtype.val"],
  "name": "SetLike.coe_mem",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} (x : ↥p), ↑x ∈ p",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μ_Admissible.rec",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.μ_Admissible",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.μ_Admissible.mk",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "IsTotal",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.μ_Admissible.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                {motive : HarderNarasimhan.μ_Admissible μ → Sort u} →\n                  (t : HarderNarasimhan.μ_Admissible μ) →\n                    ((μ_adm :\n                          (IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n                            ∀ (I : { p // p.1 < p.2 }), HarderNarasimhan.IsAttained μ I) →\n                        motive ⋯) →\n                      motive t",
  "constCategory": "Definition"},
 {"references": ["Membership.mk", "Membership", "Multiset", "Multiset.Mem"],
  "name": "Multiset.instMembership",
  "constType": "{α : Type u_1} → Membership α (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.μA",
   "PartialOrder",
   "Nontrivial",
   "Top.top",
   "OrderBot.toBot",
   "Subtype.mk",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μAstar",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → S",
  "constCategory": "Definition"},
 {"references": ["Lean.Name"],
  "name": "Lean.Name.anonymous",
  "constType": "Name",
  "constCategory": "Other"},
 {"references": ["_obj", "Prod.mk", "HarderNarasimhan.μA._rarg", "_neutral"],
  "name": "HarderNarasimhan.μAstar._rarg._cstage2",
  "constType": "_obj → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Module",
   "RingHom.instFunLike",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "LinearEquiv",
   "DFunLike.coe",
   "SemilinearEquivClass.instSemilinearMapClass",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "MonoidWithZero.toMonoid",
   "EquivLike.toFunLike",
   "instHSMul",
   "Eq",
   "LinearEquiv.instEquivLike",
   "DistribSMul.toSMulZeroClass",
   "SemilinearMapClass.toMulActionSemiHomClass",
   "AddZeroClass.toZero",
   "outParam",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "LinearEquiv.instSemilinearEquivClass",
   "MulActionSemiHomClass.map_smulₛₗ",
   "Module.toDistribMulAction",
   "HSMul.hSMul",
   "RingHomInvPair.ids",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "LinearEquiv.map_smul",
  "constType":
  "∀ {R₁ : Type u_2} {N₁ : Type u_10} {N₂ : Type u_11} [inst : Semiring R₁] [inst_1 : AddCommMonoid N₁]\n  [inst_2 : AddCommMonoid N₂] {module_N₁ : _root_.Module R₁ N₁} {module_N₂ : _root_.Module R₁ N₂} (e : N₁ ≃ₗ[R₁] N₂)\n  (c : R₁) (x : N₁), e (c • x) = c • e x",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Subtype", "Subtype.exists", "Subtype.mk", "Eq", "propext"],
  "name": "HarderNarasimhan.impl.lift_quot_middle._proof_19",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE", "ge_iff_le", "Eq", "GE.ge", "propext"],
  "name": "HarderNarasimhan.impl.rmk4d14₁._proof_18",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["Subtype", "Subtype.property", "Subtype.val"],
  "name": "Subtype.prop",
  "constType": "∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Iff.trans",
   "Module",
   "not_iff_not",
   "Iff.mp",
   "Iff.symm",
   "Submodule",
   "not_nontrivial_iff_subsingleton",
   "AddCommMonoid",
   "Subsingleton",
   "Submodule.subsingleton_iff",
   "Iff",
   "Nontrivial",
   "Semiring"],
  "name": "Submodule.nontrivial_iff",
  "constType":
  "∀ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M],\n  Nontrivial (Submodule R M) ↔ Nontrivial M",
  "constCategory": "Theorem"},
 {"references":
  ["Nat", "Nat.instCommSemiring", "CommSemiring", "inferInstance"],
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["DecidableRel", "Classical.propDecidable", "inferInstance"],
  "name": "Classical.decRel",
  "constType": "{α : Sort u_1} → (p : α → α → Prop) → DecidableRel p",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.Interval",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → { p // p.1 < p.2 } → Type",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.ext",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Inhabited.default",
   "letFun",
   "funext",
   "Eq.symm",
   "HarderNarasimhan.S",
   "SetLike.instMembership",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat",
   "Iff",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "id",
   "Eq.mpr",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.toBoundedOrder",
   "Submodule.instNontrivial",
   "Module",
   "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration",
   "Eq.mp",
   "Submodule",
   "congrArg",
   "HarderNarasimhan.impl.CP_HN'",
   "HarderNarasimhan.CoprimaryFiltration",
   "Eq",
   "HarderNarasimhan.impl.prop3d11",
   "CompleteLattice.toConditionallyCompleteLattice",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "HarderNarasimhan.impl.prop3d13₂",
   "Iff.rfl",
   "CommRing",
   "Inhabited",
   "HarderNarasimhan.impl.prop3d13₁",
   "HarderNarasimhan.CoprimaryFiltration.ext",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "Submodule.setLike",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Submodule.completeLattice",
   "inferInstance",
   "HarderNarasimhan.S₀",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instUniqueCoprimaryFiltration._proof_27",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (a : HarderNarasimhan.CoprimaryFiltration R M), a = default",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "BoundedOrder",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.JHFil._proof_1",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ], ⊥ < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan",
   "PartialOrder.toPreorder",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "PartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ClosureOperator",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "CompleteLattice"],
  "name":
  "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion._cstage1",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → CompleteLattice (HarderNarasimhan.DedekindMacNeilleCompletion α)",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderBot",
  "constType": "(α : Type u) → [LE α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["implies_congr",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "HarderNarasimhan.semistableI",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "GT.gt",
   "HarderNarasimhan.S₂I",
   "Subtype.val",
   "HarderNarasimhan.S₁I",
   "not_false_eq_true",
   "HarderNarasimhan.S₁I._proof_1",
   "forall_congr",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Exists.choose_spec",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "True.intro",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "implies_true",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Iff",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "setOf",
   "HarderNarasimhan.Semistable",
   "Ne.symm",
   "Subtype",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_36",
   "HarderNarasimhan.TotIntvl._proof_1",
   "and_true",
   "Iff.intro",
   "Prod.fst",
   "congrArg",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Semistable.mk",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_3",
   "HarderNarasimhan.Semistable.semistable",
   "exists_prop_congr",
   "LT.lt",
   "HarderNarasimhan.μA",
   "LE.le",
   "False",
   "_private.Init.PropLemmas.0._proof_14",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "_private.Init.Core.0._proof_39",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.semistable_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Semistable μ ↔ HarderNarasimhan.semistableI μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references": ["SMul"],
  "name": "SMul.mk",
  "constType": "{M : Type u} → {α : Type v} → (M → α → α) → SMul M α",
  "constCategory": "Other"},
 {"references":
  ["CommRing.toRing",
   "CommSemiring",
   "CommRing.mul_comm",
   "CommSemiring.mk",
   "CommRing",
   "Ring.toSemiring"],
  "name": "CommRing.toCommSemiring",
  "constType": "{α : Type u} → [s : CommRing α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "lt_trans",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "bot_le",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "Equiv",
   "Or",
   "SupSet.sSup",
   "HarderNarasimhan.μBstar",
   "letFun",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "HarderNarasimhan.impl.prop4d1₁",
   "HarderNarasimhan.impl.prop4d3_helper",
   "SemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLattice.toInfSet",
   "Exists",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Set.ext",
   "Eq.mpr",
   "OrderDual.instBoundedOrder",
   "HarderNarasimhan.impl.prop4d1_helper",
   "setOf",
   "HarderNarasimhan.μAstar",
   "OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "Eq.mp",
   "OrderDual.instLattice",
   "HarderNarasimhan.impl.dualμAstar_eq_μBstar",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "Iff.intro",
   "congrArg",
   "Nat.instPreorder",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "HarderNarasimhan.μmin",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "OrderDual.instLT",
   "InfSet.sInf",
   "OrderDual.instCompleteLattice",
   "OrderDual.instPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.impl.h₁_dual_of_h₁",
   "propext",
   "CompleteLattice.toConditionallyCompleteLattice",
   "_private.Mathlib.Order.Synonym.0._proof_6",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "Set",
   "instHAdd",
   "OfNat.ofNat",
   "exists_prop_congr",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "HarderNarasimhan.impl.h₂_dual_of_h₂",
   "LE.le",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop4d3₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n        μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n      HarderNarasimhan.μBstar μ = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Int.instLTInt",
   "HarderNarasimhan.JordanHolderFiltration",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Antitone",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "HarderNarasimhan.JordanHolderFiltration._proof_1",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "Nat.decLt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "HarderNarasimhan.JordanHolderFiltration.rec",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "HarderNarasimhan.JordanHolderFiltration.mk",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "Linarith.zero_lt_one",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.JordanHolderFiltration.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLinearOrder S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                {motive : HarderNarasimhan.JordanHolderFiltration μ → Sort u} →\n                  (t : HarderNarasimhan.JordanHolderFiltration μ) →\n                    ((filtration : ℕ → ℒ) →\n                        (antitone : Antitone filtration) →\n                          (fin_len : ∃ N, filtration N = ⊥) →\n                            (strict_anti : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration j < filtration i) →\n                              (first_eq_top : filtration 0 = ⊤) →\n                                (step_cond₁ :\n                                    ∀ (k : ℕ) (hk : k < Nat.find fin_len),\n                                      μ ⟨(filtration (k + 1), filtration k), ⋯⟩ = μ ⟨(⊥, ⊤), ⋯⟩) →\n                                  (step_cond₂ :\n                                      ∀ (i : ℕ) (hi : i < Nat.find fin_len) (z : ℒ) (h' : filtration (i + 1) < z),\n                                        z < filtration i →\n                                          μ ⟨(filtration (i + 1), z), h'⟩ < μ ⟨(filtration (i + 1), filtration i), ⋯⟩) →\n                                    motive\n                                      { filtration := filtration, antitone := antitone, fin_len := fin_len,\n                                        strict_anti := strict_anti, first_eq_top := first_eq_top,\n                                        step_cond₁ := step_cond₁, step_cond₂ := step_cond₂ }) →\n                      motive t",
  "constCategory": "Definition"},
 {"references":
  ["le_rfl",
   "SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "inf_le_inf",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_le_inf_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a : α) {b c : α}, b ≤ c → b ⊓ a ≤ c ⊓ a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "le_of_not_gt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "AddMonoid.toAddSemigroup",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Int.negOfNat",
   "Top.top",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "AddMonoid.toAddZeroClass",
   "Linarith.add_lt_of_neg_of_le",
   "Nat.find",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "instNatCastInt",
   "lt_of_not_ge",
   "Distrib.toAdd",
   "Nat.instAddMonoid",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HarderNarasimhan.μA",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "HarderNarasimhan.HarderNarasimhanFiltration.fin_len",
   "GT.gt",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.instAddCommMonoid",
   "GE.ge",
   "Mathlib.Meta.NormNum.isNat_add",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Nat.instPartialOrder",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "IsOrderedAddMonoid.toAddLeftMono",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "Decidable.byContradiction",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Nat.cast",
   "Subtype",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "HarderNarasimhan.HarderNarasimhanFiltration.strict_mono",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "LT.lt",
   "lt_add_one",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Linarith.zero_lt_one",
   "LE.le",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "OrderTop.toTop",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.μA_pseudo_strict_anti",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ]\n  (self : HarderNarasimhan.HarderNarasimhanFiltration μ) (i : ℕ) (hi : i + 1 < Nat.find ⋯),\n  ¬HarderNarasimhan.μA μ ⟨(self.filtration i, self.filtration (i + 1)), ⋯⟩ ≤\n      HarderNarasimhan.μA μ ⟨(self.filtration (i + 1), self.filtration (i + 2)), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "HarderNarasimhan.impl.rmk2d7",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.remark_2_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Convex μ →\n    ∀ (x : ℒ) (h : ⊥ < x ∧ x < ⊤),\n      HarderNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HarderNarasimhan.μA μ HarderNarasimhan.TotIntvl →\n        HarderNarasimhan.μA μ ⟨(x, ⊤), ⋯⟩ = HarderNarasimhan.μA μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references": ["HasSubset.mk", "Set", "HasSubset", "LE.le", "Set.instLE"],
  "name": "Set.instHasSubset",
  "constType": "{α : Type u} → HasSubset (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "And",
   "Iff.intro",
   "And.intro",
   "PartialOrder",
   "Iff",
   "LE.le",
   "le_of_eq",
   "Eq.symm",
   "le_antisymm_iff.match_1",
   "Eq",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "le_antisymm_iff",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a = b ↔ a ≤ b ∧ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg",
   "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["_obj", "_neutral"],
  "name": "HarderNarasimhan.μmin._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Nat", "LE.mk", "LE", "Nat.le"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "CompleteLattice",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLattice.toTop",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition'.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) →\n    HarderNarasimhan.WeakDescendingChainCondition' μ",
  "constCategory": "Other"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Syntax.node",
   "Lean.Name.mkStr1",
   "Array.push",
   "Lean.Syntax",
   "Array.empty",
   "Lean.SourceInfo.none"],
  "name": "AddMonoid.nsmul_succ._autoParam",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name":
  "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMonoid",
   "AddSubmonoid",
   "Module",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Submodule",
   "Semiring"],
  "name": "Submodule.toAddSubmonoid",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → Submodule R M → AddSubmonoid M",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "HarderNarasimhan.SlopeLike.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.SlopeLike.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x y z : ℒ) (h : x < y ∧ y < z),\n      (μ ⟨(x, y), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ < μ ⟨(x, z), ⋯⟩) ∧\n        (μ ⟨(x, y), ⋯⟩ < μ ⟨(x, z), ⋯⟩ ∨ μ ⟨(y, z), ⋯⟩ ≤ μ ⟨(x, z), ⋯⟩) ∧\n          (μ ⟨(x, z), ⋯⟩ < μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(y, z), ⋯⟩) ∧\n            (μ ⟨(x, z), ⋯⟩ ≤ μ ⟨(x, y), ⋯⟩ ∨ μ ⟨(x, z), ⋯⟩ < μ ⟨(y, z), ⋯⟩)) →\n    HarderNarasimhan.SlopeLike μ",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Finset",
   "Eq.trans",
   "True",
   "Set",
   "Membership.mem",
   "Set.toFinset",
   "Finset.instHasSubset",
   "Fintype",
   "Set.Elem",
   "congrArg",
   "Set.instMembership",
   "Set.instHasSubset",
   "_private.Mathlib.Data.Fintype.Sets.0._proof_1",
   "iff_self",
   "Set.toFinset_subset_toFinset._proof_4",
   "of_eq_true",
   "HasSubset.Subset",
   "Iff",
   "forall_congr",
   "Finset.instMembership"],
  "name": "Set.toFinset_subset_toFinset",
  "constType":
  "∀ {α : Type u_1} {s t : Set α} [inst : Fintype ↑s] [inst_1 : Fintype ↑t], s.toFinset ⊆ t.toFinset ↔ s ⊆ t",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "Lattice.mk",
  "constType":
  "{α : Type u} →\n  [toSemilatticeSup : SemilatticeSup α] →\n    (inf : α → α → α) →\n      (∀ (a b : α), inf a b ≤ a) → (∀ (a b : α), inf a b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ inf b c) → Lattice α",
  "constCategory": "Other"},
 {"references": ["AddGroupWithOne", "AddMonoidWithOne"],
  "name": "AddGroupWithOne.toAddMonoidWithOne",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references": ["Not", "Exists", "Classical.not_forall", "Eq", "propext"],
  "name": "_private.Init.Classical.0._proof_9",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) = ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.hasQuotient",
   "Ring.toNonAssocRing",
   "HasQuotient.Quotient",
   "Module",
   "AddCommGroup.toAddGroup",
   "AddGroupWithOne.toAddMonoidWithOne",
   "SMulZeroClass.toSMul",
   "AddMonoidWithOne.toAddMonoid",
   "instDistribSMul",
   "Submodule.Quotient.instSMul._proof_3",
   "Submodule",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "SMul",
   "Ring.toAddGroupWithOne",
   "MonoidWithZero.toMonoid",
   "AddGroup.toSubNegMonoid",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DistribSMul.toSMulZeroClass",
   "AddZeroClass.toZero",
   "DistribMulAction.toDistribSMul",
   "Submodule.Quotient.instSMul'",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Ring.toSemiring",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "Ring"],
  "name": "Submodule.Quotient.instSMul",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : _root_.Module R M] → (P : Submodule R M) → SMul R (M ⧸ P)",
  "constCategory": "Definition"},
 {"references":
  ["Set.toFinset_congr",
   "Submodule.ext",
   "Submodule.Quotient.module",
   "Submodule.map",
   "LocalizedModule.mk",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Finset.min'",
   "RingHom.id",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion",
   "Eq.symm",
   "HarderNarasimhan.S",
   "LocalizedModule.zero_mk",
   "Exists",
   "LinearMap.ker",
   "LocalizedModule",
   "LinearMap",
   "Ring.toSemiring",
   "HarderNarasimhan.impl.prop3d12._proof_12",
   "LocalizedModule.isModule'",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_9",
   "Top.top",
   "Eq.mpr",
   "Quotient.out",
   "RelEmbedding.toEmbedding",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.Quotient.instZeroQuotient",
   "MulZeroOneClass.toMulOneClass",
   "AddCommMonoid.toAddMonoid",
   "Prod.fst",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_10",
   "LocalizedModule.mkLinearMap",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "Eq",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "LinearExtension",
   "Set",
   "IsLeast.csInf_eq",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Set.toFinset",
   "eq_self",
   "HarderNarasimhan.impl.prop3d12._proof_13",
   "HarderNarasimhan.instPartialOrderS₀",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.μA._proof_3",
   "Submodule.Quotient.mk",
   "PartialOrder.toPreorder",
   "false_of_nontrivial_of_subsingleton",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Membership.mem",
   "HarderNarasimhan.μ",
   "Preorder.toLT",
   "Mathlib.Tactic.PushNeg.not_ne_eq",
   "HarderNarasimhan.μmax",
   "LocalizedModule.instZero",
   "RelEmbedding.instFunLike",
   "Submodule.subtype",
   "LinearMap.semilinearMapClass",
   "Semiring.toNonAssocSemiring",
   "Module.support._proof_1",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "forall_congr",
   "PrimeSpectrum.instPartialOrder",
   "Eq.rec",
   "Semiring.toModule",
   "NonAssocSemiring.toMulZeroOneClass",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "AddZeroClass.toZero",
   "HarderNarasimhan.impl.prop3d12._proof_17",
   "And.right",
   "PrimeSpectrum.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Exists.casesOn",
   "Finset.instSingleton",
   "Iff.of_eq",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "LinearMap.toSpanSingleton",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Eq.mp",
   "Submodule.module",
   "LinearMap.comp",
   "lt_of_le_of_ne",
   "DFunLike.coe",
   "Subsingleton",
   "HarderNarasimhan.instLinearOrderS₀",
   "PrimeSpectrum.asIdeal",
   "Set.toFinset_singleton",
   "Subtype.le",
   "Not",
   "Submodule.mkQ",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Submodule.quotientRel",
   "IsAssociatedPrime._proof_1",
   "HarderNarasimhan.impl.mem_support_of_mem_associatedPrimes",
   "Set.instSingletonSet",
   "IsAssociatedPrime",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_7",
   "RingHomSurjective.ids",
   "LT.lt",
   "LocalizedModule.subsingleton_iff_ker_eq_top",
   "HarderNarasimhan.impl.f1._proof_4",
   "of_eq_true",
   "One.toOfNat1",
   "le_of_lt",
   "False",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_3",
   "Subtype.mk",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization._proof_8",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Finset",
   "Eq.trans",
   "Singleton.singleton",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "Quotient.out_eq",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "letFun",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_1",
   "Set.setOf_eq_eq_singleton'",
   "mem_lowerBounds",
   "rfl",
   "ClosureOperator.IsClosed",
   "Submodule.addCommGroup",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Submonoid",
   "HarderNarasimhan.impl.prop3d12._proof_20",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "lowerBounds",
   "Classical.byContradiction",
   "AddCommGroup.toAddCommMonoid",
   "Finset.instMembership",
   "HarderNarasimhan.impl.f2",
   "CompleteLattice.toBoundedOrder",
   "Set.fintypeSingleton",
   "HarderNarasimhan.impl.prop3d12._proof_23",
   "setOf",
   "AddMonoid.toAddZeroClass",
   "Quotient",
   "Submodule.hasQuotient",
   "HarderNarasimhan.coe'",
   "LocalizedModule.instAddCommMonoid",
   "HarderNarasimhan.impl.μ_nonempty",
   "congr",
   "InfSet.sInf",
   "HarderNarasimhan.impl.noname",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "propext",
   "Submodule.instTop",
   "AddCommGroup",
   "OrderEmbedding",
   "OfNat.ofNat",
   "Submonoid.one",
   "PrimeSpectrum",
   "CommRing.toRing",
   "HarderNarasimhan.impl.prop3d12._proof_14",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.μA",
   "HarderNarasimhan._μ._proof_2",
   "Submodule.completeLattice",
   "HarderNarasimhan.S₀",
   "Module.Finite",
   "HarderNarasimhan.impl.f1",
   "Prod.mk",
   "Ideal.IsPrime",
   "RingHomCompTriple.ids",
   "HarderNarasimhan.impl.associated_primes_quot_koqcl",
   "Subtype.preorder",
   "Quotient.mk",
   "PrimeSpectrum.isPrime",
   "And.intro",
   "HarderNarasimhan.impl.prop3d12._proof_11",
   "funext",
   "HarderNarasimhan.impl.ker_of_quot_comp_localization",
   "SetLike.instMembership",
   "HarderNarasimhan.impl.prop3d12._proof_18",
   "Submonoid.instSetLike",
   "And",
   "True.intro",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "HarderNarasimhan.impl.prop3d12p2",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.submoduleOf",
   "HarderNarasimhan.impl.prop3d12._proof_15",
   "Subtype",
   "Function.Embedding.toFun",
   "Submodule",
   "congrArg",
   "Iff.intro",
   "Submodule.Quotient.addCommGroup",
   "Subtype.prop",
   "Ideal",
   "Ideal.primeCompl",
   "RelEmbedding.instEmbeddingLike",
   "Zero.toOfNat0",
   "RelEmbedding",
   "Finset.min'_mem",
   "Set.instLE",
   "CommRing.toCommSemiring",
   "HarderNarasimhan.impl.prop3d12._proof_16",
   "Lattice.toSemilatticeInf",
   "True",
   "CommSemiring.toSemiring",
   "CommRing",
   "exists_prop_congr",
   "CompleteSemilatticeInf.toInfSet",
   "IsNoetherianRing",
   "Submodule.setLike",
   "HarderNarasimhan.impl.prop3d12._proof_21",
   "LE.le",
   "HarderNarasimhan.impl.prop3d12._proof_19",
   "Submodule.addCommMonoid"],
  "name": "HarderNarasimhan.impl.prop3d12",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  HarderNarasimhan.μA (HarderNarasimhan.μ R M) I =\n    HarderNarasimhan.coe'.toFun {(HarderNarasimhan._μ R M I).toFinset.min' ⋯}",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "GetElem?.mk",
   "List.instGetElemNatLtLength",
   "instLTNat",
   "Nat",
   "_private.Init.GetElem.0.List.get!Internal",
   "_private.Init.GetElem.0.List.get?Internal",
   "GetElem?",
   "List",
   "Inhabited",
   "List.length"],
  "name": "List.instGetElem?NatLtLength",
  "constType":
  "{α : Type u_1} → GetElem? (List α) ℕ α fun as i => i < as.length",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "SubNegZeroMonoid.toSubNegMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "sub_eq_add_neg",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "Zero.toOfNat0",
   "neg_zero",
   "Eq",
   "True",
   "instHAdd",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "SubNegZeroMonoid",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "NegZeroClass.toNeg",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "instHSub",
   "AddMonoid.toAddZeroClass"],
  "name": "sub_zero",
  "constType":
  "∀ {G : Type u_3} [inst : SubNegZeroMonoid G] (a : G), a - 0 = a",
  "constCategory": "Theorem"},
 {"references": ["Option", "outParam", "GetElem?"],
  "name": "GetElem?.getElem?",
  "constType":
  "{coll : Type u} →\n  {idx : Type v} →\n    {elem : outParam (Type w)} →\n      {valid : outParam (coll → idx → Prop)} → [self : GetElem? coll idx elem valid] → coll → idx → Option elem",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "Preorder.toLT",
   "eq_true",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "True",
   "instHAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "add_zero",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Linarith.lt_of_lt_of_eq",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [inst_1 : PartialOrder α] {a b : α}, a < 0 → b = 0 → a + b < 0",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.trans_eq",
   "AddZeroClass",
   "AddZeroClass.toZero",
   "instHAdd",
   "LE",
   "CanonicallyOrderedAdd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "zero_add",
   "AddZeroClass.toAdd",
   "LE.le",
   "le_self_add",
   "Zero.toOfNat0"],
  "name": "zero_le",
  "constType":
  "∀ {α : Type u} [inst : AddZeroClass α] [inst_1 : LE α] [CanonicallyOrderedAdd α] (a : α), 0 ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instMembership",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "AddCommMonoid.toAddMonoid",
   "Bot.bot",
   "OfNat.ofNat",
   "Submodule",
   "AddCommMonoid",
   "Submodule.setLike",
   "Submodule.instBot",
   "Submodule.mem_bot",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_26",
  "constType":
  "∀ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {x : M},\n  (x ∈ ⊥) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["PartialOrder", "CompleteSemilatticeInf"],
  "name": "CompleteSemilatticeInf.toPartialOrder",
  "constType":
  "{α : Type u_8} → [self : CompleteSemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["rfl", "Subtype", "Subtype.ext", "Subtype.mk", "Eq", "Subtype.val"],
  "name": "Subtype.coe_eta",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (a : { a // p a }) (h : p ↑a), ⟨↑a, h⟩ = a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.JordanHolderFiltration",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → [WellFoundedGT ℒ] → {S : Type} → [CompleteLinearOrder S] → ({ p // p.1 < p.2 } → S) → Type",
  "constCategory": "Other"},
 {"references": ["lt_trans", "Preorder", "Preorder.toLT", "GT.gt"],
  "name": "gt_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a > b → b > c → a > c",
  "constCategory": "Theorem"},
 {"references":
  ["mem_upperBounds",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "GT.gt",
   "Subtype.val",
   "Set.Elem",
   "IsGreatest",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop3d4",
   "IsTotal.total",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "eq_of_ge_of_not_gt",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "HarderNarasimhan.impl.prop3d8₁",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "HarderNarasimhan.InIntvl",
   "upperBounds",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Or.inr",
   "Subtype",
   "HarderNarasimhan.StI",
   "lt_of_le_of_ne",
   "Prod.fst",
   "Or.inl",
   "IsWellFounded.wf",
   "le_of_eq",
   "WellFoundedGT",
   "Eq",
   "Subtype.le",
   "Preorder.toLE",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "LT.lt",
   "Or.casesOn",
   "IsTotal",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d8₁'",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.μA_DescendingChainCondition μ →\n    ∀ (I : { p // p.1 < p.2 }),\n      HarderNarasimhan.ConvexI I μ →\n        ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n            ∀ (z : ℒ) (hzI : HarderNarasimhan.InIntvl I z) (hz : (↑I).1 ≠ z),\n              HarderNarasimhan.IsAttained μ ⟨((↑I).1, z), ⋯⟩) →\n          ∃ s, IsGreatest (HarderNarasimhan.StI μ I) s",
  "constCategory": "Theorem"},
 {"references": ["IsLeftCancelAdd", "Add", "IsCancelAdd"],
  "name": "IsCancelAdd.toIsLeftCancelAdd",
  "constType":
  "∀ {G : Type u} {inst : Add G} [self : IsCancelAdd G], IsLeftCancelAdd G",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toNatCast",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring",
   "AddCommMonoid.add_comm",
   "AddCommMonoidWithOne",
   "AddCommMonoid.toAddMonoid",
   "AddMonoidWithOne.mk",
   "NonAssocSemiring.natCast_succ"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["Inv.inv",
   "InvOneClass.toInv",
   "Units.instGroup",
   "Units.mk0",
   "MonoidWithZero.toMulZeroOneClass",
   "GroupWithZero",
   "OfNat.ofNat",
   "MulAction.toSMul",
   "DivInvOneMonoid.toInvOneClass",
   "MulAction",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toZero",
   "Units.instMulAction",
   "HSMul.hSMul",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.toMonoidWithZero",
   "smul_inv_smul",
   "instHSMul",
   "Ne",
   "Zero.toOfNat0",
   "Eq",
   "DivisionMonoid.toDivInvOneMonoid",
   "Units",
   "GroupWithZero.toDivisionMonoid"],
  "name": "smul_inv_smul₀",
  "constType":
  "∀ {α : Type u_4} {β : Type u_5} [inst : GroupWithZero α] [inst_1 : MulAction α β] {a : α},\n  a ≠ 0 → ∀ (x : β), a • a⁻¹ • x = x",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "And",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.InIntvl",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.impl.ℒₛ._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (x : { p // HarderNarasimhan.InIntvl I p }) (p : ℒ),\n  HarderNarasimhan.InIntvl I p → (↑I).1 ≠ p ∧ p < ↑x → ((↑I).1, p).1 < ((↑I).1, p).2",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.hasQuotient",
   "Submodule.Quotient.mk",
   "SetLike.instMembership",
   "HasQuotient.Quotient",
   "Module",
   "Membership.mem",
   "Submodule.Quotient.instZeroQuotient",
   "AddCommGroup",
   "Submodule.Quotient.mk_eq_zero",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "Submodule",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "Ring"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_29",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} {x : M} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), (Submodule.Quotient.mk x = 0) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Function.not_injective_iff._proof_3",
   "Exists",
   "Eq.trans",
   "True",
   "And",
   "Function.not_injective_iff._proof_2",
   "congrArg",
   "iff_self",
   "of_eq_true",
   "Iff",
   "funext",
   "Ne",
   "Eq",
   "Function.Injective"],
  "name": "Function.not_injective_iff",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, ¬Function.Injective f ↔ ∃ a b, f a = f b ∧ a ≠ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.impl.prop3d4₀func._proof_8",
   "Decidable",
   "Eq.trans",
   "Subsingleton.elim",
   "Eq.mpr_not",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "GT.gt",
   "Subtype.val",
   "funext",
   "HarderNarasimhan.impl.prop3d4₀func._proof_4",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Exists",
   "HarderNarasimhan.impl.ℒₛ",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Subtype",
   "instDecidableTrue",
   "Eq.mp",
   "dite_congr",
   "Prod.fst",
   "congrArg",
   "instOfNatNat",
   "congr",
   "WellFoundedGT",
   "instSubsingletonDecidable",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "Set",
   "HarderNarasimhan.impl.prop3d4₀func",
   "Exists.choose",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "Ne",
   "Subtype.mk",
   "dite",
   "CompleteLattice",
   "HarderNarasimhan.impl.prop3d4₀func._proof_7"],
  "name": "HarderNarasimhan.impl.prop3d4₀func_helper",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ),\n  (↑I).1 ≠ ↑(HarderNarasimhan.impl.prop3d4₀func μ I (i + 1)) → (↑I).1 ≠ ↑(HarderNarasimhan.impl.prop3d4₀func μ I i)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Module",
   "Semiring"],
  "name": "LinearMap",
  "constType":
  "{R : Type u_14} →\n  {S : Type u_15} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        (R →+* S) →\n          (M : Type u_16) →\n            (M₂ : Type u_17) →\n              [inst_2 : AddCommMonoid M] →\n                [inst_3 : AddCommMonoid M₂] → [_root_.Module R M] → [_root_.Module S M₂] → Type (max u_16 u_17)",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Coe",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Interval",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._proof_17",
   "Lattice.toSemilatticeInf",
   "Coe.mk",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod",
   "LT.lt",
   "lcProof",
   "BoundedOrder.toOrderBot",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "bot_lt_top"],
  "name": "HarderNarasimhan.instCoeIntervalMkProdLtFstSndMkBotTop._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → Coe ℒ (HarderNarasimhan.Interval ⟨(⊥, ⊤), ⋯⟩)",
  "constCategory": "Definition"},
 {"references": ["Semiring", "Ring"],
  "name": "Ring.toSemiring",
  "constType": "{R : Type u} → [self : Ring R] → Semiring R",
  "constCategory": "Definition"},
 {"references": ["Set", "outParam", "SetLike"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → [self : SetLike A B] → A → Set B",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.Affine",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "HarderNarasimhan.Affine.casesOn",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HarderNarasimhan.Affine.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} → Sort u → HarderNarasimhan.Affine μ → HarderNarasimhan.Affine μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "WellFounded.has_min",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "IsWellFounded.wf",
   "WellFoundedGT",
   "OrderBot.toBot",
   "HarderNarasimhan.impl.JHFil._proof_1",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nat.succ",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "setOf"],
  "name": "HarderNarasimhan.impl.JHFil._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hacc : WellFoundedGT ℒ] {S : Type}\n  (μ : { p // p.1 < p.2 } → S) (n : ℕ) (x : Nat.below n.succ),\n  {p | ∃ (h : ⊥ < p), p < x.1 ∧ μ ⟨(⊥, p), h⟩ = μ ⟨(⊥, ⊤), ⋯⟩}.Nonempty →\n    ∃ a ∈ {p | ∃ (h : ⊥ < p), p < x.1 ∧ μ ⟨(⊥, p), h⟩ = μ ⟨(⊥, ⊤), ⋯⟩},\n      ∀ x_1 ∈ {p | ∃ (h : ⊥ < p), p < x.1 ∧ μ ⟨(⊥, p), h⟩ = μ ⟨(⊥, ⊤), ⋯⟩}, ¬x_1 > a",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "HarderNarasimhan.WeakSlopeLike₂.rec",
   "Subtype.prop",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakSlopeLike₂.mk",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₂.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakSlopeLike₂ μ → Sort u} →\n                (t : HarderNarasimhan.WeakSlopeLike₂ μ) →\n                  ((wsl₂ :\n                        ∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n                          μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Lean.Omega.Int.add_le_zero_iff_le_neg'",
   "instDecidableAnd",
   "Bool",
   "Bool.decide_and",
   "Decidable",
   "Eq.trans",
   "Eq.mp",
   "Subsingleton.elim",
   "Lean.Omega.Coeffs",
   "Option.some",
   "Decidable.decide",
   "Int.eq_iff_le_and_ge",
   "congrArg",
   "Bool.and",
   "congr",
   "Int.instAdd",
   "Int.instLEInt",
   "Lean.Omega.Constraint.lowerBound",
   "instSubsingletonDecidable",
   "Eq.ndrec",
   "Eq.rec",
   "Eq",
   "Bool.true",
   "propext",
   "decide_eq_true_eq",
   "Lean.Omega.UpperBound.sat",
   "instHAdd",
   "Neg.neg",
   "And",
   "Lean.Omega.LowerBound.sat",
   "Lean.Omega.Int.add_nonnneg_iff_neg_le'",
   "OfNat.ofNat",
   "Int.instNegInt",
   "Int",
   "HAdd.hAdd",
   "instDecidableEqBool",
   "instOfNat",
   "Eq.refl",
   "LE.le",
   "id",
   "Bool.and_eq_true",
   "Lean.Omega.Constraint.mk",
   "Eq.mpr",
   "Int.decLe",
   "Lean.Omega.Coeffs.dot",
   "and_comm",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.addEquality_sat",
  "constType":
  "∀ {c : ℤ} {x y : Omega.Coeffs}, c + x.dot y = 0 → { lowerBound := some (-c), upperBound := some (-c) }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "_private.Init.PropLemmas.0._proof_25",
   "GT.gt",
   "Subtype.val",
   "_private.Mathlib.Data.Set.Operations.0._proof_5",
   "And.intro",
   "letFun",
   "funext",
   "Set.Nonempty.image",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "WellFounded",
   "Exists",
   "And.right",
   "And",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "lt_iff_le_not_le",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Set.image",
   "Iff.of_eq",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Subtype",
   "Eq.mp",
   "Prod.fst",
   "congrArg",
   "_private.Init.PropLemmas.0._proof_23",
   "WellFounded.wellFounded_iff_has_min",
   "_private.Init.Data.Subtype.0._proof_2",
   "IsWellFounded.wf",
   "WellFoundedGT",
   "HarderNarasimhan.Interval",
   "Set.mem_image_of_mem",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Set",
   "IsWellFounded.mk",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "Subtype.mk"],
  "name": "HarderNarasimhan.instWellFoundedGTInterval",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hw : WellFoundedGT ℒ]\n  {z : { p // p.1 < p.2 }}, WellFoundedGT (HarderNarasimhan.Interval z)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Preorder.toLT",
   "SMulZeroClass.toSMul",
   "Subtype.val",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "DistribSMul.toSMulZeroClass",
   "rfl",
   "SetLike.instMembership",
   "AddZeroClass.toZero",
   "Submodule.addCommGroup",
   "DistribMulAction.toDistribSMul",
   "Prod.snd",
   "LinearMap",
   "Ring.toSemiring",
   "Prod",
   "Nontrivial",
   "HSMul.hSMul",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "AddMonoid.toAddZeroClass",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "Prod.fst",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Eq",
   "Submodule.mkQ",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "CommRing",
   "LT.lt",
   "CommRing.toRing",
   "Module.toDistribMulAction",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.f2._proof_6",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }) (x : R)\n  (x_1 : ↥(↑I).2),\n  (Submodule.submoduleOf (↑I).1 (↑I).2).mkQ (x • x_1) = (Submodule.submoduleOf (↑I).1 (↑I).2).mkQ (x • x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "Nat.sub_eq_iff_eq_add.match_1",
   "congrArg",
   "Iff.intro",
   "Unit",
   "HAdd.hAdd",
   "Nat",
   "Nat.add_sub_cancel",
   "instSubNat",
   "Nat.sub_add_cancel",
   "Iff",
   "Eq.refl",
   "LE.le",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Eq",
   "instHSub",
   "instLENat"],
  "name": "Nat.sub_eq_iff_eq_add",
  "constType": "∀ {b a c : ℕ}, b ≤ a → (a - b = c ↔ a = c + b)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
   "Ideal.IsPrime",
   "Submodule.Quotient.module",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Classical.propDecidable",
   "HarderNarasimhan.HarderNarasimhanFiltration.fin_len",
   "Membership.mem.out",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "Semiring.toModule",
   "HarderNarasimhan.S",
   "HarderNarasimhan.Coprimary.coprimary",
   "And.left",
   "instLTNat",
   "LinearMap.ker",
   "Exists",
   "SetLike.instMembership",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_24",
   "Exists.choose_spec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Submodule.addCommGroup",
   "LinearMap",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.impl.piecewise_coprimary",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Set.instMembership",
   "Nat",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_20",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.toBoundedOrder",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "Submodule.hasQuotient",
   "Nat.find",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "ExistsUnique.exists",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.impl.prop3d11",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "CommRing.toCommSemiring",
   "instHAdd",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "IsAssociatedPrime._proof_1",
   "HarderNarasimhan.impl.prop3d13₂",
   "AddCommGroup",
   "IsAssociatedPrime",
   "CommRing",
   "Exists.choose",
   "HarderNarasimhan.impl.prop3d13₁",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.lt_of_succ_lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Submodule.completeLattice",
   "HarderNarasimhan.S₀",
   "Submodule.addCommMonoid",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_25",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (HNFil : HarderNarasimhan.HarderNarasimhanFiltration (HarderNarasimhan.μ R M)) (n : ℕ) (hn : n + 1 < Nat.find ⋯),\n  ⋯.choose.IsPrime",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Exists.intro",
   "Nat.instPreorder",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Eq.rec",
   "Eq",
   "Preorder.toLE",
   "HarderNarasimhan.impl.function_wrapper_prop0",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Exists.choose_spec",
   "BoundedOrder",
   "HarderNarasimhan.impl.function_wrapper",
   "Exists.choose",
   "Bot.bot",
   "OfNat.ofNat",
   "Exists.casesOn",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Antitone",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.function_wrapper_prop1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (f : ℕ → ℒ) (atf : ∃ k, f k = ⊥),\n  Antitone f → f 0 = ⊤ → ∃ N, HarderNarasimhan.impl.function_wrapper f atf N = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Or",
   "Iff",
   "And",
   "Classical.propDecidable",
   "Decidable.not_and_iff_not_or_not"],
  "name": "Classical.not_and_iff_not_or_not",
  "constType": "∀ {a b : Prop}, ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "instOfNatNat",
   "Iff",
   "LE.le",
   "Nat.pos_iff_ne_zero",
   "Ne",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Nat.one_le_iff_ne_zero",
  "constType": "∀ {n : ℕ}, 1 ≤ n ↔ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "And",
   "Preorder.toLT",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "HarderNarasimhan.Resμ._proof_19",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.Resμ",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        (z : { p // p.1 < p.2 }) → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "rel_iff_cov",
   "AddLeftReflectLT",
   "instHAdd",
   "Add",
   "Iff",
   "AddLeftStrictMono",
   "LT"],
  "name": "add_lt_add_iff_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α] [AddLeftStrictMono α] [AddLeftReflectLT α] (a : α) {b c : α},\n  a + b < a + c ↔ b < c",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "OrderBot.bot_le",
   "Lattice.toSemilatticeSup",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "SemilatticeSup.toPartialOrder",
   "Bot.bot",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "LE.le",
   "OrderBot.toBot",
   "HeytingAlgebra.toOrderBot",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "CompleteLattice.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "LinearOrder.toBiheytingAlgebra",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion._proof_41",
  "constType":
  "∀ {α : Type} [inst : LinearOrder α] (a : HarderNarasimhan.DedekindMacNeilleCompletion α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_2",
   "_obj",
   "Subtype.partialOrder",
   "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Exists", "And", "Eq", "propext", "exists_eq_right"],
  "name": "_private.Init.PropLemmas.0._proof_23",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "HarderNarasimhan.WeakAscendingChainCondition.mk",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HarderNarasimhan.WeakAscendingChainCondition.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n    HarderNarasimhan.WeakAscendingChainCondition μ",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
   "PartialOrder.toPreorder",
   "Submodule.instNontrivial",
   "Module",
   "HarderNarasimhan.μ",
   "HarderNarasimhan.HarderNarasimhanFiltration.first_eq_bot",
   "instOfNatNat",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.S",
   "HarderNarasimhan.impl.prop3d11",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "HarderNarasimhan.impl.prop3d13₂",
   "CommRing",
   "Bot.bot",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "OfNat.ofNat",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "HarderNarasimhan.impl.prop3d13₁",
   "Nat",
   "IsNoetherianRing",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "ConditionallyCompleteLattice.toLattice",
   "HarderNarasimhan.S₀",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_19",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (HNFil : HarderNarasimhan.HarderNarasimhanFiltration (HarderNarasimhan.μ R M)), HNFil.filtration 0 = ⊥",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "instLTNat", "Nat", "Nat.succ", "Nat.lt.base"],
  "name": "Nat.lt_succ_self",
  "constType": "∀ (n : ℕ), n < n.succ",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "Module",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "Nonempty",
   "CommRing",
   "IsNoetherianRing",
   "HarderNarasimhan.impl.instNonemptyCoprimaryFiltration",
   "HarderNarasimhan.CoprimaryFiltration",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "inferInstance",
   "Module.Finite"],
  "name": "HarderNarasimhan.theorem_3_15₁",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  Nonempty (HarderNarasimhan.CoprimaryFiltration R M)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "LinearOrder",
   "monotone_smul_left_of_nonneg",
   "OfNat.ofNat",
   "PosSMulMono",
   "LinearOrder.toPartialOrder",
   "instDistribLatticeOfLinearOrder",
   "SMul",
   "Preorder",
   "DistribLattice.toLattice",
   "PosSMulReflectLT",
   "HSMul.hSMul",
   "LE.le",
   "instHSMul",
   "Zero.toOfNat0",
   "Zero",
   "PosSMulReflectLT.mk",
   "Preorder.toLE",
   "Monotone.reflect_lt",
   "SemilatticeInf.toPartialOrder"],
  "name": "PosSMulMono.toPosSMulReflectLT",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : SMul α β] [inst_1 : Preorder α] [inst_2 : LinearOrder β] [inst_3 : Zero α]\n  [PosSMulMono α β], PosSMulReflectLT α β",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearExtension",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["Finset", "Multiset"],
  "name": "Finset.val",
  "constType": "{α : Type u_4} → Finset α → Multiset α",
  "constCategory": "Definition"},
 {"references": ["List.Chain", "List", "List.cons"],
  "name": "List.Chain.cons",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α}, R a b → List.Chain R b l → List.Chain R a (b :: l)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Set",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.NashEquilibrium.mk",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "HarderNarasimhan.WeakDescendingChainCondition.wdcc",
   "And.intro",
   "HarderNarasimhan.NashEquilibrium",
   "letFun",
   "HarderNarasimhan.μBstar",
   "CompleteSemilatticeInf.toPartialOrder",
   "funext",
   "Eq.symm",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Iff",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "HarderNarasimhan.WeakSlopeLike₂",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "lt_top_iff_ne_top",
   "setOf",
   "HarderNarasimhan.μAstar",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.TotIntvl._proof_1",
   "Iff.intro",
   "Prod.fst",
   "congrArg",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "InfSet.sInf",
   "HarderNarasimhan.WeakSlopeLike₂.wsl₂",
   "OrderBot.toBot",
   "bot_ne_top",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Not",
   "HarderNarasimhan.NashEquilibrium.nash_eq",
   "HarderNarasimhan.impl.prop4d3₁",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "exists_prop_congr",
   "sInf_le",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "HarderNarasimhan.μA",
   "LE.le",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.rmk4d10₃",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.WeakDescendingChainCondition μ →\n    HarderNarasimhan.WeakSlopeLike₂ μ →\n      (HarderNarasimhan.NashEquilibrium μ ↔\n        ∀ (y : ℒ) (hy : y ≠ ⊤), HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl ≤ HarderNarasimhan.μmax μ ⟨(y, ⊤), ⋯⟩)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "Ideal",
   "Ideal.IsPrime",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Submodule.instTop",
   "Top.top",
   "Ideal.IsPrime.ne_top'",
   "Ne",
   "Semiring.toModule",
   "Semiring"],
  "name": "Ideal.IsPrime.ne_top",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] {I : Ideal α}, I.IsPrime → I ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["IsLeast",
   "ConditionallyCompleteLattice.toInfSet",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "IsLeast.nonempty",
   "IsGLB.csInf_eq",
   "Set",
   "IsLeast.isGLB",
   "ConditionallyCompleteLattice",
   "InfSet.sInf",
   "ConditionallyCompleteLattice.toLattice",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder"],
  "name": "IsLeast.csInf_eq",
  "constType":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsLeast s a → sInf s = a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero",
   "instHAdd",
   "AddMonoid",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "MulAction.toSMul",
   "MulAction",
   "AddMonoid.toAddSemigroup",
   "HSMul.hSMul",
   "Monoid",
   "instHSMul",
   "Zero.toOfNat0",
   "Eq",
   "DistribMulAction",
   "AddSemigroup.toAdd",
   "AddMonoid.toAddZeroClass"],
  "name": "DistribMulAction.mk",
  "constType":
  "{M : Type u_12} →\n  {A : Type u_13} →\n    [inst : Monoid M] →\n      [inst_1 : AddMonoid A] →\n        [toMulAction : MulAction M A] →\n          (∀ (a : M), a • 0 = 0) → (∀ (a : M) (x y : A), a • (x + y) = a • x + a • y) → DistribMulAction M A",
  "constCategory": "Other"},
 {"references": ["Iff.of_eq", "Iff", "Eq"],
  "name": "Eq.to_iff",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "Max.max",
   "PartialOrder.toPreorder",
   "Iff",
   "eq_comm",
   "LE.le",
   "SemilatticeSup.toMax",
   "SemilatticeSup.toPartialOrder",
   "sup_eq_right",
   "SemilatticeSup",
   "Preorder.toLE",
   "Eq"],
  "name": "right_eq_sup",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b = a ⊔ b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["HPow", "outParam"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "HarderNarasimhan.WeakDescendingChainCondition.casesOn",
   "Prod.snd",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakDescendingChainCondition.noConfusionType",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.WeakDescendingChainCondition μ} →\n                  v1 = v2 → HarderNarasimhan.WeakDescendingChainCondition.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq.refl",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "CommSemiring",
   "Eq.symm",
   "instHMul",
   "HMul.hMul",
   "Eq.ndrec",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.mul_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' * b' = c → a * b = c",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Coe",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Function.Embedding",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Coe.mk",
   "HarderNarasimhan.coe'",
   "OrderEmbedding",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "Set.instCompleteAtomicBooleanAlgebra",
   "PartialOrder",
   "Preorder.toLE",
   "Subtype.le",
   "Set.instLE"],
  "name": "HarderNarasimhan.instCoeDedekindMacNeilleCompletion._cstage1",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → Coe α (HarderNarasimhan.DedekindMacNeilleCompletion α)",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Decidable",
   "True",
   "Eq.trans",
   "instDecidableTrue",
   "Eq.mpr_not",
   "True.intro",
   "Eq.mpr_prop",
   "congrArg",
   "dite_congr",
   "eq_self",
   "of_eq_true",
   "Eq.refl",
   "Eq",
   "dite"],
  "name": "dite_cond_eq_true",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} {t : c → α} {e : ¬c → α} (h : c = True), dite c t e = t ⋯",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Pow", "Monoid", "Monoid.npow", "Pow.mk"],
  "name": "Monoid.toNatPow",
  "constType": "{M : Type u_2} → [Monoid M] → Pow M ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "CompleteLattice.le_sInf",
   "CompleteSemilatticeInf.mk",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toPartialOrder",
   "CompleteLattice",
   "CompleteSemilatticeInf",
   "CompleteLattice.sInf_le"],
  "name": "CompleteLattice.toCompleteSemilatticeInf",
  "constType":
  "{α : Type u_8} → [self : CompleteLattice α] → CompleteSemilatticeInf α",
  "constCategory": "Definition"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{α : Type u_1} → [Sub α] → HSub α α α",
  "constCategory": "Definition"},
 {"references":
  ["HMul.hMul",
   "OfNat.ofNat",
   "SMul",
   "One.toOfNat1",
   "MulAction",
   "MulOneClass.toOne",
   "HSMul.hSMul",
   "Monoid.toMulOneClass",
   "Monoid",
   "instHSMul",
   "instHMul",
   "Eq",
   "MulOneClass.toMul"],
  "name": "MulAction.mk",
  "constType":
  "{α : Type u_9} →\n  {β : Type u_10} →\n    [inst : Monoid α] →\n      [toSMul : SMul α β] → (∀ (b : β), 1 • b = b) → (∀ (x y : α) (b : β), (x * y) • b = x • y • b) → MulAction α β",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Subtype.partialOrder",
   "_private.Init.PropLemmas.0._proof_25",
   "ClosureOperator",
   "Set.iUnion",
   "Subtype.val",
   "DFunLike.coe",
   "congrArg",
   "ClosureOperator.monotone",
   "ClosureOperator.instFunLike",
   "_private.Init.Data.Subtype.0._proof_2",
   "Subtype.property",
   "funext",
   "ClosureOperator.isClosed_closure",
   "Preorder.toLE",
   "Eq.rec",
   "Eq",
   "propext",
   "Exists",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_9",
   "Set",
   "_private.Init.PropLemmas.0._proof_38",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "And",
   "_private.Mathlib.Order.SetNotation.0._proof_3",
   "exists_prop_congr",
   "Set.instMembership",
   "Exists.casesOn",
   "Iff.of_eq",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "Iff.mpr",
   "LE.le",
   "id",
   "ClosureOperator.IsClosed.closure_eq",
   "Subtype.mk",
   "And.casesOn"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_11",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (𝒮 : Set T.Closeds) (A : T.Closeds),\n  (∀ b ∈ 𝒮, b ≤ A) → ∀ ⦃x : α⦄, x ∈ ↑⟨T (⋃ a ∈ 𝒮, ↑a), ⋯⟩ → x ∈ ↑A",
  "constCategory": "Theorem"},
 {"references": ["Subsingleton", "Nontrivial", "False", "not_nontrivial"],
  "name": "false_of_nontrivial_of_subsingleton",
  "constType": "∀ (α : Type u_3) [Nontrivial α] [Subsingleton α], False",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Eq.symm",
   "Int.instLEInt",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Bot.bot",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Bool",
   "Nat.cast",
   "Option.some",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "Int.instAdd",
   "OrderBot.toBot",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Option.none",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub"],
  "name": "HarderNarasimhan.JordanHolderFiltration._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (filtration : ℕ → ℒ),\n  (∃ N, filtration N = ⊥) → ∀ (i : ℕ), ¬i < i + 1 → False",
  "constCategory": "Theorem"},
 {"references":
  ["Set.inter_subset_right",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_5",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Inter.inter",
   "ClosureOperator",
   "Subtype.val",
   "DFunLike.coe",
   "Set.inter_subset_left",
   "ClosureOperator.monotone",
   "And.intro",
   "ClosureOperator.instFunLike",
   "Subtype.property",
   "Preorder.toLE",
   "Eq.rec",
   "Eq",
   "Set.instInter",
   "Set",
   "ClosureOperator.IsClosed",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "And.right",
   "ClosureOperator.isClosed_iff_closure_le",
   "Set.instMembership",
   "ClosureOperator.Closeds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "LE.le",
   "ClosureOperator.IsClosed.closure_eq",
   "Subtype.mk"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._proof_7",
  "constType":
  "∀ {α : Type} (T : ClosureOperator (Set α)) (A B : T.Closeds) ⦃a : α⦄, a ∈ ↑⟨↑A ∩ ↑B, ⋯⟩ → a ∈ ↑B",
  "constCategory": "Theorem"},
 {"references": ["Exists", "exists_and_right", "And", "Eq", "propext"],
  "name": "HarderNarasimhan.impl.test._proof_19",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, p x ∧ b) = ((∃ x, p x) ∧ b)",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "DFunLike.coe",
   "Equiv",
   "Prod.fst",
   "OrderDual.ofDual",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "OrderDual.instLT",
   "HarderNarasimhan.μBstar",
   "OrderDual.instCompleteLattice",
   "OrderDual.instPartialOrder",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "HarderNarasimhan.impl.dualμBstar_eq_μAstar",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "OrderDual.instBoundedOrder",
   "CompleteLattice"],
  "name": "HarderNarasimhan.dualμBstar_eq_μAstar",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  OrderDual.ofDual\n    ((HarderNarasimhan.μBstar fun p => OrderDual.toDual (μ ⟨((↑p).2, (↑p).1), ⋯⟩)) = HarderNarasimhan.μAstar μ)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "GeneralizedHeytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "OrderTop",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toLattice"],
  "name": "GeneralizedHeytingAlgebra.toOrderTop",
  "constType":
  "{α : Type u_4} → [self : GeneralizedHeytingAlgebra α] → OrderTop α",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Not",
   "instLTNat",
   "And.right",
   "Iff.mp",
   "And",
   "DecidablePred",
   "Nat.findGreatest",
   "Nat.findGreatest_eq_iff",
   "OfNat.ofNat",
   "LT.lt",
   "Nat",
   "instOfNatNat",
   "LE.le",
   "Ne",
   "Eq",
   "instLENat"],
  "name": "Nat.findGreatest_is_greatest",
  "constType":
  "∀ {k : ℕ} {P : ℕ → Prop} [inst : DecidablePred P] {n : ℕ}, Nat.findGreatest P n < k → k ≤ n → ¬P k",
  "constCategory": "Theorem"},
 {"references":
  ["Finset",
   "Set",
   "Set.toFinset",
   "Finset.instHasSubset",
   "Finset.toSet",
   "Iff.rfl",
   "Set.coe_toFinset",
   "Finset.coe_subset",
   "Fintype",
   "Set.Elem",
   "congrArg",
   "Set.instHasSubset",
   "HasSubset.Subset",
   "Iff",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Eq",
   "propext"],
  "name": "Set.subset_toFinset",
  "constType":
  "∀ {α : Type u_1} {t : Set α} {s : Finset α} [inst : Fintype ↑t], s ⊆ t.toFinset ↔ ↑s ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.rec",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddSemigroup.toAdd",
   "PosSMulStrictMono",
   "Real",
   "AddCommGroup.add_comm",
   "instHAdd",
   "LinearOrder",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.mk",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "AddMonoid.toAddSemigroup",
   "LE.le"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.casesOn",
  "constType":
  "{V : Type} →\n  {motive : HarderNarasimhan.TotallyOrderedRealVectorSpace V → Sort u} →\n    (t : HarderNarasimhan.TotallyOrderedRealVectorSpace V) →\n      ([toAddCommGroup : AddCommGroup V] →\n          [toModule : _root_.Module ℝ V] →\n            [toLinearOrder : LinearOrder V] →\n              [toPosSMulStrictMono : PosSMulStrictMono ℝ V] →\n                (elim_AddLeftMono : ∀ {y z : V} (x : V), y ≤ z → x + y ≤ x + z) →\n                  motive\n                    { toAddCommGroup := toAddCommGroup, toModule := toModule, toLinearOrder := toLinearOrder,\n                      toPosSMulStrictMono := toPosSMulStrictMono, elim_AddLeftMono := elim_AddLeftMono }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": ["rfl", "cast", "letFun", "HEq.rec", "HEq", "Eq"],
  "name": "eq_of_heq",
  "constType": "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bot",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.ConvexI",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.Convex",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Classical.propDecidable",
   "GT.gt",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Eq.symm",
   "Int.instLEInt",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "List.cons",
   "Bool.true",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lean.Omega.combo_sat'",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "Prod",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Lean.Omega.LinearCombo.instAdd",
   "Lean.Omega.Int.sub_congr",
   "Nat.find",
   "Nat.cast",
   "Bool",
   "Subtype",
   "HarderNarasimhan.impl.instμ_Admissible",
   "instDecidableAnd",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Lean.Omega.Constraint.combine_sat'",
   "HarderNarasimhan.impl.HNFil",
   "Option.some",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Prod.fst",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Int.instAdd",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "instNatCastInt",
   "of_decide_eq_true",
   "List.nil",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.sub_nonneg_of_le",
   "Int.ofNat_nonneg",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "CompletelyDistribLattice.toCompleteLattice",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Option.none",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "OrderTop.toTop",
   "instLENat"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_9",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HarderNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HarderNarasimhan.Convex μ) (f : ℕ → ℒ),\n  (∃ n, f n = ⊤) →\n    ∀ (n : ℕ) (h₂ : ∃ N ≥ n + 1, HarderNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n      Nat.find h₂ ≥ n + 1 → ¬Nat.find h₂ > 0 → False",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "bot_le",
   "Membership.mem.out",
   "GT.gt",
   "HarderNarasimhan.S₂I",
   "Subtype.val",
   "Set.Elem",
   "HarderNarasimhan.S₁I",
   "IsGreatest",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.impl.prop3d8₁'",
   "HarderNarasimhan.Convex",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HarderNarasimhan.impl.prop3d8₂",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "HarderNarasimhan.impl.prop3d8₁",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.St",
   "HarderNarasimhan.IsAttained",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.in_TotIntvl",
   "Or.inr",
   "HarderNarasimhan.StI",
   "Subtype",
   "lt_of_le_of_ne",
   "Prod.fst",
   "Or.inl",
   "WellFoundedGT",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Subtype.le",
   "Eq",
   "Lattice.toSemilatticeInf",
   "Set",
   "Exists.choose",
   "Or.casesOn",
   "LT.lt",
   "IsTotal",
   "HarderNarasimhan.μA",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.proposition_3_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Convex μ →\n    ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨ ∀ (z : ℒ) (hz : ⊥ ≠ z), HarderNarasimhan.IsAttained μ ⟨(⊥, z), ⋯⟩) →\n      ((IsTotal ↑(HarderNarasimhan.St μ) fun x1 x2 => x1 ≤ x2) ∧\n          (HarderNarasimhan.μA_DescendingChainCondition μ → ∃ s, IsGreatest (HarderNarasimhan.St μ) s)) ∧\n        ∀ (x : ℒ) (hxSt : x ∈ HarderNarasimhan.St μ) (y : ℒ) (hxy : y > x),\n          HarderNarasimhan.μA μ ⟨(⊥, y), ⋯⟩ = HarderNarasimhan.μA μ ⟨(x, y), hxy⟩",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "Nat",
   "PartialOrder",
   "inferInstance",
   "Nat.instLinearOrder"],
  "name": "Nat.instPartialOrder",
  "constType": "PartialOrder ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "bot_lt_iff_ne_bot",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "Preorder.toLT",
   "Ne",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "Bot.bot",
   "propext",
   "OrderBot"],
  "name": "HarderNarasimhan.impl.ss_iff'._proof_31",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, (⊥ < a) = (a ≠ ⊥)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "WellFoundedGT",
   "Preorder.toLE",
   "HarderNarasimhan.impl.ℒₛ._proof_1",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.impl.ℒₛ._proof_2",
   "CompleteLattice",
   "setOf"],
  "name": "HarderNarasimhan.impl.ℒₛ",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        [WellFoundedGT ℒ] →\n          {S : Type} →\n            [CompleteLattice S] →\n              ({ p // p.1 < p.2 } → S) →\n                (I : { p // p.1 < p.2 }) → (x : { p // HarderNarasimhan.InIntvl I p }) → (↑I).1 ≠ ↑x → Set ℒ",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup"],
  "name": "SemilatticeSup.sup",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubset",
   "Set.subset_iUnion₂",
   "HasSubset.Subset",
   "Set",
   "Membership.mem",
   "Set.iUnion",
   "Set.instMembership"],
  "name": "Set.subset_biUnion_of_mem",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {u : α → Set β} {x : α}, x ∈ s → u x ⊆ ⋃ x ∈ s, u x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "IsGreatest",
   "SupSet.sSup",
   "ConditionallyCompleteLattice",
   "ConditionallyCompleteLattice.toLattice",
   "ConditionallyCompleteLattice.toSupSet",
   "Preorder.toLE",
   "IsGreatest.isLUB",
   "Eq",
   "IsLUB.csSup_eq",
   "IsGreatest.nonempty",
   "SemilatticeInf.toPartialOrder"],
  "name": "IsGreatest.csSup_eq",
  "constType":
  "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsGreatest s a → sSup s = a",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "Or.rec",
   "Or",
   "HasSubset.Subset",
   "Set",
   "Membership.mem",
   "Set.instUnion",
   "Union.union",
   "Set.instMembership"],
  "name": "Set.union_subset",
  "constType": "∀ {α : Type u} {s t r : Set α}, s ⊆ r → t ⊆ r → s ∪ t ⊆ r",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "Exists",
   "Prod.mk",
   "HarderNarasimhan.IsAttained._proof_4",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.μmax",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.μA",
   "HarderNarasimhan.InIntvl",
   "PartialOrder",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice"],
  "name": "HarderNarasimhan.IsAttained",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Prop",
  "constCategory": "Definition"},
 {"references": ["semiOutParam"],
  "name": "CoeOut",
  "constType": "Sort u → semiOutParam (Sort v) → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references": ["Int.neg", "Neg", "Neg.mk", "Int"],
  "name": "Int.instNegInt",
  "constType": "Neg ℤ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "And",
   "Iff.intro",
   "LT.lt",
   "lt_iff_le_and_ne.match_1",
   "And.intro",
   "ne_of_lt",
   "le_of_lt",
   "Iff",
   "PartialOrder",
   "LE.le",
   "Ne",
   "Preorder.toLE"],
  "name": "lt_iff_le_and_ne",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a < b ↔ a ≤ b ∧ a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And.right",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instBoundedOrderInterval._proof_14",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }}\n  (a : HarderNarasimhan.Interval z), ↑a ≤ (↑z).2",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.rfl", "Eq.rec", "Eq"],
  "name": "Iff.of_eq",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "HarderNarasimhan.Semistable.casesOn",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.Semistable.noConfusionType",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              Sort u → HarderNarasimhan.Semistable μ → HarderNarasimhan.Semistable μ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "HarderNarasimhan.Affine.mk",
   "HarderNarasimhan.Affine",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "HarderNarasimhan.Affine.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (a b : ℒ) (h : ¬a ≤ b), μ ⟨(a ⊓ b, a), ⋯⟩ = μ ⟨(b, a ⊔ b), ⋯⟩) → HarderNarasimhan.Affine μ",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.WeakSlopeLike₁.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₁.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n    HarderNarasimhan.WeakSlopeLike₁ μ",
  "constCategory": "Definition"},
 {"references":
  ["Real",
   "Real.instIsOrderedAddMonoid",
   "NNReal",
   "Real.instZeroLEOneClass",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Real.instAddCommMonoid",
   "Nonneg.semiring",
   "Real.instIsOrderedRing",
   "IsOrderedRing.toPosMulMono",
   "Real.partialOrder",
   "Real.semiring",
   "Semiring"],
  "name": "instNNRealSemiring",
  "constType": "Semiring NNReal",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "Ideal",
   "Set",
   "Module",
   "CommSemiring.toSemiring",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "IsAssociatedPrime",
   "CommRing",
   "setOf"],
  "name": "associatedPrimes",
  "constType":
  "(R : Type u_1) → [inst : CommRing R] → (M : Type u_2) → [inst_1 : AddCommGroup M] → [_root_.Module R M] → Set (Ideal R)",
  "constCategory": "Definition"},
 {"references": ["LE.le", "LE", "GE.ge"],
  "name": "GE.ge.le",
  "constType": "∀ {α : Type u_2} [inst : LE α] {x y : α}, x ≥ y → y ≤ x",
  "constCategory": "Theorem"},
 {"references": ["Not", "False"],
  "name": "Aesop.BuiltinRules.not_intro",
  "constType": "∀ {P : Prop}, (P → False) → ¬P",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "CoeOut.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "CoeOut",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instCoeOutInterval._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → CoeOut (HarderNarasimhan.Interval z) ℒ",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "Equiv",
   "And.intro",
   "SupSet.sSup",
   "HarderNarasimhan.μBstar",
   "funext",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Set.ext",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "OrderDual.instBoundedOrder",
   "setOf",
   "HarderNarasimhan.μAstar",
   "OrderDual",
   "OrderDual.toDual",
   "Ne.symm",
   "Subtype",
   "OrderDual.instLattice",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "Iff.intro",
   "congrArg",
   "OrderDual.ofDual",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "HarderNarasimhan.μmin",
   "Subtype.prop",
   "OrderDual.instLT",
   "BoundedOrder.toOrderTop",
   "congr",
   "InfSet.sInf",
   "OrderDual.instCompleteLattice",
   "OrderDual.instPartialOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Not",
   "_private.Mathlib.Order.Synonym.0._proof_6",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "Set",
   "HarderNarasimhan.μmax._proof_2",
   "exists_prop_congr",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "ConditionallyCompleteLattice.toSupSet",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.impl.dualμAstar_eq_μBstar",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  OrderDual.ofDual\n    ((HarderNarasimhan.μAstar fun p => OrderDual.toDual (μ ⟨((↑p).2, (↑p).1), ⋯⟩)) = HarderNarasimhan.μBstar μ)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "mt",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLT",
   "Ne",
   "Eq",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "lt_of_le_of_ne",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "True",
   "List",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_0",
  "constType":
  "∀ {a0 : ℤ} {t : List ℤ}, (Omega.LinearCombo.coordinate 0).eval (Omega.Coeffs.ofList (a0 :: t)) = a0",
  "constCategory": "Theorem"},
 {"references": ["DFunLike", "outParam"],
  "name": "DFunLike.coe",
  "constType":
  "{F : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (α → Sort u_3)} → [self : DFunLike F α β] → F → (a : α) → β a",
  "constCategory": "Definition"},
 {"references": ["Not", "Classical.not_not", "Eq", "propext"],
  "name": "_private.Init.Classical.0._proof_7",
  "constType": "∀ {a : Prop}, (¬¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.NashEquilibrium.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.μBstar",
   "Nontrivial",
   "Lattice",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.NashEquilibrium.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.NashEquilibrium μ → Sort u} →\n                ((nash_eq : HarderNarasimhan.μAstar μ = HarderNarasimhan.μBstar μ) → motive ⋯) →\n                  (t : HarderNarasimhan.NashEquilibrium μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Eq.mp",
   "Iff.mp",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Subtype.val",
   "congrArg",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "letFun",
   "Eq.symm",
   "WellFoundedGT",
   "HarderNarasimhan.impl.prop3d4₀func_len",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.impl.prop3d4₀func",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "Nat.find_spec",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "HarderNarasimhan.impl.prop3d4₀func_fin_len",
   "Lattice",
   "Nontrivial",
   "False",
   "Ne",
   "lt_self_iff_false",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d4₀func_len_nonzero",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 })\n  (hμDCC : HarderNarasimhan.μA_DescendingChainCondition μ), HarderNarasimhan.impl.prop3d4₀func_len μ I hμDCC ≠ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subsingleton",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["LinearMap.range_eq_top",
   "IsNoetherian",
   "isNoetherian_pi'",
   "LinearMap.instFunLike",
   "Module",
   "LinearMap.range",
   "isNoetherian_of_isNoetherianRing_of_finite.match_1",
   "Pi.addCommMonoid",
   "Fin",
   "Fin.fintype",
   "DFunLike.coe",
   "Finite.of_fintype",
   "Submodule",
   "Pi.Function.module",
   "LinearMap.semilinearMapClass",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "Module.Finite.exists_fin'",
   "Eq",
   "Semiring.toModule",
   "Exists",
   "Submodule.instTop",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup",
   "LinearMap",
   "Function.Surjective",
   "RingHomSurjective.ids",
   "Ring.toSemiring",
   "Ring.toAddCommGroup",
   "Nat",
   "IsNoetherianRing",
   "Iff.mpr",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "isNoetherian_of_surjective",
   "Module.Finite",
   "Ring"],
  "name": "isNoetherian_of_isNoetherianRing_of_finite",
  "constType":
  "∀ (R : Type u_1) (M : Type u_2) [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]\n  [IsNoetherianRing R] [Module.Finite R M], IsNoetherian R M",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Finset.Insert.0._proof_1",
   "Finset",
   "True",
   "Eq.trans",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Set.toFinset",
   "Fintype",
   "Set.instSingletonSet",
   "Set.Elem",
   "Set.instMembership",
   "congrArg",
   "_private.Mathlib.Data.Fintype.Sets.0._proof_1",
   "Finset.instSingleton",
   "iff_self",
   "of_eq_true",
   "congr",
   "Iff",
   "Finset.instMembership",
   "_private.Mathlib.Data.Set.Insert.0._proof_14",
   "Eq",
   "Finset.ext"],
  "name": "Set.toFinset_singleton",
  "constType":
  "∀ {α : Type u_1} (a : α) [inst : Fintype ↑{a}], {a}.toFinset = {a}",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Exists.intro",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.toTop",
   "HarderNarasimhan.Convex",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.impl.prop3d2",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "OfNat.ofNat",
   "Exists.casesOn",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HarderNarasimhan.μA_DescendingChainCondition.mk",
   "Nat",
   "HarderNarasimhan.μA",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "HarderNarasimhan.in_TotIntvl",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.cor3d3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Convex μ →\n    (∀ (f : ℕ → ℒ) (h : ∀ (n : ℕ), f n > f (n + 1)), ∃ N, HarderNarasimhan.μA μ ⟨(f (N + 1), f N), ⋯⟩ = ⊤) →\n      HarderNarasimhan.μA_DescendingChainCondition μ",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Submodule.hasQuotient",
   "Subtype",
   "PartialOrder.toPreorder",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.Quotient.module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Membership.mem",
   "Preorder.toLT",
   "DFunLike.coe",
   "Subtype.val",
   "Submodule",
   "Prod.fst",
   "Submodule.Quotient.addCommGroup",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Eq",
   "rfl",
   "Submodule.mkQ",
   "CommRing.toCommSemiring",
   "SetLike.instMembership",
   "instHAdd",
   "Submodule.addCommGroup",
   "CommSemiring.toSemiring",
   "AddCommGroup",
   "Prod.snd",
   "LinearMap",
   "CommRing",
   "Ring.toSemiring",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "CommRing.toRing",
   "IsNoetherianRing",
   "AddCommMonoid.toAddCommSemigroup",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Submodule.submoduleOf",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.f2._proof_5",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 })\n  (x x_1 : ↥(↑I).2),\n  (Submodule.submoduleOf (↑I).1 (↑I).2).mkQ (x + x_1) = (Submodule.submoduleOf (↑I).1 (↑I).2).mkQ (x + x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "instHAdd",
   "AddCommGroup.toAddGroup",
   "AddMonoid.toAddSemigroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "AddSemigroup.toAdd"],
  "name": "AddCommGroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommGroup G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "HarderNarasimhan.impl.prop3d4₀func._proof_8",
   "Eq.trans",
   "Eq.mpr_not",
   "Classical.propDecidable",
   "eq_true",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Nat.sub_one_add_one",
   "Eq.symm",
   "Eq.ndrec",
   "HarderNarasimhan.impl.ℒₛ._proof_1",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "HarderNarasimhan.impl.prop3d4₀func_defprop3₀",
   "Exists",
   "Exists.choose_spec",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat.find_spec",
   "HarderNarasimhan.InIntvl",
   "HarderNarasimhan.impl.prop3d4₀func_fin_len",
   "eq_false",
   "Eq.refl",
   "Lattice",
   "Prod.fst",
   "instOfNatNat",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Set",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "dite_cond_eq_true",
   "HarderNarasimhan.μA",
   "Ne",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "instHSub",
   "HarderNarasimhan.impl.ℒₛ._proof_2",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "WellFounded.has_min",
   "Membership.mem",
   "Nat.sub_one_lt",
   "Preorder.toLT",
   "Iff.mp",
   "GT.gt",
   "And.intro",
   "PartialOrder",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "HarderNarasimhan.impl.prop3d4₀func._proof_4",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "of_eq_false",
   "HarderNarasimhan.impl.ℒₛ",
   "And.right",
   "And",
   "Nat",
   "Nontrivial",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "congrArg",
   "dite_congr",
   "HarderNarasimhan.impl.prop3d4₀func_len_nonzero",
   "Subtype.prop",
   "IsWellFounded.wf",
   "HarderNarasimhan.impl.prop3d4₀func_len",
   "dite_cond_eq_false",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "eq_of_le_of_not_lt",
   "instHAdd",
   "HarderNarasimhan.impl.prop3d4₀func",
   "Exists.choose",
   "Eq.mpr_prop",
   "LT.lt",
   "ne_of_lt",
   "instSubNat",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "lt_self_iff_false",
   "_private.Init.Core.0._proof_39",
   "HarderNarasimhan.impl.prop3d4₀func._proof_7"],
  "name": "HarderNarasimhan.impl.prop3d4₀func_defprop3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 })\n  (hμDCC : HarderNarasimhan.μA_DescendingChainCondition μ) (y : ℒ)\n  (hy :\n    (↑I).1 < y ∧ y ≤ ↑(HarderNarasimhan.impl.prop3d4₀func μ I (HarderNarasimhan.impl.prop3d4₀func_len μ I hμDCC - 1))),\n  ¬HarderNarasimhan.μA μ ⟨((↑I).1, y), ⋯⟩ >\n      HarderNarasimhan.μA μ\n        ⟨((↑I).1, ↑(HarderNarasimhan.impl.prop3d4₀func μ I (HarderNarasimhan.impl.prop3d4₀func_len μ I hμDCC - 1))), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "Singleton.singleton",
   "Membership.mem",
   "Iff.mp",
   "Exists.intro",
   "SMulZeroClass.toSMul",
   "Submodule.span",
   "Membership.mem.out",
   "And.intro",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "Semiring.toModule",
   "Submodule.annihilator",
   "DistribSMul.toSMulZeroClass",
   "And.left",
   "SetLike.instMembership",
   "LinearMap.ker",
   "Exists",
   "AddZeroClass.toZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "PrimeSpectrum.mk",
   "DistribMulAction.toDistribSMul",
   "LinearMap",
   "Set.instMembership",
   "Exists.casesOn",
   "Iff.mpr",
   "HSMul.hSMul",
   "AddCommGroup.toAddCommMonoid",
   "id",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "LinearMap.instFunLike",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "AddCommMonoid.toAddMonoid",
   "Submodule",
   "congrArg",
   "Ideal",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "PrimeSpectrum.asIdeal",
   "Eq",
   "Preorder.toLE",
   "CommRing.toCommSemiring",
   "Set",
   "Module.support",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring.toSemiring",
   "IsAssociatedPrime._proof_1",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "CommRing",
   "IsAssociatedPrime",
   "Set.instSingletonSet",
   "OfNat.ofNat",
   "PrimeSpectrum",
   "Module.toDistribMulAction",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Module.mem_support_iff_exists_annihilator",
   "Submodule.mem_annihilator_span_singleton",
   "And.casesOn"],
  "name": "HarderNarasimhan.impl.mem_support_of_mem_associatedPrimes",
  "constType":
  "∀ {R : Type} [inst : CommRing R] {M : Type} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] {x : Ideal R}\n  (hx : x ∈ associatedPrimes R M), { asIdeal := x, isPrime := ⋯ } ∈ Module.support R M",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "Unit.unit",
   "OfNat.ofNat",
   "Unit"],
  "name": "HarderNarasimhan.impl.JHFil.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "HarderNarasimhan.μA_DescendingChainCondition.mk",
   "Nat",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μA_DescendingChainCondition.mk._flat_ctor",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n      (∀ (n : ℕ), f n > f (n + 1)) →\n        ∃ N, HarderNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(a, f N), ⋯⟩) →\n    HarderNarasimhan.μA_DescendingChainCondition μ",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "HarderNarasimhan.SlopeLike",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Prod.fst",
   "Or",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "HarderNarasimhan.impl.rmk4d15",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.remark_4_15",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ →\n    ∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤),\n      μ ⟨(⊥, x), ⋯⟩ ≤ μ HarderNarasimhan.TotIntvl ∨ ¬μ HarderNarasimhan.TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instNNRealSemiring",
   "Real",
   "NNReal",
   "Semiring.toMonoidWithZero",
   "AddMonoid",
   "Real.semiring",
   "DistribMulAction.compHom",
   "RingHom.toMonoidHom",
   "Semiring.toNonAssocSemiring",
   "NNReal.toRealHom",
   "Real.instMonoid",
   "MonoidWithZero.toMonoid",
   "DistribMulAction"],
  "name": "NNReal.instDistribMulActionOfReal",
  "constType":
  "{M : Type u_1} → [inst : AddMonoid M] → [DistribMulAction ℝ M] → DistribMulAction NNReal M",
  "constCategory": "Definition"},
 {"references":
  ["RingHomSurjective.invPair",
   "RingHomSurjective.mk",
   "Semiring.toNonAssocSemiring",
   "RingHomSurjective",
   "RingHom.id",
   "RingHomInvPair.ids",
   "RingHomSurjective.is_surjective",
   "Semiring"],
  "name": "RingHomSurjective.ids",
  "constType":
  "∀ {R₁ : Type u_1} [inst : Semiring R₁], RingHomSurjective (RingHom.id R₁)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod",
   "LT.lt",
   "And.intro",
   "Subtype.prop",
   "le_of_lt",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.instBoundedOrderInterval._proof_13",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {z : { p // p.1 < p.2 }}, (↑z).1 ≤ (↑z).2 ∧ (↑z).2 ≤ (↑z).2",
  "constCategory": "Theorem"},
 {"references":
  ["associatedPrimes",
   "CommRing.toCommSemiring",
   "Module",
   "Set",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "AddCommGroup",
   "CommRing",
   "HarderNarasimhan.Coprimary.mk",
   "Set.instMembership",
   "IsNoetherianRing",
   "HarderNarasimhan.Coprimary",
   "Ideal",
   "AddCommGroup.toAddCommMonoid",
   "ExistsUnique"],
  "name": "HarderNarasimhan.Coprimary.rec",
  "constType":
  "{R : Type} →\n  [inst : CommRing R] →\n    [inst_1 : IsNoetherianRing R] →\n      {M : Type} →\n        [inst_2 : AddCommGroup M] →\n          [inst_3 : _root_.Module R M] →\n            {motive : HarderNarasimhan.Coprimary R M → Sort u} →\n              ((coprimary : ∃! p, p ∈ associatedPrimes R M) → motive ⋯) →\n                (t : HarderNarasimhan.Coprimary R M) → motive t",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "Module",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "HarderNarasimhan.impl.μ_nonempty",
   "Prod.fst",
   "PrimeSpectrum.isPrime",
   "Finset.min'",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "PrimeSpectrum.asIdeal",
   "HarderNarasimhan._μ",
   "CommRing.toCommSemiring",
   "LinearExtension",
   "CommSemiring.toSemiring",
   "Set.toFinset",
   "AddCommGroup",
   "Prod.snd",
   "CommRing",
   "LT.lt",
   "Prod",
   "PrimeSpectrum",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.f1._proof_4",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  ((HarderNarasimhan._μ R M I).toFinset.min' ⋯).asIdeal.IsPrime",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "absurd",
   "LT.lt",
   "Preorder",
   "lt_irrefl",
   "Preorder.toLT",
   "False",
   "Ne",
   "Eq.rec",
   "Eq"],
  "name": "ne_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Sub.mk", "Nat.sub", "Sub"],
  "name": "instSubNat",
  "constType": "Sub ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Iff.trans",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "And",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "SemilatticeInf",
   "le_antisymm_iff",
   "iff_self",
   "of_eq_true",
   "Min.min",
   "congr",
   "Iff",
   "Iff.mpr",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "_private.Mathlib.Order.Lattice.0._proof_18",
   "_private.Mathlib.Order.Lattice.0._proof_16",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_of_le_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ≤ b → a ⊓ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Finset",
   "Set.mem_toFinset",
   "Set",
   "Membership.mem",
   "Finset.instMembership",
   "Set.toFinset",
   "Eq",
   "Fintype",
   "propext",
   "Set.Elem",
   "Set.instMembership"],
  "name": "HarderNarasimhan.impl.associated_primes_quot_koqcl._proof_12",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, (a ∈ s.toFinset) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.WeakAscendingChainCondition.casesOn",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "BoundedOrder",
   "Prod.snd",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "Nat",
   "Lattice",
   "Nontrivial",
   "HarderNarasimhan.WeakAscendingChainCondition.noConfusionType",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "HarderNarasimhan.WeakAscendingChainCondition.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.WeakAscendingChainCondition μ} →\n                  v1 = v2 → HarderNarasimhan.WeakAscendingChainCondition.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Top", "LE", "OrderTop"],
  "name": "OrderTop.toTop",
  "constType": "{α : Type u} → {inst : LE α} → [self : OrderTop α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "PartialOrder.toPreorder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "Nat.cast_nonneg",
   "IsOrderedRing",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Semiring.toNonAssocSemiring",
   "MulZeroClass.toZero",
   "PartialOrder",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Preorder.toLE",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring"],
  "name": "Linarith.natCast_nonneg",
  "constType":
  "∀ (α : Type u) [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.coe_injective",
   "Subtype",
   "Iff",
   "Ne",
   "Function.Injective.ne_iff",
   "Subtype.val"],
  "name": "Subtype.coe_ne_coe",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, ↑a ≠ ↑b ↔ a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "IsWellFounded.wf",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "HarderNarasimhan.impl.ℒₛ",
   "And",
   "HarderNarasimhan.impl.prop3d4₀func",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d4₀func._proof_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ)\n  (hbot : ¬(↑I).1 = ↑(HarderNarasimhan.impl.prop3d4₀func μ I n)),\n  (HarderNarasimhan.impl.ℒₛ μ I (HarderNarasimhan.impl.prop3d4₀func μ I n) hbot).Nonempty →\n    ∃ a ∈ HarderNarasimhan.impl.ℒₛ μ I (HarderNarasimhan.impl.prop3d4₀func μ I n) hbot,\n      ∀ x ∈ HarderNarasimhan.impl.ℒₛ μ I (HarderNarasimhan.impl.prop3d4₀func μ I n) hbot, ¬x > a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "instHAdd", "Add", "LE.le", "LE", "CovariantClass"],
  "name": "AddLeftMono",
  "constType": "(M : Type u_1) → [Add M] → [LE M] → Prop",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.add", "Add", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "HarderNarasimhan.semistableI",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "HarderNarasimhan.S₂I",
   "HarderNarasimhan.S₁I",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "SupSet.sSup",
   "HarderNarasimhan.μBstar",
   "letFun",
   "HarderNarasimhan.S₁I._proof_1",
   "CompleteSemilatticeInf.toPartialOrder",
   "Subtype.coe_eta",
   "Eq.symm",
   "Eq.ndrec",
   "Exists",
   "Exists.choose_spec",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.in_TotIntvl",
   "setOf",
   "HarderNarasimhan.Semistable",
   "Ne.symm",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "HarderNarasimhan.impl.rmk4d10₀",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "_private.Mathlib.Order.Defs.LinearOrder.0._proof_1",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Set",
   "CompletelyDistribLattice.toCompleteLattice",
   "LinearOrder.toPartialOrder",
   "HarderNarasimhan.μA",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "bot_lt_top",
   "HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "sSup_le_sSup_of_forall_exists_le",
   "Membership.mem",
   "_private.Init.Core.0._proof_38",
   "Preorder.toLT",
   "Iff.mp",
   "GT.gt",
   "HarderNarasimhan.μmax",
   "And.intro",
   "sSup_le",
   "PartialOrder",
   "CompleteLinearOrder",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "sInf_le_sInf_of_forall_exists_le",
   "And.right",
   "And",
   "HarderNarasimhan.TotIntvl",
   "Bot.bot",
   "Exists.casesOn",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "HarderNarasimhan.μAstar",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "HarderNarasimhan.μmin",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Not",
   "HarderNarasimhan.impl.semistable_iff",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Prod.mk.eta",
   "Exists.choose",
   "HarderNarasimhan.μmax._proof_2",
   "LT.lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "_private.Init.Core.0._proof_39",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.prop4d18₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Semistable μ → HarderNarasimhan.μBstar μ ≤ HarderNarasimhan.μAstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "Subtype",
   "HEq.refl",
   "Subtype.noConfusion",
   "Eq.refl",
   "Eq.symm",
   "HEq",
   "Subtype.mk",
   "Eq.ndrec",
   "Eq",
   "Eq.casesOn"],
  "name": "Subtype.mk.injEq",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} (val : α) (property : p val) (val_1 : α) (property_1 : p val_1),\n  (⟨val, property⟩ = ⟨val_1, property_1⟩) = (val = val_1)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Lattice.toSemilatticeSup",
   "HarderNarasimhan.μA._proof_3",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.ConvexI",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Exists.intro",
   "sup_le",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "HarderNarasimhan.impl.lem2d4₂I",
   "HarderNarasimhan.InIntvl",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "inf_le_left",
   "ConditionallyCompleteLattice.toLattice",
   "setOf",
   "inf_le_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "Prod.fst",
   "le_inf",
   "InfSet.sInf",
   "HarderNarasimhan.impl.lem2d4₁",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_sInf_iff",
   "Set",
   "sInf_le",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "le_of_lt",
   "Min.min",
   "HarderNarasimhan.μA",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop2d6₁I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.ConvexI I μ →\n    ∀ (x : ℒ),\n      HarderNarasimhan.InIntvl I x →\n        ∀ (y : ℒ),\n          HarderNarasimhan.InIntvl I y →\n            ∀ (z : ℒ),\n              HarderNarasimhan.InIntvl I z →\n                ∀ (h : x < y ∧ y < z),\n                  HarderNarasimhan.μA μ ⟨(x, y), ⋯⟩ ⊓ HarderNarasimhan.μA μ ⟨(y, z), ⋯⟩ ≤\n                    HarderNarasimhan.μA μ ⟨(x, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.Name"],
  "name": "Lean.Name.str",
  "constType": "Name → String → Name",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "ite",
   "instHAdd",
   "DecidablePred",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "Nat.succ",
   "Nat.below",
   "Nat.findGreatest.match_1"],
  "name": "Nat.findGreatest",
  "constType": "(P : ℕ → Prop) → [DecidablePred P] → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["Union"],
  "name": "Union.union",
  "constType": "{α : Type u} → [self : Union α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["_obj", "LE.mk", "Preorder.mk", "LT.mk", "_neutral"],
  "name": "HarderNarasimhan.instLatticeInterval._rarg._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["LE", "BoundedOrder", "OrderTop", "OrderBot"],
  "name": "BoundedOrder.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toOrderTop : OrderTop α] → [toOrderBot : OrderBot α] → BoundedOrder α",
  "constCategory": "Other"},
 {"references":
  ["Quotient",
   "Setoid",
   "Setoid.r",
   "Quotient.mk",
   "Quot.out_eq",
   "Eq",
   "Quotient.out"],
  "name": "Quotient.out_eq",
  "constType": "∀ {α : Sort u_1} {s : Setoid α} (q : Quotient s), ⟦q.out⟧ = q",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasCompl",
   "BiheytingAlgebra.toHeytingAlgebra",
   "HasCompl.compl",
   "Set",
   "Inter.inter",
   "Set.instEmptyCollection",
   "EmptyCollection.emptyCollection",
   "Eq",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Set.instInter",
   "Set.instBooleanAlgebra",
   "inf_compl_eq_bot"],
  "name": "Set.inter_compl_self",
  "constType": "∀ {α : Type u} (s : Set α), s ∩ sᶜ = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["AddUnits",
   "AddZeroClass.toZero",
   "instHAdd",
   "And",
   "eq_zero_of_add_left",
   "AddCommMonoid.toAddMonoid",
   "add_zero",
   "OfNat.ofNat",
   "Iff.intro",
   "HAdd.hAdd",
   "And.intro",
   "AddCommMonoid",
   "Subsingleton",
   "AddZeroClass.toAdd",
   "Iff",
   "Eq.symm",
   "eq_zero_of_add_right",
   "Zero.toOfNat0",
   "Eq.ndrec",
   "Eq",
   "And.casesOn",
   "AddMonoid.toAddZeroClass"],
  "name": "add_eq_zero",
  "constType":
  "∀ {α : Type u} [inst : AddCommMonoid α] [Subsingleton (AddUnits α)] {a b : α}, a + b = 0 ↔ a = 0 ∧ b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["ConditionallyCompleteLattice", "ConditionallyCompleteLinearOrder"],
  "name": "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLinearOrder α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "associatedPrimes",
   "Module",
   "Set",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "AddCommGroup",
   "Iff.rfl",
   "IsAssociatedPrime",
   "CommRing",
   "Set.instMembership",
   "Ideal",
   "Iff",
   "AddCommGroup.toAddCommMonoid"],
  "name": "AssociatePrimes.mem_iff",
  "constType":
  "∀ {R : Type u_1} [inst : CommRing R] {I : Ideal R} {M : Type u_2} [inst_1 : AddCommGroup M]\n  [inst_2 : _root_.Module R M], I ∈ associatedPrimes R M ↔ IsAssociatedPrime I M",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "Sub"],
  "name": "SubNegMonoid.toSub",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Sub G",
  "constCategory": "Definition"},
 {"references":
  ["neg_add_cancel_right",
   "AddRightStrictMono",
   "congrArg",
   "sub_eq_add_neg",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "Eq.symm",
   "AddGroup.toSubNegMonoid",
   "AddGroup.covconv_swap",
   "Eq",
   "propext",
   "instHAdd",
   "add_lt_add_iff_right",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "Iff.rfl",
   "LT.lt",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddZeroClass.toAdd",
   "Iff",
   "id",
   "AddGroup",
   "Eq.mpr",
   "instHSub",
   "LT",
   "AddMonoid.toAddZeroClass"],
  "name": "sub_lt_iff_lt_add",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α] [AddRightStrictMono α] {a b c : α}, a - c < b ↔ a < b + c",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Submodule.Quotient.module",
   "Singleton.singleton",
   "Ideal.IsPrime.isPrimary",
   "Union.union",
   "Ideal.instHasQuotient_1",
   "PrimeSpectrum.isPrime",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "letFun",
   "associatedPrimes.eq_empty_of_subsingleton",
   "Set.instUnion",
   "Semiring.toModule",
   "_private.Mathlib.Data.Set.Finite.Basic.0._proof_41",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Ideal.Quotient.commRing",
   "LinearMap",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Ideal.radical",
   "NegZeroClass.toZero",
   "AddCommGroup.toAddCommMonoid",
   "RingHomInvPair.ids",
   "Set.Finite",
   "associatedPrimes",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CommRing.toNonUnitalCommRing",
   "LinearEquiv",
   "Set.instEmptyCollection",
   "EmptyCollection.emptyCollection",
   "SubNegZeroMonoid.toNegZeroClass",
   "DFunLike.coe",
   "congrArg",
   "Submodule.Quotient.addCommGroup",
   "Subsingleton",
   "associatedPrimes.eq_singleton_of_isPrimary",
   "Ideal",
   "Set.Finite.union",
   "PrimeSpectrum.asIdeal",
   "Eq",
   "IsNoetherianRing.induction_on_isQuotientEquivQuotientPrime",
   "LinearEquiv.AssociatedPrimes.eq",
   "Set.Finite.subset",
   "CommRing.toCommSemiring",
   "True",
   "Set",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "CommRing",
   "Set.instSingletonSet",
   "Function.Exact",
   "Function.Surjective",
   "PrimeSpectrum",
   "Ring.toAddCommGroup",
   "CommRing.toRing",
   "IsNoetherianRing",
   "_private.Mathlib.Data.Set.Finite.Basic.0._proof_42",
   "AddCommGroup.toDivisionAddCommMonoid",
   "of_eq_true",
   "associatedPrimes.subset_union_of_exact",
   "Function.Injective",
   "Module.Finite"],
  "name": "associatedPrimes.finite",
  "constType":
  "∀ (A : Type u) [inst : CommRing A] (M : Type v) [inst_1 : AddCommGroup M] [inst_2 : _root_.Module A M]\n  [IsNoetherianRing A] [Module.Finite A M], (associatedPrimes A M).Finite",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "Subtype",
   "SetLike.instMembership",
   "LinearMap.instFunLike",
   "SemilinearMapClass",
   "Module",
   "Submodule.module",
   "CommSemiring.toSemiring",
   "Membership.mem",
   "AddCommGroup",
   "LinearMap",
   "CommRing",
   "Submodule",
   "LinearMap.semilinearMapClass",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "Submodule.setLike",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.addCommMonoid"],
  "name": "HarderNarasimhan.impl.lift_quot._proof_15",
  "constType":
  "∀ {R : Type} [inst : CommRing R] {M : Type} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] (N₂ : Submodule R M),\n  SemilinearMapClass (↥N₂ →ₗ[R] M) (RingHom.id R) (↥N₂) M",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub",
   "Eq.trans",
   "Classical.propDecidable",
   "HarderNarasimhan.JordanHolderFiltration.filtration",
   "Exists.intro",
   "Subtype.val",
   "HarderNarasimhan.JordanHolderFiltration",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "BoundedOrder",
   "HarderNarasimhan.instLatticeInterval",
   "Prod.snd",
   "le_sup_left",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "Bool",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "Max.max",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "Nat.sub_le",
   "instHSub",
   "Lean.Omega.LinearCombo.coordinate_eval_5",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.Int.ofNat_le_of_le",
   "And.intro",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLinearOrder",
   "Eq.rec",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.JordanHolderFiltration.strict_anti",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Bot.bot",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "Nontrivial",
   "id",
   "Subtype",
   "Nat.cast",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.Interval",
   "OrderBot.toBot",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "HarderNarasimhan.JordanHolderFiltration.first_eq_top",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "le_top",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "SemilatticeSup.toMax",
   "LE.le",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "Subtype.mk",
   "HarderNarasimhan.JordanHolderFiltration.fin_len",
   "OrderTop.toTop",
   "instLENat"],
  "name": "HarderNarasimhan.impl.looooooooooooooooog_lemma._proof_13",
  "constType":
  "∀ (n : ℕ) (ℒ : Type) (ntl : Nontrivial ℒ) (l : Lattice ℒ) (bo : BoundedOrder ℒ) (wacc : WellFoundedGT ℒ) (S : Type)\n  (clo : CompleteLinearOrder S) (μ : { p // p.1 < p.2 } → S) (JHy JHx : HarderNarasimhan.JordanHolderFiltration μ)\n  (this : 0 < Nat.find ⋯ - 1),\n  (fun n => ⟨JHx.filtration (Nat.find ⋯ - 1) ⊔ JHy.filtration n, ⋯⟩) (Nat.find ⋯) = ⊥ →\n    ∀ (j : ℕ), ¬Nat.find ⋯ - 1 < Nat.find ⋯ → False",
  "constCategory": "Theorem"},
 {"references": ["Union", "Set", "Union.mk", "Set.union"],
  "name": "Set.instUnion",
  "constType": "{α : Type u} → Union (Set α)",
  "constCategory": "Definition"},
 {"references": ["Inter", "Set", "Set.inter", "Inter.mk"],
  "name": "Set.instInter",
  "constType": "{α : Type u} → Inter (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Int.instAddCommGroup",
   "AddCommGroup.toAddGroup",
   "AddGroup",
   "inferInstance",
   "Int"],
  "name": "Int.instAddGroup",
  "constType": "AddGroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Preorder",
   "Set",
   "Iff",
   "LE.le",
   "lowerBounds",
   "Membership.mem",
   "Iff.rfl",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "mem_lowerBounds",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, a ∈ lowerBounds s ↔ ∀ x ∈ s, a ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "HarderNarasimhan.μA",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μA_DescendingChainCondition.μ_dcc",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.μA_DescendingChainCondition μ]\n  (a : ℒ) (f : ℕ → ℒ) (h₁ : ∀ (n : ℕ), f n > a),\n  (∀ (n : ℕ), f n > f (n + 1)) → ∃ N, HarderNarasimhan.μA μ ⟨(a, f (N + 1)), ⋯⟩ ≤ HarderNarasimhan.μA μ ⟨(a, f N), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.impl.semistable_iff",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.semistableI",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Iff",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "HarderNarasimhan.Semistable",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.semistable_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.Semistable μ ↔ HarderNarasimhan.semistableI μ HarderNarasimhan.TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocCommRing.mk",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalNonAssocCommRing"],
  "name": "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
  "constType":
  "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalNonAssocCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "AddZeroClass.toZero",
   "Module",
   "Membership.mem",
   "DistribMulAction.toDistribSMul",
   "Semiring.toMonoidWithZero",
   "SMulZeroClass.toSMul",
   "AddCommMonoid.toAddMonoid",
   "Submodule",
   "Module.toDistribMulAction",
   "AddCommMonoid",
   "Submodule.setLike",
   "Submodule.smul_mem'",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "instHSMul",
   "DistribSMul.toSMulZeroClass",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.smul_mem",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : _root_.Module R M}\n  (p : Submodule R M) {x : M} (r : R), x ∈ p → r • x ∈ p",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "HarderNarasimhan.NashEquilibrium.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.NashEquilibrium.rec",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.μBstar",
   "Nontrivial",
   "Lattice",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.NashEquilibrium.casesOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.NashEquilibrium μ → Sort u} →\n                (t : HarderNarasimhan.NashEquilibrium μ) →\n                  ((nash_eq : HarderNarasimhan.μAstar μ = HarderNarasimhan.μBstar μ) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Preorder",
   "le_top",
   "LT.lt.trans_le",
   "LT.lt.ne",
   "Top.top",
   "Preorder.toLT",
   "OrderTop",
   "Ne",
   "Preorder.toLE",
   "OrderTop.toTop"],
  "name": "ne_top_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α] {a b : α}, a < b → a ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Exists",
   "Eq.trans",
   "True",
   "Set",
   "_private.Init.Classical.0._proof_13",
   "Membership.mem",
   "And",
   "_private.Init.Classical.0._proof_9",
   "Set.instMembership",
   "congrArg",
   "Set.instHasSubset",
   "HasSubset.Subset",
   "iff_self",
   "of_eq_true",
   "Iff",
   "funext"],
  "name": "Set.not_subset_iff_exists_mem_not_mem",
  "constType": "∀ {α : Type u_1} {s t : Set α}, ¬s ⊆ t ↔ ∃ x ∈ s, x ∉ t",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Iff.mp",
   "DecidablePred",
   "Nat.findGreatest",
   "Nat.findGreatest_eq_iff",
   "congrArg",
   "False.elim",
   "instOfNatNat",
   "Nat.findGreatest_eq_zero_iff",
   "Eq.symm",
   "Eq.ndrec",
   "Eq",
   "And.left",
   "Nat.casesAuxOn",
   "rfl",
   "Not",
   "instLTNat",
   "instHAdd",
   "And.right",
   "And",
   "Nat.zero_lt_succ",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "Nat.succ",
   "Eq.refl",
   "LE.le",
   "id",
   "instDecidableEqNat",
   "Ne",
   "Eq.mpr",
   "dite",
   "instLENat"],
  "name": "Nat.findGreatest_spec",
  "constType":
  "∀ {m : ℕ} {P : ℕ → Prop} [inst : DecidablePred P] {n : ℕ}, m ≤ n → P m → P (Nat.findGreatest P n)",
  "constCategory": "Theorem"},
 {"references":
  ["ClosureOperator.isClosed_iff",
   "ClosureOperator.le_closure",
   "PartialOrder.toPreorder",
   "ClosureOperator.IsClosed",
   "ClosureOperator.toOrderHom",
   "ClosureOperator",
   "DFunLike.coe",
   "Iff.intro",
   "ClosureOperator.instFunLike",
   "OrderHom.toFun",
   "Iff",
   "PartialOrder",
   "Iff.mpr",
   "LE.le",
   "LE.le.antisymm",
   "ClosureOperator.IsClosed.closure_eq",
   "Preorder.toLE",
   "Eq",
   "Eq.le"],
  "name": "ClosureOperator.isClosed_iff_closure_le",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {c : ClosureOperator α} {x : α}, c.IsClosed x ↔ c x ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "Eq.trans",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "Lean.Omega.combo_sat'",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Prod",
   "instOfNat",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Or.elim",
   "Nat.find",
   "HarderNarasimhan.impl.instμ_Admissible",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Prod.fst",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "instOfNatNat",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "Option.none",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "instHSub",
   "PartialOrder.toPreorder",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Preorder.toLT",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GT.gt",
   "GE.ge",
   "HSub.hSub",
   "Int.instLEInt",
   "Lean.Omega.LinearCombo.add_eval",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "And.right",
   "And",
   "Lean.Omega.Constraint.addInequality_sat",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "Nontrivial",
   "Nat.lt_of_not_le",
   "id",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.cast",
   "instDecidableAnd",
   "Subtype",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "HarderNarasimhan.impl.HNFil",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "instSubNat",
   "LE.le",
   "False",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.LinearCombo.eval",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_11",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HarderNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HarderNarasimhan.Convex μ) (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (n : ℕ)\n  (h₂ : ∃ N ≥ n + 1, HarderNarasimhan.impl.HNFil μ (n + 1) ≤ f N),\n  Nat.find h₂ > 0 → Nat.find h₂ - 1 < Nat.find hffin → ¬Nat.find h₂ ≤ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "DivInvMonoid.toZPow",
   "GroupWithZero.toDivInvMonoid",
   "Subtype.val",
   "instDistribLatticeOfLinearOrder",
   "Semiring.toNonAssocSemiring",
   "Pow",
   "Zero.toOfNat0",
   "Semifield.toDivisionSemiring",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "Lattice.toSemilatticeInf",
   "IsStrictOrderedRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrder",
   "DivisionSemiring.toGroupWithZero",
   "DivisionSemiring.toSemiring",
   "HPow.hPow",
   "Nonneg.zpow._proof_5",
   "OfNat.ofNat",
   "Int",
   "DistribLattice.toLattice",
   "MulZeroClass.toZero",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semifield",
   "Subtype.mk",
   "Pow.mk"],
  "name": "Nonneg.zpow",
  "constType":
  "{α : Type u_1} → [inst : Semifield α] → [inst_1 : LinearOrder α] → [IsStrictOrderedRing α] → Pow { x // 0 ≤ x } ℤ",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Submodule.toAddSubmonoid",
   "SemilinearMapClass",
   "Module",
   "Submodule.comap._proof_12",
   "AddCommMonoid.toAddMonoid",
   "DFunLike.coe",
   "Submodule",
   "AddSubsemigroup.mk",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.comap._proof_10",
   "Submodule.map._proof_1",
   "FunLike",
   "Set.preimage",
   "Submodule.comap._proof_11",
   "AddSubmonoid.mk",
   "AddSubmonoid.comap",
   "SetLike.coe",
   "AddZeroClass.toAdd",
   "AddSubmonoid",
   "Submodule.mk",
   "Submodule.setLike",
   "AddMonoid.toAddZeroClass",
   "Semiring"],
  "name": "Submodule.comap",
  "constType":
  "{R : Type u_1} →\n  {R₂ : Type u_3} →\n    {M : Type u_5} →\n      {M₂ : Type u_7} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₂] →\n                [inst_4 : _root_.Module R M] →\n                  [inst_5 : _root_.Module R₂ M₂] →\n                    {σ₁₂ : R →+* R₂} →\n                      {F : Type u_9} →\n                        [inst_6 : FunLike F M M₂] →\n                          [SemilinearMapClass F σ₁₂ M M₂] → F → Submodule R₂ M₂ → Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "instSizeOfDefault",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "SizeOf",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "HarderNarasimhan.HarderNarasimhanFiltration.rec",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "SizeOf.sizeOf",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration._sizeOf_1",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {inst_3 : WellFoundedGT ℒ} →\n          {S : Type} →\n            {inst_4 : CompleteLattice S} →\n              {μ : { p // p.1 < p.2 } → S} →\n                {hμ : HarderNarasimhan.μA_DescendingChainCondition μ} →\n                  {hμcvx : HarderNarasimhan.Convex μ} →\n                    {h : HarderNarasimhan.μ_Admissible μ} →\n                      [SizeOf ℒ] → [SizeOf S] → HarderNarasimhan.HarderNarasimhanFiltration μ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition.μ_dcc",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "HarderNarasimhan.impl.prop3d4₀func_defprop1",
   "BoundedOrder",
   "HarderNarasimhan.impl.prop3d4₀func_strict_decreasing",
   "HarderNarasimhan.impl.prop3d4₀func_helper",
   "Prod.snd",
   "Exists.casesOn",
   "Prod",
   "Nat",
   "HarderNarasimhan.InIntvl",
   "Ne.lt_of_le",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "gt_iff_lt",
   "Subtype",
   "Ne.symm",
   "Eq.mp",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "Subtype.prop",
   "instOfNatNat",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "instHAdd",
   "HarderNarasimhan.impl.prop3d4₀func",
   "OfNat.ofNat",
   "not_le_of_gt",
   "LT.lt",
   "HAdd.hAdd",
   "HarderNarasimhan.μA",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.prop3d4₀func_fin_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  HarderNarasimhan.μA_DescendingChainCondition μ → ∃ i, ↑(HarderNarasimhan.impl.prop3d4₀func μ I i) = (↑I).1",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "RingHomInvPair.mk",
   "RingHomInvPair",
   "RingHom.comp",
   "Semiring"],
  "name": "RingHomInvPair.ids",
  "constType":
  "∀ {R₁ : Type u_1} [inst : Semiring R₁], RingHomInvPair (RingHom.id R₁) (RingHom.id R₁)",
  "constCategory": "Theorem"},
 {"references":
  ["Module",
   "Set",
   "Submodule.instMin._proof_24",
   "Inter.inter",
   "AddSubmonoid.mk",
   "Min",
   "Submodule.instMin._proof_23",
   "AddCommMonoid.toAddMonoid",
   "Min.mk",
   "Submodule",
   "Submodule.instMin._proof_25",
   "AddSubsemigroup.mk",
   "AddCommMonoid",
   "SetLike.coe",
   "AddZeroClass.toAdd",
   "Submodule.setLike",
   "Submodule.mk",
   "Set.instInter",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Submodule.instMin",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : _root_.Module R M] → Min (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["DivInvMonoid.toInv",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "GroupWithZero.toDivInvMonoid",
   "MulZeroClass.toMul",
   "Preorder.toLT",
   "HMul.hMul",
   "MonoidWithZero.toMulZeroOneClass",
   "CommGroupWithZero.toDivisionCommMonoid",
   "Subtype.val",
   "mul_inv_cancel_right₀",
   "not_false_eq_true",
   "LinearOrderedCommMonoidWithZero.toCommMonoidWithZero",
   "SemilatticeInf.toPartialOrder",
   "InvOneClass.toInv",
   "covariant_swap_mul_of_covariant_mul",
   "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
   "CommMonoidWithZero.toCommMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "eq_false",
   "id",
   "instHMul",
   "IsOrderedMonoid.toMulLeftMono",
   "CommGroupWithZero.toGroupWithZero",
   "DivisionMonoid.toDivInvOneMonoid",
   "ContravariantClass.mk",
   "Subtype",
   "Eq.mp",
   "LinearOrderedCommMonoidWithZero.toLinearOrder",
   "congrArg",
   "instDistribLatticeOfLinearOrder",
   "LT.lt.ne'",
   "congr",
   "GroupWithZero.toMonoidWithZero",
   "Subtype.property",
   "MulPosReflectLE",
   "mul_le_mul_right'",
   "Zero.toOfNat0",
   "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
   "LinearOrderedCommGroupWithZero",
   "Preorder.toLE",
   "Eq",
   "DivisionCommMonoid.toDivisionMonoid",
   "Not",
   "Inv.inv",
   "Lattice.toSemilatticeInf",
   "LinearOrderedCommMonoidWithZero.toIsOrderedMonoid",
   "True",
   "OfNat.ofNat",
   "LT.lt",
   "DistribLattice.toLattice",
   "DivInvOneMonoid.toInvOneClass",
   "of_eq_true",
   "MulZeroClass.toZero",
   "CommMonoid.toCommSemigroup",
   "LE.le",
   "False",
   "MulPosReflectLE.mk"],
  "name": "LinearOrderedCommGroupWithZero.toMulPosReflectLE",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedCommGroupWithZero α], MulPosReflectLE α",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "HarderNarasimhan.instBoundedOrderInterval._rarg", "_neutral"],
  "name": "HarderNarasimhan.instBoundedOrderInterval._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["Not", "Classical.not_imp", "And", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_implies_eq",
  "constType": "∀ (p q : Prop), (¬(p → q)) = (p ∧ ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
   "Nat.cast",
   "True",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.cast",
   "congrArg",
   "Int",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Ring.toAddGroupWithOne",
   "of_eq_true",
   "Mathlib.Meta.NormNum.IsInt",
   "AddGroupWithOne.toIntCast",
   "Int.cast_natCast",
   "Int.ofNat",
   "Eq",
   "Mathlib.Meta.NormNum.IsNat",
   "instNatCastInt",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsNat a n → Mathlib.Meta.NormNum.IsInt a (Int.ofNat n)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Prod.mk",
   "Singleton.singleton",
   "Membership.mem",
   "HarderNarasimhan.μ",
   "Iff.mp",
   "Preorder.toLT",
   "List.tfae_of_cycle",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "HarderNarasimhan.impl.rmk4d14₁",
   "Finset.min'",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "letFun",
   "List.TFAE",
   "PrimeSpectrum.instPartialOrder",
   "HarderNarasimhan.S",
   "List.cons",
   "ClosureOperator.IsClosed",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "HarderNarasimhan.μ_nonempty",
   "Finset.instSingleton",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff.mpr",
   "Iff",
   "Nontrivial",
   "Submodule.instBot",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.toBoundedOrder",
   "HarderNarasimhan.Semistable",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "RelEmbedding.toEmbedding",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "Function.Embedding.toFun",
   "HarderNarasimhan.impl.rmk4d14₂",
   "Prod.fst",
   "Ideal",
   "HarderNarasimhan._μ",
   "Eq",
   "Preorder.toLE",
   "Subtype.le",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Set.instLE",
   "List.nil",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "CommRing.toCommSemiring",
   "LinearExtension",
   "List.Chain.cons",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Submodule.instTop",
   "CommSemiring.toSemiring",
   "Set.toFinset",
   "List.Chain.nil",
   "AddCommGroup",
   "CommRing",
   "PrimeSpectrum",
   "LT.lt",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.μA",
   "LE.le",
   "Submodule.completeLattice",
   "ExistsUnique",
   "HarderNarasimhan.S₀",
   "Subtype.mk",
   "bot_lt_top",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.remark_3_14",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M],\n  [HarderNarasimhan.Semistable (HarderNarasimhan.μ R M),\n      ∀ (N : HarderNarasimhan.ℒ R M) (hN : ⊥ < N),\n        HarderNarasimhan.μA (HarderNarasimhan.μ R M) ⟨(⊥, N), hN⟩ =\n          HarderNarasimhan.coe'.toFun {(HarderNarasimhan._μ R M ⟨(⊥, ⊤), ⋯⟩).toFinset.min' ⋯},\n      ∃! p, p ∈ associatedPrimes R M].TFAE",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.SlopeLike",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "HarderNarasimhan.NashEquilibrium.mk",
   "Preorder.toLT",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "And.intro",
   "Or",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.WeakAscendingChainCondition.wacc",
   "HarderNarasimhan.μBstar",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.TotIntvl",
   "HarderNarasimhan.impl.prop4d1₂",
   "Bot.bot",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.WeakSlopeLike₂.mk",
   "Iff",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "HarderNarasimhan.μAstar",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "HarderNarasimhan.WeakSlopeLike₁.mk",
   "Subtype",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Prod.fst",
   "Iff.intro",
   "eq_of_le_of_le",
   "Subtype.prop",
   "HarderNarasimhan.μmin",
   "Or.inl",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.impl.prop4d11₂",
   "HarderNarasimhan.NashEquilibrium.nash_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "LT.lt",
   "Or.casesOn",
   "le_of_lt",
   "LE.le",
   "HarderNarasimhan.impl.prop4d11₁",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Eq.le",
   "OrderTop.toTop",
   "CompleteLattice",
   "HarderNarasimhan.SlopeLike.slopelike"],
  "name": "HarderNarasimhan.impl.prop4d16₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.SlopeLike μ →\n    HarderNarasimhan.WeakAscendingChainCondition μ →\n      HarderNarasimhan.WeakDescendingChainCondition μ →\n        (HarderNarasimhan.μmin μ HarderNarasimhan.TotIntvl = HarderNarasimhan.μmax μ HarderNarasimhan.TotIntvl ↔\n          HarderNarasimhan.NashEquilibrium μ)",
  "constCategory": "Theorem"},
 {"references": ["SubtractionMonoid", "SubtractionCommMonoid"],
  "name": "SubtractionCommMonoid.toSubtractionMonoid",
  "constType":
  "{G : Type u} → [self : SubtractionCommMonoid G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "GaloisConnection.lowerAdjoint",
   "OrderDual",
   "OrderDual.toDual",
   "PartialOrder.toPreorder",
   "Subtype",
   "LowerAdjoint.toFun",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "DFunLike.coe",
   "Equiv",
   "OrderDual.ofDual",
   "HarderNarasimhan.DedekindMacNeilleConnection",
   "PartialOrder",
   "Subtype.le",
   "Eq",
   "Preorder.toLE",
   "Set.instLE",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Function.Embedding.mk",
   "RelEmbedding.mk",
   "Equiv.instFunLike",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "Function.Embedding",
   "OrderEmbedding",
   "Set.Iic",
   "OrderDual.instPreorder",
   "lcProof",
   "upperBounds",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Iff",
   "LE.le",
   "lowerBounds",
   "Subtype.mk"],
  "name": "HarderNarasimhan.coe'._cstage1",
  "constType":
  "{α : Type} → [inst : PartialOrder α] → α ↪o HarderNarasimhan.DedekindMacNeilleCompletion α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Or.inr",
   "Nat",
   "False.elim",
   "Or.inl",
   "Or",
   "Nat.lt_or_gt_of_ne.match_1",
   "Nat.lt_trichotomy",
   "Ne",
   "GT.gt",
   "Eq"],
  "name": "Nat.lt_or_gt_of_ne",
  "constType": "∀ {a b : ℕ}, a ≠ b → a < b ∨ a > b",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "OrderDual", "Equiv"],
  "name": "OrderDual.ofDual",
  "constType": "{α : Type u_1} → αᵒᵈ ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["MulAction.toSMul",
   "MulActionWithZero",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "instHSMul",
   "Zero.toOfNat0",
   "Zero",
   "Eq",
   "OfNat.ofNat",
   "MonoidWithZero",
   "MulActionWithZero.toMulAction"],
  "name": "MulActionWithZero.smul_zero",
  "constType":
  "∀ {M₀ : Type u_2} {A : Type u_7} {inst : MonoidWithZero M₀} {inst_1 : Zero A} [self : MulActionWithZero M₀ A] (r : M₀),\n  r • 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "Membership.mem",
   "Exists.intro",
   "Equiv",
   "And.intro",
   "Semiring.toNonAssocSemiring",
   "Ideal.sInf_isPrime_of_isChain",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Maximal.le_of_ge",
   "Semiring.toModule",
   "And.left",
   "Exists",
   "And.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And",
   "Set.instMembership",
   "Exists.casesOn",
   "OrderDual.instPreorder",
   "Maximal",
   "HasSubset.Subset",
   "id",
   "Eq.mpr",
   "setOf",
   "IsChain",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "OrderDual",
   "OrderDual.toDual",
   "Submodule.instInfSet",
   "CommSemiring",
   "OmegaCompletePartialOrder.toPartialOrder",
   "DFunLike.coe",
   "OrderDual.ofDual",
   "congrArg",
   "Ideal",
   "Ideal.minimalPrimes",
   "InfSet.sInf",
   "Maximal.prop",
   "zorn_le_nonempty₀",
   "OrderDual.instLE",
   "Preorder.toLE",
   "Eq",
   "propext",
   "le_sInf_iff",
   "IsChain.symm",
   "Equiv.instFunLike",
   "Set",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OrderDual.le_toDual",
   "sInf_le",
   "CompleteSemilatticeInf.toInfSet",
   "Set.instHasSubset",
   "LE.le",
   "Submodule.completeLattice",
   "inferInstance",
   "OrderDual.ofDual_toDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "And.casesOn"],
  "name": "Ideal.exists_minimalPrimes_le",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {I J : Ideal R} [J.IsPrime], I ≤ J → ∃ p ∈ I.minimalPrimes, p ≤ J",
  "constCategory": "Theorem"},
 {"references":
  ["ClosureOperator.isClosed_iff",
   "ClosureOperator.instFunLike",
   "OrderHom.toFun",
   "PartialOrder.toPreorder",
   "ClosureOperator.IsClosed",
   "Iff.mpr",
   "PartialOrder",
   "ClosureOperator.toOrderHom",
   "ClosureOperator",
   "Eq",
   "ClosureOperator.idempotent",
   "DFunLike.coe"],
  "name": "ClosureOperator.isClosed_closure",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] (c : ClosureOperator α) (x : α), c.IsClosed (c x)",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "eq_true",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.AtLeastTwo",
   "PartialOrder",
   "Nat.one_lt_ofNat",
   "CharZero",
   "Preorder.toLE",
   "Eq",
   "AddMonoidWithOne",
   "AddSemigroup.toAdd",
   "AddZeroClass.toZero",
   "True",
   "instOfNatAtLeastTwo",
   "OfNat.ofNat",
   "ZeroLEOneClass",
   "LT.lt",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "AddMonoid.toAddSemigroup",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddZeroClass"],
  "name": "_private.Mathlib.Data.Nat.Cast.Order.Basic.0._proof_15",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [AddLeftMono α] [ZeroLEOneClass α] [CharZero α]\n  {n : ℕ} [inst_5 : n.AtLeastTwo], (1 < OfNat.ofNat n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Iff",
   "Set.subset_empty_iff",
   "Membership.mem",
   "Eq",
   "Set.instEmptyCollection",
   "EmptyCollection.emptyCollection",
   "Iff.symm",
   "Set.instMembership"],
  "name": "Set.eq_empty_iff_forall_not_mem",
  "constType": "∀ {α : Type u} {s : Set α}, s = ∅ ↔ ∀ (x : α), x ∉ s",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "bot_le",
   "Subtype.val",
   "Equiv",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instTop",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OrderDual.instOrderTop",
   "Nat.lt_add_one",
   "Prod",
   "Exists.casesOn",
   "Nat",
   "OrderDual.instPreorder",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.impl.fine",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "HarderNarasimhan.impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "StrictMono",
   "OrderDual",
   "Subtype",
   "Eq.mp",
   "DFunLike.coe",
   "congrArg",
   "Nat.instPreorder",
   "Prod.fst",
   "OrderDual.ofDual",
   "Subtype.prop",
   "instOfNatNat",
   "OrderDual.instLT",
   "OrderBot.toBot",
   "OrderDual.instLE",
   "Eq",
   "Preorder.toLE",
   "le_top",
   "Lattice.toSemilatticeInf",
   "OrderDual.ofDual_le_ofDual",
   "Equiv.instFunLike",
   "instHAdd",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.h₁_dual_of_h₁",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    ∀ (x : ℕ → ℒᵒᵈ) (smf : StrictMono x),\n      ∃ N, (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨(x N, x (N + 1)), ⋯⟩ ≤ (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨(x N, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Top", "LE.le", "Top.top", "LE", "OrderTop"],
  "name": "OrderTop.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toTop : Top α] → (∀ (a : α), a ≤ ⊤) → OrderTop α",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "HarderNarasimhan.Interval",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "HarderNarasimhan.instCoeForallSubtypeProdLtFstSndForallIntervalOfCompleteLattice._cstage1",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {z : { p // p.1 < p.2 }} →\n          {S : Type} → [CompleteLattice S] → Coe ({ p // p.1 < p.2 } → S) ({ p // p.1 < p.2 } → S)",
  "constCategory": "Definition"},
 {"references": ["Add", "Distrib"],
  "name": "Distrib.toAdd",
  "constType": "{R : Type u_1} → [self : Distrib R] → Add R",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "HarderNarasimhan.WeakDescendingChainCondition",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    HarderNarasimhan.WeakDescendingChainCondition μ",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Ring.toNonAssocRing",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "PartialOrder",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "Zero.toOfNat0",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsOrderedAddMonoid.toAddLeftMono",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "IsOrderedRing",
   "AddGroupWithOne.toAddGroup",
   "AddCommMonoid.toAddCommSemigroup",
   "sub_nonpos_of_le",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "covariant_swap_add_of_covariant_add",
   "instHSub",
   "Ring"],
  "name": "Linarith.sub_nonpos_of_le",
  "constType":
  "∀ {α : Type u} [inst : Ring α] [inst_1 : PartialOrder α] [IsOrderedRing α] {a b : α}, a ≤ b → a - b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "Module",
   "AddCommGroup.toAddGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddSemigroup.toAdd",
   "PosSMulStrictMono",
   "Real",
   "AddCommGroup.add_comm",
   "instHAdd",
   "LinearOrder",
   "AddCommMonoid.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup",
   "Real.semiring",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "Module.toDistribMulAction",
   "SubNegMonoid.toAddMonoid",
   "Real.instZero",
   "AddMonoid.toAddSemigroup",
   "LE.le"],
  "name": "HarderNarasimhan.TotallyOrderedRealVectorSpace.mk",
  "constType":
  "{V : Type} →\n  [toAddCommGroup : AddCommGroup V] →\n    [toModule : _root_.Module ℝ V] →\n      [toLinearOrder : LinearOrder V] →\n        [toPosSMulStrictMono : PosSMulStrictMono ℝ V] →\n          (∀ {y z : V} (x : V), y ≤ z → x + y ≤ x + z) → HarderNarasimhan.TotallyOrderedRealVectorSpace V",
  "constCategory": "Other"},
 {"references": ["HAdd", "outParam"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["PartialOrder", "LinearOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u_2} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "DecidableLE",
   "LinearOrder",
   "Preorder.toLE"],
  "name": "LinearOrder.toDecidableLE",
  "constType": "{α : Type u_2} → [self : LinearOrder α] → DecidableLE α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Ideal.IsPrime",
   "Submodule.Quotient.module",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "Semiring.toModule",
   "And.left",
   "SetLike.instMembership",
   "Exists",
   "LinearMap.ker",
   "Submodule.addCommGroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Prod.snd",
   "LinearMap",
   "Set.instMembership",
   "Prod",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.submoduleOf",
   "LinearMap.toSpanSingleton",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Submodule.hasQuotient",
   "Subtype",
   "LinearMap.instFunLike",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Prod.fst",
   "Submodule",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "Eq",
   "CommRing.toCommSemiring",
   "Set",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsAssociatedPrime._proof_1",
   "AddCommGroup",
   "IsAssociatedPrime",
   "CommRing",
   "LT.lt",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "Module.Finite"],
  "name": "HarderNarasimhan._μ._proof_2",
  "constType":
  "∀ (R : Type) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (M : Type) [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 }),\n  ∀ p ∈ associatedPrimes R (↥(↑I).2 ⧸ Submodule.submoduleOf (↑I).1 (↑I).2), p.IsPrime",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "LinearMap.instFunLike",
   "Eq.mp",
   "Module",
   "LinearMap.range",
   "Submodule.module",
   "Membership.mem",
   "Submodule.map",
   "congrArg",
   "Submodule",
   "Submodule.subtype",
   "LinearMap.semilinearMapClass",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "RingHom.id",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SetLike.instMembership",
   "LinearMap.map_le_range",
   "LinearMap",
   "RingHomSurjective.ids",
   "Submodule.range_subtype",
   "Submodule.setLike",
   "LE.le",
   "Submodule.completeLattice",
   "Submodule.addCommMonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Semiring"],
  "name": "Submodule.map_subtype_le",
  "constType":
  "∀ {R : Type u_1} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M) (p' : Submodule R ↥p), Submodule.map p.subtype p' ≤ p",
  "constCategory": "Theorem"},
 {"references":
  ["IsStrictOrderedRing.mk",
   "PartialOrder.toPreorder",
   "IsOrderedCancelAddMonoid.mk",
   "Nat.le_of_add_le_add_left",
   "Eq.mp",
   "Exists.intro",
   "Nat.add_le_add_left",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "Nat.mul_lt_mul_of_pos_right",
   "Nat.instSemiring",
   "Nat.ne_of_lt",
   "instOfNatNat",
   "Zero.toOfNat0",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nontrivial.mk",
   "Preorder.toLE",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "add_comm",
   "IsOrderedAddMonoid.mk",
   "IsStrictOrderedRing",
   "Exists",
   "Nat.instPartialOrder",
   "instHAdd",
   "ZeroLEOneClass.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat.zero_lt_succ",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat",
   "Nat.zero_lt_one",
   "One.toOfNat1",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "AddMonoidWithOne.toOne",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "Nat.mul_lt_mul_of_pos_left",
   "id",
   "Ne",
   "Eq.mpr",
   "Nat.le_of_lt"],
  "name": "Nat.instIsStrictOrderedRing",
  "constType": "IsStrictOrderedRing ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "PartialOrder.toPreorder",
   "AddCommGroup.toAddGroup",
   "Preorder.toLT",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubtractionMonoid",
   "IsOrderedAddMonoid",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddGroup.toSubNegMonoid",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "AddCommGroup",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "neg_neg_iff_pos",
   "LT.lt",
   "NegZeroClass.toNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "IsOrderedAddMonoid.toIsOrderedCancelAddMonoid",
   "Iff.mpr",
   "AddCommGroup.toAddCommMonoid",
   "NegZeroClass.toZero",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "AddMonoid.toAddZeroClass"],
  "name": "neg_neg_of_pos",
  "constType":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : PartialOrder α] [IsOrderedAddMonoid α] {a : α}, 0 < a → -a < 0",
  "constCategory": "Theorem"},
 {"references": ["Neg"],
  "name": "Neg.mk",
  "constType": "{α : Type u} → (α → α) → Neg α",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "Eq.trans",
   "True",
   "instHAdd",
   "List",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Nat",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Coeffs.get",
   "instOfNatNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Eq",
   "List.cons"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_5",
  "constType":
  "∀ {a0 a1 a2 a3 a4 a5 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 5).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: a4 :: a5 :: t)) = a5",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "instOfNatNat",
   "Zero.toOfNat0",
   "Nat.cast_succ",
   "Eq",
   "AddMonoidWithOne",
   "AddSemigroup.toAdd",
   "AddZeroClass.toZero",
   "instHAdd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat",
   "zero_add",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "AddZeroClass.toAdd",
   "Nat.succ",
   "Eq.refl",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_zero",
   "AddMonoidWithOne.toOne",
   "id",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "Preorder.le_refl", "LE.le", "Preorder.toLE"],
  "name": "le_refl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["not_le",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_11",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (¬a ≤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Int.instLEInt",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Bool.true",
   "List.cons",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "BoundedOrder",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nat.lt_of_not_le",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Bool",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Option.some",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Int.instAdd",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Preorder.toLE",
   "Eq",
   "of_decide_eq_true",
   "instNatCastInt",
   "Not",
   "List.nil",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Option.none",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "instLENat",
   "OrderTop.toTop"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (f : ℕ → ℒ) (hffin : ∃ n, f n = ⊤) (i j : ℕ),\n  j < Nat.find hffin → ¬j + 1 ≤ Nat.find hffin → False",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE", "ge_iff_le", "Eq", "GE.ge", "propext"],
  "name": "_private.Init.Core.0._proof_38",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "Set"],
  "name": "InfSet.mk",
  "constType": "{α : Type u_1} → (Set α → α) → InfSet α",
  "constCategory": "Other"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Eq.mpr_not",
   "Preorder.toLT",
   "Classical.propDecidable",
   "IsGreatest",
   "HarderNarasimhan.impl.HNFil._proof_3",
   "HarderNarasimhan.Convex",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists.choose_spec",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "Nat",
   "Eq.refl",
   "Iff.mpr",
   "eq_false",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "Subtype",
   "HarderNarasimhan.StI",
   "HarderNarasimhan.impl.HNFil",
   "dite_congr",
   "Prod.fst",
   "congrArg",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "WellFoundedGT",
   "instDecidableFalse",
   "Preorder.toLE",
   "Eq",
   "Not",
   "HarderNarasimhan.impl.HNFil._proof_4",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "instHAdd",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "False",
   "Ne",
   "Subtype.mk",
   "dite",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.impl.HNFil_prop_of_def",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ] (n : ℕ)\n  (h' : HarderNarasimhan.impl.HNFil μ n ≠ ⊤),\n  IsGreatest (HarderNarasimhan.StI μ ⟨(HarderNarasimhan.impl.HNFil μ n, ⊤), ⋯⟩) (HarderNarasimhan.impl.HNFil μ (n + 1))",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Subtype.lt", "Subtype", "Iff.mpr", "Iff.rfl", "Subtype.val", "LT"],
  "name": "Subtype.GCongr.coe_lt_coe",
  "constType":
  "∀ {α : Type u_2} [inst : LT α] {p : α → Prop} {x y : Subtype p}, x < y → ↑x < ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Set.Nonempty",
   "Exists",
   "Set.not_nonempty_iff_eq_empty._proof_27",
   "Eq.trans",
   "True",
   "Set",
   "Membership.mem",
   "Set.not_nonempty_iff_eq_empty._proof_26",
   "EmptyCollection.emptyCollection",
   "Set.instEmptyCollection",
   "congrArg",
   "Set.instMembership",
   "iff_self",
   "of_eq_true",
   "Iff",
   "congr",
   "Eq"],
  "name": "Set.not_nonempty_iff_eq_empty",
  "constType": "∀ {α : Type u} {s : Set α}, ¬s.Nonempty ↔ s = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Prod.fst",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Preorder.toLE",
   "Eq",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "instHSub",
   "HarderNarasimhan.WeakDescendingChainCondition'",
   "CompleteLattice",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "CompleteLattice.toTop",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "SemilatticeInf.toPartialOrder",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "HarderNarasimhan.WeakDescendingChainCondition'.rec",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "LE.le",
   "Linarith.zero_lt_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "HarderNarasimhan.WeakDescendingChainCondition'.mk",
   "instLENat",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.WeakDescendingChainCondition'.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakDescendingChainCondition' μ → Sort u} →\n                (t : HarderNarasimhan.WeakDescendingChainCondition' μ) →\n                  ((wdcc' : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["instNNRealSemiring",
   "RingHom.toMonoidHom",
   "NNReal.toRealHom",
   "Semiring.toNonAssocSemiring",
   "Real",
   "MulAction",
   "MulAction.compHom",
   "Real.instMonoid",
   "MonoidWithZero.toMonoid",
   "NNReal",
   "Semiring.toMonoidWithZero",
   "Real.semiring"],
  "name": "NNReal.instMulActionOfReal",
  "constType": "{M : Type u_1} → [MulAction ℝ M] → MulAction NNReal M",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Subtype.mk_lt_mk",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "HarderNarasimhan.μmax",
   "Subtype.coe_inj",
   "And.intro",
   "Subtype.GCongr.coe_lt_coe",
   "SupSet.sSup",
   "funext",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μmax_res_intvl._proof_20",
   "Exists",
   "And.right",
   "And",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Prod.snd",
   "lt_iff_le_not_le",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Iff.of_eq",
   "HarderNarasimhan.InIntvl",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Set.ext",
   "Eq.mpr",
   "setOf",
   "Subtype",
   "Subtype.lt",
   "le_trans",
   "and_true",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "HarderNarasimhan.Resμ",
   "Iff.intro",
   "Prod.fst",
   "congrArg",
   "Subtype.prop",
   "congr",
   "Subtype.property",
   "HarderNarasimhan.Interval",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "HarderNarasimhan.instBoundedOrderInterval",
   "HarderNarasimhan.μmax._proof_2",
   "exists_prop_congr",
   "LT.lt",
   "eq_self",
   "HarderNarasimhan.instNontrivialInterval",
   "SupSet",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "HarderNarasimhan.μmax_res_intvl",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {I : { p // p.1 < p.2 }} {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} {J : { p // p.1 < p.2 }},\n  HarderNarasimhan.μmax (HarderNarasimhan.Resμ I μ) J = HarderNarasimhan.μmax μ ⟨(↑(↑J).1, ↑(↑J).2), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "HarderNarasimhan.WeakSlopeLike₁.mk",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "HarderNarasimhan.WeakSlopeLike₁",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "HarderNarasimhan.WeakSlopeLike₁.rec",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "HarderNarasimhan.WeakSlopeLike₁.recOn",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_3 : CompleteLattice S] →\n            {μ : { p // p.1 < p.2 } → S} →\n              {motive : HarderNarasimhan.WeakSlopeLike₁ μ → Sort u} →\n                (t : HarderNarasimhan.WeakSlopeLike₁ μ) →\n                  ((wsl₁ :\n                        ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                          μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                      motive ⋯) →\n                    motive t",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Eq.substr",
   "True",
   "Eq.trans",
   "of_eq_true",
   "Eq.refl",
   "forall_congr",
   "Eq.symm",
   "Eq.rec",
   "Eq",
   "congrArg"],
  "name": "forall_prop_domain_congr",
  "constType":
  "∀ {p₁ p₂ : Prop} {q₁ : p₁ → Prop} {q₂ : p₂ → Prop} (h₁ : p₁ = p₂),\n  (∀ (a : p₂), q₁ ⋯ = q₂ a) → (∀ (a : p₁), q₁ a) = ∀ (a : p₂), q₂ a",
  "constCategory": "Theorem"},
 {"references": ["_obj", "_neutral"],
  "name":
  "HarderNarasimhan.instCompleteLatticeClosedsSetOfPartialOrder_harderNarasimhan._rarg._lambda_3._cstage2",
  "constType": "_obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_17",
   "Submodule.Quotient.module",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Classical.propDecidable",
   "HarderNarasimhan.S",
   "HarderNarasimhan.Coprimary.coprimary",
   "instLTNat",
   "Exists",
   "SetLike.instMembership",
   "Submodule.addCommGroup",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.impl.piecewise_coprimary",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Set.instMembership",
   "Nat",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "Top.top",
   "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_20",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.toBoundedOrder",
   "Submodule.submoduleOf",
   "Submodule.hasQuotient",
   "Nat.find",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Subtype",
   "HasQuotient.Quotient",
   "Module",
   "Submodule.module",
   "Submodule",
   "ExistsUnique.exists",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "instOfNatNat",
   "HarderNarasimhan.impl.prop3d11",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "CommRing.toCommSemiring",
   "instHAdd",
   "Set",
   "CommSemiring.toSemiring",
   "Submodule.instTop",
   "HarderNarasimhan.impl.prop3d13₂",
   "AddCommGroup",
   "CommRing",
   "HarderNarasimhan.impl.prop3d13₁",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "CommRing.toRing",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "Submodule.setLike",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Submodule.completeLattice",
   "HarderNarasimhan.S₀",
   "Submodule.addCommMonoid",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.instInhabitedCoprimaryFiltration._proof_22",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (HNFil : HarderNarasimhan.HarderNarasimhanFiltration (HarderNarasimhan.μ R M)) (n : ℕ),\n  n + 1 < Nat.find ⋯ →\n    ∃ x,\n      x ∈\n        associatedPrimes R\n          (↥(HNFil.filtration (n + 1 + 1)) ⧸\n            Submodule.submoduleOf (HNFil.filtration (n + 1)) (HNFil.filtration (n + 1 + 1)))",
  "constCategory": "Theorem"},
 {"references": ["HarderNarasimhan.μmax._rarg", "_obj", "_neutral"],
  "name": "HarderNarasimhan.μmax._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["MulAction.toSMul",
   "DistribSMul.mk",
   "AddZeroClass.toZero",
   "SMulZeroClass.mk",
   "DistribMulAction.smul_zero",
   "DistribMulAction.toMulAction",
   "Monoid",
   "AddMonoid",
   "DistribSMul",
   "DistribMulAction",
   "DistribMulAction.smul_add",
   "AddMonoid.toAddZeroClass"],
  "name": "DistribMulAction.toDistribSMul",
  "constType":
  "{M : Type u_1} → {A : Type u_7} → [inst : Monoid M] → [inst_1 : AddMonoid A] → [DistribMulAction M A] → DistribSMul M A",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Int.instSub",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Preorder.toLT",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Eq.symm",
   "Int.instLEInt",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "HarderNarasimhan.Convex",
   "CompleteLinearOrder",
   "List.cons",
   "Bool.true",
   "SemilatticeInf.toPartialOrder",
   "instLTNat",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Exists",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instNegInt",
   "Prod",
   "instDecidableEqBool",
   "Nat",
   "instOfNat",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.LinearCombo.instAdd",
   "Nat.find",
   "instDecidableAnd",
   "Nat.cast",
   "Subtype",
   "HarderNarasimhan.impl.instμ_Admissible",
   "Bool",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "HarderNarasimhan.impl.HNFil",
   "Option.some",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.mk",
   "Prod.fst",
   "Lean.Omega.LinearCombo.instSub",
   "Lean.Omega.Coeffs.ofList",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Int.instAdd",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "instNatCastInt",
   "of_decide_eq_true",
   "List.nil",
   "Not",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Lean.Omega.LinearCombo",
   "Nat.decLe",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Exists.choose",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "CompletelyDistribLattice.toCompleteLattice",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Option.none",
   "instSubNat",
   "LE.le",
   "Int.natCast_add",
   "False",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Constraint.mk",
   "instHSub",
   "OrderTop.toTop",
   "instLENat"],
  "name": "HarderNarasimhan.impl.theorem3d10._proof_12",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : HarderNarasimhan.μA_DescendingChainCondition μ)\n  (hμcvx : HarderNarasimhan.Convex μ) (f : ℕ → ℒ),\n  (∃ n, f n = ⊤) → ∀ (n : ℕ), (∃ N ≥ n + 1, HarderNarasimhan.impl.HNFil μ (n + 1) ≤ f N) → ¬n < n + 1 → False",
  "constCategory": "Theorem"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "HarderNarasimhan.TotIntvl._proof_1",
   "Prod.snd",
   "Bot.bot",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "OrderBot.toBot",
   "Subtype.mk",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.TotIntvl",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references": ["Max"],
  "name": "Max.mk",
  "constType": "{α : Type u} → (α → α → α) → Max α",
  "constCategory": "Other"},
 {"references":
  ["LT.lt",
   "Not",
   "instLTNat",
   "Nat",
   "Nat.lt_or_ge",
   "LE.le",
   "Or.resolve_right",
   "GT.gt",
   "GE.ge",
   "instLENat"],
  "name": "Nat.gt_of_not_le",
  "constType": "∀ {n m : ℕ}, ¬n ≤ m → n > m",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "False.elim", "Decidable", "Decidable.byCases", "id", "False"],
  "name": "Decidable.byContradiction",
  "constType": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["instLTNat",
   "HEq.refl",
   "Fin",
   "Eq.casesOn",
   "LT.lt",
   "Eq.propIntro",
   "Nat",
   "Eq.refl",
   "Fin.mk",
   "HEq",
   "Eq.symm",
   "Eq",
   "Fin.noConfusion",
   "Eq.ndrec"],
  "name": "Fin.mk.injEq",
  "constType":
  "∀ {n : ℕ} (val : ℕ) (isLt : val < n) (val_1 : ℕ) (isLt_1 : val_1 < n), (⟨val, isLt⟩ = ⟨val_1, isLt_1⟩) = (val = val_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "AddGroupWithOne.toAddMonoidWithOne",
   "inferInstance",
   "AddMonoidWithOne",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne",
  "constType": "{α : Type u} → [Ring α] → AddMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.mk._flat_ctor",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] →\n                    [h : HarderNarasimhan.μ_Admissible μ] →\n                      (filtration : ℕ → ℒ) →\n                        Monotone filtration →\n                          filtration 0 = ⊥ →\n                            (fin_len : ∃ n, filtration n = ⊤) →\n                              (strict_mono : ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                (∀ (i : ℕ) (h : i < Nat.find fin_len),\n                                    HarderNarasimhan.Semistable\n                                      (HarderNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)) →\n                                  (∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n                                      ¬HarderNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n                                          HarderNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩) →\n                                    HarderNarasimhan.HarderNarasimhanFiltration μ",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instMembership",
   "Subtype",
   "ZeroMemClass.zero_mem",
   "Zero.mk",
   "Membership.mem",
   "Zero.toOfNat0",
   "SetLike",
   "Subtype.mk",
   "Zero",
   "OfNat.ofNat",
   "ZeroMemClass"],
  "name": "ZeroMemClass.zero",
  "constType":
  "{A : Type u_3} →\n  {M₁ : Type u_4} → [inst : SetLike A M₁] → [inst_1 : Zero M₁] → [hA : ZeroMemClass A M₁] → (S' : A) → Zero ↥S'",
  "constCategory": "Definition"},
 {"references":
  ["HarderNarasimhan.S₀_order",
   "Finset",
   "Eq.trans",
   "Singleton.singleton",
   "Submodule.Quotient.module",
   "Membership.mem.out",
   "Subtype.val",
   "Finset.min'",
   "letFun",
   "Eq.symm",
   "Exists",
   "Submodule.addCommGroup",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "HarderNarasimhan.InIntvl",
   "Iff",
   "Finset.instMembership",
   "AddCommGroup.toAddCommMonoid",
   "HarderNarasimhan.impl.prop3d12p2._proof_6",
   "Eq.mpr",
   "Submodule.hasQuotient",
   "HasQuotient.Quotient",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.impl.μ_nonempty",
   "Prod.fst",
   "HarderNarasimhan.impl.prop3d12p2._proof_4",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "Eq",
   "propext",
   "Set.mem_toFinset",
   "LinearExtension",
   "Set",
   "Finset.val",
   "Set.toFinset",
   "AddCommGroup",
   "PrimeSpectrum",
   "CommRing.toRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "HarderNarasimhan._μ._proof_2",
   "Submodule.completeLattice",
   "Ne",
   "HarderNarasimhan.S₀",
   "HarderNarasimhan.impl.prop3d12p1",
   "Module.Finite",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.instLES₀",
   "Prod.mk",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "Finset.toSet",
   "Finset.coe_singleton",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "PrimeSpectrum.instPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "SetLike.instMembership",
   "And.right",
   "PrimeSpectrum.mk",
   "Exists.casesOn",
   "Finset.instSingleton",
   "HasSubset.Subset",
   "Nontrivial",
   "id",
   "Submodule.submoduleOf",
   "Multiset.instMembership",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "associatedPrimes",
   "Subtype",
   "Eq.mp",
   "Submodule.module",
   "le_trans",
   "lt_of_le_of_ne",
   "congrArg",
   "Submodule",
   "instDistribLatticeOfLinearOrder",
   "Submodule.Quotient.addCommGroup",
   "Ideal",
   "PrimeSpectrum.asIdeal",
   "Finset.min'_mem",
   "CommRing.toCommSemiring",
   "HarderNarasimhan.impl.prop3d12p2._proof_5",
   "Lattice.toSemilatticeInf",
   "CommSemiring.toSemiring",
   "Finset.instHasSubset",
   "CommRing",
   "Set.instSingletonSet",
   "Multiset",
   "LT.lt",
   "Set.instHasSubset",
   "IsNoetherianRing",
   "DistribLattice.toLattice",
   "Submodule.setLike",
   "LE.le",
   "Subtype.mk",
   "Submodule.addCommMonoid"],
  "name": "HarderNarasimhan.impl.prop3d12p2",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (I : { z // z.1 < z.2 })\n  (N'' : HarderNarasimhan.ℒ R M) (ha1 : HarderNarasimhan.InIntvl I N'') (ha2 : N'' ≠ (↑I).2),\n  {(HarderNarasimhan._μ R M I).toFinset.min' ⋯} ≤ (HarderNarasimhan._μ R M ⟨(N'', (↑I).2), ⋯⟩).toFinset",
  "constCategory": "Theorem"},
 {"references": ["ConditionallyCompleteLattice", "Lattice"],
  "name": "ConditionallyCompleteLattice.toLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["LinearMap.ker",
   "Subtype",
   "SetLike.instMembership",
   "LinearMap.instFunLike",
   "Module",
   "Submodule.module",
   "LinearMap.ker_eq_bot_of_injective",
   "Membership.mem",
   "LinearMap",
   "Bot.bot",
   "Subtype.ext_val",
   "Submodule.subtype",
   "Submodule",
   "LinearMap.semilinearMapClass",
   "AddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Submodule.setLike",
   "RingHom.id",
   "Submodule.instBot",
   "Eq",
   "Submodule.addCommMonoid",
   "Semiring"],
  "name": "Submodule.ker_subtype",
  "constType":
  "∀ {R : Type u_1} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]\n  (p : Submodule R M), LinearMap.ker p.subtype = ⊥",
  "constCategory": "Theorem"},
 {"references": ["Not", "Iff", "Classical.propDecidable", "Decidable.not_not"],
  "name": "Classical.not_not",
  "constType": "∀ {a : Prop}, ¬¬a ↔ a",
  "constCategory": "Theorem"},
 {"references": ["Function.Embedding"],
  "name": "Function.Embedding.toFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → (α ↪ β) → α → β",
  "constCategory": "Definition"},
 {"references": ["IsTotal", "Or"],
  "name": "IsTotal.mk",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop}, (∀ (a b : α), r a b ∨ r b a) → IsTotal α r",
  "constCategory": "Other"},
 {"references":
  ["Int.cast_add",
   "Int.add",
   "Distrib.toAdd",
   "Ring.toNonAssocRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "instHAdd",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "Int.cast",
   "Int",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.instAdd",
   "Eq.symm",
   "AddGroupWithOne.toIntCast",
   "Mathlib.Meta.NormNum.isInt_add.match_1",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.isInt_add",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → a'.add b' = c → Mathlib.Meta.NormNum.IsInt (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μAstar",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Eq.refl",
   "Nontrivial",
   "Top.top",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.μAstar.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : PartialOrder ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  HarderNarasimhan.μAstar μ = HarderNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Ordering.gt",
   "Decidable",
   "ite",
   "DecidableEq",
   "Ordering.eq",
   "Ordering.lt",
   "Eq",
   "Ordering",
   "LT"],
  "name": "compareOfLessAndEq",
  "constType":
  "{α : Type u_1} → (x y : α) → [inst : LT α] → [Decidable (x < y)] → [DecidableEq α] → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "PartialOrder",
   "Subtype.le",
   "Preorder.toLE",
   "Eq",
   "HarderNarasimhan.coe'._proof_49",
   "Set.instLE",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Function.Embedding.mk",
   "RelEmbedding.mk",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "ClosureOperator.IsClosed",
   "OrderEmbedding",
   "Set.Iic",
   "HarderNarasimhan.coe'._proof_50",
   "HarderNarasimhan.coe'._proof_48",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "LE.le",
   "Subtype.mk"],
  "name": "HarderNarasimhan.coe'.eq_1",
  "constType":
  "∀ {α : Type} [inst : PartialOrder α],\n  HarderNarasimhan.coe' = { toFun := fun x => ⟨Set.Iic x, ⋯⟩, inj' := ⋯, map_rel_iff' := ⋯ }",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "HarderNarasimhan.impl.HNFil",
   "Prod.fst",
   "instOfNatNat",
   "WellFoundedGT",
   "HarderNarasimhan.Convex",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "eq_self",
   "Nat",
   "BoundedOrder.toOrderBot",
   "of_eq_true",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S} [hμ : HarderNarasimhan.μA_DescendingChainCondition μ]\n  [hμcvx : HarderNarasimhan.Convex μ] [h : HarderNarasimhan.μ_Admissible μ], HarderNarasimhan.impl.HNFil μ 0 = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Ord",
   "Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "CompleteLattice.toBot",
   "Ord.compare",
   "Lattice.inf_le_left",
   "DecidableEq",
   "HNot.hnot",
   "Preorder.toLT",
   "SemilatticeSup.toPartialOrder",
   "SDiff",
   "Lattice.inf",
   "compareOfLessAndEq",
   "HImp",
   "HNot",
   "Or",
   "HasCompl.compl",
   "CompleteLattice.toTop",
   "CompleteLinearOrder",
   "SemilatticeInf.mk",
   "Preorder.toLE",
   "Eq",
   "CompleteLinearOrder.compare_eq_compareOfLessAndEq._autoParam",
   "Lattice.inf_le_right",
   "DecidableLE",
   "DecidableLT",
   "CompleteLattice.toLattice",
   "HasCompl",
   "Ordering",
   "Bot.bot",
   "Lattice.le_inf",
   "Max.max",
   "Min.min",
   "Iff",
   "SemilatticeSup.toMax",
   "LE.le",
   "Top.top",
   "SDiff.sdiff",
   "autoParam",
   "HImp.himp",
   "CompleteLattice"],
  "name": "CompleteLinearOrder.mk",
  "constType":
  "{α : Type u_8} →\n  [toCompleteLattice : CompleteLattice α] →\n    [toHImp : HImp α] →\n      (∀ (a b c : α), a ≤ b ⇨ c ↔ a ⊓ b ≤ c) →\n        [toHasCompl : HasCompl α] →\n          (∀ (a : α), a ⇨ ⊥ = aᶜ) →\n            [toSDiff : SDiff α] →\n              [toHNot : HNot α] →\n                (∀ (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c) →\n                  (∀ (a : α), ⊤ \\ a = ￢a) →\n                    [toOrd : Ord α] →\n                      (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n                        DecidableLE α →\n                          (toDecidableEq : DecidableEq α) →\n                            (toDecidableLT : DecidableLT α) →\n                              autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b)\n                                  CompleteLinearOrder.compare_eq_compareOfLessAndEq._autoParam →\n                                CompleteLinearOrder α",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "HarderNarasimhan.Semistable.noConfusionType",
   "Top.top",
   "HarderNarasimhan.Semistable.casesOn",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.Semistable.noConfusion",
  "constType":
  "{ℒ : Type} →\n  {inst : Nontrivial ℒ} →\n    {inst_1 : Lattice ℒ} →\n      {inst_2 : BoundedOrder ℒ} →\n        {S : Type} →\n          {inst_3 : CompleteLattice S} →\n            {μ : { p // p.1 < p.2 } → S} →\n              {P : Sort u} →\n                {v1 v2 : HarderNarasimhan.Semistable μ} → v1 = v2 → HarderNarasimhan.Semistable.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "eq_of_le_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "HarderNarasimhan.impl.prop4d20",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "HarderNarasimhan.NashEquilibrium",
   "HarderNarasimhan.WeakSlopeLike₁",
   "HarderNarasimhan.Interval",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.WeakAscendingChainCondition",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "HarderNarasimhan.instBoundedOrderInterval",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "HarderNarasimhan.instNontrivialInterval",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.proposition_4_20",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥), HarderNarasimhan.WeakAscendingChainCondition (HarderNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n    (∀ (x : ℒ) (hx : x ≠ ⊥), HarderNarasimhan.WeakSlopeLike₁ (HarderNarasimhan.Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n      HarderNarasimhan.NashEquilibrium μ → HarderNarasimhan.Semistable μ",
  "constCategory": "Theorem"},
 {"references": ["Not", "IsIrrefl", "IsIrrefl.irrefl"],
  "name": "irrefl",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop} [IsIrrefl α r] (a : α), ¬r a a",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.μ",
   "Inhabited.default",
   "letFun",
   "HarderNarasimhan.instCompleteLinearOrderDedekindMacNeilleCompletion",
   "CompleteLinearOrder",
   "HarderNarasimhan.S",
   "Exists",
   "HarderNarasimhan.CoprimaryFiltration.filtration",
   "HarderNarasimhan.impl.CP_HN",
   "HarderNarasimhan.instUniqueHarderNarasimhanFiltration",
   "HarderNarasimhan.impl.instμ_AdmissibleℒSμ",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Unique.uniq",
   "Exists.casesOn",
   "Nat",
   "Eq.refl",
   "Nontrivial",
   "AddCommGroup.toAddCommMonoid",
   "id",
   "Eq.mpr",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLattice.toBoundedOrder",
   "Submodule.instNontrivial",
   "HarderNarasimhan.impl.instμ_Admissible",
   "Module",
   "HarderNarasimhan.instInhabitedHarderNarasimhanFiltration",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "congrArg",
   "HarderNarasimhan.CoprimaryFiltration",
   "HarderNarasimhan.instLinearOrderS₀",
   "HarderNarasimhan.impl.prop3d11",
   "Eq",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Unique",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.impl.prop3d13₂",
   "AddCommGroup",
   "CommRing",
   "Inhabited",
   "HarderNarasimhan.impl.prop3d13₁",
   "CompletelyDistribLattice.toCompleteLattice",
   "IsNoetherianRing",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.instPartialOrderS₀",
   "Unique.toInhabited",
   "HarderNarasimhan.HarderNarasimhanFiltration.filtration",
   "Submodule.completeLattice",
   "inferInstance",
   "HarderNarasimhan.S₀",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "Module.Finite"],
  "name": "HarderNarasimhan.impl.CP_HN'",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M]\n  (CPFil : HarderNarasimhan.CoprimaryFiltration R M), CPFil.filtration = default.filtration",
  "constCategory": "Theorem"},
 {"references":
  ["WellFounded",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Set",
   "WellFounded.has_min",
   "Membership.mem",
   "And",
   "Exists.intro",
   "Iff.intro",
   "Set.instMembership",
   "Exists.casesOn",
   "Acc",
   "WellFounded.intro",
   "Iff",
   "Classical.byContradiction",
   "Acc.intro",
   "False",
   "And.casesOn",
   "setOf"],
  "name": "WellFounded.wellFounded_iff_has_min",
  "constType":
  "∀ {α : Type u_1} {r : α → α → Prop}, WellFounded r ↔ ∀ (s : Set α), s.Nonempty → ∃ m ∈ s, ∀ x ∈ s, ¬r x m",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.FiniteTotalPayoff",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteLattice.toTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "HarderNarasimhan.FiniteTotalPayoff.mk",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] {μ : { p // p.1 < p.2 } → S}, μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤ → HarderNarasimhan.FiniteTotalPayoff μ",
  "constCategory": "Other"},
 {"references":
  ["Ideal.IsPrime",
   "Set",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal.primeCompl._proof_1",
   "MulZeroOneClass.toMulOneClass",
   "Subsemigroup.mk",
   "Submonoid",
   "Set.instHasCompl",
   "Ideal.primeCompl._proof_2",
   "Submonoid.mk",
   "Semiring.toNonAssocSemiring",
   "SetLike.coe",
   "Ideal",
   "Submodule.setLike",
   "HasCompl.compl",
   "Semiring.toModule",
   "MulOneClass.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "Semiring"],
  "name": "Ideal.primeCompl",
  "constType":
  "{α : Type u} → [inst : Semiring α] → (P : Ideal α) → [hp : P.IsPrime] → Submonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Exists.intro", "Eq", "forall_exists_index", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_12",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (∃ x, p x) → Prop}, (∀ (h : ∃ x, p x), q h) = ∀ (x : α) (h : p x), q ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["Finset",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Finset.coe_inf'",
   "Membership.mem",
   "WithTop",
   "WithTop.some",
   "congrArg",
   "Finset.inf",
   "instDistribLatticeOfLinearOrder",
   "WithTop.orderTop",
   "Finset.min'",
   "Eq",
   "Preorder.toLE",
   "Eq.rec",
   "Finset.Nonempty",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "True",
   "LinearOrder",
   "Function.comp",
   "eq_self",
   "DistribLattice.toLattice",
   "of_eq_true",
   "WithTop.semilatticeInf",
   "Eq.refl",
   "Finset.instMembership",
   "id",
   "Finset.inf'_congr",
   "Finset.mem_of_min",
   "Finset.inf'"],
  "name": "Finset.min'_mem",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrder α] (s : Finset α) (H : s.Nonempty), s.min' H ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeSup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "SemilatticeSup.le_sup_left",
  "constType":
  "∀ {α : Type u} [self : SemilatticeSup α] (a b : α), a ≤ SemilatticeSup.sup a b",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_not", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_not_eq",
  "constType": "∀ (p : Prop), (¬¬p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "ne_comm",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LE.le.lt_iff_ne",
   "bot_le",
   "Bot.bot",
   "LT.lt",
   "Iff",
   "PartialOrder",
   "Ne",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderBot"],
  "name": "bot_lt_iff_ne_bot",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, ⊥ < a ↔ a ≠ ⊥",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "HarderNarasimhan.μ_Admissible",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → [WellFoundedGT ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Other"},
 {"references": ["Not", "not_and", "And", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_and_eq",
  "constType": "∀ (p q : Prop), (¬(p ∧ q)) = (p → ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "PartialOrder.toPreorder",
   "AddCommGroup.toAddGroup",
   "Preorder.toLT",
   "CommGroupWithZero.toDivisionCommMonoid",
   "SMulZeroClass.toSMul",
   "instNNRealPartialOrder",
   "GT.gt",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "RelEmbedding.instFunLike",
   "NNReal.instLinearOrder",
   "NNReal.instLinearOrderedCommGroupWithZero",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "CompleteLattice.toTop",
   "AddGroup.toSubNegMonoid",
   "DistribSMul.toSMulZeroClass",
   "SemilatticeInf.toPartialOrder",
   "InvOneClass.toInv",
   "Real",
   "AddZeroClass.toZero",
   "ClosureOperator.IsClosed",
   "NNReal",
   "DistribMulAction.toDistribSMul",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "LinearOrder.toDecidableLT",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "HSMul.hSMul",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "AddMonoid.toAddZeroClass",
   "instNNRealSemiring",
   "instNNRealZero",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "DFunLike.coe",
   "Prod.fst",
   "instDistribLatticeOfLinearOrder",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
   "Eq",
   "Preorder.toLE",
   "Subtype.le",
   "DivisionCommMonoid.toDivisionMonoid",
   "Set.instLE",
   "Not",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Inv.inv",
   "Lattice.toSemilatticeInf",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Semiring.toMonoidWithZero",
   "OrderEmbedding",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "Real.semiring",
   "NNReal.instDistribMulActionOfReal",
   "OfNat.ofNat",
   "HarderNarasimhan.μQuotient",
   "LT.lt",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toModule",
   "Module.toDistribMulAction",
   "DivInvOneMonoid.toInvOneClass",
   "DistribLattice.toLattice",
   "SubNegMonoid.toAddMonoid",
   "LE.le",
   "dite",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.μQuotient.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {V : Type}\n  [inst_3 : HarderNarasimhan.TotallyOrderedRealVectorSpace V] (r : { p // p.1 < p.2 } → NNReal)\n  (d : { p // p.1 < p.2 } → V) (z : { p // p.1 < p.2 }),\n  HarderNarasimhan.μQuotient r d z = if x : r z > 0 then HarderNarasimhan.coe' ((r z)⁻¹ • d z) else ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toNonAssocRing",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "IsCancelAdd.toIsLeftCancelAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "HarderNarasimhan.instLatticeInterval",
   "BoundedOrder",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoid.toAddSemigroup",
   "Top.top",
   "Int.negOfNat",
   "HarderNarasimhan.Semistable",
   "Nat.find",
   "HarderNarasimhan.HarderNarasimhanFiltration._proof_1",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "Nat.instNeZeroSucc",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instIsStrictOrderedRing",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Nat.cast_add",
   "AddZeroClass.toAdd",
   "Monoid.toNatPow",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "Nat.instAddCommMonoid",
   "Monotone",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instLEInt",
   "HarderNarasimhan.Convex",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "SemilatticeInf.toPartialOrder",
   "Nat.instPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "HarderNarasimhan.HarderNarasimhanFiltration",
   "Nat.instCanonicallyOrderedAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast",
   "Eq.mp",
   "CommRing.toNonUnitalCommRing",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "instHAdd",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "lt_add_one",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.zero_lt_one",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "HarderNarasimhan.μA_DescendingChainCondition",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Prod.snd",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Int.add_one_le_iff",
   "Nat.instPreorder",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "Nat.instAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.μA",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "neg_neg_of_pos",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Prod.mk",
   "Int.rawCast",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.instIsOrderedAddMonoid",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "HarderNarasimhan.HarderNarasimhanFiltration.mk",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "MonoidWithZero.toMonoid",
   "Nat.instIsOrderedCancelAddMonoid",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "Mathlib.Tactic.Ring.sub_congr",
   "OrderBot.toBot",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "HarderNarasimhan.μ_Admissible",
   "CommSemiring.toSemiring",
   "Nat.decLe",
   "Semiring.toMonoidWithZero",
   "HarderNarasimhan.instNontrivialInterval",
   "NegZeroClass.toNeg",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Int.instAddMonoid",
   "instLENat"],
  "name": "HarderNarasimhan.HarderNarasimhanFiltration.rec",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [inst_3 : WellFoundedGT ℒ] →\n          {S : Type} →\n            [inst_4 : CompleteLattice S] →\n              {μ : { p // p.1 < p.2 } → S} →\n                [hμ : HarderNarasimhan.μA_DescendingChainCondition μ] →\n                  [hμcvx : HarderNarasimhan.Convex μ] →\n                    [h : HarderNarasimhan.μ_Admissible μ] →\n                      {motive : HarderNarasimhan.HarderNarasimhanFiltration μ → Sort u} →\n                        ((filtration : ℕ → ℒ) →\n                            (monotone : Monotone filtration) →\n                              (first_eq_bot : filtration 0 = ⊥) →\n                                (fin_len : ∃ n, filtration n = ⊤) →\n                                  (strict_mono :\n                                      ∀ (i j : ℕ), i < j → j ≤ Nat.find fin_len → filtration i < filtration j) →\n                                    (piecewise_semistable :\n                                        ∀ (i : ℕ) (h : i < Nat.find fin_len),\n                                          HarderNarasimhan.Semistable\n                                            (HarderNarasimhan.Resμ ⟨(filtration i, filtration (i + 1)), ⋯⟩ μ)) →\n                                      (μA_pseudo_strict_anti :\n                                          ∀ (i : ℕ) (hi : i + 1 < Nat.find fin_len),\n                                            ¬HarderNarasimhan.μA μ ⟨(filtration i, filtration (i + 1)), ⋯⟩ ≤\n                                                HarderNarasimhan.μA μ ⟨(filtration (i + 1), filtration (i + 2)), ⋯⟩) →\n                                        motive\n                                          { filtration := filtration, monotone := monotone,\n                                            first_eq_bot := first_eq_bot, fin_len := fin_len,\n                                            strict_mono := strict_mono, piecewise_semistable := piecewise_semistable,\n                                            μA_pseudo_strict_anti := μA_pseudo_strict_anti }) →\n                          (t : HarderNarasimhan.HarderNarasimhanFiltration μ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "HarderNarasimhan.μA",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice",
   "HarderNarasimhan.Semistable"],
  "name": "HarderNarasimhan.Semistable.semistable",
  "constType":
  "∀ {ℒ : Type} {inst : Nontrivial ℒ} {inst_1 : Lattice ℒ} {inst_2 : BoundedOrder ℒ} {S : Type}\n  {inst_3 : CompleteLattice S} {μ : { p // p.1 < p.2 } → S} [self : HarderNarasimhan.Semistable μ] (x : ℒ) (hx : x ≠ ⊥),\n  ¬HarderNarasimhan.μA μ ⟨(⊥, x), ⋯⟩ > HarderNarasimhan.μA μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_iUnion",
   "Exists",
   "Set",
   "Membership.mem",
   "Set.iUnion",
   "Eq",
   "propext",
   "Set.instMembership"],
  "name": "_private.Mathlib.Order.SetNotation.0._proof_3",
  "constType":
  "∀ {α : Type u} {ι : Sort v} {x : α} {s : ι → Set α}, (x ∈ ⋃ i, s i) = ∃ i, x ∈ s i",
  "constCategory": "Theorem"},
 {"references":
  ["add_right_inj",
   "HAdd.hAdd",
   "IsLeftCancelAdd",
   "instHAdd",
   "Add",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Algebra.Group.Defs.0._proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [IsLeftCancelAdd G] (a : G) {b c : G}, (a + b = a + c) = (b = c)",
  "constCategory": "Theorem"},
 {"references":
  ["Module.toMulActionWithZero._proof_1",
   "AddZeroClass.toZero",
   "Module",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.zero_smul",
   "MulActionWithZero.mk",
   "AddCommMonoid",
   "Module.toDistribMulAction",
   "MulAction",
   "MulActionWithZero",
   "MonoidWithZero.toMonoid",
   "DistribMulAction.toMulAction",
   "inferInstance",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Module.toMulActionWithZero",
  "constType":
  "{R : Type u_5} →\n  {M : Type u_6} → {x : Semiring R} → {x_1 : AddCommMonoid M} → [_root_.Module R M] → MulActionWithZero R M",
  "constCategory": "Definition"},
 {"references":
  ["Preorder",
   "Preorder.toLT",
   "GT.gt",
   "Preorder.toLE",
   "GE.ge",
   "lt_of_lt_of_le"],
  "name": "gt_of_ge_of_gt",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≥ b → b > c → a > c",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Classical.choose"],
  "name": "Exists.choose",
  "constType": "{α : Sort u_1} → {p : α → Prop} → (∃ a, p a) → α",
  "constCategory": "Definition"},
 {"references":
  ["le_add_iff_nonneg_left",
   "AddZeroClass",
   "AddZeroClass.toZero",
   "instHAdd",
   "LE",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "AddRightMono",
   "AddZeroClass.toAdd",
   "LE.le",
   "Zero.toOfNat0",
   "Eq",
   "propext",
   "AddRightReflectLE"],
  "name": "_private.Mathlib.Algebra.Order.Monoid.Unbundled.Basic.0._proof_12",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α] [AddRightMono α] [AddRightReflectLE α] (a : α) {b : α},\n  (a ≤ b + a) = (0 ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["HarderNarasimhan.TotallyOrderedRealVectorSpace",
   "PartialOrder.toPreorder",
   "AddCommGroup.toAddGroup",
   "Preorder.toLT",
   "CommGroupWithZero.toDivisionCommMonoid",
   "SMulZeroClass.toSMul",
   "instNNRealPartialOrder",
   "GT.gt",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "RelEmbedding.instFunLike",
   "NNReal.instLinearOrder",
   "NNReal.instLinearOrderedCommGroupWithZero",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toLinearOrder",
   "CompleteLattice.toTop",
   "AddGroup.toSubNegMonoid",
   "DistribSMul.toSMulZeroClass",
   "SemilatticeInf.toPartialOrder",
   "InvOneClass.toInv",
   "Real",
   "AddZeroClass.toZero",
   "ClosureOperator.IsClosed",
   "NNReal",
   "DistribMulAction.toDistribSMul",
   "BoundedOrder",
   "Prod.snd",
   "Prod",
   "LinearOrder.toDecidableLT",
   "Set.instCompleteAtomicBooleanAlgebra",
   "Nontrivial",
   "Lattice",
   "HSMul.hSMul",
   "Top.top",
   "AddCommGroup.toAddCommMonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "AddMonoid.toAddZeroClass",
   "instNNRealSemiring",
   "instNNRealZero",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HarderNarasimhan.coe'",
   "DFunLike.coe",
   "Prod.fst",
   "instDistribLatticeOfLinearOrder",
   "MonoidWithZero.toMonoid",
   "instHSMul",
   "Zero.toOfNat0",
   "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
   "Preorder.toLE",
   "Subtype.le",
   "DivisionCommMonoid.toDivisionMonoid",
   "Set.instLE",
   "Not",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "Inv.inv",
   "Lattice.toSemilatticeInf",
   "Set",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Semiring.toMonoidWithZero",
   "OrderEmbedding",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toAddCommGroup",
   "Real.semiring",
   "NNReal.instDistribMulActionOfReal",
   "OfNat.ofNat",
   "LT.lt",
   "HarderNarasimhan.TotallyOrderedRealVectorSpace.toModule",
   "Module.toDistribMulAction",
   "DivInvOneMonoid.toInvOneClass",
   "DistribLattice.toLattice",
   "SubNegMonoid.toAddMonoid",
   "LE.le",
   "dite",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion"],
  "name": "HarderNarasimhan.μQuotient",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        {V : Type} →\n          [inst_2 : HarderNarasimhan.TotallyOrderedRealVectorSpace V] →\n            ({ p // p.1 < p.2 } → NNReal) →\n              ({ p // p.1 < p.2 } → V) → { p // p.1 < p.2 } → HarderNarasimhan.DedekindMacNeilleCompletion V",
  "constCategory": "Definition"},
 {"references": ["Or.rec", "Or.inr", "Or.inl", "Or"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b), (∀ (h : a), motive ⋯) → (∀ (h : b), motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Preorder", "Preorder.toLT"],
  "name": "StrictAnti",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["DivInvMonoid.toInv",
   "DivInvOneMonoid.toDivInvMonoid",
   "InvOneClass",
   "DivInvOneMonoid.inv_one",
   "DivInvMonoid.toMonoid",
   "Monoid.toOne",
   "DivInvOneMonoid",
   "InvOneClass.mk"],
  "name": "DivInvOneMonoid.toInvOneClass",
  "constType": "{G : Type u_2} → [self : DivInvOneMonoid G] → InvOneClass G",
  "constCategory": "Definition"},
 {"references": ["Lattice", "DistribLattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{α : Type u_1} → [self : DistribLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HarderNarasimhan.SlopeLike",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Nat.instSuccAddOrder",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instCommSemiring",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "BoundedOrder",
   "Prod.snd",
   "Ring.toSemiring",
   "Prod",
   "BoundedOrder.toOrderBot",
   "instOfNat",
   "Eq.refl",
   "AddMonoid.toAddSemigroup",
   "Classical.byContradiction",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Int.negOfNat",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "HarderNarasimhan.Semistable",
   "Linarith.add_lt_of_neg_of_le",
   "Ne.symm",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.instRing",
   "Nat.instPreorder",
   "Prod.fst",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "_private.Init.PropLemmas.0._proof_15",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "lt_of_not_ge",
   "instNatCastInt",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.neg_zero",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Int.instIsOrderedAddMonoid",
   "Linarith.sub_nonpos_of_le",
   "HPow.hPow",
   "OfNat.ofNat",
   "Int",
   "Nat.cast_add",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "LinearOrder.toPartialOrder",
   "AddGroupWithOne.toAddGroup",
   "Monoid.toNatPow",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "HarderNarasimhan.impl.JHFil_anti_mono",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "HarderNarasimhan.impl.JHFil",
   "Ne",
   "neg_neg_of_pos",
   "instHSub",
   "bot_lt_top",
   "Nat.cast_one",
   "Int.instCommRing",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Prod.mk",
   "Preorder.toLT",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "GE.ge",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "Int.instLEInt",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "CompleteLattice.toTop",
   "CompleteLinearOrder",
   "AddGroup.toSubNegMonoid",
   "Eq.rec",
   "Int.ofNat",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "HarderNarasimhan.impl.JHFil_prop₁",
   "strictAnti_of_add_one_lt",
   "SemilatticeInf.toPartialOrder",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Nat.instPartialOrder",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Bot.bot",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Exists.casesOn",
   "Nat.instIsSuccArchimedean",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "Nat.cast",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "CommRing.toNonUnitalCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Nat.instOne",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "BoundedOrder.toOrderTop",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MonoidWithZero.toMonoid",
   "IsMax",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "StrictAnti",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.instSemiring",
   "LE.le",
   "Linarith.zero_lt_one",
   "False",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Subtype.mk",
   "instLENat",
   "OrderTop.toTop",
   "Int.instAddMonoid"],
  "name": "HarderNarasimhan.impl.JHFil_fin_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [hacc : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (hμ : μ ⟨(⊥, ⊤), ⋯⟩ ≠ ⊤)\n  (hμsl : HarderNarasimhan.SlopeLike μ) (hst : HarderNarasimhan.Semistable μ)\n  (hdc : ∀ (x : ℕ → ℒ) (sax : StrictAnti x), ∃ N, μ ⟨(x (N + 1), x N), ⋯⟩ = ⊤),\n  ∃ N, HarderNarasimhan.impl.JHFil μ hμ hμsl hst hdc N = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.ext",
   "Set.toFinset_congr",
   "Ring.toNonAssocRing",
   "instLawfulBEq",
   "AddCommGroup.toAddGroup",
   "Submodule.Quotient.module",
   "Submodule.map",
   "Classical.propDecidable",
   "QuotientAddGroup.leftRel",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Submodule.Quotient.instSMul",
   "SMulZeroClass.toSMul",
   "HarderNarasimhan.impl.prop3d12",
   "sub_zero",
   "HarderNarasimhan.DedekindMacNeilleCompletion",
   "AddGroup.toSubtractionMonoid",
   "Submodule.Quotient.instSMul._proof_3",
   "Subtype.coe_inj",
   "Finset.min'",
   "HarderNarasimhan.impl.ss_iff'._proof_26",
   "RingHom.id",
   "CompleteSemilatticeInf.toPartialOrder",
   "Module.IsNoetherian.finite",
   "Eq.symm",
   "HarderNarasimhan.impl.quot_ntl'",
   "HarderNarasimhan.S",
   "HarderNarasimhan.impl.ss_iff'._proof_29",
   "SemilinearMapClass.toMulActionSemiHomClass",
   "Exists",
   "LinearMap.ker",
   "HarderNarasimhan.impl.ss_iff'._proof_28",
   "AddSubgroup.instSetLike",
   "LinearOrder",
   "Submodule.Quotient.mk_smul",
   "HarderNarasimhan.instLatticeInterval",
   "HarderNarasimhan.impl.ss_iff'._proof_17",
   "LinearMap",
   "Ring.toSemiring",
   "eq_false",
   "Iff",
   "SMulMemClass.smul_mem",
   "Submodule.instBot",
   "Top.top",
   "Eq.mpr",
   "HarderNarasimhan.impl.ss_iff'._proof_34",
   "Quotient.out",
   "HarderNarasimhan.Semistable",
   "RelEmbedding.toEmbedding",
   "HasQuotient.Quotient",
   "LinearMap.instFunLike",
   "Module",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.Quotient.instZeroQuotient",
   "HarderNarasimhan.impl.ss_iff'._proof_27",
   "AddCommMonoid.toAddMonoid",
   "HarderNarasimhan.Resμ",
   "Prod.fst",
   "HarderNarasimhan.impl.ss_iff'._proof_32",
   "Ideal.ext",
   "Subtype.property",
   "Eq",
   "HarderNarasimhan.DedekindMacNeilleClosureOperator",
   "AddSubgroupClass.sub",
   "LinearExtension",
   "Set",
   "SubNegMonoid.toNeg",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Set.toFinset",
   "Eq.to_iff",
   "eq_self",
   "Module.toDistribMulAction",
   "AddZeroClass.toAdd",
   "HarderNarasimhan.instPartialOrderS₀",
   "QuotientAddGroup.mk",
   "Ne",
   "instHSub",
   "CompleteLattice.toCompleteSemilatticeInf",
   "HarderNarasimhan.impl.ss_iff'._proof_18",
   "instBEqOfDecidableEq",
   "Quotient.mk''",
   "HarderNarasimhan.μA_res_intvl",
   "Submodule.Quotient.mk",
   "PartialOrder.toPreorder",
   "HarderNarasimhan.impl.ss_iff'._proof_22",
   "instLinearOrderLinearExtensionOfPartialOrder",
   "zero_sub",
   "HarderNarasimhan.μ",
   "Membership.mem",
   "Preorder.toLT",
   "HarderNarasimhan.impl.ss_iff'._proof_19",
   "GT.gt",
   "Algebra.id",
   "RelEmbedding.instFunLike",
   "Submodule.subtype",
   "LinearMap.semilinearMapClass",
   "MulAction.toSMul",
   "not_false_eq_true",
   "Semiring.toNonAssocSemiring",
   "Ne.bot_lt'",
   "HarderNarasimhan.instFintypeElemLinearExtensionPrimeSpectrum_μ",
   "forall_congr",
   "eq_of_heq",
   "DistribMulAction.toMulAction",
   "PrimeSpectrum.instPartialOrder",
   "AddGroup.toSubNegMonoid",
   "beq_eq_beq",
   "Eq.rec",
   "Semiring.toModule",
   "Finset.Nonempty",
   "DistribSMul.toSMulZeroClass",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "AddZeroClass.toZero",
   "HarderNarasimhan.impl.ss_iff'._proof_31",
   "outParam",
   "PrimeSpectrum.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "And.right",
   "Bot.bot",
   "Exists.casesOn",
   "AddSubgroup",
   "isNoetherian_submodule'",
   "HarderNarasimhan.instBoundedOrderInterval._proof_14",
   "Finset.instSingleton",
   "Iff.of_eq",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "LinearMap.toSpanSingleton",
   "associatedPrimes",
   "Submodule.instNontrivial",
   "Subtype.lt",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0._proof_4",
   "Eq.mp",
   "Submodule.module",
   "Submodule.smulMemClass",
   "lt_of_le_of_ne",
   "DFunLike.coe",
   "BoundedOrder.toOrderTop",
   "HarderNarasimhan.instLinearOrderS₀",
   "isNoetherian_of_isNoetherianRing_of_finite",
   "Algebra.toSMul",
   "HarderNarasimhan.Semistable.mk",
   "AddCommSemigroup.toAddCommMagma",
   "Subtype.le",
   "Not",
   "Submodule.mkQ",
   "instHAdd",
   "CompleteAtomicBooleanAlgebra.toCompleteLattice",
   "Submodule.quotientRel",
   "IsAssociatedPrime._proof_1",
   "IsAssociatedPrime",
   "Submodule.sub_mem_iff_left",
   "Submodule.submoduleOf._proof_14",
   "HarderNarasimhan.instBoundedOrderInterval._proof_13",
   "Submodule.add_mem",
   "RingHomSurjective.ids",
   "LT.lt",
   "of_eq_true",
   "le_of_lt",
   "Subtype.instLawfulBEq",
   "False",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_3",
   "Subtype.mk",
   "trivial",
   "OrderTop.toTop",
   "LT",
   "HarderNarasimhan.instCompleteLatticeDedekindMacNeilleCompletion",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Finset",
   "HarderNarasimhan.instBoundedOrderInterval._proof_16",
   "Bot.mk",
   "Submodule.mem_map_of_mem",
   "Eq.trans",
   "Singleton.singleton",
   "LE",
   "Exists.intro",
   "HarderNarasimhan.impl.quot_ntl",
   "instDistribSMul",
   "map_smul",
   "Subtype.val",
   "BoundedOrder.mk",
   "Quotient.out_eq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "iff_self",
   "SubNegMonoid.toSub",
   "letFun",
   "Submodule.addSubgroupClass",
   "HarderNarasimhan.impl.lift_quot._proof_15",
   "Eq.ndrec",
   "rfl",
   "sub_self",
   "HarderNarasimhan.impl.test",
   "ClosureOperator.IsClosed",
   "Submodule.addCommGroup",
   "Prod.snd",
   "lt_iff_le_not_le",
   "Set.instMembership",
   "Prod",
   "Submodule.mem_map",
   "BoundedOrder.toOrderBot",
   "Submodule.comap",
   "Set.instCompleteAtomicBooleanAlgebra",
   "HarderNarasimhan.impl.ss_iff'._proof_21",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "HEq",
   "Set.ext",
   "Subtype.instBEq",
   "Top.mk",
   "CompleteLattice.toBoundedOrder",
   "AddMonoid.toAddZeroClass",
   "setOf",
   "Quotient",
   "Submodule.hasQuotient",
   "Bool",
   "Ne.symm",
   "HarderNarasimhan.coe'",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "and_true",
   "HarderNarasimhan.impl.μ_nonempty",
   "congr",
   "AddCommMagma.toAdd",
   "QuotientAddGroup.mk_out_eq_mul",
   "HarderNarasimhan.impl.ss_iff'._proof_20",
   "HarderNarasimhan._μ",
   "Preorder.toLE",
   "OrderBot.mk",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "OrderTop.mk",
   "HarderNarasimhan.instLinearOrderDedekindMacNeilleCompletion",
   "IsScalarTower.left",
   "HarderNarasimhan.impl.ss_iff'._proof_24",
   "Submodule.mem_comap",
   "Submodule.instTop",
   "HarderNarasimhan.instBoundedOrderInterval._proof_15",
   "HarderNarasimhan.impl.lift_quot._proof_16",
   "AddCommGroup",
   "HarderNarasimhan.impl.ss_iff'._proof_23",
   "HarderNarasimhan.instBoundedOrderInterval",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "PrimeSpectrum",
   "LinearOrder.toPartialOrder",
   "CommRing.toRing",
   "HarderNarasimhan.impl.lift_quot._proof_14",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HarderNarasimhan.ℒ",
   "HarderNarasimhan.μA",
   "HarderNarasimhan._μ._proof_2",
   "Submodule.map_subtype_le",
   "Submodule.completeLattice",
   "HarderNarasimhan.impl.lift_quot",
   "Submodule.smul",
   "HarderNarasimhan.S₀",
   "Submodule.sub_mem_iff_right",
   "bot_lt_top",
   "And.casesOn",
   "Module.Finite",
   "DFunLike",
   "Prod.mk",
   "Ideal.IsPrime",
   "Subtype.mk_lt_mk",
   "Iff.mp",
   "Quotient.mk",
   "AddMonoidWithOne.toAddMonoid",
   "Subtype.GCongr.coe_lt_coe",
   "And.intro",
   "Ring.toAddGroupWithOne",
   "funext",
   "HSub.hSub",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SetLike.instMembership",
   "Neg.neg",
   "DistribMulAction.toDistribSMul",
   "And",
   "Submodule.Quotient.instSMul'",
   "Submodule.toAddSubgroup",
   "Submodule.Quotient.mk_eq_zero",
   "Iff.mpr",
   "HSMul.hSMul",
   "Nontrivial",
   "NegZeroClass.toZero",
   "id",
   "SetLike.coe_mem",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.submoduleOf",
   "Submodule.Quotient.isScalarTower",
   "Submodule.ker_subtype",
   "Subtype",
   "sub_eq_zero",
   "Module.Finite.quotient",
   "Submodule.coe_eq_zero",
   "HarderNarasimhan.impl.ss_iff'._proof_30",
   "Function.Embedding.toFun",
   "Subtype.partialOrder",
   "SubNegZeroMonoid.toSubNegMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "Iff.intro",
   "Submodule",
   "congrArg",
   "Submodule.Quotient.addCommGroup",
   "Subtype.prop",
   "Ideal",
   "MonoidWithZero.toMonoid",
   "HarderNarasimhan.impl.lift_quot_not_bot",
   "instHSMul",
   "Zero.toOfNat0",
   "HarderNarasimhan.Interval",
   "RelEmbedding.instEmbeddingLike",
   "HarderNarasimhan.impl.lift_quot_middle",
   "OrderBot.toBot",
   "HarderNarasimhan.impl.ss_iff'._proof_25",
   "RelEmbedding",
   "Submodule.instOrderBot",
   "Set.instLE",
   "bot_lt_iff_ne_bot",
   "CommRing.toCommSemiring",
   "Lattice.toSemilatticeInf",
   "Submodule.add",
   "HEq.refl",
   "True",
   "_private.HarderNarasimhan.CoprimaryFiltration.Impl.0._proof_2",
   "CommSemiring.toSemiring",
   "HarderNarasimhan.Semistable.semistable",
   "Semiring.toMonoidWithZero",
   "Iff.rfl",
   "CommRing",
   "Eq.casesOn",
   "Submodule.isScalarTower'",
   "exists_prop_congr",
   "HarderNarasimhan.instNontrivialInterval",
   "IsNoetherianRing",
   "AddCommMonoid.toAddCommSemigroup",
   "SubNegMonoid.toAddMonoid",
   "Submodule.setLike",
   "LE.le",
   "Submodule.zero",
   "BEq.beq",
   "Submodule.addCommMonoid"],
  "name": "HarderNarasimhan.impl.ss_iff'",
  "constType":
  "∀ {R : Type} [inst : CommRing R] [inst_1 : IsNoetherianRing R] {M : Type} [inst_2 : Nontrivial M]\n  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : Module.Finite R M] (N₁ N₂ : HarderNarasimhan.ℒ R M)\n  (hN : N₁ < N₂),\n  HarderNarasimhan.Semistable (HarderNarasimhan.Resμ ⟨(N₁, N₂), hN⟩ (HarderNarasimhan.μ R M)) ↔\n    HarderNarasimhan.Semistable (HarderNarasimhan.μ R (↥N₂ ⧸ Submodule.submoduleOf N₁ N₂))",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instAddCommGroup",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "inferInstance",
   "AddMonoid",
   "AddGroup.toSubNegMonoid",
   "Int"],
  "name": "Int.instAddMonoid",
  "constType": "AddMonoid ℤ",
  "constCategory": "Definition"}]