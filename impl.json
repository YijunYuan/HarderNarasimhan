[{"references": ["rfl", "Eq.rec", "Eq"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references": ["Subsingleton.allEq", "Subsingleton", "Eq"],
  "name": "Subsingleton.elim",
  "constType": "∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable", "Classical.propDecidable._proof_3", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "InIntvl",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "S₁I._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (y : ℒ),\n  InIntvl I y → (↑I).1 ≠ y → ((↑I).1, y).1 < ((↑I).1, y).2",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "lt_trans",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "μAstar",
   "Subtype.val",
   "Equiv",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "μBstar",
   "SemilatticeInf.toPartialOrder",
   "impl.prop4d1₂",
   "Exists",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Nontrivial",
   "Lattice",
   "OrderDual.instBoundedOrder",
   "impl.dualμBstar_eq_μAstar",
   "OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "OrderDual.instLattice",
   "impl.h₁_dual_of_h₁",
   "DFunLike.coe",
   "Nat.instPreorder",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "instOfNatNat",
   "OrderDual.instLT",
   "OrderDual.instCompleteLattice",
   "OrderBot.toBot",
   "OrderDual.instPartialOrder",
   "Eq",
   "Preorder.toLE",
   "impl.dualμAstar_eq_μBstar",
   "Lattice.toSemilatticeInf",
   "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "Equiv.instFunLike",
   "instHAdd",
   "impl.h₂_dual_of_h₂",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.prop4d3₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n        μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n      μAstar μ ≤ μBstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["impl.ℒₛ._proof_1",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "Prod.fst",
   "μA",
   "CompleteSemilatticeInf.toPartialOrder",
   "WellFoundedGT",
   "impl.ℒₛ._proof_2",
   "Preorder.toLE",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "impl.ℒₛ",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        [WellFoundedGT ℒ] →\n          {S : Type} →\n            [CompleteLattice S] →\n              ({ p // p.1 < p.2 } → S) → (I : { p // p.1 < p.2 }) → (x : { p // InIntvl I p }) → (↑I).1 ≠ ↑x → Set ℒ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Equiv",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["Int.instCommRing",
   "CommRing.toCommSemiring",
   "CommSemiring",
   "inferInstance",
   "Int"],
  "name": "Int.instCommSemiring",
  "constType": "CommSemiring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["le_top",
   "TotIntvl",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "bot_le",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "And.intro",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "InIntvl",
   "SemilatticeInf.toPartialOrder"],
  "name": "in_TotIntvl",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (x : ℒ), InIntvl TotIntvl x",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Preorder.toLE",
   "GT.gt",
   "le_of_not_lt"],
  "name": "le_of_not_gt",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬a > b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → Coe ({ p // p.1 < p.2 } → S) ({ p // p.1 < p.2 } → Sᵒᵈ)",
  "constCategory": "Definition"},
 {"references": ["OrderDual", "Top", "Bot", "Top.mk", "Bot.bot"],
  "name": "OrderDual.instTop",
  "constType": "(α : Type u) → [Bot α] → Top αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "Nat.recAux",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "absurd",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "Eq.refl",
   "HSub.hSub",
   "Ne",
   "Eq",
   "instHSub"],
  "name": "Nat.sub_one_add_one",
  "constType": "∀ {a : ℕ}, a ≠ 0 → a - 1 + 1 = a",
  "constCategory": "Theorem"},
 {"references": ["Int.lt", "LT.mk", "LT", "Int"],
  "name": "Int.instLTInt",
  "constType": "LT ℤ",
  "constCategory": "Definition"},
 {"references":
  ["instDistribLatticeOfLinearOrder",
   "DistribLattice.toLattice",
   "Lattice",
   "inferInstance",
   "Int.instLinearOrder",
   "Int"],
  "name": "instLatticeInt",
  "constType": "Lattice ℤ",
  "constCategory": "Definition"},
 {"references":
  ["PUnit.unit",
   "Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "OfNat.ofNat",
   "Unit"],
  "name": "impl.prop4d1₁_seq.match_1._cstage1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((k : ℕ) → motive k.succ) → motive k",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Nat",
   "Nat.cast",
   "LE.le",
   "Int.instLEInt",
   "Eq",
   "instLENat",
   "propext",
   "Mathlib.Tactic.Zify.natCast_le",
   "instNatCastInt",
   "Int"],
  "name": "_private.Mathlib.Tactic.Zify.0._proof_2",
  "constType": "∀ (a b : ℕ), (a ≤ b) = (↑a ≤ ↑b)",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "BoundedOrder",
  "constType": "(α : Type u) → [LE α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup.le_sup_left",
   "Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "le_sup_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["contravariant_swap_add_of_contravariant_add",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "AddCommGroup.toAddGroup",
   "Preorder.toLT",
   "HMul.hMul",
   "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
   "GT.gt",
   "AddGroup.toSubtractionMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toNonAssocSemiring",
   "IsCancelAdd.toIsRightCancelAdd",
   "Ring.toAddGroupWithOne",
   "letFun",
   "PartialOrder",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "InvolutiveNeg.toNeg",
   "IsCancelAdd.toIsLeftCancelAdd",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Order.Group.Unbundled.Basic.0._proof_10",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddGroup.existsAddOfLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "IsOrderedAddMonoid.toAddLeftMono",
   "Ring.toSemiring",
   "id",
   "NegZeroClass.toZero",
   "instHMul",
   "Eq.mpr",
   "mul_pos_of_neg_of_neg",
   "covariant_swap_add_of_covariant_add",
   "AddMonoid.toAddZeroClass",
   "Eq.mp",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "neg_of_neg_pos",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "neg_mul",
   "IsOrderedCancelAddMonoid.toAddLeftReflectLT",
   "Zero.toOfNat0",
   "Eq",
   "Preorder.toLE",
   "IsStrictOrderedRing.toIsOrderedCancelAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Distrib.toMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "LT.lt",
   "Ring.toAddCommGroup",
   "NegZeroClass.toNeg",
   "AddGroupWithOne.toAddGroup",
   "HasDistribNeg.toInvolutiveNeg",
   "SubNegMonoid.toAddMonoid",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "neg_neg_of_pos",
   "IsStrictOrderedRing.toMulPosStrictMono",
   "_private.Init.Core.0._proof_39",
   "Ring"],
  "name": "Linarith.mul_neg",
  "constType":
  "∀ {α : Type u} [inst : Ring α] [inst_1 : PartialOrder α] [IsStrictOrderedRing α] {a b : α}, a < 0 → 0 < b → b * a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["le_refl",
   "OrderDual",
   "Preorder",
   "OrderDual.instLT",
   "LE.le",
   "Preorder.toLT",
   "OrderDual.instLE",
   "Preorder.mk",
   "Preorder.toLE",
   "lt_iff_le_not_le",
   "LE.le.trans"],
  "name": "OrderDual.instPreorder",
  "constType": "(α : Type u_5) → [Preorder α] → Preorder αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "SupSet.sSup",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "μmin",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "μmax._proof_2",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "μB",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["absurd", "Not", "False.elim", "False", "Eq", "propext", "Iff.intro"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "instOfNat",
   "Int.negOfNat.match_1",
   "Int.negSucc",
   "OfNat.ofNat",
   "Unit",
   "Int"],
  "name": "Int.negOfNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Eq.mp",
   "Prod.mk",
   "Preorder.toLT",
   "congrArg",
   "Prod.fst",
   "And.intro",
   "inf_top_eq",
   "BoundedOrder.toOrderTop",
   "μA",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "ConvexI",
   "impl.prop2d6₁I",
   "Min.min",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toBoundedOrder",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "impl.prop3d2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (z : ℒ),\n          InIntvl I z →\n            ∀ (h : x < z),\n              μA μ ⟨(x, z), h⟩ = ⊤ → ∀ (a : ℒ), InIntvl I a → ∀ (hax : a < x), μA μ ⟨(a, x), hax⟩ ≤ μA μ ⟨(a, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "le_top",
   "PartialOrder.toPreorder",
   "Iff",
   "PartialOrder",
   "Preorder.toLT",
   "Top.top",
   "LE.le.lt_iff_ne",
   "OrderTop",
   "Ne",
   "Preorder.toLE",
   "OrderTop.toTop"],
  "name": "lt_top_iff_ne_top",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, a < ⊤ ↔ a ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "IsAttained",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "S₁I._proof_2",
   "Membership.mem.out",
   "Subtype.val",
   "IsComparable",
   "And.intro",
   "False.elim",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "not_lt_of_le",
   "Eq.symm",
   "IsTotal.total",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "eq_of_ge_of_not_gt",
   "Exists",
   "Exists.choose_spec",
   "And.right",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "S₂I",
   "Or.inr",
   "Subtype",
   "lt_of_le_of_ne",
   "Prod.fst",
   "le_rfl",
   "impl.prop2d6₃I",
   "Subtype.prop",
   "Or.inl",
   "μA",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "Lattice.toSemilatticeInf",
   "Set",
   "Exists.choose",
   "ConvexI",
   "LT.lt",
   "Or.casesOn",
   "IsTotal",
   "ne_of_lt",
   "le_of_lt",
   "S₁I",
   "LE.le",
   "StI",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.prop3d8₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  ConvexI I μ →\n    ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n        ∀ (z : ℒ) (hzI : InIntvl I z) (hz : (↑I).1 ≠ z), IsAttained μ ⟨((↑I).1, z), ⋯⟩) →\n      ∀ (x : ℒ) (hxSt : x ∈ StI μ I) (y : ℒ), InIntvl I y → ∀ (hxy : x < y), μA μ ⟨((↑I).1, y), ⋯⟩ = μA μ ⟨(x, y), hxy⟩",
  "constCategory": "Theorem"},
 {"references":
  ["impl.ℒₛ._proof_1",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "impl.ℒₛ",
   "Prod.fst",
   "μA",
   "CompleteSemilatticeInf.toPartialOrder",
   "WellFoundedGT",
   "impl.ℒₛ._proof_2",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Exists.choose_spec",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "impl.prop3d4₀func",
   "impl.prop3d4₀func._proof_7",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func._proof_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ)\n  (hbot : ¬(↑I).1 = ↑(impl.prop3d4₀func μ I n)) (hne : (impl.ℒₛ μ I (impl.prop3d4₀func μ I n) hbot).Nonempty),\n  InIntvl I ⋯.choose",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "instLTNat",
   "Nat",
   "Exists",
   "And",
   "Nat.findX",
   "DecidablePred",
   "Subtype.val"],
  "name": "Nat.find",
  "constType": "{p : ℕ → Prop} → [DecidablePred p] → (∃ n, p n) → ℕ",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Iff", "Iff.rfl", "GT.gt", "LT"],
  "name": "gt_iff_lt",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, x > y ↔ y < x",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "True", "trivial", "Decidable.isTrue"],
  "name": "instDecidableTrue",
  "constType": "Decidable True",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "True",
   "Eq.trans",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring",
   "Distrib.toMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "HMul.hMul",
   "add_mul",
   "congrArg",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "instHMul",
   "Eq",
   "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.add_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b c₁ c₂ d : R},\n  a₁ * b = c₁ → a₂ * b = c₂ → c₁ + c₂ = d → (a₁ + a₂) * b = d",
  "constCategory": "Theorem"},
 {"references": ["IsWellOrder", "IsWellFounded"],
  "name": "IsWellOrder.toIsWellFounded",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [self : IsWellOrder α r], IsWellFounded α r",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "instLatticeInterval._proof_9",
   "Preorder.toLT",
   "Lattice.mk",
   "instLatticeInterval._proof_3",
   "instLatticeInterval._proof_12",
   "instLatticeInterval._proof_6",
   "Subtype.val",
   "Prod.fst",
   "PartialOrder.mk",
   "instLatticeInterval._proof_2",
   "instLatticeInterval._proof_4",
   "LT.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "instLatticeInterval._proof_7",
   "Not",
   "Lattice.toSemilatticeInf",
   "instLatticeInterval._proof_10",
   "instLatticeInterval._proof_8",
   "And",
   "BoundedOrder",
   "instLatticeInterval._proof_5",
   "Prod.snd",
   "instLatticeInterval._proof_11",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Interval",
   "instLatticeInterval._proof_1",
   "SemilatticeSup.toMax",
   "Lattice",
   "Nontrivial",
   "LE.mk",
   "LE.le",
   "SemilatticeSup.mk",
   "Subtype.mk",
   "Preorder.mk"],
  "name": "instLatticeInterval",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → Lattice (Interval z)",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "And.right",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Prod.fst",
   "LT.lt",
   "Lattice",
   "SemilatticeInf.toPartialOrder",
   "And.left"],
  "name": "SlopeLike._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (x y z : ℒ), x < y ∧ y < z → (x, z).1 < (x, z).2",
  "constCategory": "Theorem"},
 {"references": ["GetElem", "outParam"],
  "name": "GetElem.getElem",
  "constType":
  "{coll : Type u} →\n  {idx : Type v} →\n    {elem : outParam (Type w)} →\n      {valid : outParam (coll → idx → Prop)} →\n        [self : GetElem coll idx elem valid] → (xs : coll) → (i : idx) → valid xs i → elem",
  "constCategory": "Definition"},
 {"references": [],
  "name": "List",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.le.refl", "LE.le", "instLENat"],
  "name": "Nat.le_refl",
  "constType": "∀ (n : ℕ), n ≤ n",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.fst",
  "constType": "{α : Type u} → {β : Type v} → α × β → α",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toNatCast",
   "NonAssocSemiring.natCast_zero",
   "Semiring.mk",
   "Nat.instSemiring._proof_8",
   "Nat.instNonUnitalSemiring",
   "Nat.instMonoidWithZero",
   "MonoidWithZero",
   "NonAssocSemiring.one_mul",
   "Nat",
   "Nat.instSemiring._proof_9",
   "NonAssocSemiring.mul_one",
   "Nat.instNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring",
   "NonUnitalSemiring",
   "Monoid.npow",
   "Semiring",
   "NonAssocSemiring.natCast_succ"],
  "name": "Nat.instSemiring",
  "constType": "Semiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["ConditionallyCompleteLinearOrderBot",
   "CompleteLinearOrder.toDecidableLE",
   "Lattice.toSemilatticeSup",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_5",
   "CompleteLinearOrder.toDecidableEq",
   "CompleteLattice.toBot",
   "PartialOrder.toPreorder",
   "ConditionallyCompleteLinearOrder.mk",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_7",
   "SemilatticeSup.toPartialOrder",
   "CompleteLinearOrder.toDecidableLT",
   "CompleteLinearOrder.compare_eq_compareOfLessAndEq",
   "ConditionallyCompleteLinearOrderBot.mk",
   "CompleteLinearOrder.le_total",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_8",
   "ConditionallyCompleteLattice",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot._proof_6",
   "CompleteLinearOrder.toCompleteLattice",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLinearOrder",
   "Preorder.toLE",
   "CompleteLinearOrder.toOrd",
   "OrderBot.mk",
   "CompleteLattice.toConditionallyCompleteLattice"],
  "name": "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
  "constType":
  "{α : Type u_5} → [h : CompleteLinearOrder α] → ConditionallyCompleteLinearOrderBot α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "PartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "LT.lt",
   "Prod",
   "CompleteSemilatticeInf.toInfSet",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "μmin",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable.not_imp_symm", "Decidable"],
  "name": "Not.decidable_imp_symm",
  "constType": "∀ {a b : Prop} [Decidable a], (¬a → b) → ¬b → a",
  "constCategory": "Theorem"},
 {"references": ["NatCast.mk", "Nat", "NatCast", "Int.ofNat", "Int"],
  "name": "instNatCastInt",
  "constType": "NatCast ℤ",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Ring.toNonAssocRing",
   "Bool.false",
   "Classical.propDecidable",
   "AddGroupWithOne.toAddMonoidWithOne",
   "S₁I._proof_2",
   "Int.instCommSemiring",
   "le_of_not_gt",
   "CompleteSemilatticeInf.toPartialOrder",
   "Int.instLTInt",
   "Subtype.coe_eta",
   "Eq.symm",
   "Nat.sub_one_add_one",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instLatticeInt",
   "instLTNat",
   "Exists",
   "_private.Mathlib.Tactic.Zify.0._proof_2",
   "inf_eq_right",
   "ne_of_gt",
   "BoundedOrder",
   "Ring.toSemiring",
   "Linarith.mul_neg",
   "instOfNat",
   "impl.prop3d4₀func",
   "eq_false",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Int.negOfNat",
   "Int.instCharZero",
   "impl.prop3d4₀func_len_nonzero",
   "Nat.find",
   "Mathlib.Tactic.Ring.add_mul",
   "Nat.le_refl",
   "Nat.one_le_iff_ne_zero",
   "Prod.fst",
   "Int.instIsStrictOrderedRing",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Eq",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Set",
   "Int.instIsOrderedAddMonoid",
   "instOfNatAtLeastTwo",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.mul_congr",
   "lt_of_lt_of_le",
   "Nat.cast_add",
   "eq_self",
   "Monoid.toNatPow",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "not_false_eq_true",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "PartialOrder",
   "forall_congr",
   "Int.instLEInt",
   "AddGroup.toSubNegMonoid",
   "Int.ofNat",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "And.right",
   "lt_of_le_of_lt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_zero",
   "Nat",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidWithOne.toNatCast",
   "ge_of_eq",
   "Nat.lt_of_le_sub_one",
   "impl.prop3d4₀func_len",
   "S₂I",
   "SemilatticeInf.toMin",
   "Nat.cast",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "CommRing.toNonUnitalCommRing",
   "μA",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Not",
   "Set.Nonempty",
   "μDCC",
   "instHAdd",
   "Prod.mk.eta",
   "Distrib.toMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.add_congr",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.neg_add",
   "of_eq_true",
   "ne_of_lt",
   "instSubNat",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_lt",
   "S₁I",
   "Linarith.zero_lt_one",
   "SemilatticeSup.toMax",
   "False",
   "Subtype.mk",
   "ge_trans",
   "Linarith.natCast_nonneg",
   "_private.Init.Core.0._proof_39",
   "instAddNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq.trans",
   "Exists.intro",
   "Subtype.val",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "impl.prop3d4₀func_fin_len",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "letFun",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "SubNegMonoid.toSub",
   "Nat.decreasingInduction",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.sub_pf",
   "Eq.ndrec",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Nat.recAux",
   "impl.prop3d4₀func_defprop1",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "instNonemptyOfInhabited",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Nat.add_lt_of_lt_sub",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Linarith.add_lt_of_neg_of_le",
   "Bool",
   "_private.Init.PropLemmas.0._proof_17",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.add_one_le_iff",
   "Int.instRing",
   "Nat.instPreorder",
   "impl.prop3d4₀func_defprop2",
   "le_rfl",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Int.instAddCommGroup",
   "instOfNatNat",
   "congr",
   "Int.instAdd",
   "WellFoundedGT",
   "Mathlib.Tactic.Ring.mul_add",
   "sup_le_iff",
   "Preorder.toLE",
   "Linarith.lt_irrefl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Distrib.toAdd",
   "IsStrictOrderedRing.toIsOrderedRing",
   "Linarith.sub_nonpos_of_le",
   "OfNat.ofNat",
   "Int",
   "HAdd.hAdd",
   "impl.prop3d4₀func_defprop3",
   "LinearOrder.toPartialOrder",
   "Max.max",
   "AddGroupWithOne.toAddGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "instIsIrreflGt",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nat.le_of_succ_le",
   "StI",
   "neg_neg_of_pos",
   "right_lt_sup",
   "dite",
   "Nat.find_min",
   "_private.Mathlib.Tactic.Zify.0._proof_3",
   "Nat.cast_one",
   "Mathlib.Tactic.Ring.zero_mul",
   "Lattice.toSemilatticeSup",
   "Int.instCommRing",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "impl.prop3d4₀func_strict_decreasing",
   "Prod.mk",
   "_private.Init.Core.0._proof_38",
   "Nat.sub_one_lt",
   "Iff.mp",
   "HMul.hMul",
   "Int.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "And.intro",
   "Mathlib.Meta.NormNum.isNat_add",
   "Ring.toAddGroupWithOne",
   "impl.prop3d4₀func_defprop3₀",
   "Nat.sub_add_cancel",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.zero_lt_of_ne_zero",
   "Nat.instLinearOrder",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "instHPow",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "And",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Decidable.byContradiction",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instHMul",
   "instNatAtLeastTwo",
   "ConditionallyCompleteLattice.toLattice",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Subtype",
   "impl.prop3d4₀func_helper",
   "SemilatticeSup.toPartialOrder",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.neg_mul",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "irrefl",
   "Subtype.prop",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "impl.prop2d8₁I",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.sub_congr",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.cast_zero",
   "InIntvl",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Mathlib.Tactic.Ring.of_eq",
   "Lattice.toSemilatticeInf",
   "True",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "gt_of_ge_of_gt",
   "ConvexI",
   "NegZeroClass.toNeg",
   "Min.min",
   "Int.instSemiring",
   "LE.le",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "instLENat",
   "Int.instAddMonoid",
   "instInhabitedTrue"],
  "name": "impl.prop3d4",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  μDCC μ → ∀ (I : { p // p.1 < p.2 }), ConvexI I μ → (StI μ I).Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "S₁I._proof_2",
   "GT.gt",
   "Membership.mem.out",
   "Subtype.val",
   "And.intro",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "eq_of_ge_of_not_gt",
   "Exists",
   "Exists.choose_spec",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "impl.prop2d6₁I",
   "Iff.of_eq",
   "Iff.mpr",
   "Eq.refl",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "ConditionallyCompleteLattice.toLattice",
   "Mathlib.Tactic.PushNeg.not_implies_eq",
   "S₂I",
   "SemilatticeInf.toMin",
   "Subtype",
   "Eq.mp",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "le_rfl",
   "Subtype.prop",
   "μA",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Not",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "Lattice.toSemilatticeInf",
   "Set",
   "Mathlib.Tactic.PushNeg.not_forall_eq",
   "Exists.choose",
   "inf_eq_left",
   "exists_prop_congr",
   "not_le_of_gt",
   "ConvexI",
   "LT.lt",
   "ne_of_lt",
   "le_of_lt",
   "Min.min",
   "S₁I",
   "LE.le",
   "StI",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "And.casesOn"],
  "name": "impl.prop3d7₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  ConvexI I μ →\n    ∀ (x : ℒ) (hxSt : x ∈ StI μ I) (y : ℒ), InIntvl I y → ∀ (hy : y > x), ¬μA μ ⟨((↑I).1, x), ⋯⟩ ≤ μA μ ⟨(x, y), hy⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "Unit.unit",
   "OfNat.ofNat",
   "Unit"],
  "name": "impl.prop4d1₁_seq.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((k : ℕ) → motive k.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "True",
   "Eq.trans",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "OfNat.ofNat",
   "congrArg",
   "Ring.toAddCommGroup",
   "eq_self",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NegZeroClass.toNeg",
   "of_eq_true",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NegZeroClass.toZero",
   "Zero.toOfNat0",
   "neg_zero",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_zero",
  "constType": "∀ {R : Type u_2} [inst : Ring R], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "le_top",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "Nat.lt_add_one",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "Lattice",
   "Top.top",
   "OrderTop.toTop",
   "StrictMono"],
  "name": "prop_4_1_cond₁._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (x : ℕ → ℒ), StrictMono x → ∀ (N : ℕ), (x N, ⊤).1 < (x N, ⊤).2",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "IsAttained",
   "lt_sup_of_lt_right",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "sup_le",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "IsComparable",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "IsTotal.total",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "Exists.choose_spec",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "S₂I",
   "Or.inr",
   "Subtype",
   "SemilatticeSup.toPartialOrder",
   "IsTotal.mk",
   "lt_of_le_of_ne",
   "Prod.fst",
   "le_rfl",
   "Subtype.prop",
   "Or.inl",
   "μA",
   "WellFoundedGT",
   "sup_le_iff",
   "Eq",
   "Preorder.toLE",
   "Subtype.le",
   "InIntvl",
   "Lattice.toSemilatticeInf",
   "eq_of_le_of_not_lt",
   "impl.prop2d8₂I",
   "Set",
   "Exists.choose",
   "le_sup_of_le_left",
   "Or.casesOn",
   "ConvexI",
   "LT.lt",
   "IsTotal",
   "Max.max",
   "ne_of_lt",
   "le_of_lt",
   "S₁I",
   "LE.le",
   "SemilatticeSup.toMax",
   "StI",
   "Ne",
   "Subtype.mk",
   "Subtype.casesOn",
   "CompleteLattice.toCompleteSemilatticeInf",
   "lt_sup_of_lt_left",
   "CompleteLattice"],
  "name": "impl.prop3d8₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  ConvexI I μ →\n    ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n        ∀ (z : ℒ) (hzI : InIntvl I z) (hz : (↑I).1 ≠ z), IsAttained μ ⟨((↑I).1, z), ⋯⟩) →\n      IsTotal ↑(StI μ I) fun x1 x2 => x1 ≤ x2",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "TotIntvl",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "μAstar",
   "Subtype.val",
   "in_TotIntvl",
   "And.intro",
   "SupSet.sSup",
   "sSup_le",
   "funext",
   "TotIntvl._proof_1",
   "Eq.rec",
   "impl.prop4d1₁",
   "μBstar",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "prop_4_1_cond₂",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "μmax._proof_2",
   "Iff",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Ne.symm",
   "Subtype",
   "Eq.mp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "prop_4_1_cond₁",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Iff.intro",
   "Prod.fst",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "bot_ne_top",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "propext",
   "μmin",
   "Not",
   "NashEquilibrium",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "le_sSup",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "impl.rmk4d10₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  prop_4_1_cond₁ μ →\n    prop_4_1_cond₂ μ → (NashEquilibrium μ ↔ ∀ (y : ℒ) (hy : y ≠ ⊥), μmin μ ⟨(⊥, y), ⋯⟩ ≤ μmin μ TotIntvl)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "True",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "SemilatticeInf",
   "eq_self",
   "of_eq_true",
   "Min.min",
   "inf_of_le_left",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_idem",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] (a : α), a ⊓ a = a",
  "constCategory": "Theorem"},
 {"references":
  ["IsOrderedAddMonoid.mk",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "instHAdd",
   "congrArg",
   "Int",
   "HAdd.hAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "IsOrderedAddMonoid",
   "Int.add_le_add_left",
   "LE.le",
   "id",
   "Int.instAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Eq.mpr",
   "Eq",
   "Preorder.toLE",
   "add_comm",
   "SemilatticeInf.toPartialOrder",
   "instLatticeInt"],
  "name": "Int.instIsOrderedAddMonoid",
  "constType": "IsOrderedAddMonoid ℤ",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Eq.symm", "Eq.rec", "Eq", "LT"],
  "name": "lt_of_eq_of_lt",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LT α], a = b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "And",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "SemilatticeInf",
   "le_antisymm_iff",
   "iff_self",
   "of_eq_true",
   "Min.min",
   "congr",
   "Iff",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "_private.Mathlib.Order.Lattice.0._proof_18",
   "_private.Mathlib.Order.Lattice.0._proof_16",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_eq_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = a ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Subtype.prop",
   "Or",
   "OrderDual.instLT",
   "OrderDual.instTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instLE",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "OrderDual.instPreorder",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.h₂_dual_of_h₂",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  {μ : { p // p.1 < p.2 } → S},\n  (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1), μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n      (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) z ≤ (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨((↑z).1, ⊤), ⋯⟩ ∨\n        (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨((↑z).2, ⊤), hz⟩ ≤ (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨((↑z).1, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["CompletelyDistribLattice", "CompleteLattice"],
  "name": "CompletelyDistribLattice.toCompleteLattice",
  "constType":
  "{α : Type u} → [self : CompletelyDistribLattice α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references": ["PUnit", "Nat", "Nat.rec", "PProd"],
  "name": "Nat.below",
  "constType": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "le_of_eq", "Preorder.toLE", "Eq"],
  "name": "Eq.le",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLT",
   "not_lt_of_le",
   "Preorder.toLE"],
  "name": "LE.le.not_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a",
  "constCategory": "Theorem"},
 {"references":
  ["bot_lt_iff_ne_bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Lattice",
   "Ne",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "semistable._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (x : ℒ), x ≠ ⊥ → ⊥ < (⊥, x).2",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "Exists",
   "Prod.mk",
   "IsAttained._proof_4",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "μA",
   "PartialOrder",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "μmax",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice"],
  "name": "IsAttained",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Iff", "Membership.mem", "Iff.rfl", "Set.instMembership"],
  "name": "Set.mem_def",
  "constType": "∀ {α : Type u} {a : α} {s : Set α}, a ∈ s ↔ s a",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Nat.rawCast",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat"],
  "name": "Mathlib.Meta.NormNum.IsNat.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] (n : ℕ), Mathlib.Meta.NormNum.IsNat n.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["not_imp_not",
   "WellFounded",
   "Not",
   "WellFounded.has_min.match_1",
   "Set.Nonempty",
   "Exists",
   "Set",
   "Membership.mem",
   "Iff.mp",
   "And",
   "Exists.intro",
   "Set.instMembership",
   "Acc",
   "And.intro",
   "letFun",
   "Acc.recOn",
   "WellFounded.apply"],
  "name": "WellFounded.has_min",
  "constType":
  "∀ {α : Type u_4} {r : α → α → Prop}, WellFounded r → ∀ (s : Set α), s.Nonempty → ∃ a ∈ s, ∀ x ∈ s, ¬r x a",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.rawCast",
   "Int",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.IsInt.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : Ring α] (n : ℤ), Mathlib.Meta.NormNum.IsInt n.rawCast n",
  "constCategory": "Theorem"},
 {"references": ["semiOutParam"],
  "name": "Coe",
  "constType": "semiOutParam (Sort u) → Sort v → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references": ["Preorder", "LT"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u_2} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "μA",
   "PartialOrder",
   "Nontrivial",
   "Top.top",
   "OrderBot.toBot",
   "Subtype.mk",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "μAstar",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → S",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "AddCommMonoid",
   "inferInstance",
   "Nat.instAddCancelCommMonoid",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "Nat.instAddCommMonoid",
  "constType": "AddCommMonoid ℕ",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Monotone",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Not", "False.elim", "True", "False", "eq_true", "Eq"],
  "name": "not_false_eq_true",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references": ["rfl", "funext", "Eq.rec", "Eq"],
  "name": "forall_congr",
  "constType":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references": ["Int.le", "LE.mk", "LE", "Int"],
  "name": "Int.instLEInt",
  "constType": "LE ℤ",
  "constCategory": "Definition"},
 {"references": ["Iff", "Membership.mem", "List.instMembership", "List"],
  "name": "List.TFAE",
  "constType": "List Prop → Prop",
  "constCategory": "Definition"},
 {"references": ["Top", "CompleteLattice"],
  "name": "CompleteLattice.toTop",
  "constType": "{α : Type u_8} → [self : CompleteLattice α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["impl.ℒₛ._proof_1",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "impl.ℒₛ",
   "Prod.fst",
   "μA",
   "CompleteSemilatticeInf.toPartialOrder",
   "impl.prop3d4₀func._proof_5",
   "WellFoundedGT",
   "impl.ℒₛ._proof_2",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Exists.choose_spec",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ) (x : Nat.below n.succ)\n  (hbot : ¬(↑I).1 = ↑x.1) (hne : (impl.ℒₛ μ I x.1 hbot).Nonempty), InIntvl I ⋯.choose",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a ⋯ → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references": ["Not", "False.elim", "Eq.mp", "False", "Eq"],
  "name": "of_eq_false",
  "constType": "∀ {p : Prop}, p = False → ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Membership.mem",
   "And",
   "sInf_le_of_le",
   "CompleteSemilatticeInf",
   "Set.instMembership",
   "CompleteSemilatticeInf.toInfSet",
   "sInf_le_sInf_of_forall_exists_le.match_1",
   "LE.le",
   "CompleteSemilatticeInf.toPartialOrder",
   "InfSet.sInf",
   "le_sInf",
   "Preorder.toLE"],
  "name": "sInf_le_sInf_of_forall_exists_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s t : Set α}, (∀ x ∈ s, ∃ y ∈ t, y ≤ x) → sInf t ≤ sInf s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Real",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["AddZeroClass", "Zero"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Preorder",
   "le_of_lt",
   "not_le_of_lt",
   "le_trans",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLT",
   "Preorder.toLE"],
  "name": "lt_of_le_of_lt",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubset",
   "HasSubset.Subset",
   "Set",
   "Set.setOf_subset_setOf",
   "Eq",
   "propext",
   "setOf"],
  "name": "_private.Mathlib.Data.Set.Basic.0._proof_18",
  "constType":
  "∀ {α : Type u} {p q : α → Prop}, ({a | p a} ⊆ {a | q a}) = ∀ (a : α), p a → q a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "And.right",
   "Preorder.toLT",
   "And",
   "Prod.snd",
   "lt_of_le_of_ne",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "PartialOrder",
   "LE.le",
   "Ne",
   "Preorder.toLE",
   "InIntvl",
   "And.left"],
  "name": "μA._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (I : { p // p.1 < p.2 }) (a : ℒ),\n  InIntvl I a ∧ a ≠ (↑I).2 → (a, (↑I).2).1 < (a, (↑I).2).2",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "Top",
   "OrderDual.instTop",
   "LE",
   "OrderTop",
   "bot_le",
   "OrderDual.instLE",
   "OrderBot.toBot",
   "inferInstanceAs",
   "OrderBot",
   "OrderTop.mk"],
  "name": "OrderDual.instOrderTop",
  "constType": "(α : Type u) → [inst : LE α] → [OrderBot α] → OrderTop αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Nat.exists_eq_add_of_le",
   "Nat",
   "CanonicallyOrderedAdd.mk",
   "ExistsAddOfLE.mk",
   "CanonicallyOrderedAdd",
   "Nat.le_add_right",
   "instLENat"],
  "name": "Nat.instCanonicallyOrderedAdd",
  "constType": "CanonicallyOrderedAdd ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "AddZeroClass.toZero",
   "AddZeroClass.toAdd",
   "AddZeroClass",
   "instHAdd",
   "Zero.toOfNat0",
   "Eq",
   "OfNat.ofNat",
   "AddZeroClass.zero_add"],
  "name": "zero_add",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "Nat.cast",
   "Eq.trans",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroOneClass.toMulOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Nat.instAddMonoidWithOne",
   "pow_one",
   "Semiring.toNonAssocSemiring",
   "instOfNatNat",
   "congr",
   "MonoidWithZero.toMonoid",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "instHPow",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Distrib.toMul",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "mul_one",
   "add_zero",
   "HPow.hPow",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "of_eq_true",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "AddMonoidWithOne.toOne",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Nat.rawCast",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.atom_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Exists.intro",
   "sup_le",
   "Subtype.val",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "inf_le_left",
   "ConditionallyCompleteLattice.toLattice",
   "setOf",
   "inf_le_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "impl.lem2d4₂I",
   "Prod.fst",
   "le_inf",
   "μA",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_sInf_iff",
   "Set",
   "sInf_le",
   "ConvexI",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "le_of_lt",
   "Min.min",
   "impl.lem2d4₁",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "dite",
   "CompleteLattice"],
  "name": "impl.prop2d6₁I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (y : ℒ),\n          InIntvl I y →\n            ∀ (z : ℒ), InIntvl I z → ∀ (h : x < y ∧ y < z), μA μ ⟨(x, y), ⋯⟩ ⊓ μA μ ⟨(y, z), ⋯⟩ ≤ μA μ ⟨(x, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Preorder", "LE.le", "le_of_eq", "Eq.symm", "Preorder.toLE", "Eq"],
  "name": "ge_of_eq",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] {a b : α}, a = b → b ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Option",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "impl.ℒₛ",
   "Prod.fst",
   "IsWellFounded.wf",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "impl.prop3d4₀func",
   "Lattice",
   "Nontrivial",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func._proof_7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ)\n  (hbot : ¬(↑I).1 = ↑(impl.prop3d4₀func μ I n)),\n  (impl.ℒₛ μ I (impl.prop3d4₀func μ I n) hbot).Nonempty →\n    ∃ a ∈ impl.ℒₛ μ I (impl.prop3d4₀func μ I n) hbot, ∀ x ∈ impl.ℒₛ μ I (impl.prop3d4₀func μ I n) hbot, ¬x > a",
  "constCategory": "Theorem"},
 {"references":
  ["ConditionallyCompleteLinearOrderBot", "ConditionallyCompleteLinearOrder"],
  "name":
  "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLinearOrderBot α] → ConditionallyCompleteLinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "PartialOrder.toPreorder",
   "Or",
   "LE.le",
   "LinearOrder",
   "Preorder.toLE",
   "LinearOrder.le_total"],
  "name": "le_total",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "LT.lt",
   "Min.min",
   "Iff.mpr",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "inf_lt_left"],
  "name": "ConvexI._proof_1",
  "constType": "∀ {ℒ : Type} [inst : Lattice ℒ] (x y : ℒ), ¬x ≤ y → x ⊓ y < x",
  "constCategory": "Theorem"},
 {"references": ["Prod.forall", "Prod", "Prod.mk", "Eq", "propext"],
  "name": "_private.Init.Data.Prod.0._proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β → Prop}, (∀ (x : α × β), p x) = ∀ (a : α) (b : β), p (a, b)",
  "constCategory": "Theorem"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name":
  "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder._proof_17",
   "CompleteSemilatticeSup.toSupSet",
   "OmegaCompletePartialOrder",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "CompleteLattice.instOmegaCompletePartialOrder._proof_16",
   "Nat",
   "iSup",
   "CompleteSemilatticeInf.toPartialOrder",
   "OmegaCompletePartialOrder.Chain.instFunLikeNat",
   "OmegaCompletePartialOrder.Chain",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OmegaCompletePartialOrder.mk",
   "CompleteLattice"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder",
  "constType":
  "{α : Type u_2} → [CompleteLattice α] → OmegaCompletePartialOrder α",
  "constCategory": "Definition"},
 {"references": ["SemilatticeInf", "SemilatticeInf.inf", "Min", "Min.mk"],
  "name": "SemilatticeInf.toMin",
  "constType": "{α : Type u} → [SemilatticeInf α] → Min α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.rec", "Eq"],
  "name": "impl.stupid_helper",
  "constType": "∀ {α : Type} {a b c d : α}, a = b → b = c → c = d → a = d",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toNonUnitalCommRing._proof_27",
   "AddGroup.mk",
   "Ring.toSub",
   "NonUnitalNonAssocSemiring.toMul",
   "CommRing.toNonUnitalCommRing._proof_33",
   "AddCommMonoid.toAddMonoid",
   "CommRing.toNonUnitalCommRing._proof_32",
   "CommRing.toNonUnitalCommRing._proof_31",
   "NonUnitalCommRing",
   "CommRing.toNonUnitalCommRing._proof_28",
   "AddCommGroup.mk",
   "CommRing.toNonUnitalCommRing._proof_29",
   "CommRing.toNonUnitalCommRing._proof_36",
   "CommRing.toNonUnitalCommRing._proof_34",
   "SubNegMonoid.mk",
   "CommRing.toNonUnitalCommRing._proof_35",
   "Semiring.toNonUnitalSemiring",
   "Ring.toNeg",
   "Ring.zsmul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommRing",
   "NonUnitalNonAssocRing.mk",
   "NonUnitalCommRing.mk",
   "Ring.toSemiring",
   "CommRing.toNonUnitalCommRing._proof_30",
   "CommRing.toRing",
   "NonUnitalRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toNonUnitalCommRing._proof_26",
   "CommRing.mul_comm"],
  "name": "CommRing.toNonUnitalCommRing",
  "constType": "{α : Type u} → [s : CommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references": ["Exists", "Set", "Eq", "setOf"],
  "name": "Set.range",
  "constType": "{α : Type u} → {ι : Sort u_1} → (ι → α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._cstage1",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → Coe ({ p // p.1 < p.2 } → S) ({ p // p.1 < p.2 } → Sᵒᵈ)",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Or.inr",
   "Decidable",
   "Eq.mpr_not",
   "Decidable.em",
   "Eq.mpr_prop",
   "congrArg",
   "Or.casesOn",
   "dif_pos",
   "Or",
   "Or.inl",
   "Eq.refl",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "dif_neg",
   "Eq.rec",
   "Eq",
   "dite"],
  "name": "dite_congr",
  "constType":
  "∀ {b c : Prop} {α : Sort u_1} {x : Decidable b} [inst : Decidable c] {x_1 : b → α} {u : c → α} {y : ¬b → α} {v : ¬c → α}\n  (h₁ : b = c), (∀ (h : c), x_1 ⋯ = u h) → (∀ (h : ¬c), y ⋯ = v h) → dite b x_1 y = dite c u v",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "IsAttained",
   "Prod.mk",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Exists.intro",
   "sup_le",
   "Subtype.val",
   "IsComparable",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Prod",
   "Exists.casesOn",
   "Classical.or_iff_not_imp_left",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "setOf",
   "SemilatticeInf.toMin",
   "impl.prop2d6₂I₂",
   "Or.inr",
   "Subtype",
   "Ne.symm",
   "le_trans",
   "Or.resolve_right",
   "impl.lem2d4₂I",
   "lt_of_le_of_ne",
   "Prod.fst",
   "eq_of_le_of_le",
   "le_inf",
   "Or.inl",
   "μA",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "IsAttained._proof_4",
   "impl.comparable_iff",
   "sInf_le",
   "ConvexI",
   "LT.lt",
   "Or.casesOn",
   "impl.prop2d6₂I₁",
   "impl.prop2d6₀",
   "le_of_lt",
   "Min.min",
   "impl.lem2d4₁",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "μmax",
   "CompleteLattice"],
  "name": "impl.prop2d6₃I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (y : ℒ),\n          InIntvl I y →\n            ∀ (z : ℒ),\n              InIntvl I z →\n                ∀ (h : x < y ∧ y < z),\n                  IsComparable (μA μ ⟨(x, y), ⋯⟩) (μA μ ⟨(y, z), ⋯⟩) ∨ IsAttained μ ⟨(x, z), ⋯⟩ →\n                    μA μ ⟨(y, z), ⋯⟩ = μA μ ⟨(x, z), ⋯⟩ ∨\n                      μA μ ⟨(x, y), ⋯⟩ ≤ μA μ ⟨(x, z), ⋯⟩ ∧ μA μ ⟨(x, z), ⋯⟩ < μA μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["OrderDual", "Nontrivial"],
  "name": "OrderDual.instNontrivial",
  "constType": "∀ {α : Type u_1} [h : Nontrivial α], Nontrivial αᵒᵈ",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "Prod.mk",
   "Coe",
   "Preorder.toLT",
   "Coe.mk",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references": ["LE", "OrderTop", "BoundedOrder"],
  "name": "BoundedOrder.toOrderTop",
  "constType":
  "{α : Type u} → {inst : LE α} → [self : BoundedOrder α] → OrderTop α",
  "constCategory": "Definition"},
 {"references":
  ["le_refl",
   "Preorder",
   "LE.le",
   "id",
   "Eq.mpr",
   "Preorder.toLE",
   "Eq",
   "congrArg"],
  "name": "le_of_eq",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["AddCommMonoidWithOne", "AddMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_2} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "of_eq_false",
   "Decidable",
   "Eq.trans",
   "True",
   "Eq.mpr_not",
   "dite_congr",
   "Eq.mpr_prop",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "Eq.refl",
   "False",
   "instDecidableFalse",
   "Eq",
   "dite",
   "not_false"],
  "name": "dite_cond_eq_false",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} {t : c → α} {e : ¬c → α} (h : c = False), dite c t e = e ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "BoundedOrder",
   "subsingleton_of_bot_eq_top",
   "Bot.bot",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "not_subsingleton",
   "PartialOrder",
   "Nontrivial",
   "Top.top",
   "Ne",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop"],
  "name": "bot_ne_top",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : BoundedOrder α] [Nontrivial α], ⊥ ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["PUnit.unit",
   "Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "OfNat.ofNat",
   "Unit"],
  "name": "impl.prop3d4₀func.match_1._cstage1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["TotIntvl",
   "Eq.trans",
   "Exists.intro",
   "S₁I._proof_2",
   "Membership.mem.out",
   "Subtype.val",
   "in_TotIntvl",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "SupSet.sSup",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Subtype.coe_eta",
   "Eq.symm",
   "Eq.ndrec",
   "μBstar",
   "Exists",
   "Exists.choose_spec",
   "BoundedOrder",
   "Prod.snd",
   "semistableI",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Eq.mpr",
   "setOf",
   "Ne.symm",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "_private.Mathlib.Order.Defs.LinearOrder.0._proof_1",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext",
   "μmin",
   "Set",
   "CompletelyDistribLattice.toCompleteLattice",
   "LinearOrder.toPartialOrder",
   "Ne",
   "μmax",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "bot_lt_top",
   "impl.semistable_iff",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "sSup_le_sSup_of_forall_exists_le",
   "Membership.mem",
   "_private.Init.Core.0._proof_38",
   "Preorder.toLT",
   "Iff.mp",
   "GT.gt",
   "μAstar",
   "And.intro",
   "sSup_le",
   "PartialOrder",
   "CompleteLinearOrder",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "impl.rmk4d10₀",
   "sInf_le_sInf_of_forall_exists_le",
   "And.right",
   "And",
   "μA._proof_3",
   "Bot.bot",
   "Exists.casesOn",
   "μmax._proof_2",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "S₂I",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "semistable",
   "lt_of_le_of_ne",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "μA",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "InIntvl",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Prod.mk.eta",
   "Exists.choose",
   "LT.lt",
   "S₁I",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "_private.Init.Core.0._proof_39",
   "OrderTop.toTop"],
  "name": "impl.prop4d18₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S), semistable μ → μBstar μ ≤ μAstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Or",
   "Iff",
   "And",
   "Classical.propDecidable",
   "Decidable.not_and_iff_not_or_not"],
  "name": "not_and_or",
  "constType": "∀ {a b : Prop}, ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "μAstar",
   "Subtype.val",
   "Equiv",
   "in_TotIntvl",
   "And.intro",
   "SupSet.sSup",
   "funext",
   "Eq.symm",
   "Eq.rec",
   "μBstar",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "μmax._proof_2",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Set.ext",
   "Eq.mpr",
   "OrderDual.instBoundedOrder",
   "setOf",
   "OrderDual",
   "OrderDual.toDual",
   "Ne.symm",
   "Subtype",
   "OrderDual.instLattice",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "Iff.intro",
   "congrArg",
   "OrderDual.ofDual",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "OrderDual.instLT",
   "BoundedOrder.toOrderTop",
   "congr",
   "InfSet.sInf",
   "OrderDual.instCompleteLattice",
   "OrderDual.instPartialOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "μmin",
   "Not",
   "_private.Mathlib.Order.Synonym.0._proof_6",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "Set",
   "exists_prop_congr",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "ConditionallyCompleteLattice.toSupSet",
   "μmax",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "impl.dualμAstar_eq_μBstar",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  OrderDual.ofDual ((μAstar fun p => OrderDual.toDual (μ ⟨((↑p).2, (↑p).1), ⋯⟩)) = μBstar μ)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.le_top", "LE.le", "Top.top", "LE", "OrderTop", "OrderTop.toTop"],
  "name": "le_top",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "Equiv.instFunLike",
   "Iff",
   "LE.le",
   "LE",
   "OrderDual.instLE",
   "Iff.rfl",
   "DFunLike.coe",
   "Equiv",
   "OrderDual.ofDual"],
  "name": "OrderDual.ofDual_le_ofDual",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {a b : αᵒᵈ}, OrderDual.ofDual a ≤ OrderDual.ofDual b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "IsAttained",
   "Prod.mk",
   "Preorder.toLT",
   "sup_le",
   "Subtype.val",
   "IsComparable",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "impl.prop2d8₀I",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Exists.casesOn",
   "Prod",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "ConditionallyCompleteLattice.toLattice",
   "inf_comm",
   "SemilatticeInf.toMin",
   "Or.inr",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "Or.inl",
   "μA",
   "impl.prop2d8₁I",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Lattice.toSemilatticeInf",
   "IsAttained._proof_4",
   "inf_eq_left",
   "ConvexI",
   "LT.lt",
   "Or.casesOn",
   "Max.max",
   "Min.min",
   "SemilatticeSup.toMax",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "μmax",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "lt_sup_of_lt_left"],
  "name": "impl.prop2d8₂I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (y : ℒ),\n          InIntvl I y →\n            ∀ (u : ℒ),\n              InIntvl I u →\n                ∀ (h : u < x ∧ u < y),\n                  IsComparable (μA μ ⟨(u, x), ⋯⟩) (μA μ ⟨(u, y), ⋯⟩) ∨ IsAttained μ ⟨(u, x ⊔ y), ⋯⟩ →\n                    μA μ ⟨(u, x), ⋯⟩ ≤ μA μ ⟨(u, x ⊔ y), ⋯⟩ ∨ μA μ ⟨(u, y), ⋯⟩ ≤ μA μ ⟨(u, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod",
   "LT.lt",
   "And.intro",
   "Subtype.prop",
   "le_of_lt",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "impl.prop3d4₀func._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }), (↑I).1 ≤ (↑I).1 ∧ (↑I).1 ≤ (↑I).2",
  "constCategory": "Theorem"},
 {"references":
  ["TotIntvl",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Prod.fst",
   "ConvexI",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "Convex",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "And.right",
   "Preorder.toLT",
   "Prod.snd",
   "lt_of_le_of_ne",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "PartialOrder",
   "LE.le",
   "Ne",
   "Preorder.toLE",
   "InIntvl"],
  "name": "IsAttained._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (I : { p // p.1 < p.2 }) (a : ℒ),\n  InIntvl I a → a ≠ (↑I).2 → (a, (↑I).2).1 < (a, (↑I).2).2",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Distrib.toAdd",
   "Semiring.toNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Eq.refl",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Eq.symm",
   "Eq.ndrec",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.add_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' + b' = c → a + b = c",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.rec", "Eq"],
  "name": "Eq.mpr_prop",
  "constType": "∀ {p q : Prop}, p = q → q → p",
  "constCategory": "Theorem"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "prop_4_3_cond₂._proof_6",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "prop_4_3_cond₂",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GE.ge",
   "Prod.fst",
   "μA",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq",
   "Eq.rec",
   "Preorder.toLE",
   "le_antisymm",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "inf_eq_right",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "ConvexI",
   "impl.prop2d6₁I",
   "impl.prop2d6₀",
   "Min.min",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.prop2d6₂I₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (y : ℒ),\n          InIntvl I y →\n            ∀ (z : ℒ),\n              InIntvl I z →\n                ∀ (h : x < y ∧ y < z), μA μ ⟨(x, y), ⋯⟩ ≥ μA μ ⟨(y, z), ⋯⟩ → μA μ ⟨(y, z), ⋯⟩ = μA μ ⟨(x, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsTotal",
  "constType": "(α : Sort u_1) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "lcProof",
  "constType": "∀ {α : Prop}, α",
  "constCategory": "Axiom"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "funext",
   "forall_congr",
   "Eq.symm",
   "sInf_le_sInf",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "_private.Mathlib.Data.Set.Basic.0._proof_18",
   "Prod.snd",
   "μA._proof_3",
   "Prod",
   "HasSubset.Subset",
   "Iff.of_eq",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "Subtype",
   "Prod.fst",
   "congrArg",
   "μA",
   "congr",
   "_private.Init.PropLemmas.0._proof_12",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "lt_of_lt_of_le",
   "exists_prop_congr",
   "LT.lt",
   "Set.instHasSubset",
   "le_of_lt",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "CompleteLattice"],
  "name": "impl.prop2d6₀",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (x y z : ℒ) (h : x < y ∧ y < z),\n  μA μ ⟨(x, z), ⋯⟩ ≤ μA μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "OfNat.mk", "One.one", "One"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "Eq.ndrec",
   "Eq",
   "add_comm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Neg.neg",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "SubNegMonoid.toNeg",
   "neg_add_rev",
   "HAdd.hAdd",
   "Ring.toAddCommGroup",
   "eq_self",
   "NegZeroClass.toNeg",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "Ring",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.neg_add",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a₁ a₂ b₁ b₂ : R}, -a₁ = b₁ → -a₂ = b₂ → -(a₁ + a₂) = b₁ + b₂",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "AddZeroClass.toZero",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["True", "Eq.symm", "trivial", "Eq.rec", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toAddCommGroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NegZeroClass.toNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Neg.neg",
   "Eq.refl",
   "Eq.symm",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Eq.ndrec",
   "Eq",
   "SubNegZeroMonoid.toNegZeroClass",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_congr",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a a' b : R}, a = a' → -a' = b → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "LE.le",
   "And",
   "Iff.mp",
   "Preorder.toLT",
   "Preorder.toLE",
   "lt_iff_le_not_le",
   "And.left"],
  "name": "le_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "S₁I._proof_2",
   "Subtype.val",
   "Prod.fst",
   "μA",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "S₁I",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        {S : Type} →\n          [CompleteLattice S] →\n            ({ p // p.1 < p.2 } → S) → (I : { p // p.1 < p.2 }) → (x : ℒ) → InIntvl I x → (↑I).1 ≠ x → Prop",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup.sup", "SemilatticeSup", "Max", "Max.mk"],
  "name": "SemilatticeSup.toMax",
  "constType": "{α : Type u} → [SemilatticeSup α] → Max α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{α : Sort u} → {p : α → Prop} → (val : α) → p val → Subtype p",
  "constCategory": "Other"},
 {"references": ["Preorder", "le_trans", "Preorder.toLE", "GE.ge"],
  "name": "ge_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≥ b → b ≥ c → a ≥ c",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "Eq", "GT.gt", "LT", "propext"],
  "name": "_private.Init.Core.0._proof_39",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod.casesOn",
   "And.intro",
   "Preorder.toLE",
   "Nontrivial.mk",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "ne_of_lt",
   "le_of_lt",
   "Interval",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Ne",
   "Subtype.casesOn",
   "Subtype.mk",
   "Subtype.coe_ne_coe"],
  "name": "instNontrivialInterval",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {z : { p // p.1 < p.2 }},\n  Nontrivial (Interval z)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Prod",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "Subtype",
   "Subtype.prop",
   "Lattice",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._proof_11",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (p : { p // p.1 < p.2 }), (↑p).1 < (↑p).2",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegZeroMonoid.mk",
   "SubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid._proof_16",
   "SubNegZeroMonoid"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid",
  "constType": "{α : Type u_1} → [SubtractionMonoid α] → SubNegZeroMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "lt_trans",
   "TotIntvl",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "bot_le",
   "μAstar",
   "Subtype.val",
   "Equiv",
   "Or",
   "SupSet.sSup",
   "letFun",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "impl.prop4d1₁",
   "μBstar",
   "SemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLattice.toInfSet",
   "Exists",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "impl.prop4d3_helper",
   "Nat.lt_add_one",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Set.ext",
   "Eq.mpr",
   "OrderDual.instBoundedOrder",
   "setOf",
   "OrderDual.toDual",
   "OrderDual",
   "Subtype",
   "Eq.mp",
   "OrderDual.instLattice",
   "impl.h₁_dual_of_h₁",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "Iff.intro",
   "congrArg",
   "Nat.instPreorder",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "impl.prop4d1_helper",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "OrderDual.instLT",
   "InfSet.sInf",
   "OrderDual.instCompleteLattice",
   "OrderDual.instPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "propext",
   "CompleteLattice.toConditionallyCompleteLattice",
   "μmin",
   "_private.Mathlib.Order.Synonym.0._proof_6",
   "impl.dualμAstar_eq_μBstar",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "Set",
   "instHAdd",
   "impl.h₂_dual_of_h₂",
   "OfNat.ofNat",
   "exists_prop_congr",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "LE.le",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "μmax",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "impl.prop4d3₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : ⊥ < (↑z).1),\n        μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ z ∨ μ ⟨(⊥, (↑z).2), ⋯⟩ ≤ μ ⟨(⊥, (↑z).1), hz⟩) →\n      μBstar μ = μmax μ TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "PartialOrder.toPreorder",
   "Real",
   "inferInstance",
   "Real.partialOrder"],
  "name": "Real.instPreorder",
  "constType": "Preorder ℝ",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "_private.Mathlib.Order.Lattice.0._proof_9",
   "And",
   "SemilatticeSup.toPartialOrder",
   "and_true",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "Max.max",
   "le_antisymm_iff",
   "iff_self",
   "_private.Mathlib.Order.Lattice.0._proof_7",
   "of_eq_true",
   "congr",
   "Iff",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Eq",
   "Preorder.toLE"],
  "name": "sup_eq_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = a ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Max.max",
   "le_sup_right",
   "PartialOrder.toPreorder",
   "LT.lt.trans_le",
   "SemilatticeSup.toMax",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "SemilatticeSup"],
  "name": "lt_sup_of_lt_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c < b → c < a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["Not", "Eq.symm", "Eq.rec", "Eq"],
  "name": "Eq.mpr_not",
  "constType": "∀ {p q : Prop}, p = q → ¬q → ¬p",
  "constCategory": "Theorem"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references": ["Set", "Membership.mem", "setOf", "Set.instMembership"],
  "name": "Membership.mem.out",
  "constType": "∀ {α : Type u} {p : α → Prop} {a : α}, a ∈ {x | p x} → p a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup.sup_le",
   "Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "sup_le",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "OrderDual",
   "sup_assoc",
   "Min.min",
   "OrderDual.instSemilatticeSup",
   "Eq"],
  "name": "inf_assoc",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a b c : α), a ⊓ b ⊓ c = a ⊓ (b ⊓ c)",
  "constCategory": "Theorem"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1",
   "Mathlib.Meta.NormNum.IsInt",
   "AddGroupWithOne.toIntCast",
   "Int.rawCast",
   "Eq",
   "Int.cast",
   "Ring",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
  "constType":
  "∀ {α : Type u} {a : α} {n : ℤ} [inst : Ring α], Mathlib.Meta.NormNum.IsInt a n → a = n.rawCast",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.mk",
   "AddCommGroup.add_comm",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "SubNegMonoid.toAddMonoid",
   "NonUnitalNonAssocRing.zero_mul",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.left_distrib"],
  "name": "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup.le_sup_right",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "le_sup_right",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Function.injective_id",
   "CharZero.mk",
   "CharZero",
   "Nat.instAddMonoidWithOne"],
  "name": "Nat.instCharZero",
  "constType": "CharZero ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocSemiring.mk",
   "AddCommGroup.add_comm",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocCommRing",
   "NonUnitalNonAssocCommRing.mul_comm",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.zero_mul",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.left_distrib"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "TotIntvl",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Exists.intro",
   "GT.gt",
   "Prod.fst",
   "in_TotIntvl",
   "instOfNatNat",
   "μA",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "Eq",
   "SemilatticeInf.toPartialOrder",
   "μDCC",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "Convex",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "Exists.casesOn",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "μDCC._proof_1",
   "Nat",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "impl.prop3d2",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.cor3d3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  Convex μ → (∀ (f : ℕ → ℒ) (h : ∀ (n : ℕ), f n > f (n + 1)), ∃ N, μA μ ⟨(f (N + 1), f N), ⋯⟩ = ⊤) → μDCC μ",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "instLTNat",
   "instHAdd",
   "Nat.leRec",
   "Nat.leRec._proof_5",
   "Nat.le_refl",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Nat",
   "Nat.le_succ_of_le",
   "instOfNatNat",
   "LE.le",
   "Nat.le_of_succ_le",
   "Nat.lt_succ_self",
   "Nat.decreasingInduction._proof_11",
   "instLENat",
   "Nat.decreasingInduction._proof_10"],
  "name": "Nat.decreasingInduction",
  "constType":
  "{n : ℕ} →\n  {motive : (m : ℕ) → m ≤ n → Sort u_1} →\n    ((k : ℕ) → (h : k < n) → motive (k + 1) h → motive k ⋯) → motive n ⋯ → {m : ℕ} → (mn : m ≤ n) → motive m mn",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "impl.lem2d4₃I",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "impl.lem2d4₂I",
   "Prod.fst",
   "And.intro",
   "μA",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "InIntvl",
   "inf_lt_left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "gt_of_ge_of_gt",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "ConvexI",
   "Max.max",
   "Min.min",
   "impl.lem2d4₁",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "right_lt_sup",
   "μmax",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.lem2d4I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (w : ℒ),\n          InIntvl I w →\n            ∀ (hxw : ¬x ≤ w) (u t : ℒ) (huxw : u ≤ x ⊓ w) (hxwt : x ⊔ w ≤ t),\n              μA μ ⟨(u, x), ⋯⟩ ≤ μmax μ ⟨(x ⊓ w, x), ⋯⟩ ∧\n                μmax μ ⟨(x ⊓ w, x), ⋯⟩ ≤ μmax μ ⟨(w, t), ⋯⟩ ∧ μA μ ⟨(u, x), ⋯⟩ ≤ μA μ ⟨(w, x ⊔ w), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "PartialOrder.toPreorder",
   "eq_of_le_of_not_lt",
   "PartialOrder",
   "LE.le",
   "Eq.symm",
   "Preorder.toLT",
   "Eq",
   "Preorder.toLE"],
  "name": "eq_of_ge_of_not_gt",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≤ b → ¬a < b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "True",
   "instOfNatNat",
   "instHAdd",
   "eq_true",
   "Eq",
   "Nat.lt_add_one",
   "OfNat.ofNat"],
  "name": "_private.Init.Data.Nat.Basic.0._proof_6",
  "constType": "∀ (n : ℕ), (n < n + 1) = True",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Eq.comm", "Eq"],
  "name": "eq_comm",
  "constType": "∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "Preorder.toLT",
   "False",
   "lt_self_iff_false",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.Basic.0._proof_1",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] (x : α), (x < x) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "Exists",
   "instOfNatNat",
   "Nontrivial",
   "Exists.intro",
   "Ne",
   "Nontrivial.mk",
   "OfNat.ofNat",
   "Nat.zero_ne_one"],
  "name": "Nat.instNontrivial",
  "constType": "Nontrivial ℕ",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.snd",
  "constType": "{α : Type u} → {β : Type v} → α × β → β",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "TotIntvl",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "in_TotIntvl",
   "SupSet.sSup",
   "TotIntvl._proof_1",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "BoundedOrder.toOrderBot",
   "μmax._proof_2",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Set.ext",
   "setOf",
   "Ne.symm",
   "Subtype",
   "Prod.fst",
   "congrArg",
   "Iff.intro",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "LT.lt",
   "ne_of_lt",
   "Ne",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "μmax",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "impl.prop4d3_helper",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  sSup {x | ∃ y, ∃ (hy : ⊥ < y), μ ⟨(⊥, y), hy⟩ = x} = μmax μ TotIntvl",
  "constCategory": "Theorem"},
 {"references": ["Membership.mk", "Set", "Set.Mem", "Membership"],
  "name": "Set.instMembership",
  "constType": "{α : Type u} → Membership α (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Or.inl", "Or", "or_self.match_1", "Eq", "propext", "Iff.intro"],
  "name": "or_self",
  "constType": "∀ (p : Prop), (p ∨ p) = p",
  "constCategory": "Theorem"},
 {"references": ["LE", "BoundedOrder", "OrderBot"],
  "name": "BoundedOrder.toOrderBot",
  "constType":
  "{α : Type u} → {inst : LE α} → [self : BoundedOrder α] → OrderBot α",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro", "Nonempty", "Inhabited", "Inhabited.default"],
  "name": "instNonemptyOfInhabited",
  "constType": "∀ {α : Sort u} [Inhabited α], Nonempty α",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references": ["One", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → One R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Not", "Decidable.byContradiction", "Classical.propDecidable", "False"],
  "name": "Classical.byContradiction",
  "constType": "∀ {p : Prop}, (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["Nat", "AddMonoidWithOne.toNatCast", "Nat.cast", "AddMonoidWithOne"],
  "name": "Nat.rawCast",
  "constType": "{α : Type u} → [AddMonoidWithOne α] → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "OrderDual",
   "Min.min",
   "OrderDual.instSemilatticeSup",
   "Eq",
   "sup_comm"],
  "name": "inf_comm",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a b : α), a ⊓ b = b ⊓ a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "Prod",
   "LT.lt",
   "And.intro",
   "Subtype.prop",
   "le_of_lt",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "impl.prop3d4₀func._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }), (↑I).1 ≤ (↑I).2 ∧ (↑I).2 ≤ (↑I).2",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.zero_add",
   "AddMonoid.toZero",
   "AddMonoid.add_zero",
   "AddZeroClass",
   "AddMonoid.toAddSemigroup",
   "AddMonoid",
   "AddZeroClass.mk",
   "AddSemigroup.toAdd"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "μAstar",
   "Subtype.val",
   "Equiv",
   "in_TotIntvl",
   "And.intro",
   "SupSet.sSup",
   "funext",
   "Eq.symm",
   "Eq.rec",
   "μBstar",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "ConditionallyCompleteLattice.toInfSet",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "μmax._proof_2",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Set.ext",
   "Eq.mpr",
   "OrderDual.instBoundedOrder",
   "setOf",
   "OrderDual",
   "OrderDual.toDual",
   "Ne.symm",
   "Subtype",
   "OrderDual.instLattice",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "DFunLike.coe",
   "Iff.intro",
   "congrArg",
   "OrderDual.ofDual",
   "Prod.fst",
   "OrderDual.instNontrivial",
   "Subtype.prop",
   "OrderDual.instLT",
   "BoundedOrder.toOrderTop",
   "congr",
   "OrderDual.instCompleteLattice",
   "InfSet.sInf",
   "OrderDual.instPartialOrder",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "μmin",
   "Not",
   "_private.Mathlib.Order.Synonym.0._proof_6",
   "Lattice.toSemilatticeInf",
   "Equiv.instFunLike",
   "Set",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "μmax",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "impl.dualμBstar_eq_μAstar",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  OrderDual.ofDual ((μBstar fun p => OrderDual.toDual (μ ⟨((↑p).2, (↑p).1), ⋯⟩)) = μAstar μ)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "sup_eq_left",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "inf_le_inf_left",
   "sup_le",
   "Subtype.val",
   "And.intro",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "le_sup_left",
   "μA._proof_3",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "sup_le_sup_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "impl.lem2d4₂I",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "lt_irrefl",
   "μA",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "ConvexI",
   "LT.lt",
   "Max.max",
   "Min.min",
   "impl.lem2d4₁",
   "LE.le",
   "SemilatticeSup.toMax",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "right_lt_sup",
   "μmax",
   "CompleteLattice"],
  "name": "impl.lem2d4₃I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (w : ℒ), InIntvl I w → ∀ (hxw : ¬x ≤ w) (u : ℒ) (huxw : u ≤ x ⊓ w), μA μ ⟨(u, x), ⋯⟩ ≤ μA μ ⟨(w, x ⊔ w), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["forall_const", "Nonempty", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_17",
  "constType":
  "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (∀ (a : α), b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["CompletelyDistribLattice.mk",
   "CompleteLinearOrder.himp_bot",
   "CompleteLinearOrder.top_sdiff",
   "CompleteLinearOrder.toHNot",
   "CompleteLinearOrder.toHImp",
   "CompleteLinearOrder.toCompletelyDistribLattice._proof_28",
   "CompletelyDistribLattice",
   "CompleteLinearOrder.sdiff_le_iff",
   "CompleteLinearOrder.toCompleteLattice",
   "CompleteLinearOrder.toHasCompl",
   "CompleteLinearOrder",
   "CompleteLinearOrder.le_himp_iff",
   "CompleteLinearOrder.toSDiff"],
  "name": "CompleteLinearOrder.toCompletelyDistribLattice",
  "constType":
  "{α : Type u} → [CompleteLinearOrder α] → CompletelyDistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["And.intro",
   "True",
   "And",
   "Eq",
   "trivial",
   "propext",
   "And.left",
   "Iff.intro"],
  "name": "and_true",
  "constType": "∀ (p : Prop), (p ∧ True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "instOfNat",
   "instHAdd",
   "Iff",
   "Int.instAdd",
   "LE.le",
   "Int.instLTInt",
   "Int.instLEInt",
   "Iff.rfl",
   "OfNat.ofNat",
   "Int"],
  "name": "Int.add_one_le_iff",
  "constType": "∀ {a b : ℤ}, a + 1 ≤ b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "impl.ℒₛ._proof_1",
   "Eq.trans",
   "Eq.mpr_not",
   "Classical.propDecidable",
   "eq_true",
   "Exists.intro",
   "Membership.mem.out",
   "impl.ℒₛ",
   "Subtype.val",
   "False.elim",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.ndrec",
   "LT.lt.not_le",
   "Exists",
   "Exists.choose_spec",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "impl.prop3d4₀func",
   "eq_false",
   "Eq.refl",
   "Lattice",
   "Classical.byContradiction",
   "Eq.mpr",
   "impl.prop3d4₀func._proof_8",
   "instDecidableTrue",
   "Prod.fst",
   "instOfNatNat",
   "congr",
   "WellFoundedGT",
   "not_true_eq_false",
   "Eq",
   "Preorder.toLE",
   "Set",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "dite_cond_eq_true",
   "Ne",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le.ge",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "WellFounded.has_min",
   "_private.Init.Core.0._proof_38",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "GE.ge",
   "And.intro",
   "PartialOrder",
   "funext",
   "forall_congr",
   "Eq.rec",
   "impl.ℒₛ._proof_2",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "of_eq_false",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "Nat",
   "Nontrivial",
   "impl.prop3d4₀func._proof_7",
   "id",
   "Subtype",
   "Eq.mp",
   "impl.prop3d4₀func_helper",
   "le_trans",
   "lt_of_le_of_ne",
   "congrArg",
   "dite_congr",
   "Subtype.prop",
   "μA",
   "IsWellFounded.wf",
   "instDecidableFalse",
   "dite_cond_eq_false",
   "InIntvl",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "impl.prop3d4₀func._proof_4",
   "instHAdd",
   "gt_of_ge_of_gt",
   "Exists.choose",
   "Eq.mpr_prop",
   "LT.lt",
   "ne_of_lt",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39"],
  "name": "impl.prop3d4₀func_defprop2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ)\n  (hi : (↑I).1 ≠ ↑(impl.prop3d4₀func μ I (i + 1))) (z : ℒ)\n  (hz : ↑(impl.prop3d4₀func μ I (i + 1)) < z ∧ z ≤ ↑(impl.prop3d4₀func μ I i)),\n  ¬μA μ ⟨((↑I).1, z), ⋯⟩ ≥ μA μ ⟨((↑I).1, ↑(impl.prop3d4₀func μ I (i + 1))), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast.mk",
   "Nat.instAddMonoidWithOne._proof_2",
   "Nat.instAddMonoid",
   "Nat",
   "Nat.instOne",
   "AddMonoidWithOne",
   "AddMonoidWithOne.mk",
   "Nat.instAddMonoidWithOne._proof_1"],
  "name": "Nat.instAddMonoidWithOne",
  "constType": "AddMonoidWithOne ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "Nat",
   "Preorder",
   "PartialOrder.toPreorder",
   "inferInstance",
   "Nat.instLinearOrder"],
  "name": "Nat.instPreorder",
  "constType": "Preorder ℕ",
  "constCategory": "Definition"},
 {"references": ["le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_rfl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a : α}, a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "_neutral",
   "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._rarg"],
  "name":
  "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Not", "Exists", "not_exists", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_15",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) = ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "TotIntvl",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "in_TotIntvl",
   "TotIntvl._proof_1",
   "SemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLattice.toInfSet",
   "Exists",
   "And.right",
   "And",
   "ne_top_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "BoundedOrder.toOrderBot",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Set.ext",
   "lt_top_iff_ne_top",
   "setOf",
   "Subtype",
   "Prod.fst",
   "congrArg",
   "Iff.intro",
   "BoundedOrder.toOrderTop",
   "InfSet.sInf",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "μmin",
   "Lattice.toSemilatticeInf",
   "Set",
   "LT.lt",
   "Ne",
   "Subtype.mk",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "impl.prop4d1_helper",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  sInf {x | ∃ x_1, ∃ (hx : x_1 < ⊤), μ ⟨(x_1, ⊤), hx⟩ = x} = μmin μ TotIntvl",
  "constCategory": "Theorem"},
 {"references": ["Nat", "OfNat", "OfNat.mk"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references":
  ["Not", "le_rfl", "LT.lt", "Preorder", "not_le_of_lt", "Preorder.toLT"],
  "name": "lt_irrefl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), ¬a < a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references": ["Int.add", "Add", "Add.mk", "Int"],
  "name": "Int.instAdd",
  "constType": "Add ℤ",
  "constCategory": "Definition"},
 {"references": ["InfSet", "Set"],
  "name": "InfSet.sInf",
  "constType": "{α : Type u_1} → [self : InfSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "impl.ℒₛ",
   "Prod.fst",
   "IsWellFounded.wf",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ) (x : Nat.below n.succ)\n  (hbot : ¬(↑I).1 = ↑x.1),\n  (impl.ℒₛ μ I x.1 hbot).Nonempty → ∃ a ∈ impl.ℒₛ μ I x.1 hbot, ∀ x_1 ∈ impl.ℒₛ μ I x.1 hbot, ¬x_1 > a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "instDecidableIff",
   "instDecidableEqOfIff",
   "Bool",
   "True",
   "instDecidableTrue",
   "Decidable.decide",
   "Eq.refl",
   "id",
   "False",
   "instDecidableFalse",
   "Eq",
   "Bool.true",
   "of_decide_eq_true",
   "instDecidableNot"],
  "name": "not_true_eq_false",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "Lattice",
   "Top.top",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "prop_4_1_cond₂._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (z : { p // p.1 < p.2 }),\n  (↑z).2 < ⊤ → ((↑z).1, ⊤).1 < ((↑z).1, ⊤).2",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "sup_le_iff.match_1",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "And",
   "sup_le",
   "le_sup_left",
   "Iff.intro",
   "And.intro",
   "Max.max",
   "le_sup_right",
   "Iff",
   "LE.le",
   "SemilatticeSup.toMax",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "sup_le_iff",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ⊔ b ≤ c ↔ a ≤ c ∧ b ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u_2} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Not", "Preorder", "lt_irrefl", "Preorder.toLT"],
  "name": "Linarith.lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, ¬a < a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "OrderDual",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "SemilatticeInf",
   "LT.lt",
   "left_lt_sup",
   "OrderDual.instSemilatticeSup",
   "Min.min",
   "Iff",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_lt_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b < a ↔ ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "TotIntvl",
   "Prod.mk",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "in_TotIntvl",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "impl.rmk4d10₀",
   "Exists",
   "And.right",
   "Or.resolve_left",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "μmax._proof_2",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Ne.symm",
   "Subtype",
   "Classical.not_not",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Prod.fst",
   "le_rfl",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "propext",
   "μmin",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "LT.lt",
   "LE.le",
   "le_sSup",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "dite",
   "μmax",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "impl.prop4d12",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤), ¬μ ⟨(⊥, x), ⋯⟩ ≤ μ TotIntvl ∨ μ TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩) →\n    μmax μ TotIntvl = μ TotIntvl → μmin μ TotIntvl = μmax μ TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "inferInstance",
   "AddMonoid",
   "AddCommMonoid.toAddMonoid",
   "Nat.instAddCommMonoid"],
  "name": "Nat.instAddMonoid",
  "constType": "AddMonoid ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "le_trans",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Membership.mem",
   "Preorder.toLE",
   "sInf_le",
   "Set.instMembership",
   "CompleteSemilatticeInf"],
  "name": "sInf_le_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a b : α}, b ∈ s → b ≤ a → sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Int",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "impl.ℒₛ._proof_1",
   "Eq.trans",
   "Eq.mpr_not",
   "Classical.propDecidable",
   "eq_true",
   "Exists.intro",
   "Membership.mem.out",
   "impl.ℒₛ",
   "Subtype.val",
   "impl.prop3d4₀func_fin_len",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Nat.sub_one_add_one",
   "Eq.symm",
   "Eq.ndrec",
   "Exists",
   "Exists.choose_spec",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat.find_spec",
   "impl.prop3d4₀func",
   "eq_false",
   "Eq.refl",
   "Lattice",
   "impl.prop3d4₀func_len_nonzero",
   "impl.prop3d4₀func._proof_8",
   "Prod.fst",
   "instOfNatNat",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "Set",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "dite_cond_eq_true",
   "Ne",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "instHSub",
   "CompleteLattice",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "WellFounded.has_min",
   "Membership.mem",
   "Nat.sub_one_lt",
   "Preorder.toLT",
   "Iff.mp",
   "GT.gt",
   "And.intro",
   "impl.prop3d4₀func_defprop3₀",
   "PartialOrder",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "impl.ℒₛ._proof_2",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "of_eq_false",
   "And.right",
   "And",
   "Nat",
   "Nontrivial",
   "impl.prop3d4₀func._proof_7",
   "impl.prop3d4₀func_len",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "congrArg",
   "dite_congr",
   "Subtype.prop",
   "μA",
   "IsWellFounded.wf",
   "dite_cond_eq_false",
   "InIntvl",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "μDCC",
   "eq_of_le_of_not_lt",
   "instHAdd",
   "impl.prop3d4₀func._proof_4",
   "Exists.choose",
   "Eq.mpr_prop",
   "LT.lt",
   "ne_of_lt",
   "instSubNat",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "lt_self_iff_false",
   "_private.Init.Core.0._proof_39"],
  "name": "impl.prop3d4₀func_defprop3",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (hμDCC : μDCC μ) (y : ℒ)\n  (hy : (↑I).1 < y ∧ y ≤ ↑(impl.prop3d4₀func μ I (impl.prop3d4₀func_len μ I hμDCC - 1))),\n  ¬μA μ ⟨((↑I).1, y), ⋯⟩ > μA μ ⟨((↑I).1, ↑(impl.prop3d4₀func μ I (impl.prop3d4₀func_len μ I hμDCC - 1))), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid",
   "SubtractionMonoid.mk",
   "AddCommGroup.add_comm",
   "SubtractionMonoid.neg_eq_of_add",
   "AddCommGroup.toAddGroup",
   "SubtractionCommMonoid",
   "SubtractionCommMonoid.mk",
   "AddCommGroup",
   "SubtractionMonoid.neg_neg",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.neg_add_rev",
   "AddGroup.toSubtractionMonoid"],
  "name": "AddCommGroup.toDivisionAddCommMonoid",
  "constType": "{G : Type u_1} → [AddCommGroup G] → SubtractionCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Subtype.lt",
   "Subtype.mk_lt_mk",
   "Preorder.toLT",
   "instLatticeInterval",
   "Subtype.val",
   "Prod.fst",
   "Subtype.GCongr.coe_lt_coe",
   "Subtype.prop",
   "Subtype.property",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "lt_iff_le_not_le",
   "LT.lt",
   "Prod",
   "Interval",
   "Iff.mpr",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk"],
  "name": "Resμ._proof_19",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (z : { p // p.1 < p.2 })\n  (p : { p // p.1 < p.2 }), ↑(↑p).1 < ↑(↑p).2",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Lean.Name"],
  "name": "Lean.Name.num",
  "constType": "Name → ℕ → Name",
  "constCategory": "Other"},
 {"references": ["Subtype.rec", "Subtype", "Subtype.mk"],
  "name": "Subtype.casesOn",
  "constType":
  "{α : Sort u} →\n  {p : α → Prop} →\n    {motive : Subtype p → Sort u_1} →\n      (t : Subtype p) → ((val : α) → (property : p val) → motive ⟨val, property⟩) → motive t",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable", "Decidable.casesOn"],
  "name": "dite",
  "constType":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "SupSet.sSup",
   "PartialOrder",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "μmax._proof_2",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "setOf"],
  "name": "μmax",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "impl.prop4d1₁_seq._proof_3",
   "_private.Init.Classical.0._proof_9",
   "Membership.mem.out",
   "Subtype.val",
   "impl.prop4d1₁_seq",
   "False.elim",
   "Or",
   "letFun",
   "forall_congr",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Exists.choose_spec",
   "Or.resolve_left",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Nat",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "StrictMono",
   "impl.prop4d1₁_seq._proof_1",
   "setOf",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "_private.Init.Classical.0._proof_7",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "Nat.instPreorder",
   "Prod.fst",
   "_private.Init.PropLemmas.0._proof_15",
   "impl.prop4d1₁_seq._proof_2",
   "not_lt_top_iff",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "not_true_eq_false",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "Set",
   "_private.Init.Classical.0._proof_13",
   "impl.prop4d1₁_seq._proof_8",
   "Exists.choose",
   "OfNat.ofNat",
   "exists_prop_congr",
   "impl.prop4d1₁_seq._proof_9",
   "HAdd.hAdd",
   "LT.lt",
   "LE.le",
   "False",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "And.casesOn"],
  "name": "impl.prop4d1₁_seq._proof_10",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S)\n  (h₁ : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩)\n  (h₂ :\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty) (k : ℕ),\n  ⋯.choose ∈ {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE", "GE.ge"],
  "name": "LE.le.ge",
  "constType": "∀ {α : Type u_2} [inst : LE α] {x y : α}, x ≤ y → y ≥ x",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "Nat.cast",
   "Int.instLTInt",
   "Eq",
   "Mathlib.Tactic.Zify.natCast_lt",
   "propext",
   "instNatCastInt",
   "Int"],
  "name": "_private.Mathlib.Tactic.Zify.0._proof_3",
  "constType": "∀ (a b : ℕ), (a < b) = (↑a < ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring.toDistrib",
   "True",
   "Eq.trans",
   "Distrib.toMul",
   "CommSemiring",
   "MulZeroClass.toMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "HMul.hMul",
   "MulZeroClass.zero_mul",
   "OfNat.ofNat",
   "congrArg",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Zero.toOfNat0",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.zero_mul",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 * b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Preorder", "le_of_lt", "Preorder.toLT", "lt_of_lt_of_le"],
  "name": "lt_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "InfSet",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "impl.prop4d14",
   "Subtype",
   "PartialOrder.toPreorder",
   "TotIntvl",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "List.tfae_of_cycle",
   "Prod.fst",
   "eq_of_le_of_le",
   "impl.rmk4d13",
   "letFun",
   "impl.rmk4d15",
   "Eq.symm",
   "List.TFAE",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "μmin",
   "List.nil",
   "impl.prop4d12",
   "impl.rmk4d10₀",
   "Lattice.toSemilatticeInf",
   "List.Chain.cons",
   "And.right",
   "And",
   "BoundedOrder",
   "List.Chain.nil",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "SlopeLike",
   "μmax",
   "CompleteLattice"],
  "name": "impl.prop4d16₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  SlopeLike μ → [μmax μ TotIntvl = μ TotIntvl, μmin μ TotIntvl = μ TotIntvl, μmin μ TotIntvl = μmax μ TotIntvl].TFAE",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "sSup_le_sSup_of_forall_exists_le.match_1",
   "CompleteSemilatticeSup",
   "Membership.mem",
   "And",
   "CompleteSemilatticeSup.toSupSet",
   "LE.le.trans",
   "Set.instMembership",
   "le_sSup_iff",
   "upperBounds",
   "SupSet.sSup",
   "sSup_le",
   "Iff.mpr",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sSup_le_sSup_of_forall_exists_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s t : Set α}, (∀ x ∈ s, ∃ y ∈ t, x ≤ y) → sSup s ≤ sSup t",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "HSub.hSub",
   "Ne",
   "Nat.pred_lt",
   "instHSub",
   "OfNat.ofNat"],
  "name": "Nat.sub_one_lt",
  "constType": "∀ {n : ℕ}, n ≠ 0 → n - 1 < n",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "Subtype", "Preorder.lift", "Subtype.val"],
  "name": "Subtype.preorder",
  "constType":
  "{α : Type u_2} → [Preorder α] → (p : α → Prop) → Preorder (Subtype p)",
  "constCategory": "Definition"},
 {"references": ["HMul", "outParam"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["OrderBot.bot_le", "LE.le", "LE", "OrderBot.toBot", "Bot.bot", "OrderBot"],
  "name": "bot_le",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderBot α] {a : α}, ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder", "Or", "PartialOrder", "LE.le", "Preorder.toLE"],
  "name": "IsComparable",
  "constType": "{ℒ : Type} → [PartialOrder ℒ] → ℒ → ℒ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Nat.cast",
   "instHAdd",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.cast_add",
   "HAdd.hAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.add",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.isNat_add.match_1",
   "Eq.symm",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "AddSemigroup.toAdd"],
  "name": "Mathlib.Meta.NormNum.isNat_add",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {f : α → α → α} {a b : α} {a' b' c : ℕ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsNat a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → a'.add b' = c → Mathlib.Meta.NormNum.IsNat (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Bot.mk",
   "Preorder.toLT",
   "instLatticeInterval",
   "instBoundedOrderInterval._proof_16",
   "Subtype.val",
   "BoundedOrder.mk",
   "Prod.fst",
   "Preorder.toLE",
   "OrderBot.mk",
   "SemilatticeInf.toPartialOrder",
   "OrderTop.mk",
   "Lattice.toSemilatticeInf",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "instBoundedOrderInterval._proof_15",
   "instBoundedOrderInterval._proof_14",
   "Interval",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.mk",
   "Subtype.mk",
   "instBoundedOrderInterval._proof_13"],
  "name": "instBoundedOrderInterval",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] → [inst_2 : BoundedOrder ℒ] → {z : { p // p.1 < p.2 }} → BoundedOrder (Interval z)",
  "constCategory": "Definition"},
 {"references":
  ["Ring.intCast_ofNat",
   "Ring.toNeg",
   "Semiring.natCast_succ",
   "Ring.toSub",
   "Semiring.toOne",
   "Ring.zsmul",
   "AddGroupWithOne.mk",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddGroupWithOne",
   "AddCommMonoid.toAddMonoid",
   "Ring.neg_add_cancel",
   "Ring.zsmul_neg'",
   "AddMonoidWithOne.mk",
   "Ring.intCast_negSucc",
   "Ring.toSemiring",
   "Ring.zsmul_zero'",
   "Ring.sub_eq_add_neg",
   "Ring.toIntCast",
   "Semiring.toNatCast",
   "Semiring.natCast_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNonUnitalSemiring",
   "Ring"],
  "name": "Ring.toAddGroupWithOne",
  "constType": "{R : Type u} → [self : Ring R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Classical.propDecidable",
   "Subtype.val",
   "Prod.fst",
   "impl.prop3d4₀func_fin_len",
   "Subtype.prop",
   "Eq.symm",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not.decidable_imp_symm",
   "Not",
   "instLTNat",
   "Lattice.toSemilatticeInf",
   "μDCC",
   "eq_of_le_of_not_lt",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Nat",
   "impl.prop3d4₀func",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "Nat.find_min",
   "CompleteLattice",
   "impl.prop3d4₀func_len"],
  "name": "impl.prop3d4₀func_defprop3₀",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (hμDCC : μDCC μ),\n  ∀ i < impl.prop3d4₀func_len μ I hμDCC, (↑I).1 < ↑(impl.prop3d4₀func μ I i)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SupSet.sSup",
   "Set",
   "CompleteSemilatticeSup.sSup_le",
   "LE.le",
   "Membership.mem",
   "CompleteSemilatticeSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "sSup_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references": ["HSub", "outParam"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "prop_4_3_cond₁._proof_5",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Prod",
   "StrictAnti",
   "Nat",
   "BoundedOrder.toOrderBot",
   "prop_4_3_cond₁._proof_4",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "prop_4_3_cond₁",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "True",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_isNat.match_1",
   "Int.cast",
   "congrArg",
   "Int",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Ring.toAddGroupWithOne",
   "of_eq_true",
   "Mathlib.Meta.NormNum.IsInt",
   "AddGroupWithOne.toIntCast",
   "Int.cast_natCast",
   "Int.ofNat",
   "Eq",
   "Mathlib.Meta.NormNum.IsNat",
   "instNatCastInt",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsInt a (Int.ofNat n) → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Nat.zero_lt_of_ne_zero.match_1",
   "instLTNat",
   "instHAdd",
   "Nat.zero_lt_succ",
   "OfNat.ofNat",
   "LT.lt",
   "absurd",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "Eq.refl",
   "Ne",
   "Eq"],
  "name": "Nat.zero_lt_of_ne_zero",
  "constType": "∀ {a : ℕ}, a ≠ 0 → 0 < a",
  "constCategory": "Theorem"},
 {"references": ["AddSemigroup", "Add"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references": ["HPow.mk", "HPow", "Pow", "Pow.pow"],
  "name": "instHPow",
  "constType": "{α : Type u_1} → {β : Type u_2} → [Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references": ["InfSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toInfSet",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "lt_trans",
   "PartialOrder.toPreorder",
   "TotIntvl",
   "Prod.mk",
   "Preorder.toLT",
   "bot_le",
   "Exists.intro",
   "μAstar",
   "Subtype.val",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "impl.prop4d1₁",
   "μBstar",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "Prod",
   "Nat",
   "BoundedOrder.toOrderBot",
   "μmax._proof_2",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Eq.mpr",
   "setOf",
   "StrictMono",
   "Subtype",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Nat.instPreorder",
   "Prod.fst",
   "congrArg",
   "le_rfl",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "μmin",
   "Lattice.toSemilatticeInf",
   "le_top",
   "instHAdd",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "ne_of_lt",
   "LE.le",
   "le_sSup",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "impl.prop4d1₂",
  "constType":
  "∀ (ℒ : Type) [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n        μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n      μAstar μ ≤ μBstar μ",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "Exists.intro",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "And.intro",
   "Subtype.prop",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "μmin",
   "Lattice.toSemilatticeInf",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "sInf_le",
   "LT.lt",
   "Prod",
   "ne_of_lt",
   "μmax._proof_2",
   "le_of_lt",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "le_sSup",
   "Ne",
   "Subtype.mk",
   "μmax",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice",
   "setOf"],
  "name": "impl.rmk4d10₀",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }), μmin μ I ≤ μ I ∧ μ I ≤ μmax μ I",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["semiOutParam", "Coe"],
  "name": "Coe.mk",
  "constType": "{α : semiOutParam (Sort u)} → {β : Sort v} → (α → β) → Coe α β",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "Real.instPreorder",
   "PartialOrder.toPreorder",
   "WellFounded.has_min",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "bot_le",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "Monotone",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "CompleteLattice.toTop",
   "Eq.rec",
   "Set.mem_range_self",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "eq_of_ge_of_not_gt",
   "Exists",
   "Exists.choose_spec",
   "Real",
   "And.right",
   "lt_of_le_of_lt",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Nat.lt_add_one",
   "Set.instMembership",
   "Prod",
   "IsWellOrder",
   "Nat",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "CompleteLattice.toBoundedOrder",
   "setOf",
   "Subtype.lt",
   "Subtype",
   "IsWellOrder.toIsWellFounded",
   "Set.range",
   "Prod.fst",
   "Nat.instPreorder",
   "Set.mem_setOf",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "IsWellFounded.wf",
   "Real.instLT",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Real.partialOrder",
   "Not",
   "Set.Nonempty",
   "le_top",
   "Lattice.toSemilatticeInf",
   "Set",
   "instHAdd",
   "Exists.choose",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "le_of_lt",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.rmk4d4",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (r : ℒ → ℝ),\n  Monotone r →\n    (IsWellOrder ↑(Set.range r) fun x1 x2 => x1 < x2) →\n      (∀ (z : { p // p.1 < p.2 }), r (↑z).1 = r (↑z).2 → μ z = ⊤) →\n        ∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "Preorder.toLT",
   "μAstar",
   "Subtype.val",
   "in_TotIntvl",
   "And.intro",
   "False.elim",
   "SupSet.sSup",
   "funext",
   "forall_congr",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq.rec",
   "Eq.ndrec",
   "μBstar",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Exists",
   "_private.Mathlib.Order.Basic.0._proof_1",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Bot.bot",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "μmax._proof_2",
   "Iff",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "Aesop.BuiltinRules.not_intro",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Iff.intro",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "InfSet.sInf",
   "_private.Init.PropLemmas.0._proof_12",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "propext",
   "μmin",
   "Not",
   "sSup_le_iff",
   "bot_lt_iff_ne_bot",
   "le_sInf_iff",
   "Lattice.toSemilatticeInf",
   "Set",
   "exists_prop_congr",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "ne_of_lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "_private.Mathlib.Order.CompleteLattice.Defs.0._proof_2",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top",
   "And.casesOn"],
  "name": "impl.rmk4d10₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  μBstar μ ≤ μAstar μ ↔ ∀ (x : ℒ) (hx : x ≠ ⊤) (y : ℒ) (hy : ⊥ < y), μmin μ ⟨(⊥, y), hy⟩ ≤ μmax μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocCommSemiring", "NonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Or",
   "Iff",
   "Decidable.or_iff_not_imp_left",
   "Classical.propDecidable"],
  "name": "Classical.or_iff_not_imp_left",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ ¬a → b",
  "constCategory": "Theorem"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "∀ {a b : Prop}, (a → b) → ¬b → ¬a",
  "constCategory": "Theorem"},
 {"references": ["Or", "Iff", "Or.comm"],
  "name": "or_comm",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ b ∨ a",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "LE.le", "Membership.mem", "LE", "Set.instMembership", "setOf"],
  "name": "upperBounds",
  "constType": "{α : Type u_1} → [LE α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Preorder.toLT",
   "Ne",
   "lt_of_le_of_ne",
   "Preorder.toLE",
   "flip"],
  "name": "Ne.lt_of_le",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≠ b → a ≤ b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["TotIntvl",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "μAstar",
   "Subtype.val",
   "in_TotIntvl",
   "And.intro",
   "SupSet.sSup",
   "letFun",
   "sSup_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "TotIntvl._proof_1",
   "Eq.rec",
   "μBstar",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "impl.rmk4d10₀",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "μB",
   "BoundedOrder.toOrderBot",
   "μmax._proof_2",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Ne.symm",
   "Subtype",
   "le_trans",
   "OmegaCompletePartialOrder.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Prod.fst",
   "μA",
   "BoundedOrder.toOrderTop",
   "InfSet.sInf",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "μmin",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "sInf_le",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "LE.le",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "impl.prop4d11₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S), μmin μ TotIntvl = μmax μ TotIntvl → μBstar μ ≤ μAstar μ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 → Prop",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_left"],
  "name": "inf_le_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["HMul", "HMul.mk", "Mul", "Mul.mul"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_le_succ",
   "instAddNat",
   "HAdd.hAdd",
   "Nat",
   "Nat.AtLeastTwo",
   "instOfNatNat",
   "instHAdd",
   "Nat.AtLeastTwo.mk",
   "Nat.zero_le",
   "OfNat.ofNat"],
  "name": "instNatAtLeastTwo",
  "constType": "∀ {n : ℕ}, (n + 2).AtLeastTwo",
  "constCategory": "Theorem"},
 {"references":
  ["mem_upperBounds",
   "PartialOrder.toPreorder",
   "IsAttained",
   "Prod.mk",
   "WellFounded.has_min",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "GT.gt",
   "Subtype.val",
   "Set.Elem",
   "IsGreatest",
   "And.intro",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "IsTotal.total",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "eq_of_ge_of_not_gt",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "upperBounds",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Or.inr",
   "Subtype",
   "lt_of_le_of_ne",
   "Prod.fst",
   "Or.inl",
   "IsWellFounded.wf",
   "le_of_eq",
   "WellFoundedGT",
   "Eq",
   "Subtype.le",
   "Preorder.toLE",
   "InIntvl",
   "Not",
   "impl.prop3d4",
   "μDCC",
   "Lattice.toSemilatticeInf",
   "impl.prop3d8₁",
   "Set",
   "ConvexI",
   "LT.lt",
   "Or.casesOn",
   "IsTotal",
   "LE.le",
   "StI",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.prop3d8₁'",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  μDCC μ →\n    ∀ (I : { p // p.1 < p.2 }),\n      ConvexI I μ →\n        ((IsTotal S fun x1 x2 => x1 ≤ x2) ∨\n            ∀ (z : ℒ) (hzI : InIntvl I z) (hz : (↑I).1 ≠ z), IsAttained μ ⟨((↑I).1, z), ⋯⟩) →\n          ∃ s, IsGreatest (StI μ I) s",
  "constCategory": "Theorem"},
 {"references":
  ["List.nil",
   "instAddNat",
   "instHAdd",
   "List.brecOn",
   "List",
   "List.length.match_1",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "List.below",
   "Nat",
   "instOfNatNat",
   "List.cons"],
  "name": "List.length",
  "constType": "{α : Type u_1} → List α → ℕ",
  "constCategory": "Definition"},
 {"references": ["Lean.Name"],
  "name": "Lean.Name.anonymous",
  "constType": "Name",
  "constCategory": "Other"},
 {"references": [],
  "name": "Subtype",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "instOfNatNat",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "Nat",
   "impl.prop3d4₀func",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "impl.prop3d4₀func._proof_3",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func.eq_1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  impl.prop3d4₀func μ I 0 = ⟨(↑I).2, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Decidable",
   "Eq.trans",
   "Subsingleton.elim",
   "Eq.mpr_not",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "GT.gt",
   "Subtype.val",
   "impl.ℒₛ",
   "funext",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat",
   "impl.prop3d4₀func",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "impl.prop3d4₀func._proof_7",
   "impl.prop3d4₀func._proof_8",
   "Subtype",
   "instDecidableTrue",
   "Eq.mp",
   "dite_congr",
   "Prod.fst",
   "congrArg",
   "instOfNatNat",
   "congr",
   "WellFoundedGT",
   "instSubsingletonDecidable",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "impl.prop3d4₀func._proof_4",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "Ne",
   "Subtype.mk",
   "dite",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func_helper",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ),\n  (↑I).1 ≠ ↑(impl.prop3d4₀func μ I (i + 1)) → (↑I).1 ≠ ↑(impl.prop3d4₀func μ I i)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "LE.le",
   "And.right",
   "And",
   "Iff.mp",
   "Preorder.toLT",
   "Preorder.toLE",
   "lt_iff_le_not_le"],
  "name": "not_le_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "HMul.hMul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "mul_neg",
   "MonoidWithZero.toMonoid",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "InvolutiveNeg.toNeg",
   "Eq.ndrec",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "instHPow",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "HPow.hPow",
   "Ring.toSemiring",
   "Ring.toAddCommGroup",
   "eq_self",
   "Nat",
   "NegZeroClass.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Monoid.toNatPow",
   "of_eq_true",
   "instHMul",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_mul",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] (a₁ : R) (a₂ : ℕ) {a₃ b : R}, -a₃ = b → -(a₁ ^ a₂ * a₃) = a₁ ^ a₂ * b",
  "constCategory": "Theorem"},
 {"references":
  ["semistable._proof_3",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "μA",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "semistable._proof_4",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "Top.top",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "semistable",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.toNeg",
   "SubNegZeroMonoid.toSubNegMonoid",
   "NegZeroClass",
   "NegZeroClass.mk",
   "SubNegZeroMonoid",
   "SubNegZeroMonoid.neg_zero"],
  "name": "SubNegZeroMonoid.toNegZeroClass",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → NegZeroClass G",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Iff", "Membership.mem", "Iff.rfl", "setOf", "Set.instMembership"],
  "name": "Set.mem_setOf",
  "constType": "∀ {α : Type u} {a : α} {p : α → Prop}, a ∈ {x | p x} ↔ p a",
  "constCategory": "Theorem"},
 {"references": ["Subtype", "Subtype.property", "Subtype.val"],
  "name": "Subtype.prop",
  "constType": "∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat", "Nat.instCommSemiring", "CommSemiring", "inferInstance"],
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "sup_le",
   "Subtype.val",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "impl.prop2d8₀I",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "inf_le_left",
   "ConditionallyCompleteLattice.toLattice",
   "setOf",
   "inf_le_right",
   "Or.inr",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "lt_of_le_of_ne",
   "Prod.fst",
   "Or.inl",
   "μA",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Lattice.toSemilatticeInf",
   "le_sInf_iff",
   "Set",
   "Or.casesOn",
   "ConvexI",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "Max.max",
   "Min.min",
   "LE.le",
   "SemilatticeSup.toMax",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "CompleteLattice",
   "lt_sup_of_lt_left"],
  "name": "impl.prop2d8₁I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (y : ℒ),\n          InIntvl I y →\n            ∀ (u : ℒ), InIntvl I u → ∀ (h : u < x ∧ u < y), μA μ ⟨(u, x), ⋯⟩ ⊓ μA μ ⟨(u, y), ⋯⟩ ≤ μA μ ⟨(u, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Real", "_private.Mathlib.Data.Real.Basic.0.Real.lt", "LT.mk", "LT"],
  "name": "Real.instLT",
  "constType": "LT ℝ",
  "constCategory": "Definition"},
 {"references": ["Monoid", "MonoidWithZero"],
  "name": "MonoidWithZero.toMonoid",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Monoid M₀",
  "constCategory": "Definition"},
 {"references": ["OfNat", "OfNat.mk", "Zero", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddGroup",
   "Ring.toAddGroupWithOne",
   "Eq.refl",
   "SubNegMonoid.toSub",
   "Eq.symm",
   "HSub.hSub",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "instHSub",
   "Eq",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.sub_congr",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a a' b b' c : R}, a = a' → b = b' → a' - b' = c → a - b = c",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "Decidable.isFalse", "False", "not_false"],
  "name": "instDecidableFalse",
  "constType": "Decidable False",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Prod",
   "PartialOrder.toPreorder",
   "Subtype",
   "PartialOrder",
   "LE.le",
   "And",
   "Preorder.toLT",
   "Prod.snd",
   "Preorder.toLE",
   "Subtype.val",
   "Prod.fst"],
  "name": "InIntvl",
  "constType":
  "{ℒ : Type} → [inst : PartialOrder ℒ] → { p // p.1 < p.2 } → ℒ → Prop",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq.symm", "Eq.ndrec", "Eq"],
  "name": "Mathlib.Tactic.Ring.of_eq",
  "constType": "∀ {α : Sort u_2} {a b c : α}, a = c → b = c → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "instLTNat",
   "Nat",
   "GetElem",
   "List.get",
   "Fin.mk",
   "List",
   "List.length",
   "GetElem.mk"],
  "name": "List.instGetElemNatLtLength",
  "constType":
  "{α : Type u_1} → GetElem (List α) ℕ α fun as i => i < as.length",
  "constCategory": "Definition"},
 {"references":
  ["instLTNat",
   "List",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.263",
   "Option.some",
   "List.instGetElem?NatLtLength",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.251",
   "LT.lt",
   "GetElem?.getElem?",
   "Nat",
   "Iff",
   "Option",
   "List.mem_of_getElem?",
   "List.TFAE",
   "autoParam",
   "Eq",
   "List.length"],
  "name": "List.TFAE.out",
  "constType":
  "∀ {l : List Prop},\n  l.TFAE →\n    ∀ (n₁ n₂ : ℕ) {a b : Prop}, autoParam (l[n₁]? = some a) _auto✝ → autoParam (l[n₂]? = some b) _auto✝¹ → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "Lattice",
   "SemilatticeSup.toPartialOrder",
   "Lattice.inf",
   "SemilatticeInf.mk",
   "Lattice.le_inf"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["LE.le.eq_or_lt",
   "LT.lt",
   "Not",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Or.resolve_right",
   "Preorder.toLT",
   "Eq",
   "Preorder.toLE"],
  "name": "eq_of_le_of_not_lt",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≤ b → ¬a < b → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "Semiring.mul_one",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "MonoidWithZero",
   "Semiring.one_mul",
   "Semiring.npow_succ",
   "MonoidWithZero.mk",
   "Semigroup.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Monoid.mk",
   "Semiring.npow",
   "Semiring.npow_zero",
   "Semiring.toNonUnitalSemiring",
   "Semiring",
   "NonUnitalSemiring.mul_assoc"],
  "name": "Semiring.toMonoidWithZero",
  "constType": "{α : Type u} → [self : Semiring α] → MonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["le_rfl",
   "SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "inf_le_inf",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_le_inf_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a : α) {b c : α}, b ≤ c → b ⊓ a ≤ c ⊓ a",
  "constCategory": "Theorem"},
 {"references": ["Subtype", "Subtype.forall", "Subtype.mk", "Eq", "propext"],
  "name": "_private.Init.Data.Subtype.0._proof_1",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∀ (x : { a // p a }), q x) = ∀ (a : α) (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "exists_prop_congr.match_1",
   "Iff.mpr",
   "Iff",
   "Iff.mp",
   "Exists.intro",
   "exists_prop_congr.match_2",
   "Iff.intro"],
  "name": "exists_prop_congr",
  "constType":
  "∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q ↔ ∃ (h : p'), q' ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "CompleteSemilatticeInf.toPartialOrder",
   "ConvexI._proof_2",
   "Preorder.toLE",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Max.max",
   "Min.min",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toMax",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "ConvexI._proof_1",
   "CompleteLattice"],
  "name": "ConvexI",
  "constType":
  "{ℒ : Type} →\n  [inst : Lattice ℒ] → {S : Type} → [CompleteLattice S] → { p // p.1 < p.2 } → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references": ["HasSubset.mk", "Set", "HasSubset", "LE.le", "Set.instLE"],
  "name": "Set.instHasSubset",
  "constType": "{α : Type u} → HasSubset (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "TotIntvl",
   "Prod.mk",
   "Preorder.toLT",
   "μAstar",
   "SlopeLike._proof_1",
   "Subtype.val",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "prop_4_3_cond₁",
   "μBstar",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "impl.prop4d1₂",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod",
   "BoundedOrder.toOrderBot",
   "impl.prop4d11₁",
   "Iff",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "Subtype",
   "OmegaCompletePartialOrder.toPartialOrder",
   "prop_4_1_cond₁",
   "SlopeLike._proof_2",
   "impl.prop4d11₂",
   "Prod.fst",
   "Iff.intro",
   "eq_of_le_of_le",
   "Subtype.prop",
   "Or.inl",
   "BoundedOrder.toOrderTop",
   "prop_4_3_cond₂._proof_6",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "μmin",
   "NashEquilibrium",
   "Lattice.toSemilatticeInf",
   "LT.lt",
   "Or.casesOn",
   "le_of_lt",
   "LE.le",
   "SlopeLike",
   "SlopeLike._proof_3",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "Eq.le",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "impl.prop4d16₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  SlopeLike μ → prop_4_1_cond₁ μ → prop_4_3_cond₁ μ → (μmin μ TotIntvl = μmax μ TotIntvl ↔ NashEquilibrium μ)",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "PUnit.unit",
  "constType": "PUnit.{u}",
  "constCategory": "Other"},
 {"references": ["Neg", "NegZeroClass"],
  "name": "NegZeroClass.toNeg",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Neg G",
  "constCategory": "Definition"},
 {"references":
  ["Int.instCommSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Int",
   "Semiring"],
  "name": "Int.instSemiring",
  "constType": "Semiring ℤ",
  "constCategory": "Definition"},
 {"references": ["Min"],
  "name": "Min.min",
  "constType": "{α : Type u} → [self : Min α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "SlopeLike._proof_2",
   "Prod.snd",
   "SlopeLike._proof_1",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Or",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "SlopeLike._proof_3",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "SlopeLike",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeSup.le_sSup",
   "PartialOrder.toPreorder",
   "SupSet.sSup",
   "Set",
   "LE.le",
   "Membership.mem",
   "CompleteSemilatticeSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "le_sSup",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, a ∈ s → a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "add_left_comm",
   "True",
   "Eq.trans",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.toAddCommSemigroup",
   "of_eq_true",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Eq",
   "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_gt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₂ c : R} (b₁ : R), a + b₂ = c → a + (b₁ + b₂) = b₁ + c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "sInf_le_sInf",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "Subtype",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "le_rfl",
   "eq_of_le_of_le",
   "μA",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "Lattice.toSemilatticeInf",
   "Set",
   "ConvexI",
   "LT.lt",
   "impl.rmk2d5₂",
   "LE.le",
   "Convex_of_Convex_large",
   "Ne",
   "Subtype.mk",
   "μmax",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.rmk2d5₃",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ → μA μ I = μA (μmax μ) I",
  "constCategory": "Theorem"},
 {"references": ["Nat", "LE.mk", "LE", "Nat.le"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "le_sInf_iff",
   "Set",
   "Membership.mem",
   "CompleteSemilatticeInf",
   "Set.instMembership",
   "CompleteSemilatticeInf.toInfSet",
   "LE.le",
   "CompleteSemilatticeInf.toPartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "propext"],
  "name": "_private.Mathlib.Order.CompleteLattice.Defs.0._proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, (a ≤ sInf s) = ∀ b ∈ s, a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "TotIntvl",
   "Prod.mk",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "in_TotIntvl",
   "And.intro",
   "Or",
   "sSup_le",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "impl.rmk4d10₀",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "μmax._proof_2",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Classical.not_not",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Or.resolve_right",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Prod.fst",
   "le_rfl",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "propext",
   "μmin",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "Set",
   "sInf_le",
   "LT.lt",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "μmax",
   "OrderTop.toTop",
   "CompleteLattice",
   "And.casesOn"],
  "name": "impl.prop4d14",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤), μ ⟨(⊥, x), ⋯⟩ ≤ μ TotIntvl ∨ ¬μ TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩) →\n    μmin μ TotIntvl = μ TotIntvl → μmax μ TotIntvl = μmin μ TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.intCast_ofNat",
   "Ring.toSub",
   "AddGroup.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.zsmul_succ'",
   "Ring.toNonUnitalRing._proof_13",
   "AddCommMonoid.toAddMonoid",
   "Ring.intCast_negSucc",
   "Ring.zsmul_zero'",
   "Ring.sub_eq_add_neg",
   "Semiring.toNatCast",
   "AddCommGroup.mk",
   "Ring.toNonAssocRing._proof_18",
   "SubNegMonoid.mk",
   "Semiring.toNonUnitalSemiring",
   "Ring.toNeg",
   "Semiring.toOne",
   "Ring.toNonAssocRing._proof_17",
   "Ring.zsmul",
   "Ring.toNonUnitalRing._proof_14",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocRing",
   "Ring.zsmul_neg'",
   "Ring.neg_add_cancel",
   "NonUnitalNonAssocRing.mk",
   "Ring.toSemiring",
   "Ring.toNonUnitalRing._proof_10",
   "Ring.toNonUnitalRing._proof_12",
   "Ring.toIntCast",
   "Ring.toNonUnitalRing._proof_11",
   "Ring.toNonAssocRing._proof_16",
   "Ring.toNonAssocRing._proof_19",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocRing.mk",
   "Ring"],
  "name": "Ring.toNonAssocRing",
  "constType": "{α : Type u} → [Ring α] → NonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "TotIntvl._proof_1",
   "OrderBot.toBot",
   "Subtype.mk",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "TotIntvl",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "TotIntvl",
   "Eq.trans",
   "Exists.intro",
   "Subtype.val",
   "in_TotIntvl",
   "SupSet.sSup",
   "letFun",
   "Eq.symm",
   "TotIntvl._proof_1",
   "impl.prop4d1₁",
   "μBstar",
   "semistable._proof_4",
   "Exists",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "μB",
   "BoundedOrder.toOrderBot",
   "Interval",
   "Eq.refl",
   "Lattice",
   "Top.top",
   "Set.ext",
   "Eq.mpr",
   "setOf",
   "Ne.symm",
   "OmegaCompletePartialOrder.toPartialOrder",
   "instLatticeInterval",
   "Prod.fst",
   "congr",
   "InfSet.sInf",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "μmin",
   "NashEquilibrium",
   "Set",
   "eq_self",
   "SupSet",
   "Resμ._proof_19",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "bot_lt_top",
   "CompleteLattice",
   "LE.le.not_lt",
   "InfSet",
   "semistable._proof_3",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Iff.mp",
   "bot_le",
   "μAstar",
   "And.intro",
   "instBoundedOrderInterval",
   "funext",
   "forall_congr",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "μA._proof_3",
   "Bot.bot",
   "Resμ",
   "Exists.casesOn",
   "prop_4_1_cond₂",
   "Iff.of_eq",
   "μmax._proof_2",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "prop_4_1_cond₁",
   "semistable",
   "impl.stupid_helper",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Iff.intro",
   "congrArg",
   "BoundedOrder.toOrderTop",
   "μA",
   "_private.Init.PropLemmas.0._proof_12",
   "OrderBot.toBot",
   "InIntvl",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "of_eq_true",
   "LE.le",
   "le_sSup",
   "Subtype.mk",
   "ConditionallyCompleteLattice.toSupSet",
   "OrderTop.toTop",
   "instNontrivialInterval",
   "Subtype.coe_ne_coe"],
  "name": "impl.prop4d20",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℒ) (hx : x ≠ ⊥), prop_4_1_cond₁ (Resμ ⟨(⊥, x), ⋯⟩ μ)) →\n    (∀ (x : ℒ) (hx : x ≠ ⊥), prop_4_1_cond₂ (Resμ ⟨(⊥, x), ⋯⟩ μ)) → NashEquilibrium μ → semistable μ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop → Type",
  "constCategory": "Other"},
 {"references":
  ["implies_congr",
   "TotIntvl",
   "Eq.trans",
   "Exists.intro",
   "Membership.mem.out",
   "S₁I._proof_2",
   "Subtype.val",
   "in_TotIntvl",
   "SupSet.sSup",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Subtype.coe_eta",
   "Eq.symm",
   "Eq.ndrec",
   "rfl",
   "Exists",
   "BoundedOrder",
   "Prod.snd",
   "Set.setOf_app_iff",
   "semistableI",
   "Set.instMembership",
   "Prod",
   "Interval",
   "Iff",
   "Eq.refl",
   "Lattice",
   "Set.ext",
   "Eq.mpr",
   "setOf",
   "instLatticeInterval",
   "Prod.fst",
   "le_rfl",
   "congr",
   "InfSet.sInf",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Set",
   "lt_of_eq_of_lt",
   "Resμ._proof_19",
   "SupSet",
   "StI",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "CompleteLattice",
   "And.casesOn",
   "impl.semistable_iff",
   "InfSet",
   "PartialOrder.toPreorder",
   "lt_of_lt_of_eq",
   "Set.mem_def",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Iff.mp",
   "GT.gt",
   "And.intro",
   "instBoundedOrderInterval",
   "PartialOrder",
   "forall_congr",
   "funext",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "μA._proof_3",
   "Resμ",
   "Exists.casesOn",
   "Subtype.coe_eq_of_eq_mk",
   "Iff.of_eq",
   "μmax._proof_2",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "S₂I",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "impl.stupid_helper",
   "semistable",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Iff.intro",
   "congrArg",
   "Subtype.prop",
   "μA",
   "InIntvl",
   "Not",
   "Lattice.toSemilatticeInf",
   "Prod.mk.eta",
   "exists_prop_congr",
   "LT.lt",
   "CompleteSemilatticeInf.toInfSet",
   "ne_of_lt",
   "le_of_lt",
   "S₁I",
   "LE.le",
   "Subtype.mk",
   "_private.Init.Core.0._proof_39",
   "instNontrivialInterval",
   "Subtype.coe_ne_coe"],
  "name": "impl.semistableI_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  semistableI μ I ↔ semistable (Resμ I μ)",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references": ["AddGroupWithOne", "AddMonoidWithOne"],
  "name": "AddGroupWithOne.toAddMonoidWithOne",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references": ["True", "Eq", "trivial", "propext", "Iff.intro"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "Exists", "Classical.not_forall", "Eq", "propext"],
  "name": "_private.Init.Classical.0._proof_9",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) = ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "GetElem?.mk",
   "List.instGetElemNatLtLength",
   "instLTNat",
   "Nat",
   "_private.Init.GetElem.0.List.get!Internal",
   "_private.Init.GetElem.0.List.get?Internal",
   "GetElem?",
   "List",
   "Inhabited",
   "List.length"],
  "name": "List.instGetElem?NatLtLength",
  "constType":
  "{α : Type u_1} → GetElem? (List α) ℕ α fun as i => i < as.length",
  "constCategory": "Definition"},
 {"references": ["Option", "outParam", "GetElem?"],
  "name": "GetElem?.getElem?",
  "constType":
  "{coll : Type u} →\n  {idx : Type v} →\n    {elem : outParam (Type w)} →\n      {valid : outParam (coll → idx → Prop)} → [self : GetElem? coll idx elem valid] → coll → idx → Option elem",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "le_top",
   "PartialOrder.toPreorder",
   "Min.min",
   "inf_of_le_left",
   "Top.top",
   "OrderTop",
   "Eq",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_top_eq",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : OrderTop α] (a : α), a ⊓ ⊤ = a",
  "constCategory": "Theorem"},
 {"references": ["PartialOrder", "CompleteSemilatticeInf"],
  "name": "CompleteSemilatticeInf.toPartialOrder",
  "constType":
  "{α : Type u_8} → [self : CompleteSemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["rfl", "Subtype", "Subtype.ext", "Subtype.mk", "Eq", "Subtype.val"],
  "name": "Subtype.coe_eta",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (a : { a // p a }) (h : p ↑a), ⟨↑a, h⟩ = a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Eq.rec", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "Set.instHasSubset",
   "PartialOrder.toPreorder",
   "HasSubset.Subset",
   "Set",
   "LE.le",
   "InfSet.sInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "IsGLB.mono",
   "Preorder.toLE",
   "isGLB_sInf",
   "CompleteSemilatticeInf"],
  "name": "sInf_le_sInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s t : Set α}, s ⊆ t → sInf t ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toNatCast",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring",
   "AddCommMonoid.add_comm",
   "AddCommMonoidWithOne",
   "AddCommMonoid.toAddMonoid",
   "AddMonoidWithOne.mk",
   "NonAssocSemiring.natCast_succ"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "implies_congr",
   "TotIntvl",
   "Eq.trans",
   "Exists.intro",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "impl.prop4d1₁_seq",
   "strictMono_nat_of_lt_succ",
   "in_TotIntvl",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Exists",
   "Exists.choose_spec",
   "ne_top_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Lattice",
   "Classical.byContradiction",
   "Top.top",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "setOf",
   "StrictMono",
   "Prod.fst",
   "Nat.instPreorder",
   "impl.prop4d1_helper",
   "instOfNatNat",
   "InfSet.sInf",
   "Eq",
   "Preorder.toLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "μmin",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "Set",
   "sInf_le_of_le",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "Ne",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "bot_lt_top",
   "CompleteLattice",
   "And.casesOn",
   "lt_trans",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Subtype.preorder",
   "μAstar",
   "And.intro",
   "Or",
   "sSup_le",
   "funext",
   "forall_congr",
   "Eq.rec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "ConditionallyCompleteLattice.toInfSet",
   "And.right",
   "And",
   "μA._proof_3",
   "Bot.bot",
   "Nat.lt_add_one",
   "Exists.casesOn",
   "Nat",
   "Iff.of_eq",
   "μmax._proof_2",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "Subtype",
   "Eq.mp",
   "lt_of_le_of_ne",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Set.mem_setOf",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "OrderBot.toBot",
   "le_antisymm",
   "InIntvl",
   "Not",
   "Set.Nonempty",
   "le_top",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Mathlib.Tactic.PushNeg.not_and_eq",
   "Mathlib.Tactic.PushNeg.not_forall_eq",
   "Exists.choose",
   "exists_prop_congr",
   "LT.lt",
   "LE.le",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "False",
   "le_sInf",
   "Subtype.mk",
   "OrderTop.toTop"],
  "name": "impl.prop4d1₁",
  "constType":
  "∀ (ℒ : Type) [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] (S : Type)\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n    (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n        μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n      μAstar μ = μmin μ TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "μB",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Nontrivial",
   "Top.top",
   "OrderBot.toBot",
   "Subtype.mk",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "μBstar",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → S",
  "constCategory": "Definition"},
 {"references": ["Nat.lt", "Nat", "LT.mk", "LT"],
  "name": "instLTNat",
  "constType": "LT ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Iff.trans",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "True",
   "Eq.trans",
   "And",
   "and_true",
   "true_and",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "congrArg",
   "SemilatticeInf",
   "le_antisymm_iff",
   "iff_self",
   "of_eq_true",
   "Min.min",
   "congr",
   "Iff",
   "_private.Mathlib.Order.Lattice.0._proof_17",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "_private.Mathlib.Order.Lattice.0._proof_18",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_eq_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["absurd", "Not", "Or.elim", "Or", "id"],
  "name": "Or.resolve_left",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬a → b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "absurd",
   "LT.lt",
   "Preorder",
   "lt_irrefl",
   "Preorder.toLT",
   "False",
   "Ne",
   "Eq.rec",
   "Eq"],
  "name": "ne_of_gt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, b < a → a ≠ b",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Ring"],
  "name": "Ring.toSemiring",
  "constType": "{R : Type u} → [self : Ring R] → Semiring R",
  "constCategory": "Definition"},
 {"references": ["True", "eq_true", "Eq", "trivial"],
  "name": "implies_true",
  "constType": "∀ (α : Sort u), (∀ (a : α), True) = True",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.succ", "Nat.rec", "Nat.zero"],
  "name": "Nat.casesOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → motive Nat.zero → ((n : ℕ) → motive n.succ) → motive t",
  "constCategory": "Definition"},
 {"references": ["Nat", "OfNat", "OfNat.mk", "Int.ofNat", "Int"],
  "name": "instOfNat",
  "constType": "{n : ℕ} → OfNat ℤ n",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "GT.gt",
   "impl.ℒₛ",
   "Subtype.val",
   "Prod.fst",
   "instOfNatNat",
   "impl.prop3d4₀func._proof_5",
   "WellFoundedGT",
   "impl.prop3d4₀func._proof_6",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "impl.prop3d4₀func.match_1",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "impl.prop3d4₀func._proof_4",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Nat.brecOn",
   "Exists.choose",
   "OfNat.ofNat",
   "Set.instMembership",
   "Unit",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nontrivial",
   "Nat.below",
   "Subtype.mk",
   "dite",
   "impl.prop3d4₀func._proof_3",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        [h : WellFoundedGT ℒ] →\n          {S : Type} →\n            [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → (I : { p // p.1 < p.2 }) → ℕ → { p // InIntvl I p }",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Bool",
   "PartialOrder.toPreorder",
   "Nat.cast",
   "Nat.cast_lt",
   "Mathlib.Meta.NormNum.ble_eq_false",
   "Bool.false",
   "Iff.mp",
   "Preorder.toLT",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "Semiring.toNonAssocSemiring",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "CharZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Nat.ble",
   "IsOrderedRing.toZeroLEOneClass",
   "instLTNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Meta.NormNum.isNat_lt_true.match_1",
   "IsOrderedAddMonoid.toAddLeftMono",
   "LT.lt",
   "IsOrderedRing",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.IsNat",
   "Semiring"],
  "name": "Mathlib.Meta.NormNum.isNat_lt_true",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] [CharZero α] {a b : α} {a' b' : ℕ},\n  Mathlib.Meta.NormNum.IsNat a a' → Mathlib.Meta.NormNum.IsNat b b' → b'.ble a' = false → a < b",
  "constCategory": "Theorem"},
 {"references": ["Top"],
  "name": "Top.top",
  "constType": "{α : Type u_1} → [self : Top α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Int.instCommRing",
   "CommRing.toRing",
   "Nat",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toAddMonoidWithOne",
   "CharZero.mk",
   "CharZero",
   "Int.ofNat.inj",
   "Int"],
  "name": "Int.instCharZero",
  "constType": "CharZero ℤ",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Eq.rec", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Preorder", "Preorder.toLT"],
  "name": "StrictMono",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Eq.mp",
   "Iff.mp",
   "Classical.propDecidable",
   "Preorder.toLT",
   "Subtype.val",
   "congrArg",
   "Prod.fst",
   "impl.prop3d4₀func_fin_len",
   "Subtype.prop",
   "instOfNatNat",
   "letFun",
   "Eq.symm",
   "WellFoundedGT",
   "Eq.rec",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "μDCC",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "Nat.find_spec",
   "Nat",
   "impl.prop3d4₀func",
   "Eq.refl",
   "Lattice",
   "Nontrivial",
   "False",
   "Ne",
   "lt_self_iff_false",
   "CompleteLattice",
   "impl.prop3d4₀func_len"],
  "name": "impl.prop3d4₀func_len_nonzero",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (hμDCC : μDCC μ),\n  impl.prop3d4₀func_len μ I hμDCC ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "List.rec",
   "GetElem.getElem",
   "List",
   "Option.some",
   "List.instGetElem?NatLtLength",
   "Nat.le.casesOn",
   "GetElem?.getElem?",
   "instOfNatNat",
   "Nat.le.refl",
   "Eq.symm",
   "Eq.ndrec",
   "Eq",
   "List.get._proof_34",
   "List.cons",
   "Nat.le",
   "Nat.casesAuxOn",
   "List.nil",
   "List.instGetElemNatLtLength",
   "instLTNat",
   "HEq.refl",
   "instHAdd",
   "Nat.noConfusion",
   "Nat.le.step",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "Nat.succ",
   "Option",
   "Eq.refl",
   "HEq",
   "List.length"],
  "name": "List.getElem?_eq_getElem",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i : ℕ} (h : i < l.length), l[i]? = some l[i]",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "OrderDual", "Equiv"],
  "name": "OrderDual.toDual",
  "constType": "{α : Type u_1} → α ≃ αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "_neutral",
   "impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._rarg"],
  "name":
  "impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["PartialOrder", "OmegaCompletePartialOrder"],
  "name": "OmegaCompletePartialOrder.toPartialOrder",
  "constType":
  "{α : Type u_6} → [self : OmegaCompletePartialOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["impl.prop4d3₁",
   "PartialOrder.toPreorder",
   "TotIntvl",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "μAstar",
   "Subtype.val",
   "in_TotIntvl",
   "And.intro",
   "CompleteSemilatticeInf.toPartialOrder",
   "funext",
   "prop_4_3_cond₁",
   "Eq.symm",
   "TotIntvl._proof_1",
   "Eq.rec",
   "μBstar",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Bot.bot",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Iff",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "id",
   "Eq.mpr",
   "lt_top_iff_ne_top",
   "setOf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Subtype",
   "Eq.mp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Iff.intro",
   "Prod.fst",
   "congrArg",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "μA",
   "InfSet.sInf",
   "OrderBot.toBot",
   "bot_ne_top",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "propext",
   "Not",
   "NashEquilibrium",
   "Lattice.toSemilatticeInf",
   "Set",
   "exists_prop_congr",
   "sInf_le",
   "CompleteSemilatticeInf.toInfSet",
   "LT.lt",
   "prop_4_3_cond₂",
   "LE.le",
   "le_sInf",
   "Ne",
   "Subtype.mk",
   "μmax",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "bot_lt_top"],
  "name": "impl.rmk4d10₃",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  prop_4_3_cond₁ μ →\n    prop_4_3_cond₂ μ → (NashEquilibrium μ ↔ ∀ (y : ℒ) (hy : y ≠ ⊤), μmax μ TotIntvl ≤ μmax μ ⟨(y, ⊤), ⋯⟩)",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "Option.some",
  "constType": "{α : Type u} → α → Option α",
  "constCategory": "Other"},
 {"references":
  ["Nat",
   "instOfNatNat",
   "Iff",
   "LE.le",
   "Nat.pos_iff_ne_zero",
   "Ne",
   "instLENat",
   "OfNat.ofNat"],
  "name": "Nat.one_le_iff_ne_zero",
  "constType": "∀ {n : ℕ}, 1 ≤ n ↔ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "impl.lem2d4₂I",
   "Prod.snd",
   "Prod.fst",
   "le_rfl",
   "ConvexI",
   "Prod",
   "LT.lt",
   "Max.max",
   "SemilatticeSup.toMax",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "μmax",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "impl.rmk2d5₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S), ConvexI I μ → ConvexI I (μmax μ)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "OrderTop",
   "LT.lt",
   "PartialOrder",
   "Iff",
   "Top.top",
   "Preorder.toLE",
   "Eq",
   "lt_top_iff_ne_top",
   "Iff.not_left",
   "OrderTop.toTop"],
  "name": "not_lt_top_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, ¬a < ⊤ ↔ a = ⊤",
  "constCategory": "Theorem"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["IsStrictOrderedRing",
   "Lattice.toSemilatticeInf",
   "Int.instSemiring",
   "Int.instNontrivial",
   "Int.instIsOrderedAddMonoid",
   "Int.mul_pos",
   "IsStrictOrderedRing.of_mul_pos",
   "Int.instZeroLEOneClass",
   "Int.instRing",
   "instLatticeInt",
   "SemilatticeInf.toPartialOrder",
   "Int"],
  "name": "Int.instIsStrictOrderedRing",
  "constType": "IsStrictOrderedRing ℤ",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "HMul.hMul",
   "Int.rawCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroup.toSubtractionMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "InvolutiveNeg.toNeg",
   "Eq.ndrec",
   "MulOneClass.toMul",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Neg.neg",
   "Int.instNegInt",
   "Ring.toSemiring",
   "instOfNat",
   "AddMonoidWithOne.toOne",
   "Int.negOfNat",
   "instHMul",
   "one_mul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "MulZeroOneClass.toMulOneClass",
   "Int.cast",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "Int.cast_one",
   "neg_mul",
   "MulOneClass.toOne",
   "Eq",
   "True",
   "Distrib.toMul",
   "OfNat.ofNat",
   "Int.cast_neg",
   "Int",
   "Ring.toAddCommGroup",
   "eq_self",
   "NegZeroClass.toNeg",
   "AddGroupWithOne.toAddGroup",
   "of_eq_true",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HasDistribNeg.toInvolutiveNeg",
   "One.toOfNat1",
   "AddGroupWithOne.toIntCast",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.neg_one_mul",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a b : R}, (Int.negOfNat 1).rawCast * a = b → -a = b",
  "constCategory": "Theorem"},
 {"references": ["Not", "Exists", "not_exists", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_exists_eq",
  "constType": "∀ {α : Sort u_1} (s : α → Prop), (¬∃ x, s x) = ∀ (x : α), ¬s x",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "OrderDual.instLT",
   "Lattice",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (p : { p // p.1 < p.2 }), (↑p).1 < (↑p).2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Set",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["List.Chain", "List", "List.cons"],
  "name": "List.Chain.cons",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α}, R a b → List.Chain R b l → List.Chain R a (b :: l)",
  "constCategory": "Other"},
 {"references":
  ["Nat", "OfNat", "Nat.cast", "OfNat.mk", "Nat.AtLeastTwo", "NatCast"],
  "name": "instOfNatAtLeastTwo",
  "constType":
  "{R : Type u_1} → {n : ℕ} → [NatCast R] → [n.AtLeastTwo] → OfNat R n",
  "constCategory": "Definition"},
 {"references": ["List.nil", "List.Chain"],
  "name": "List.Chain.nil",
  "constType": "∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []",
  "constCategory": "Other"},
 {"references":
  ["Iff.trans",
   "Max.max",
   "PartialOrder.toPreorder",
   "Iff",
   "eq_comm",
   "LE.le",
   "SemilatticeSup.toMax",
   "SemilatticeSup.toPartialOrder",
   "sup_eq_right",
   "SemilatticeSup",
   "Preorder.toLE",
   "Eq"],
  "name": "right_eq_sup",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b = a ⊔ b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["HPow", "outParam"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "le_trans",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeSup",
   "le_sup_left",
   "Preorder.toLE"],
  "name": "le_sup_of_le_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c ≤ a → c ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "le_of_lt",
   "not_le_of_lt",
   "le_trans",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLT",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq.refl",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "CommSemiring",
   "Eq.symm",
   "instHMul",
   "HMul.hMul",
   "Eq.ndrec",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.mul_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' * b' = c → a * b = c",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "impl.prop4d1₁_seq._proof_3",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Prod.fst",
   "Nat.instPreorder",
   "impl.prop4d1₁_seq",
   "impl.prop4d1₁_seq._proof_2",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "instHAdd",
   "impl.prop4d1₁_seq._proof_8",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "OfNat.ofNat",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf",
   "impl.prop4d1₁_seq._proof_1",
   "StrictMono"],
  "name": "impl.prop4d1₁_seq._proof_9",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S)\n  (h₁ : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩)\n  (h₂ :\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty) (k : ℕ),\n  ∃ xB,\n    ∃ (hAB : ↑(impl.prop4d1₁_seq μ h₁ h₂ h₃ k) < xB),\n      ¬μ ⟨(↑(impl.prop4d1₁_seq μ h₁ h₂ h₃ k), xB), hAB⟩ ≤ μ ⟨(↑(impl.prop4d1₁_seq μ h₁ h₂ h₃ k), ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Nat.cast",
   "Eq.trans",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "instOfNatNat",
   "Nat.add_succ",
   "Zero.toOfNat0",
   "Nat.cast_succ",
   "Eq",
   "AddMonoidWithOne",
   "AddSemigroup.toAdd",
   "True",
   "AddZeroClass.toZero",
   "instHAdd",
   "Nat.recAux",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "of_eq_true",
   "Nat.succ",
   "Eq.refl",
   "add_assoc",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_zero",
   "AddMonoidWithOne.toOne",
   "id",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass"],
  "name": "Nat.cast_add",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references": ["rfl", "True", "eq_true", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Decidable",
   "True",
   "Eq.trans",
   "instDecidableTrue",
   "Eq.mpr_not",
   "True.intro",
   "Eq.mpr_prop",
   "congrArg",
   "dite_congr",
   "eq_self",
   "of_eq_true",
   "Eq.refl",
   "Eq",
   "dite"],
  "name": "dite_cond_eq_true",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} {t : c → α} {e : ¬c → α} (h : c = True), dite c t e = t ⋯",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Pow", "Monoid", "Monoid.npow", "Pow.mk"],
  "name": "Monoid.toNatPow",
  "constType": "{M : Type u_2} → [Monoid M] → Pow M ℕ",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass", "Add"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "And.right",
   "Lattice",
   "Preorder.toLT",
   "And",
   "SemilatticeInf.toPartialOrder"],
  "name": "SlopeLike._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (x y z : ℒ), x < y ∧ y < z → y < z",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._cstage1",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "CompleteLattice.le_sInf",
   "CompleteSemilatticeInf.mk",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toPartialOrder",
   "CompleteLattice",
   "CompleteSemilatticeInf",
   "CompleteLattice.sInf_le"],
  "name": "CompleteLattice.toCompleteSemilatticeInf",
  "constType":
  "{α : Type u_8} → [self : CompleteLattice α] → CompleteSemilatticeInf α",
  "constCategory": "Definition"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{α : Type u_1} → [Sub α] → HSub α α α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompleteLattice",
  "constType": "Type u_8 → Type u_8",
  "constCategory": "Other"},
 {"references":
  ["Preorder",
   "upperBounds",
   "Set",
   "Iff",
   "LE.le",
   "Membership.mem",
   "Iff.rfl",
   "Preorder.toLE",
   "Set.instMembership"],
  "name": "mem_upperBounds",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, a ∈ upperBounds s ↔ ∀ x ∈ s, x ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "Subtype",
   "PartialOrder.toPreorder",
   "prop_4_1_cond₁",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "semistable",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "impl.prop4d3₂",
   "μAstar",
   "Prod.fst",
   "eq_of_le_of_le",
   "Or.inl",
   "Or",
   "prop_4_3_cond₁",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "μBstar",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "impl.prop4d18₁",
   "NashEquilibrium",
   "impl.prop4d1₂",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Or.casesOn",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "prop_4_1_cond₂",
   "prop_4_3_cond₂",
   "Eq.refl",
   "LE.le",
   "Lattice",
   "Nontrivial"],
  "name": "impl.prop4d18₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  semistable μ → prop_4_1_cond₁ μ ∧ prop_4_1_cond₂ μ ∨ prop_4_3_cond₁ μ ∧ prop_4_3_cond₂ μ → NashEquilibrium μ",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u_2} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Eq.rec", "Eq", "LT"],
  "name": "lt_of_lt_of_eq",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LT α], a < b → b = c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "AddZeroClass.toZero",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "zero_add",
   "AddZeroClass.toAdd",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_pf_zero_add",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 + b = b",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → γ → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Or.inr",
   "Or.rec",
   "Or.imp_right",
   "Or.inl",
   "Or",
   "Or.imp_left",
   "Iff",
   "Function.comp",
   "Iff.intro"],
  "name": "or_assoc",
  "constType": "∀ {a b c : Prop}, (a ∨ b) ∨ c ↔ a ∨ b ∨ c",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.natCast_succ",
   "Semiring.mul_one",
   "Semiring.natCast_zero",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "NonAssocSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNonUnitalSemiring",
   "Semiring.one_mul",
   "Semiring"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["add_left_comm",
   "Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "congr",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq.ndrec",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddSemigroup.toAdd",
   "Distrib.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "True",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "AddCommMonoid.toAddCommSemigroup",
   "add_assoc",
   "AddMonoid.toAddSemigroup"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b₁ b₂ c₁ c₂ : R},\n  a₁ + b₁ = c₁ → a₂ + b₂ = c₂ → a₁ + a₂ + (b₁ + b₂) = c₁ + c₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["IsTotal", "Or"],
  "name": "IsTotal.total",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop} [self : IsTotal α r] (a b : α), r a b ∨ r b a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "TotIntvl",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "not_le_of_lt",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "SlopeLike._proof_2",
   "SlopeLike._proof_1",
   "Prod.fst",
   "And.intro",
   "Or.inl",
   "Or",
   "BoundedOrder.toOrderTop",
   "letFun",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Or.casesOn",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "SlopeLike",
   "Top.top",
   "SlopeLike._proof_3",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "impl.rmk4d15",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  SlopeLike μ → ∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤), μ ⟨(⊥, x), ⋯⟩ ≤ μ TotIntvl ∨ ¬μ TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "SemilatticeSup.toPartialOrder",
   "Prod.fst",
   "LT.lt",
   "Max.max",
   "Iff.mpr",
   "SemilatticeSup.toMax",
   "Lattice",
   "LE.le",
   "right_lt_sup",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "ConvexI._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (x y : ℒ), ¬x ≤ y → (y, x ⊔ y).1 < x ⊔ (y, x ⊔ y).1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteLinearOrder",
  "constType": "Type u_8 → Type u_8",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "AddGroup"],
  "name": "AddGroup.toSubNegMonoid",
  "constType": "{A : Type u} → [self : AddGroup A] → SubNegMonoid A",
  "constCategory": "Definition"},
 {"references": ["Nat", "Int"],
  "name": "Int.ofNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "InIntvl",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "impl.ℒₛ._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (x : { p // InIntvl I p }),\n  (↑I).1 ≠ ↑x → ((↑I).1, ↑x).1 < ((↑I).1, ↑x).2",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Set",
   "Membership.mem",
   "Exists.intro",
   "Eq",
   "Set.range",
   "Set.instMembership"],
  "name": "Set.mem_range_self",
  "constType":
  "∀ {α : Type u} {ι : Sort u_1} {f : ι → α} (i : ι), f i ∈ Set.range f",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.cons",
  "constType": "{α : Type u} → α → List α → List α",
  "constCategory": "Other"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "Nat.casesOn",
   "Nat.succ",
   "instOfNatNat",
   "Unit.unit",
   "OfNat.ofNat",
   "Unit"],
  "name": "impl.prop3d4₀func.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (k : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive k",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toPartialOrder",
   "Nat",
   "PartialOrder",
   "inferInstance",
   "Nat.instLinearOrder"],
  "name": "Nat.instPartialOrder",
  "constType": "PartialOrder ℕ",
  "constCategory": "Definition"},
 {"references": ["NonAssocSemiring", "NonUnitalNonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring.toDistrib",
   "True",
   "Eq.trans",
   "Distrib.toMul",
   "CommSemiring",
   "MulZeroClass.toMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "OfNat.ofNat",
   "congrArg",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Zero.toOfNat0",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.mul_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Bot"],
  "name": "Bot.bot",
  "constType": "{α : Type u_1} → [self : Bot α] → α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "LT.lt",
   "instLTNat",
   "Nat",
   "instOfNatNat",
   "instHAdd",
   "Nat.lt.base",
   "OfNat.ofNat"],
  "name": "Nat.lt_add_one",
  "constType": "∀ (n : ℕ), n < n + 1",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.rec", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p), (∀ (w : α) (h : p w), motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "Or",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "prop_4_1_cond₂._proof_3",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "prop_4_1_cond₂",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Preorder.toLT",
   "OfNat.ofNat",
   "Nat.lt_add_one",
   "Nat.instPreorder",
   "LT.lt",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "Lattice",
   "StrictMono",
   "SemilatticeInf.toPartialOrder"],
  "name": "prop_4_1_cond₁._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (x : ℕ → ℒ), StrictMono x → ∀ (N : ℕ), x N < x (N + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "Subtype.property",
   "Subtype.ext",
   "Subtype.mk",
   "Eq.rec",
   "Eq",
   "Subtype.val"],
  "name": "Subtype.coe_eq_of_eq_mk",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a : { a // p a }} {b : α} (h : ↑a = b), a = ⟨b, ⋯⟩",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.rfl", "Eq.rec", "Eq"],
  "name": "Iff.of_eq",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "And.right",
   "Preorder.toLT",
   "And",
   "Prod.snd",
   "lt_of_le_of_ne",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "PartialOrder",
   "LE.le",
   "Ne",
   "Preorder.toLE",
   "InIntvl",
   "And.left"],
  "name": "μmax._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : PartialOrder ℒ] (I : { p // p.1 < p.2 }) (u : ℒ),\n  InIntvl I u ∧ (↑I).1 ≠ u → ((↑I).1, u).1 < ((↑I).1, u).2",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "LE",
   "OrderDual.instOrderBot",
   "OrderTop",
   "BoundedOrder",
   "inferInstanceAs",
   "OrderDual.instLE",
   "BoundedOrder.mk",
   "OrderBot",
   "OrderDual.instOrderTop"],
  "name": "OrderDual.instBoundedOrder",
  "constType":
  "(α : Type u) → [inst : LE α] → [BoundedOrder α] → BoundedOrder αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["instLTNat",
   "Iff.mp",
   "Nat.le_pred_iff_lt",
   "Nat.pred",
   "OfNat.ofNat",
   "LT.lt",
   "Nat",
   "instSubNat",
   "instOfNatNat",
   "LE.le",
   "HSub.hSub",
   "instHSub",
   "instLENat"],
  "name": "Nat.lt_of_le_sub_one",
  "constType": "∀ {m n : ℕ}, 0 < m → n ≤ m - 1 → n < m",
  "constCategory": "Theorem"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name":
  "impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.find",
   "μDCC",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Classical.propDecidable",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "impl.prop3d4₀func_fin_len",
   "Prod",
   "LT.lt",
   "Nat",
   "impl.prop3d4₀func",
   "Nontrivial",
   "Lattice",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "impl.prop3d4₀func_len",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        [WellFoundedGT ℒ] →\n          {S : Type} → [inst_4 : CompleteLattice S] → (μ : { p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → μDCC μ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "S₁I._proof_2",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "μA",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Ne",
   "Subtype.mk",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "S₂I",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        {S : Type} →\n          [CompleteLattice S] →\n            ({ p // p.1 < p.2 } → S) → (I : { p // p.1 < p.2 }) → (x : ℒ) → InIntvl I x → (↑I).1 ≠ x → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderDual",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Subtype", "LT.mk", "Subtype.val", "LT"],
  "name": "Subtype.lt",
  "constType": "{α : Type u_2} → [LT α] → {p : α → Prop} → LT (Subtype p)",
  "constCategory": "Definition"},
 {"references": ["Nat", "NatCast.natCast", "NatCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "OrderDual",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.inf",
   "OrderDual.instSemilatticeSup",
   "OrderDual.instLattice._proof_26",
   "Lattice",
   "Lattice.mk",
   "OrderDual.instLattice._proof_27",
   "OrderDual.instLattice._proof_25",
   "OrderDual.instSemilatticeInf"],
  "name": "OrderDual.instLattice",
  "constType": "(α : Type u_1) → [Lattice α] → Lattice αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["Not", "False"],
  "name": "Aesop.BuiltinRules.not_intro",
  "constType": "∀ {P : Prop}, (P → False) → ¬P",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "prop_4_1_cond₁._proof_2",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "prop_4_1_cond₁._proof_1",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "StrictMono"],
  "name": "prop_4_1_cond₁",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references": ["_obj", "Prod.mk", "_neutral"],
  "name":
  "impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references": ["absurd", "Not", "Or.elim", "Or", "id"],
  "name": "Or.resolve_right",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "mt",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "lt_of_le_not_le",
   "LE.le",
   "Preorder.toLT",
   "Ne",
   "Eq",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "lt_of_le_of_ne",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "impl.prop4d3₁",
   "TotIntvl",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "le_trans",
   "prop_4_1_cond₁",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "μAstar",
   "Prod.fst",
   "eq_of_le_of_le",
   "BoundedOrder.toOrderTop",
   "prop_4_3_cond₁",
   "OrderBot.toBot",
   "Eq",
   "Eq.rec",
   "Preorder.toLE",
   "impl.prop4d1₁",
   "μBstar",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "μmin",
   "impl.rmk4d10₀",
   "Lattice.toSemilatticeInf",
   "And.right",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "LT.lt",
   "Prod",
   "prop_4_1_cond₂",
   "prop_4_3_cond₂",
   "BoundedOrder.toOrderBot",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "μmax",
   "OrderTop.toTop",
   "bot_lt_top",
   "CompleteLattice"],
  "name": "impl.prop4d11₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  prop_4_1_cond₁ μ →\n    prop_4_1_cond₂ μ → prop_4_3_cond₁ μ → prop_4_3_cond₂ μ → μBstar μ ≤ μAstar μ → μmin μ TotIntvl = μmax μ TotIntvl",
  "constCategory": "Theorem"},
 {"references": ["DFunLike", "outParam"],
  "name": "DFunLike.coe",
  "constType":
  "{F : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (α → Sort u_3)} → [self : DFunLike F α β] → F → (a : α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["le_refl", "Preorder", "True", "LE.le", "eq_true", "Eq", "Preorder.toLE"],
  "name": "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_not", "Eq", "propext"],
  "name": "_private.Init.Classical.0._proof_7",
  "constType": "∀ {a : Prop}, (¬¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Subtype.val",
   "Prod.fst",
   "PartialOrder",
   "InfSet.sInf",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "Exists",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "LT.lt",
   "Prod",
   "CompleteSemilatticeInf.toInfSet",
   "Nontrivial",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "CompleteLattice",
   "setOf"],
  "name": "μA",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : PartialOrder ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references": ["WellFounded", "IsWellFounded"],
  "name": "IsWellFounded.wf",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [self : IsWellFounded α r], WellFounded r",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "True",
   "Eq.trans",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "add_assoc",
   "AddMonoid.toAddSemigroup",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddSemigroup.toAdd"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_lt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₂ b c : R} (a₁ : R), a₂ + b = c → a₁ + a₂ + b = a₁ + c",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "Not",
   "rfl",
   "Subsingleton",
   "Decidable.isFalse",
   "Decidable",
   "Subsingleton.intro",
   "Eq",
   "instSubsingletonDecidable.match_1",
   "Decidable.isTrue"],
  "name": "instSubsingletonDecidable",
  "constType": "∀ (p : Prop), Subsingleton (Decidable p)",
  "constCategory": "Theorem"},
 {"references": ["Subtype", "LE.le", "LE.mk", "LE", "Subtype.val"],
  "name": "Subtype.le",
  "constType": "{α : Type u_2} → [LE α] → {p : α → Prop} → LE (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["Real.partialOrder._proof_44",
   "Real.partialOrder._proof_45",
   "Real",
   "Real.partialOrder._proof_43",
   "Real.partialOrder._proof_42",
   "Real.instLE",
   "LT.lt",
   "PartialOrder.mk",
   "PartialOrder",
   "Real.instLT",
   "LE.mk",
   "LE.le",
   "Preorder.mk",
   "LT.mk"],
  "name": "Real.partialOrder",
  "constType": "PartialOrder ℝ",
  "constCategory": "Definition"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.nil",
  "constType": "{α : Type u} → List α",
  "constCategory": "Other"},
 {"references": ["Exists", "Set", "Membership.mem", "Set.instMembership"],
  "name": "Set.Nonempty",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Prod.fst",
   "μA",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "μDCC._proof_1",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "μDCC",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "lcProof",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._cstage1",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Prod",
   "Prod.mk",
   "Prod.mk.eta.match_1",
   "Prod.snd",
   "Eq",
   "Prod.fst"],
  "name": "Prod.mk.eta",
  "constType": "∀ {α : Type u_1} {β : Type u_2} {p : α × β}, (p.1, p.2) = p",
  "constCategory": "Theorem"},
 {"references": ["Add.add", "HAdd.mk", "HAdd", "Add"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references":
  ["le_top",
   "True",
   "LE.le",
   "Top.top",
   "LE",
   "eq_true",
   "OrderTop",
   "Eq",
   "OrderTop.toTop"],
  "name": "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_3",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, (a ≤ ⊤) = True",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Distrib"],
  "name": "Distrib.toMul",
  "constType": "{R : Type u_1} → [self : Distrib R] → Mul R",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "True",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "Mathlib.Tactic.Ring.cast_pos.match_1",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.cast_pos",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = n.rawCast + 0",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "impl.prop4d1₁_seq._proof_3",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Prod.fst",
   "Nat.instPreorder",
   "impl.prop4d1₁_seq",
   "impl.prop4d1₁_seq._proof_2",
   "Subtype.prop",
   "Or",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "OfNat.ofNat",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "HAdd.hAdd",
   "Nat",
   "Lattice",
   "Nontrivial",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf",
   "impl.prop4d1₁_seq._proof_1",
   "StrictMono"],
  "name": "impl.prop4d1₁_seq._proof_8",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S)\n  (h₁ : ∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩)\n  (h₂ :\n    ∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty) (k : ℕ),\n  ↑(impl.prop4d1₁_seq μ h₁ h₂ h₃ k) < ⊤",
  "constCategory": "Theorem"},
 {"references": ["Not", "Exists", "Classical.not_forall", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_forall_eq",
  "constType": "∀ {α : Sort u_1} (s : α → Prop), (¬∀ (x : α), s x) = ∃ x, ¬s x",
  "constCategory": "Theorem"},
 {"references":
  ["S₂I",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "le_trans",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "lt_of_le_of_ne",
   "S₁I._proof_2",
   "Membership.mem.out",
   "Subtype.val",
   "Prod.fst",
   "le_rfl",
   "And.intro",
   "μA",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "semistableI",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Exists.casesOn",
   "S₁I",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "StI",
   "Ne",
   "Subtype.mk",
   "CompleteLattice",
   "And.casesOn"],
  "name": "impl.prop3d7₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (x : ℒ) (hxSt : x ∈ StI μ I),\n  semistableI μ ⟨((↑I).1, x), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.sInf_le",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Membership.mem",
   "Preorder.toLE",
   "Set.instMembership",
   "CompleteSemilatticeInf"],
  "name": "sInf_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, a ∈ s → sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Nat",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "instOfNatNat",
   "instHAdd",
   "Lattice",
   "Preorder.toLT",
   "GT.gt",
   "OfNat.ofNat",
   "SemilatticeInf.toPartialOrder"],
  "name": "μDCC._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (a : ℒ) (f : ℕ → ℒ), (∀ (n : ℕ), f n > a) → ∀ (N : ℕ), f (N + 1) > a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "absurd",
   "LT.lt",
   "Preorder",
   "lt_irrefl",
   "Preorder.toLT",
   "False",
   "Ne",
   "Eq.rec",
   "Eq"],
  "name": "ne_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Sub.mk", "Nat.sub", "Sub"],
  "name": "instSubNat",
  "constType": "Sub ℕ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "And.intro",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "sInf_le_sInf",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "μA._proof_3",
   "Set.instMembership",
   "Prod",
   "Exists.casesOn",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "setOf",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "Prod.fst",
   "le_rfl",
   "μA",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "sInf_le",
   "LT.lt",
   "ne_of_lt",
   "Min.min",
   "le_of_lt",
   "LE.le",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "CompleteLattice"],
  "name": "impl.lem2d4₁",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (x w : ℒ) (hxw : ¬x ≤ w) (u : ℒ) (huxw : u ≤ x ⊓ w),\n  μA μ ⟨(u, x), ⋯⟩ ≤ μmax μ ⟨(x ⊓ w, x), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["IsStrictOrderedRing.toCharZero",
   "PartialOrder.toPreorder",
   "IsStrictOrderedRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Preorder.toLT",
   "zero_lt_one",
   "OfNat.ofNat",
   "LT.lt",
   "Semiring.toNonAssocSemiring",
   "One.toOfNat1",
   "MulZeroClass.toZero",
   "PartialOrder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddMonoidWithOne.toOne",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NeZero.charZero_one",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring",
   "IsStrictOrderedRing.toZeroLEOneClass"],
  "name": "Linarith.zero_lt_one",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [inst_1 : PartialOrder α] [IsStrictOrderedRing α], 0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["One.toOfNat1",
   "AddZeroClass.toZero",
   "AddZeroClass.toAdd",
   "AddZeroClass",
   "zero_le",
   "ZeroLEOneClass.mk",
   "One",
   "LE",
   "CanonicallyOrderedAdd",
   "OfNat.ofNat",
   "ZeroLEOneClass"],
  "name": "CanonicallyOrderedAdd.toZeroLeOneClass",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α] [CanonicallyOrderedAdd α] [inst_3 : One α], ZeroLEOneClass α",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toInfSet",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "LE.le",
   "Membership.mem",
   "CompleteSemilatticeInf.le_sInf",
   "Preorder.toLE",
   "Set.instMembership",
   "CompleteSemilatticeInf"],
  "name": "le_sInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Preorder",
   "False.elim",
   "lt_irrefl",
   "Iff",
   "Preorder.toLT",
   "False",
   "Iff.intro"],
  "name": "lt_self_iff_false",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] (x : α), x < x ↔ False",
  "constCategory": "Theorem"},
 {"references": ["Top", "LE", "OrderTop"],
  "name": "OrderTop.toTop",
  "constType": "{α : Type u} → {inst : LE α} → [self : OrderTop α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "PartialOrder.toPreorder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "Nat.cast_nonneg",
   "IsOrderedRing",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Semiring.toNonAssocSemiring",
   "MulZeroClass.toZero",
   "PartialOrder",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Preorder.toLE",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring"],
  "name": "Linarith.natCast_nonneg",
  "constType":
  "∀ (α : Type u) [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.coe_injective",
   "Subtype",
   "Iff",
   "Ne",
   "Function.Injective.ne_iff",
   "Subtype.val"],
  "name": "Subtype.coe_ne_coe",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, ↑a ≠ ↑b ↔ a ≠ b",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.add", "Add", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Prod.mk",
   "Preorder.toLT",
   "And",
   "lt_of_le_of_ne",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "InIntvl",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "impl.ℒₛ._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (I : { p // p.1 < p.2 }) (x : { p // InIntvl I p }) (p : ℒ),\n  InIntvl I p → (↑I).1 ≠ p ∧ p < ↑x → ((↑I).1, p).1 < ((↑I).1, p).2",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "sorryAx",
  "constType": "(α : Sort u) → Bool → α",
  "constCategory": "Axiom"},
 {"references": ["String", "Lean.Name"],
  "name": "Lean.Name.str",
  "constType": "Name → String → Name",
  "constCategory": "Other"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "Lattice",
   "Top.top",
   "Preorder.toLE",
   "OrderTop.toTop",
   "SemilatticeInf.toPartialOrder"],
  "name": "impl.prop4d1₁_seq._proof_3",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (z : { p // p.1 < p.2 }),\n  (↑z).2 < ⊤ → ((↑z).1, ⊤).1 < ((↑z).1, ⊤).2",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "List.rec",
   "List.getLastD",
   "List.getLastD_mem_cons",
   "_private.Batteries.Data.List.Lemmas.0._proof_13",
   "List.Mem.head",
   "Eq.trans",
   "Eq.mp",
   "Iff.mp",
   "eq_true",
   "List",
   "and_true",
   "List.getLast?",
   "List.tfae_of_cycle._proof_4",
   "Iff.intro",
   "congrArg",
   "_private.Batteries.Data.List.Lemmas.0._proof_12",
   "And.intro",
   "List.Chain",
   "letFun",
   "congr",
   "forall_congr",
   "List.TFAE",
   "List.tfae_of_cycle._proof_5",
   "Eq",
   "List.getLastD_cons",
   "List.cons",
   "List.getLastD_eq_getLast?",
   "List.nil",
   "_private.Mathlib.Data.List.TFAE.0._proof_1",
   "True",
   "And.right",
   "And",
   "Option.getD",
   "Function.comp",
   "List.tfae_of_cycle._proof_3",
   "implies_true",
   "and_self",
   "of_eq_true",
   "Iff",
   "Eq.refl",
   "id",
   "Eq.mpr",
   "implies_congr_ctx",
   "And.casesOn"],
  "name": "List.tfae_of_cycle",
  "constType":
  "∀ {a b : Prop} {l : List Prop}, List.Chain (fun x1 x2 => x1 → x2) a (b :: l) → (l.getLastD b → a) → (a :: b :: l).TFAE",
  "constCategory": "Theorem"},
 {"references":
  ["le_rfl",
   "SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "inf_le_inf",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "inf_le_inf_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a : α) {b c : α}, b ≤ c → a ⊓ b ≤ a ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Lattice.toSemilatticeInf",
   "PartialOrder.toPreorder",
   "Lattice",
   "Preorder.toLT",
   "And",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "SlopeLike._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (x y z : ℒ), x < y ∧ y < z → x < y",
  "constCategory": "Theorem"},
 {"references": ["Subtype", "Set", "Membership.mem", "Set.instMembership"],
  "name": "Set.Elem",
  "constType": "{α : Type u} → Set α → Type u",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instIsTransLt",
   "instHAdd",
   "Preorder.toLT",
   "OfNat.ofNat",
   "Nat.instPreorder",
   "LT.lt",
   "HAdd.hAdd",
   "Preorder",
   "Nat",
   "instOfNatNat",
   "Nat.rel_of_forall_rel_succ_of_lt",
   "StrictMono"],
  "name": "strictMono_nat_of_lt_succ",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α}, (∀ (n : ℕ), f n < f (n + 1)) → StrictMono f",
  "constCategory": "Theorem"},
 {"references":
  ["upperBounds", "Set", "Membership.mem", "And", "LE", "Set.instMembership"],
  "name": "IsGreatest",
  "constType": "{α : Type u_1} → [LE α] → Set α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "impl.prop4d1₁_seq._proof_5",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "impl.prop4d1₁_seq._proof_3",
   "Subtype.val",
   "Set.Elem",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "BoundedOrder",
   "impl.prop4d1₁_seq._proof_4",
   "Prod.snd",
   "Nat.brecOn",
   "Nat.lt_add_one",
   "Unit",
   "Set.instMembership",
   "Prod",
   "Nat",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "StrictMono",
   "impl.prop4d1₁_seq._proof_1",
   "setOf",
   "Subtype",
   "Nat.instPreorder",
   "Prod.fst",
   "impl.prop4d1₁_seq._proof_2",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "impl.prop4d1₁_seq._proof_7",
   "Not",
   "impl.prop4d1₁_seq.match_1",
   "Set.Nonempty",
   "le_top",
   "Lattice.toSemilatticeInf",
   "impl.prop4d1₁_seq._proof_6",
   "instHAdd",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.succ",
   "LE.le",
   "Nat.below",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "impl.prop4d1₁_seq",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [inst_1 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_2 : CompleteLattice S] →\n            (μ : { p // p.1 < p.2 } → S) →\n              (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                    μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                  {YA |\n                        ∃ (h : YA < ⊤),\n                          ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty →\n                    ℕ → ↑{YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "impl.prop3d4₀func_strict_decreasing",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "impl.prop3d4₀func_defprop1",
   "BoundedOrder",
   "Prod.snd",
   "Exists.casesOn",
   "Prod",
   "Nat",
   "impl.prop3d4₀func",
   "Ne.lt_of_le",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "gt_iff_lt",
   "Subtype",
   "Ne.symm",
   "Eq.mp",
   "impl.prop3d4₀func_helper",
   "lt_of_le_of_ne",
   "Prod.fst",
   "congrArg",
   "Subtype.prop",
   "instOfNatNat",
   "μA",
   "WellFoundedGT",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "propext",
   "Not",
   "μDCC",
   "Lattice.toSemilatticeInf",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "instHAdd",
   "OfNat.ofNat",
   "not_le_of_gt",
   "LT.lt",
   "HAdd.hAdd",
   "μDCC._proof_1",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func_fin_len",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  μDCC μ → ∃ i, ↑(impl.prop3d4₀func μ I i) = (↑I).1",
  "constCategory": "Theorem"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references":
  ["ConditionallyCompleteLattice", "ConditionallyCompleteLinearOrder"],
  "name": "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLinearOrder α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references": ["Set", "SupSet"],
  "name": "SupSet.sSup",
  "constType": "{α : Type u_1} → [self : SupSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "letFun",
  "constType":
  "{α : Sort u} → {β : α → Sort v} → (v : α) → ((x : α) → β x) → β v",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Sub"],
  "name": "SubNegMonoid.toSub",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Sub G",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "not_le_of_lt",
   "imp_not_comm",
   "LE.le",
   "Preorder.toLT",
   "Iff.mp",
   "Preorder.toLE"],
  "name": "not_lt_of_le",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "CommSemiring",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "instOfNatNat",
   "congr",
   "MonoidWithZero.toMonoid",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHPow",
   "Distrib.toAdd",
   "True",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "Distrib.toMul",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.mul_zero",
   "HPow.hPow",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "of_eq_true",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "Nat.cast_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero._proof_1",
   "Distrib.leftDistribClass",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b : R} (x : R) (e : ℕ),\n  Mathlib.Meta.NormNum.IsNat (a + b) 0 → Mathlib.Meta.NormNum.IsNat (x ^ e * a + x ^ e * b) 0",
  "constCategory": "Theorem"},
 {"references":
  ["S₂I",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "S₁I._proof_2",
   "Subtype.val",
   "Prod.fst",
   "eq_of_le_of_le",
   "μA",
   "le_of_not_gt",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "WellFoundedGT",
   "CompleteLinearOrder",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "CompletelyDistribLattice.toCompleteLattice",
   "Exists.casesOn",
   "LinearOrder.toPartialOrder",
   "S₁I",
   "Lattice",
   "Nontrivial",
   "StI",
   "Ne",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "And.casesOn"],
  "name": "impl.rmk3d5",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  ∀ x ∈ StI μ I, ∀ y ∈ StI μ I, x = y",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "BoundedOrder",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "SemilatticeInf.toPartialOrder"],
  "name": "TotIntvl._proof_1",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ], ⊥ < ⊤",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "LE.le",
   "not_le_of_lt",
   "Preorder.toLT",
   "Preorder.toLE"],
  "name": "LT.lt.not_le",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toNonAssocRing",
   "Eq.trans",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "congrArg",
   "sub_eq_add_neg",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Eq.ndrec",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "Neg.neg",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Ring.toAddCommGroup",
   "eq_self",
   "NegZeroClass.toNeg",
   "AddGroupWithOne.toAddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "of_eq_true",
   "instHSub",
   "AddMonoid.toAddZeroClass",
   "Ring"],
  "name": "Mathlib.Tactic.Ring.sub_pf",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a b c d : R}, -b = c → a + c = d → a - b = d",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Iff.trans",
   "PartialOrder.toPreorder",
   "or_comm",
   "Or",
   "Iff",
   "PartialOrder",
   "LE.le",
   "Preorder.toLT",
   "Eq",
   "Preorder.toLE",
   "le_iff_lt_or_eq"],
  "name": "le_iff_eq_or_lt",
  "constType":
  "∀ {α : Type u_2} [inst : PartialOrder α] {a b : α}, a ≤ b ↔ a = b ∨ a < b",
  "constCategory": "Theorem"},
 {"references": ["PUnit.unit", "Unit"],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "BoundedOrder",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderTop.toTop",
   "bot_lt_top",
   "SemilatticeInf.toPartialOrder"],
  "name": "semistable._proof_4",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ], ⊥ < ⊤",
  "constCategory": "Theorem"},
 {"references": ["Classical.choose_spec", "Exists", "Exists.choose"],
  "name": "Exists.choose_spec",
  "constType": "∀ {α : Sort u_1} {p : α → Prop} (P : ∃ a, p a), p P.choose",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocCommRing.mk",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalNonAssocCommRing"],
  "name": "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
  "constType":
  "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalNonAssocCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Preorder",
   "le_top",
   "LT.lt.trans_le",
   "LT.lt.ne",
   "Top.top",
   "Preorder.toLT",
   "OrderTop",
   "Ne",
   "Preorder.toLE",
   "OrderTop.toTop"],
  "name": "ne_top_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α] {a b : α}, a < b → a ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "HAdd.hAdd",
   "Nat",
   "instHAdd",
   "instOfNatNat",
   "Nat.rec",
   "OfNat.ofNat"],
  "name": "Nat.recAux",
  "constType":
  "{motive : ℕ → Sort u} → motive 0 → ((n : ℕ) → motive n → motive (n + 1)) → (t : ℕ) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "impl.ℒₛ._proof_1",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "WellFounded.has_min",
   "Prod.mk",
   "Membership.mem",
   "Eq.mpr_not",
   "Preorder.toLT",
   "Classical.propDecidable",
   "eq_true",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "impl.ℒₛ",
   "False.elim",
   "letFun",
   "PartialOrder",
   "CompleteSemilatticeInf.toPartialOrder",
   "impl.ℒₛ._proof_2",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "of_eq_false",
   "Exists",
   "Exists.choose_spec",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat",
   "impl.prop3d4₀func",
   "Eq.refl",
   "eq_false",
   "Classical.byContradiction",
   "impl.prop3d4₀func._proof_7",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "impl.prop3d4₀func._proof_8",
   "Subtype",
   "instDecidableTrue",
   "Eq.mp",
   "impl.prop3d4₀func_helper",
   "lt_of_le_of_ne",
   "dite_congr",
   "congrArg",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "μA",
   "IsWellFounded.wf",
   "not_true_eq_false",
   "WellFoundedGT",
   "instDecidableFalse",
   "dite_cond_eq_false",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "instHAdd",
   "impl.prop3d4₀func._proof_4",
   "Exists.choose",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "dite",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func_defprop1",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ)\n  (hi : (↑I).1 ≠ ↑(impl.prop3d4₀func μ I (i + 1))),\n  μA μ ⟨((↑I).1, ↑(impl.prop3d4₀func μ I (i + 1))), ⋯⟩ > μA μ ⟨((↑I).1, ↑(impl.prop3d4₀func μ I i)), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Prod.fst",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Lattice",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf"],
  "name": "impl.prop4d1₁_seq._proof_4",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S)\n  (h₃ : {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty),\n  Exists.choose h₃ ∈ {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Theorem"},
 {"references":
  ["PUnit.unit",
   "PUnit",
   "Nat",
   "Nat.succ",
   "Nat.rec",
   "Nat.below",
   "PProd",
   "Nat.zero",
   "PProd.mk"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.rfl", "setOf"],
  "name": "Set.setOf_app_iff",
  "constType": "∀ {α : Type u} {p : α → Prop} {x : α}, {x | p x} x ↔ p x",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Preorder",
   "Iff",
   "LE.le",
   "And",
   "Preorder.toLT",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "lt_iff_le_not_le",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Set",
   "Membership.mem",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Set.instMembership",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "StI",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "semistableI",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "LT.lt",
   "instLTNat",
   "Nat.find",
   "Nat",
   "Exists",
   "Subtype.property",
   "And",
   "Nat.findX",
   "DecidablePred",
   "Subtype.val",
   "And.left"],
  "name": "Nat.find_spec",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n), p (Nat.find H)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "Interval",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → { p // p.1 < p.2 } → Type",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "sorryAx",
   "TotIntvl",
   "Eq.trans",
   "impl.prop4d20",
   "Lean.Name.str",
   "Bool.false",
   "Exists.intro",
   "eq_true",
   "List.tfae_of_cycle",
   "SlopeLike._proof_1",
   "List.instGetElem?NatLtLength",
   "Subtype.val",
   "GetElem?.getElem?",
   "Nat.instCharZero",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "instLTNat",
   "_private.Init.Data.Nat.Basic.0._proof_6",
   "Exists",
   "BoundedOrder",
   "Nat.instNontrivial",
   "Prod.snd",
   "lt_iff_le_not_le",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Interval",
   "Iff",
   "Eq.refl",
   "Lattice",
   "AddMonoidWithOne.toOne",
   "Top.top",
   "Eq.mpr",
   "StrictMono",
   "AddMonoid.toAddZeroClass",
   "_private.Mathlib.Data.Nat.Cast.Order.Ring.0._proof_7",
   "List.getElem?_eq_getElem",
   "Or.inr",
   "OmegaCompletePartialOrder.toPartialOrder",
   "instLatticeInterval",
   "SlopeLike._proof_2",
   "GetElem.getElem",
   "List",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Option.some",
   "Nat.instPreorder",
   "Prod.fst",
   "Nat.instAddMonoidWithOne",
   "Or.inl",
   "Nat.instSemiring",
   "instOfNatNat",
   "congr",
   "prop_4_1_cond₂._proof_3",
   "_private.Mathlib.Data.Nat.Cast.Order.Basic.0._proof_15",
   "Preorder.toLE",
   "Eq",
   "μmin",
   "NashEquilibrium",
   "Nat.instAddMonoid",
   "prop_4_1_cond₁._proof_2",
   "IsStrictOrderedRing.toIsOrderedRing",
   "List.Chain.cons",
   "List.Chain.nil",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "CompletelyDistribLattice.toCompleteLattice",
   "eq_self",
   "AddZeroClass.toAdd",
   "Resμ._proof_19",
   "SlopeLike._proof_3",
   "Nat.instIsStrictOrderedRing",
   "Ne",
   "Lean.Name.num",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "impl.prop4d18₂",
   "PartialOrder.toPreorder",
   "impl.prop4d16₁",
   "Lean.Name",
   "Prod.mk",
   "Iff.mp",
   "Preorder.toLT",
   "Nat.instAddCommMonoid",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "And.intro",
   "instBoundedOrderInterval",
   "Mathlib.Meta.NormNum.isNat_add",
   "Or",
   "prop_4_3_cond₁",
   "List.TFAE",
   "CompleteLinearOrder",
   "Nat.instIsOrderedAddMonoid",
   "List.cons",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "AddZeroClass.toZero",
   "Nat.instPartialOrder",
   "And",
   "IsOrderedAddMonoid.toAddLeftMono",
   "True.intro",
   "Bot.bot",
   "Resμ",
   "Exists.casesOn",
   "Nat.instCanonicallyOrderedAdd",
   "prop_4_1_cond₂",
   "prop_4_1_cond₁._proof_1",
   "Nat",
   "zero_add",
   "Option",
   "Iff.mpr",
   "Nontrivial",
   "id",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "_private.Init.Data.Prod.0._proof_1",
   "List.length",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Lean.Name.anonymous",
   "Subtype",
   "le_trans",
   "prop_4_1_cond₁",
   "semistable",
   "congrArg",
   "BoundedOrder.toOrderTop",
   "Zero.toOfNat0",
   "OrderBot.toBot",
   "Not",
   "List.nil",
   "List.instGetElemNatLtLength",
   "bot_lt_iff_ne_bot",
   "List.TFAE.out",
   "Lattice.toSemilatticeInf",
   "True",
   "instHAdd",
   "_private.Init.Data.Subtype.0._proof_1",
   "Or.casesOn",
   "LT.lt",
   "prop_4_3_cond₂",
   "impl.prop4d16₂",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "SlopeLike",
   "CanonicallyOrderedAdd.toZeroLeOneClass",
   "Subtype.mk",
   "OrderTop.toTop",
   "instNontrivialInterval"],
  "name": "impl.thm4d21",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  SlopeLike μ →\n    prop_4_1_cond₁ μ →\n      prop_4_3_cond₁ μ →\n        [μmax μ TotIntvl = μ TotIntvl, μmin μ TotIntvl = μ TotIntvl, μmin μ TotIntvl = μmax μ TotIntvl,\n            NashEquilibrium μ, semistable μ].TFAE",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Iff",
   "funext",
   "Membership.mem",
   "Eq",
   "propext",
   "Set.instMembership"],
  "name": "Set.ext",
  "constType":
  "∀ {α : Type u} {a b : Set α}, (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "instLTNat",
   "Nat.succ_add",
   "Nat.add_le_of_le_sub",
   "Eq.mp",
   "instHAdd",
   "Nat.ge_of_not_lt",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.not_lt_zero",
   "Nat",
   "Nat.sub_eq_zero_of_le",
   "instSubNat",
   "Nat.succ",
   "instOfNatNat",
   "letFun",
   "LE.le",
   "HSub.hSub",
   "instHSub",
   "instLENat",
   "Nat.le_of_lt"],
  "name": "Nat.add_lt_of_lt_sub",
  "constType": "∀ {a b c : ℕ}, a < c - b → a + b < c",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_imp", "And", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_implies_eq",
  "constType": "∀ (p q : Prop), (¬(p → q)) = (p ∧ ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "CompleteLattice.toBot",
   "BoundedOrder",
   "BoundedOrder.mk",
   "CompleteLattice.le_top",
   "CompleteLattice.bot_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.toTop",
   "Preorder.toLE",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderBot.mk",
   "CompleteLattice",
   "OrderTop.mk"],
  "name": "CompleteLattice.toBoundedOrder",
  "constType": "{α : Type u_1} → [inst : CompleteLattice α] → BoundedOrder α",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "setOf",
  "constType": "{α : Type u} → (α → Prop) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
   "Nat.cast",
   "True",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.cast",
   "congrArg",
   "Int",
   "eq_self",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Ring.toAddGroupWithOne",
   "of_eq_true",
   "Mathlib.Meta.NormNum.IsInt",
   "AddGroupWithOne.toIntCast",
   "Int.cast_natCast",
   "Int.ofNat",
   "Eq",
   "Mathlib.Meta.NormNum.IsNat",
   "instNatCastInt",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsNat a n → Mathlib.Meta.NormNum.IsInt a (Int.ofNat n)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Min.min",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_right"],
  "name": "inf_le_right",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Preorder.toLT",
   "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "AddMonoidWithOne.toAddMonoid",
   "Semiring.toNonAssocSemiring",
   "IsCancelAdd.toIsRightCancelAdd",
   "PartialOrder",
   "Zero.toOfNat0",
   "add_lt_of_neg_of_le",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Preorder.toLE",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "IsStrictOrderedRing.toIsOrderedCancelAddMonoid",
   "Distrib.toAdd",
   "IsStrictOrderedRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "IsStrictOrderedRing.toIsOrderedRing",
   "instHAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsOrderedAddMonoid.toAddLeftMono",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "AddCommMonoid.toAddCommSemigroup",
   "AddZeroClass.toAdd",
   "MulZeroClass.toZero",
   "LE.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "covariant_swap_add_of_covariant_add",
   "Semiring",
   "AddMonoid.toAddZeroClass"],
  "name": "Linarith.add_lt_of_neg_of_le",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [inst_1 : PartialOrder α] [IsStrictOrderedRing α] {a b c : α},\n  a < 0 → b ≤ c → a + b < c",
  "constCategory": "Theorem"},
 {"references":
  ["le_rfl",
   "Max.max",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "sup_le_sup",
   "SemilatticeSup",
   "Preorder.toLE"],
  "name": "sup_le_sup_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → ∀ (c : α), a ⊔ c ≤ b ⊔ c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "True",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instOfNatAtLeastTwo",
   "Preorder.toLT",
   "eq_true",
   "OfNat.ofNat",
   "Nat.ofNat_pos",
   "LT.lt",
   "IsOrderedRing",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Semiring.toNonAssocSemiring",
   "Nat.AtLeastTwo",
   "MulZeroClass.toZero",
   "PartialOrder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Nontrivial",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring"],
  "name": "_private.Mathlib.Data.Nat.Cast.Order.Ring.0._proof_7",
  "constType":
  "∀ {α : Type u_3} [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] [Nontrivial α] {n : ℕ}\n  [inst_4 : n.AtLeastTwo], (0 < OfNat.ofNat n) = True",
  "constCategory": "Theorem"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["lt_trans",
   "SemilatticeInf.toMin",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "And.intro",
   "μA",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "Eq",
   "Eq.rec",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice.toConditionallyCompleteLattice",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "inf_eq_left",
   "LT.lt",
   "Prod",
   "ConvexI",
   "impl.prop2d6₁I",
   "impl.prop2d6₀",
   "le_of_lt",
   "Min.min",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "ConditionallyCompleteLattice.toLattice",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.prop2d6₂I₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (y : ℒ),\n          InIntvl I y →\n            ∀ (z : ℒ),\n              InIntvl I z →\n                ∀ (h : x < y ∧ y < z),\n                  μA μ ⟨(x, y), ⋯⟩ < μA μ ⟨(y, z), ⋯⟩ →\n                    μA μ ⟨(x, y), ⋯⟩ ≤ μA μ ⟨(x, z), ⋯⟩ ∧ μA μ ⟨(x, z), ⋯⟩ ≤ μA μ ⟨(y, z), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "Ne", "Eq"],
  "name": "Ne.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "BoundedOrder",
   "Bot.bot",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "eq_false",
   "Nontrivial",
   "Top.top",
   "False",
   "OrderBot.toBot",
   "bot_ne_top",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop"],
  "name": "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_36",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : BoundedOrder α] [Nontrivial α], (⊥ = ⊤) = False",
  "constCategory": "Theorem"},
 {"references": ["SubtractionMonoid", "SubtractionCommMonoid"],
  "name": "SubtractionCommMonoid.toSubtractionMonoid",
  "constType":
  "{G : Type u} → [self : SubtractionCommMonoid G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Int.instCommRing", "CommRing.toRing", "inferInstance", "Int", "Ring"],
  "name": "Int.instRing",
  "constType": "Ring ℤ",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "OrderDual", "Equiv"],
  "name": "OrderDual.ofDual",
  "constType": "{α : Type u_1} → αᵒᵈ ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "add_add_add_comm",
   "CommSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "instOfNatNat",
   "Mathlib.Meta.NormNum.IsNat.out",
   "Zero.toOfNat0",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq.ndrec",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "Eq.refl",
   "Nat.cast_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "id",
   "Eq.mpr",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b₁ b₂ c : R},\n  Mathlib.Meta.NormNum.IsNat (a₁ + b₁) 0 → a₂ + b₂ = c → a₁ + a₂ + (b₁ + b₂) = c",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Prod.fst",
   "Nat.instPreorder",
   "BoundedOrder.toOrderTop",
   "instOfNatNat",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toSemilatticeInf",
   "le_top",
   "instHAdd",
   "BoundedOrder",
   "Prod.snd",
   "OfNat.ofNat",
   "Nat.lt_add_one",
   "lt_of_lt_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "Lattice",
   "Top.top",
   "OrderTop.toTop",
   "StrictMono"],
  "name": "impl.prop4d1₁_seq._proof_2",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (x : ℕ → ℒ), StrictMono x → ∀ (N : ℕ), (x N, ⊤).1 < (x N, ⊤).2",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf",
   "SemilatticeInf.toMin",
   "PartialOrder.toPreorder",
   "Min.min",
   "SemilatticeInf.le_inf",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "le_inf",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instSub",
   "AddGroup.mk",
   "Nat.cast",
   "Zero.ofOfNat0",
   "Int.zero_add",
   "HMul.hMul",
   "Int.add_zero",
   "Int.instAddCommGroup._proof_4",
   "Int.instMul",
   "Int.zero_mul",
   "AddCommGroup.mk",
   "Int.instAdd",
   "Int.sub_eq_add_neg",
   "SubNegMonoid.mk",
   "AddSemigroup.mk",
   "instNatCastInt",
   "Int.add_assoc",
   "Int.instAddCommGroup._proof_3",
   "AddCommGroup",
   "Int.instNegInt",
   "AddMonoid.mk",
   "Int",
   "Nat",
   "instOfNat",
   "Int.add_left_neg",
   "Int.add_comm",
   "instHMul"],
  "name": "Int.instAddCommGroup",
  "constType": "AddCommGroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "not_lt",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLT",
   "LinearOrder",
   "Eq",
   "Preorder.toLE",
   "propext"],
  "name": "_private.Mathlib.Order.Defs.LinearOrder.0._proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "impl.prop4d1₁_seq._proof_3",
   "Subtype.val",
   "Set.Elem",
   "impl.prop4d1₁_seq",
   "Or",
   "CompleteSemilatticeInf.toPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "BoundedOrder",
   "impl.prop4d1₁_seq._proof_4",
   "Prod.snd",
   "Nat.lt_add_one",
   "Unit",
   "Set.instMembership",
   "Prod",
   "Nat",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "StrictMono",
   "impl.prop4d1₁_seq._proof_1",
   "setOf",
   "Subtype",
   "Nat.instPreorder",
   "Prod.fst",
   "impl.prop4d1₁_seq._proof_2",
   "Subtype.prop",
   "instOfNatNat",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Not",
   "impl.prop4d1₁_seq.match_1",
   "Set.Nonempty",
   "le_top",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Set",
   "impl.prop4d1₁_seq._proof_8",
   "Exists.choose",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "impl.prop4d1₁_seq._proof_9",
   "HAdd.hAdd",
   "LT.lt",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "impl.prop4d1₁_seq._proof_10",
   "CompleteLattice"],
  "name": "impl.prop4d1₁_seq._sunfold",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [inst_1 : BoundedOrder ℒ] →\n        {S : Type} →\n          [inst_2 : CompleteLattice S] →\n            (μ : { p // p.1 < p.2 } → S) →\n              (∀ (x : ℕ → ℒ) (smf : StrictMono x), ∃ N, μ ⟨(x N, x (N + 1)), ⋯⟩ ≤ μ ⟨(x N, ⊤), ⋯⟩) →\n                (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤),\n                    μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n                  {YA |\n                        ∃ (h : YA < ⊤),\n                          ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}.Nonempty →\n                    ℕ → ↑{YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "CompleteLattice.le_sInf",
   "PartialOrder.toPreorder",
   "OrderDual.instCompleteLattice._proof_29",
   "OrderDual.instLattice",
   "CompleteSemilatticeSup.toSupSet",
   "CompleteLattice.toCompleteSemilatticeSup",
   "OrderDual.instCompleteLattice._proof_30",
   "OrderDual.supSet",
   "BoundedOrder.toOrderTop",
   "OrderDual.infSet",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.sSup_le",
   "OrderDual.instLE",
   "OrderBot.toBot",
   "Preorder.toLE",
   "CompleteLattice.sInf_le",
   "CompleteLattice.le_sSup",
   "CompleteLattice.mk",
   "CompleteLattice.toLattice",
   "BoundedOrder",
   "CompleteSemilatticeInf.toInfSet",
   "BoundedOrder.toOrderBot",
   "OrderDual.instBoundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toBoundedOrder",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "OrderDual.instCompleteLattice",
  "constType": "{α : Type u_1} → [CompleteLattice α] → CompleteLattice αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["IsWellFounded", "GT.gt", "LT"],
  "name": "WellFoundedGT",
  "constType": "(α : Type u_1) → [LT α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["ConditionallyCompleteLinearOrder.compare_eq_compareOfLessAndEq",
   "ConditionallyCompleteLinearOrder.toLinearOrder._proof_3",
   "Lattice.toSemilatticeSup",
   "SemilatticeInf.toMin",
   "ConditionallyCompleteLinearOrder.toLinearOrder._proof_4",
   "Lattice.toSemilatticeInf",
   "ConditionallyCompleteLinearOrder.toDecidableLE",
   "ConditionallyCompleteLinearOrder",
   "LinearOrder",
   "SemilatticeSup.toPartialOrder",
   "LinearOrder.mk",
   "ConditionallyCompleteLinearOrder.le_total",
   "ConditionallyCompleteLinearOrder.toDecidableEq",
   "ConditionallyCompleteLinearOrder.toDecidableLT",
   "ConditionallyCompleteLinearOrder.toOrd",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "SemilatticeSup.toMax",
   "ConditionallyCompleteLattice.toLattice"],
  "name": "ConditionallyCompleteLinearOrder.toLinearOrder",
  "constType":
  "{α : Type u_1} → [ConditionallyCompleteLinearOrder α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Bot.bot",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "Subtype.prop",
   "Lattice",
   "OrderBot.toBot",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder"],
  "name": "prop_4_3_cond₂._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] (z : { p // p.1 < p.2 }),\n  ⊥ < (↑z).1 → (⊥, (↑z).2).1 < (⊥, (↑z).2).2",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "eq_true",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.AtLeastTwo",
   "PartialOrder",
   "Nat.one_lt_ofNat",
   "CharZero",
   "Preorder.toLE",
   "Eq",
   "AddMonoidWithOne",
   "AddSemigroup.toAdd",
   "AddZeroClass.toZero",
   "True",
   "instOfNatAtLeastTwo",
   "OfNat.ofNat",
   "ZeroLEOneClass",
   "LT.lt",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "AddMonoid.toAddSemigroup",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddZeroClass"],
  "name": "_private.Mathlib.Data.Nat.Cast.Order.Basic.0._proof_15",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [AddLeftMono α] [ZeroLEOneClass α] [CharZero α]\n  {n : ℕ} [inst_5 : n.AtLeastTwo], (1 < OfNat.ofNat n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CommSemiring",
   "HMul.hMul",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "congr",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "Eq.ndrec",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.toAdd",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddZeroClass.toZero",
   "instHAdd",
   "mul_add",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "add_zero",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "AddZeroClass.toAdd",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHMul",
   "Distrib.leftDistribClass",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.mul_add",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₁ b₂ c₁ c₂ d : R},\n  a * b₁ = c₁ → a * b₂ = c₂ → c₁ + 0 + c₂ = d → a * (b₁ + b₂) = d",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "CompleteLattice.le_sInf",
   "Set.Nonempty",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "CompleteLattice.toInfSet",
   "Set",
   "CompleteLattice.toLattice",
   "Membership.mem",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "BddBelow",
   "BddAbove",
   "Set.instMembership",
   "upperBounds",
   "ConditionallyCompleteLattice",
   "lowerBounds",
   "CompleteLattice.sSup_le",
   "Preorder.toLE",
   "CompleteLattice",
   "ConditionallyCompleteLattice.mk",
   "CompleteLattice.sInf_le"],
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_1} → [CompleteLattice α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references":
  ["impl.prop3d4₀func._proof_8",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Classical.propDecidable",
   "Preorder.toLT",
   "GT.gt",
   "impl.ℒₛ",
   "Subtype.val",
   "Prod.fst",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "impl.prop3d4₀func.match_1",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "impl.prop3d4₀func._proof_4",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "Unit",
   "LT.lt",
   "Prod",
   "Nat",
   "impl.prop3d4₀func",
   "impl.prop3d4₀func._proof_7",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "dite",
   "impl.prop3d4₀func._proof_3",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func._sunfold",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] →\n        [h : WellFoundedGT ℒ] →\n          {S : Type} →\n            [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → (I : { p // p.1 < p.2 }) → ℕ → { p // InIntvl I p }",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "μAstar",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Nontrivial",
   "Lattice",
   "Eq",
   "Preorder.toLE",
   "μBstar",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "NashEquilibrium",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] → [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → Prop",
  "constCategory": "Definition"},
 {"references": ["Add", "Distrib"],
  "name": "Distrib.toAdd",
  "constType": "{R : Type u_1} → [self : Distrib R] → Add R",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "Membership.mem",
   "isGLB_sInf",
   "CompleteSemilatticeInf",
   "Set.instMembership",
   "CompleteSemilatticeInf.toInfSet",
   "Iff",
   "CompleteSemilatticeInf.toPartialOrder",
   "InfSet.sInf",
   "LE.le",
   "le_isGLB_iff",
   "Preorder.toLE"],
  "name": "le_sInf_iff",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, a ≤ sInf s ↔ ∀ b ∈ s, a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.toDual",
   "OrderDual",
   "Exists",
   "Equiv.instFunLike",
   "OrderDual.exists",
   "Eq",
   "DFunLike.coe",
   "Equiv",
   "propext"],
  "name": "_private.Mathlib.Order.Synonym.0._proof_6",
  "constType":
  "∀ {α : Type u_1} {p : αᵒᵈ → Prop}, (∃ a, p a) = ∃ a, p (OrderDual.toDual a)",
  "constCategory": "Theorem"},
 {"references":
  ["IsStrictOrderedRing.toPosMulStrictMono",
   "PartialOrder.toPreorder",
   "IsStrictOrderedRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Distrib.toMul",
   "mul_le_mul_of_nonneg_left",
   "IsOrderedRing.mk",
   "MulPosStrictMono.toMulPosMono",
   "IsOrderedRing",
   "Semiring.toNonAssocSemiring",
   "mul_le_mul_of_nonneg_right",
   "MulZeroClass.toZero",
   "PartialOrder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsOrderedCancelAddMonoid.toIsOrderedAddMonoid",
   "PosMulStrictMono.toPosMulMono",
   "IsStrictOrderedRing.toMulPosStrictMono",
   "Semiring",
   "IsStrictOrderedRing.toIsOrderedCancelAddMonoid",
   "IsStrictOrderedRing.toZeroLEOneClass"],
  "name": "IsStrictOrderedRing.toIsOrderedRing",
  "constType":
  "∀ {R : Type u} [inst : Semiring R] [inst_1 : PartialOrder R] [IsStrictOrderedRing R], IsOrderedRing R",
  "constCategory": "Theorem"},
 {"references":
  ["impl.prop4d1₁_seq._proof_5",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "Prod.fst",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Exists.choose_spec",
   "Set",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nat.below",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf"],
  "name": "impl.prop4d1₁_seq._proof_6",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (k : ℕ) (x : Nat.below k.succ),\n  ∃ xB, ∃ (hAB : ↑x.1 < xB), ¬μ ⟨(↑x.1, xB), hAB⟩ ≤ μ ⟨(↑x.1, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_imp", "And", "Eq", "propext"],
  "name": "_private.Init.Classical.0._proof_13",
  "constType": "∀ {a b : Prop}, (¬(a → b)) = (a ∧ ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Ring.toNonAssocRing",
   "IsOrderedRing.toIsOrderedAddMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "PartialOrder",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "Zero.toOfNat0",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsOrderedAddMonoid.toAddLeftMono",
   "OfNat.ofNat",
   "Ring.toSemiring",
   "IsOrderedRing",
   "AddGroupWithOne.toAddGroup",
   "AddCommMonoid.toAddCommSemigroup",
   "sub_nonpos_of_le",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "covariant_swap_add_of_covariant_add",
   "instHSub",
   "Ring"],
  "name": "Linarith.sub_nonpos_of_le",
  "constType":
  "∀ {α : Type u} [inst : Ring α] [inst_1 : PartialOrder α] [IsOrderedRing α] {a b : α}, a ≤ b → a - b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["impl.prop3d4₀func._proof_8",
   "Subtype",
   "PartialOrder.toPreorder",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "GT.gt",
   "impl.ℒₛ",
   "Subtype.val",
   "Prod.fst",
   "WellFoundedGT",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Set.Nonempty",
   "Exists",
   "Lattice.toSemilatticeInf",
   "Set",
   "impl.prop3d4₀func._proof_4",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "impl.prop3d4₀func",
   "Nat.succ",
   "Eq.refl",
   "impl.prop3d4₀func._proof_7",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "dite",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func.eq_2",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [h : WellFoundedGT ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (n : ℕ),\n  impl.prop3d4₀func μ I n.succ =\n    if hbot : (↑I).1 = ↑(impl.prop3d4₀func μ I n) then ⟨(↑I).1, ⋯⟩\n    else\n      if hne : (impl.ℒₛ μ I (impl.prop3d4₀func μ I n) hbot).Nonempty then\n        let res := ⋯;\n        ⟨res.choose, ⋯⟩\n      else ⟨(↑I).1, ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Nat", "OfNat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Preorder",
   "LE.le",
   "not_le_of_lt",
   "Preorder.toLT",
   "Preorder.toLE",
   "GT.gt"],
  "name": "not_le_of_gt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a > b → ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["HAdd", "outParam"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["PartialOrder", "LinearOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u_2} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["Max"],
  "name": "Max.max",
  "constType": "{α : Type u} → [self : Max α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.zsmul_succ'",
   "AddGroupWithOne.sub_eq_add_neg",
   "AddGroupWithOne.zsmul",
   "AddGroup.mk",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroupWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toSub",
   "AddGroupWithOne.zsmul_neg'",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne.neg_add_cancel",
   "AddGroup",
   "AddGroupWithOne.zsmul_zero'",
   "SubNegMonoid.mk"],
  "name": "AddGroupWithOne.toAddGroup",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddGroup R",
  "constCategory": "Definition"},
 {"references": ["MulZeroClass", "Zero"],
  "name": "MulZeroClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SupSet",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["LT.lt",
   "IsIrrefl",
   "Preorder",
   "Preorder.toLT",
   "IsIrrefl.swap",
   "GT.gt",
   "instIsIrreflLt"],
  "name": "instIsIrreflGt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α], IsIrrefl α fun x1 x2 => x1 > x2",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Subtype",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "And.right",
   "le_trans",
   "Preorder.toLT",
   "And",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "ConvexI",
   "Prod",
   "LT.lt",
   "And.intro",
   "Lattice",
   "LE.le",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice",
   "And.left",
   "SemilatticeInf.toPartialOrder"],
  "name": "Convex_of_Convex_large",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] {S : Type} [inst_1 : CompleteLattice S] (I₁ I₂ : { p // p.1 < p.2 }),\n  (↑I₁).1 ≤ (↑I₂).1 ∧ (↑I₂).2 ≤ (↑I₁).2 → ∀ (μ : { p // p.1 < p.2 } → S), ConvexI I₁ μ → ConvexI I₂ μ",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MulZeroClass.mk",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → MulZeroClass α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_trans", "Nat", "Nat.le_succ", "Nat.succ", "LE.le", "instLENat"],
  "name": "Nat.le_of_succ_le",
  "constType": "∀ {n m : ℕ}, n.succ ≤ m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["S₂I",
   "Exists",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Set",
   "And",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "S₁I",
   "Nontrivial",
   "Lattice",
   "Ne",
   "Preorder.toLE",
   "InIntvl",
   "CompleteLattice",
   "setOf",
   "SemilatticeInf.toPartialOrder"],
  "name": "StI",
  "constType":
  "{ℒ : Type} →\n  [Nontrivial ℒ] →\n    [inst : Lattice ℒ] →\n      [BoundedOrder ℒ] → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → Set ℒ",
  "constCategory": "Definition"},
 {"references":
  ["IsStrictOrderedRing.mk",
   "PartialOrder.toPreorder",
   "IsOrderedCancelAddMonoid.mk",
   "Nat.le_of_add_le_add_left",
   "Eq.mp",
   "Exists.intro",
   "Nat.add_le_add_left",
   "congrArg",
   "Semiring.toNonAssocSemiring",
   "Nat.mul_lt_mul_of_pos_right",
   "Nat.instSemiring",
   "Nat.ne_of_lt",
   "instOfNatNat",
   "Zero.toOfNat0",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nontrivial.mk",
   "Preorder.toLE",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "add_comm",
   "IsOrderedAddMonoid.mk",
   "IsStrictOrderedRing",
   "Exists",
   "Nat.instPartialOrder",
   "instHAdd",
   "ZeroLEOneClass.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat.zero_lt_succ",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat",
   "Nat.zero_lt_one",
   "One.toOfNat1",
   "AddCommMonoid.toAddCommSemigroup",
   "MulZeroClass.toZero",
   "AddMonoidWithOne.toOne",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LE.le",
   "Nat.mul_lt_mul_of_pos_left",
   "id",
   "Ne",
   "Eq.mpr",
   "Nat.le_of_lt"],
  "name": "Nat.instIsStrictOrderedRing",
  "constType": "IsStrictOrderedRing ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "Not",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "SemilatticeSup.toPartialOrder",
   "LE.le.lt_iff_ne",
   "right_eq_sup",
   "LT.lt",
   "Max.max",
   "le_sup_right",
   "Iff",
   "not_congr",
   "SemilatticeSup.toMax",
   "LE.le",
   "SemilatticeSup",
   "Ne",
   "Eq",
   "Preorder.toLE"],
  "name": "right_lt_sup",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b < a ⊔ b ↔ ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegZeroMonoid",
   "PartialOrder.toPreorder",
   "AddCommGroup.toAddGroup",
   "Preorder.toLT",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubtractionMonoid",
   "IsOrderedAddMonoid",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddGroup.toSubNegMonoid",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Neg.neg",
   "IsOrderedAddMonoid.toAddLeftMono",
   "AddCommGroup",
   "IsOrderedCancelAddMonoid.toIsCancelAdd",
   "OfNat.ofNat",
   "neg_neg_iff_pos",
   "LT.lt",
   "NegZeroClass.toNeg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toAddMonoid",
   "IsOrderedAddMonoid.toIsOrderedCancelAddMonoid",
   "Iff.mpr",
   "AddCommGroup.toAddCommMonoid",
   "NegZeroClass.toZero",
   "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
   "AddMonoid.toAddZeroClass"],
  "name": "neg_neg_of_pos",
  "constType":
  "∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : PartialOrder α] [IsOrderedAddMonoid α] {a : α}, 0 < a → -a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Preorder.toLT",
   "BoundedOrder",
   "Bot.bot",
   "LT.lt",
   "BoundedOrder.toOrderBot",
   "BoundedOrder.toOrderTop",
   "PartialOrder",
   "Iff.mpr",
   "Nontrivial",
   "Top.top",
   "Ne",
   "OrderBot.toBot",
   "bot_ne_top",
   "lt_top_iff_ne_top",
   "Preorder.toLE",
   "OrderTop.toTop"],
  "name": "bot_lt_top",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : BoundedOrder α] [Nontrivial α], ⊥ < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "instLTNat",
   "Nat.find",
   "Nat",
   "Exists",
   "Subtype.property",
   "And.right",
   "And",
   "Nat.findX",
   "DecidablePred",
   "Subtype.val"],
  "name": "Nat.find_min",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n) {m : ℕ}, m < Nat.find H → ¬p m",
  "constCategory": "Theorem"},
 {"references": ["And.intro", "And", "And.rec"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "AddMonoidWithOne.toAddMonoid",
   "congrArg",
   "instOfNatNat",
   "Zero.toOfNat0",
   "Nat.cast_succ",
   "Eq",
   "AddMonoidWithOne",
   "AddSemigroup.toAdd",
   "AddZeroClass.toZero",
   "instHAdd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat",
   "zero_add",
   "AddMonoidWithOne.toNatCast",
   "One.toOfNat1",
   "AddZeroClass.toAdd",
   "Nat.succ",
   "Eq.refl",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_zero",
   "AddMonoidWithOne.toOne",
   "id",
   "Eq.mpr",
   "AddMonoid.toAddZeroClass"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._rarg",
   "_neutral"],
  "name":
  "impl.instCoeForallSubtypeProdLtFstSndForallOrderDualOfNontrivialOfBoundedOrderOfCompleteLattice_harderNarasimhan._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Preorder", "Preorder.le_refl", "LE.le", "Preorder.toLE"],
  "name": "le_refl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Lattice", "SemilatticeSup"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeSup α",
  "constCategory": "Definition"},
 {"references":
  ["Int.instMonoid",
   "Int.mul_add",
   "NonUnitalNonAssocSemiring.mk",
   "AddCommGroup.toAddGroup",
   "Int.instCommRing._proof_3",
   "Int.instCommRing._proof_10",
   "Int.one_mul",
   "Int.instCommRing._proof_12",
   "SubNegMonoid.toSub",
   "AddGroup.toSubNegMonoid",
   "CommSemigroup",
   "instHPow",
   "CommRing.mk",
   "SubNegMonoid.zsmul",
   "AddCommMonoid.mk",
   "Int.instCommRing._proof_4",
   "Int.mul_zero",
   "NatCast.mk",
   "Nat",
   "Int.instCommRing._proof_8",
   "Int.mul_one",
   "Nat.cast",
   "Int.instCommSemigroup",
   "Semigroup.toMul",
   "Int.zero_mul",
   "Int.instAddCommGroup",
   "MulOneClass.toOne",
   "Monoid.toMulOneClass",
   "Int.instCommRing._proof_5",
   "Int.instCommRing._proof_6",
   "Ring.mk",
   "instNatCastInt",
   "NonUnitalSemiring.mk",
   "AddCommGroup.add_comm",
   "SubNegMonoid.toNeg",
   "Int.instCommRing._proof_7",
   "Int.instCommRing._proof_9",
   "Int.instCommRing._proof_1",
   "Semiring.mk",
   "AddCommGroup",
   "Int.instCommRing._proof_2",
   "CommRing",
   "HPow.hPow",
   "Int",
   "Int.add_mul",
   "CommSemigroup.mul_comm",
   "Int.instCommRing._proof_11",
   "SubNegMonoid.toAddMonoid",
   "Monoid.toNatPow",
   "CommSemigroup.toSemigroup",
   "IntCast.mk"],
  "name": "Int.instCommRing",
  "constType": "CommRing ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "Prod.fst",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "Lattice.toSemilatticeInf",
   "Exists",
   "Set",
   "BoundedOrder",
   "Prod.snd",
   "Exists.choose",
   "Set.instMembership",
   "LT.lt",
   "Prod",
   "Nat",
   "Nat.succ",
   "Lattice",
   "Nat.below",
   "LE.le",
   "Top.top",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "setOf"],
  "name": "impl.prop4d1₁_seq._proof_5",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (k : ℕ) (x : Nat.below k.succ), ↑x.1 < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "TotIntvl",
   "PartialOrder.toPreorder",
   "semistable._proof_3",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "GT.gt",
   "S₁I._proof_2",
   "Subtype.val",
   "in_TotIntvl",
   "not_false_eq_true",
   "funext",
   "forall_congr",
   "CompleteSemilatticeInf.toPartialOrder",
   "TotIntvl._proof_1",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "semistable._proof_4",
   "Exists",
   "Exists.choose_spec",
   "And",
   "BoundedOrder",
   "True.intro",
   "Prod.snd",
   "Bot.bot",
   "semistableI",
   "Set.instMembership",
   "Prod",
   "implies_true",
   "BoundedOrder.toOrderBot",
   "Iff.of_eq",
   "Iff",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "Eq.mpr",
   "setOf",
   "S₂I",
   "Ne.symm",
   "Subtype",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_36",
   "semistable",
   "and_true",
   "Iff.intro",
   "Prod.fst",
   "congrArg",
   "μA",
   "BoundedOrder.toOrderTop",
   "congr",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "InIntvl",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "True",
   "Set",
   "_private.Mathlib.Order.BoundedOrder.Basic.0._proof_3",
   "exists_prop_congr",
   "LT.lt",
   "S₁I",
   "LE.le",
   "False",
   "_private.Init.PropLemmas.0._proof_14",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "_private.Init.Core.0._proof_39",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "impl.semistable_iff",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S), semistable μ ↔ semistableI μ TotIntvl",
  "constCategory": "Theorem"},
 {"references":
  ["Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1",
   "Nat.rawCast",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
  "constType":
  "∀ {α : Type u} {a : α} {n : ℕ} [inst : AddMonoidWithOne α], Mathlib.Meta.NormNum.IsNat a n → a = n.rawCast",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.mk",
  "constType": "{α : Type u} → {β : Type v} → α → β → α × β",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lean.Name",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["implies_congr",
   "instAddNat",
   "impl.ℒₛ._proof_1",
   "PartialOrder.toPreorder",
   "Decidable",
   "Eq.trans",
   "WellFounded.has_min",
   "Prod.mk",
   "Subsingleton.elim",
   "Eq.mpr_not",
   "Membership.mem",
   "Preorder.toLT",
   "Classical.propDecidable",
   "eq_true",
   "Membership.mem.out",
   "GT.gt",
   "Subtype.val",
   "impl.ℒₛ",
   "False.elim",
   "letFun",
   "forall_congr",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "Eq.ndrec",
   "impl.ℒₛ._proof_2",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "of_eq_false",
   "Exists",
   "Exists.choose_spec",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "Nat",
   "impl.prop3d4₀func",
   "Eq.refl",
   "eq_false",
   "Classical.byContradiction",
   "impl.prop3d4₀func._proof_7",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "impl.prop3d4₀func._proof_8",
   "Subtype",
   "instDecidableTrue",
   "Eq.mp",
   "impl.prop3d4₀func_helper",
   "lt_of_le_of_ne",
   "dite_congr",
   "congrArg",
   "Prod.fst",
   "Subtype.prop",
   "instOfNatNat",
   "μA",
   "IsWellFounded.wf",
   "not_true_eq_false",
   "WellFoundedGT",
   "instDecidableFalse",
   "instSubsingletonDecidable",
   "dite_cond_eq_false",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "Not",
   "Set.Nonempty",
   "Lattice.toSemilatticeInf",
   "True",
   "impl.prop3d4₀func._proof_4",
   "instHAdd",
   "Set",
   "Exists.choose",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "dite_cond_eq_true",
   "of_eq_true",
   "LE.le",
   "False",
   "Ne",
   "Subtype.mk",
   "dite",
   "CompleteLattice.toCompleteSemilatticeInf",
   "_private.Init.Core.0._proof_39",
   "CompleteLattice"],
  "name": "impl.prop3d4₀func_strict_decreasing",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] [inst_3 : WellFoundedGT ℒ] {S : Type}\n  [inst_4 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }) (i : ℕ),\n  (↑I).1 ≠ ↑(impl.prop3d4₀func μ I i) → ↑(impl.prop3d4₀func μ I i) > ↑(impl.prop3d4₀func μ I (i + 1))",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "LE", "ge_iff_le", "Eq", "GE.ge", "propext"],
  "name": "_private.Init.Core.0._proof_38",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "Coe",
   "Coe.mk",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "OrderDual.instLT",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan._proof_11",
   "SemilatticeInf.toPartialOrder"],
  "name":
  "impl.instCoeSubtypeProdLtFstSndOrderDualOfNontrivialOfBoundedOrder_harderNarasimhan",
  "constType":
  "{ℒ : Type} → [Nontrivial ℒ] → [inst : Lattice ℒ] → [BoundedOrder ℒ] → Coe { p // p.1 < p.2 } { p // p.1 < p.2 }",
  "constCategory": "Definition"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "Int.cast",
   "Int",
   "Ring"],
  "name": "Int.rawCast",
  "constType": "{α : Type u} → [Ring α] → ℤ → α",
  "constCategory": "Definition"},
 {"references": ["AddMonoid", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat.to_eq.match_1",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "Unit"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_eq",
  "constType":
  "∀ {α : Type u} [inst : AddMonoidWithOne α] {n : ℕ} {a a' : α}, Mathlib.Meta.NormNum.IsNat a n → ↑n = a' → a = a'",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "Nat.add_sub_of_le",
   "Nat.add_comm",
   "congrArg",
   "HAdd.hAdd",
   "Nat",
   "instSubNat",
   "Eq.refl",
   "LE.le",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "Eq",
   "instHSub",
   "instLENat"],
  "name": "Nat.sub_add_cancel",
  "constType": "∀ {n m : ℕ}, m ≤ n → n - m + m = n",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.instOmegaCompletePartialOrder",
   "Or.inr",
   "TotIntvl",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "not_le_of_lt",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Preorder.toLT",
   "SlopeLike._proof_2",
   "SlopeLike._proof_1",
   "Prod.fst",
   "And.intro",
   "Or.inl",
   "Or",
   "BoundedOrder.toOrderTop",
   "letFun",
   "OrderBot.toBot",
   "Eq",
   "Preorder.toLE",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Not",
   "bot_lt_iff_ne_bot",
   "Lattice.toSemilatticeInf",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Or.casesOn",
   "LT.lt",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Iff.mpr",
   "LE.le",
   "Lattice",
   "Nontrivial",
   "SlopeLike",
   "Top.top",
   "SlopeLike._proof_3",
   "Ne",
   "Subtype.mk",
   "lt_top_iff_ne_top",
   "OrderTop.toTop",
   "CompleteLattice"],
  "name": "impl.rmk4d13",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (μ : { p // p.1 < p.2 } → S),\n  SlopeLike μ → ∀ (x : ℒ) (hx : x ≠ ⊥ ∧ x ≠ ⊤), ¬μ ⟨(⊥, x), ⋯⟩ ≤ μ TotIntvl ∨ μ TotIntvl ≤ μ ⟨(x, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.sound", "letFun", "Quot.liftOn", "Eq", "Quot.mk", "Quot", "congrArg"],
  "name": "funext",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["IsOrderedAddMonoid.mk",
   "PartialOrder.toPreorder",
   "Nat.instPartialOrder",
   "instHAdd",
   "Nat.add_le_add_left",
   "Nat.instAddCommMonoid",
   "congrArg",
   "HAdd.hAdd",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "IsOrderedAddMonoid",
   "LE.le",
   "id",
   "Eq.mpr",
   "AddCommMagma.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Eq",
   "Preorder.toLE",
   "add_comm"],
  "name": "Nat.instIsOrderedAddMonoid",
  "constType": "IsOrderedAddMonoid ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.lt",
   "Nat.instMax",
   "instMinNat",
   "DecidableEq",
   "Nat.le_refl",
   "PartialOrder.mk",
   "LT.mk",
   "Nat.instLinearOrder._proof_3",
   "Nat.le",
   "Nat.le_trans",
   "DecidableLE",
   "DecidableLT",
   "LinearOrder",
   "Nat.decLe",
   "LinearOrder.mk",
   "instOrdNat",
   "Nat.le_antisymm",
   "Nat.decLt",
   "Nat",
   "Nat.instLinearOrder._proof_2",
   "Nat.instLinearOrder._proof_1",
   "LE.mk",
   "Nat.le_total",
   "inferInstance",
   "instDecidableEqNat",
   "Preorder.mk",
   "Nat.lt_iff_le_not_le"],
  "name": "Nat.instLinearOrder",
  "constType": "LinearOrder ℕ",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "NonAssocRing"],
  "name": "NonAssocRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring.right_distrib",
   "NonUnitalNonAssocSemiring.toMul",
   "AddMonoid.toAddSemigroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Distrib",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.left_distrib",
   "Distrib.mk",
   "NonUnitalNonAssocSemiring",
   "AddSemigroup.toAdd"],
  "name": "NonUnitalNonAssocSemiring.toDistrib",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Distrib α",
  "constCategory": "Definition"},
 {"references": ["Neg"],
  "name": "Neg.neg",
  "constType": "{α : Type u} → [self : Neg α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "Iff.mp",
   "sup_le",
   "le_sup_right",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "le_sup_left",
   "Prod",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "Or.inr",
   "SemilatticeInf.toMin",
   "Subtype",
   "not_le_of_lt",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "impl.lem2d4₂I",
   "Prod.fst",
   "congrArg",
   "le_inf",
   "Or.inl",
   "μA",
   "Preorder.toLE",
   "Eq",
   "sup_le_iff",
   "InIntvl",
   "propext",
   "inf_lt_left",
   "Not",
   "not_and_or",
   "Lattice.toSemilatticeInf",
   "ConvexI",
   "LT.lt",
   "Or.casesOn",
   "Max.max",
   "le_of_lt",
   "Min.min",
   "impl.lem2d4₁",
   "SemilatticeSup.toMax",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "CompleteLattice"],
  "name": "impl.prop2d8₀I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (y : ℒ),\n          InIntvl I y →\n            ∀ (u : ℒ) (h : u < x ∧ u < y) (w : ℒ),\n              InIntvl I w →\n                ∀ (hw : u ≤ w ∧ w < x ⊔ y),\n                  μA μ ⟨(u, x), ⋯⟩ ≤ μmax μ ⟨(w, x ⊔ y), ⋯⟩ ∨ μA μ ⟨(u, y), ⋯⟩ ≤ μmax μ ⟨(w, x ⊔ y), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftMono",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddCommMonoid.toAddMonoid",
   "IsOrderedAddMonoid.add_le_add_left",
   "HAdd.hAdd",
   "AddCommMonoid",
   "AddZeroClass.toAdd",
   "PartialOrder",
   "IsOrderedAddMonoid",
   "LE.le",
   "CovariantClass.mk",
   "Preorder.toLE",
   "AddMonoid.toAddZeroClass"],
  "name": "IsOrderedAddMonoid.toAddLeftMono",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : PartialOrder α] [IsOrderedAddMonoid α], AddLeftMono α",
  "constCategory": "Theorem"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Subtype",
   "Prod.mk",
   "And",
   "instLatticeInterval",
   "Preorder.toLT",
   "BoundedOrder",
   "Prod.snd",
   "Subtype.val",
   "Prod.fst",
   "Prod",
   "LT.lt",
   "Interval",
   "Resμ._proof_19",
   "LE.le",
   "Nontrivial",
   "Lattice",
   "Subtype.mk",
   "Preorder.toLE",
   "CompleteLattice",
   "SemilatticeInf.toPartialOrder"],
  "name": "Resμ",
  "constType":
  "{ℒ : Type} →\n  [inst : Nontrivial ℒ] →\n    [inst_1 : Lattice ℒ] →\n      [inst_2 : BoundedOrder ℒ] →\n        (z : { p // p.1 < p.2 }) → {S : Type} → [CompleteLattice S] → ({ p // p.1 < p.2 } → S) → { p // p.1 < p.2 } → S",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IsWellOrder",
  "constType": "(α : Type u) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Not", "False.elim", "Decidable", "Decidable.byCases", "id", "False"],
  "name": "Decidable.byContradiction",
  "constType": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "AddGroupWithOne.toAddMonoidWithOne",
   "inferInstance",
   "AddMonoidWithOne",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne",
  "constType": "{α : Type u} → [Ring α] → AddMonoidWithOne α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references": ["ConditionallyCompleteLattice", "Lattice"],
  "name": "ConditionallyCompleteLattice.toLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Nat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm",
   "Eq",
   "AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat"],
  "name": "Mathlib.Meta.NormNum.isNat_ofNat",
  "constType":
  "∀ (α : Type u) [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, ↑n = a → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "Preorder.toLT",
   "OfNat.ofNat",
   "Nat.lt_add_one",
   "Nat.instPreorder",
   "LT.lt",
   "HAdd.hAdd",
   "Nat",
   "instOfNatNat",
   "Lattice",
   "StrictMono",
   "SemilatticeInf.toPartialOrder"],
  "name": "impl.prop4d1₁_seq._proof_1",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] (x : ℕ → ℒ), StrictMono x → ∀ (N : ℕ), x N < x (N + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "PartialOrder.toPreorder",
   "IsAttained",
   "Prod.mk",
   "Preorder.toLT",
   "GT.gt",
   "Subtype.val",
   "IsComparable",
   "And.intro",
   "Or",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLinearOrder",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "Prod",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Classical.byContradiction",
   "Nontrivial",
   "Lattice",
   "Top.top",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "le_total",
   "Or.inr",
   "Subtype",
   "not_le_of_lt",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Prod.fst",
   "le_rfl",
   "impl.prop2d6₃I",
   "Or.inl",
   "BoundedOrder.toOrderTop",
   "μA",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "ConditionallyCompleteLinearOrder.toLinearOrder",
   "OrderBot.toBot",
   "Preorder.toLE",
   "Eq",
   "Not",
   "Lattice.toSemilatticeInf",
   "le_top",
   "Or.casesOn",
   "CompletelyDistribLattice.toCompleteLattice",
   "ConvexI",
   "LT.lt",
   "le_of_lt",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "bot_lt_top"],
  "name": "impl.rmk2d7",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLinearOrder S] (μ : { p // p.1 < p.2 } → S),\n  ConvexI ⟨(⊥, ⊤), ⋯⟩ μ →\n    ∀ (x : ℒ) (h : ⊥ < x ∧ x < ⊤), μA μ ⟨(⊥, x), ⋯⟩ > μA μ ⟨(⊥, ⊤), ⋯⟩ → μA μ ⟨(x, ⊤), ⋯⟩ = μA μ ⟨(⊥, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["Not", "Iff", "Classical.propDecidable", "Decidable.not_not"],
  "name": "Classical.not_not",
  "constType": "∀ {a : Prop}, ¬¬a ↔ a",
  "constCategory": "Theorem"},
 {"references": ["PartialOrder", "SemilatticeSup"],
  "name": "SemilatticeSup.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["IsTotal", "Or"],
  "name": "IsTotal.mk",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop}, (∀ (a b : α), r a b ∨ r b a) → IsTotal α r",
  "constCategory": "Other"},
 {"references":
  ["Int.cast_add",
   "Int.add",
   "Distrib.toAdd",
   "Ring.toNonAssocRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "instHAdd",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "Int.cast",
   "Int",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toAddGroupWithOne",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.instAdd",
   "Eq.symm",
   "AddGroupWithOne.toIntCast",
   "Mathlib.Meta.NormNum.isInt_add.match_1",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSemigroup.toAdd",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.isInt_add",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → a'.add b' = c → Mathlib.Meta.NormNum.IsInt (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["instAddNat",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "bot_le",
   "Subtype.val",
   "Equiv",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instTop",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "lt_of_le_of_lt",
   "BoundedOrder",
   "Prod.snd",
   "Bot.bot",
   "OrderDual.instOrderTop",
   "Nat.lt_add_one",
   "Prod",
   "Exists.casesOn",
   "Nat",
   "OrderDual.instPreorder",
   "BoundedOrder.toOrderBot",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Top.top",
   "StrictMono",
   "OrderDual",
   "Subtype",
   "Eq.mp",
   "DFunLike.coe",
   "congrArg",
   "Nat.instPreorder",
   "Prod.fst",
   "OrderDual.ofDual",
   "Subtype.prop",
   "instOfNatNat",
   "OrderDual.instLT",
   "OrderBot.toBot",
   "OrderDual.instLE",
   "Eq",
   "Preorder.toLE",
   "le_top",
   "Lattice.toSemilatticeInf",
   "OrderDual.ofDual_le_ofDual",
   "Equiv.instFunLike",
   "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "instHAdd",
   "OfNat.ofNat",
   "lt_of_lt_of_le",
   "LT.lt",
   "HAdd.hAdd",
   "StrictAnti",
   "impl.fuck",
   "LE.le",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.h₁_dual_of_h₁",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  {μ : { p // p.1 < p.2 } → S},\n  (∀ (x : ℕ → ℒ) (saf : StrictAnti x), ∃ N, μ ⟨(⊥, x N), ⋯⟩ ≤ μ ⟨(x (N + 1), x N), ⋯⟩) →\n    ∀ (x : ℕ → ℒᵒᵈ) (smf : StrictMono x),\n      ∃ N, (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨(x N, x (N + 1)), ⋯⟩ ≤ (fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) ⟨(x N, ⊤), ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "_private.Init.Core.0._proof_38",
   "Iff.mp",
   "Preorder.toLT",
   "Exists.intro",
   "Subtype.val",
   "inf_assoc",
   "And.intro",
   "le_sup_right",
   "sSup_le",
   "letFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.symm",
   "ConvexI._proof_2",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "And.left",
   "Exists",
   "lt_of_le_of_lt",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "mt",
   "μmax._proof_2",
   "Eq.refl",
   "Iff.mpr",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "ConvexI._proof_1",
   "setOf",
   "sup_le_sup_right",
   "SemilatticeInf.toMin",
   "Subtype",
   "le_trans",
   "SemilatticeSup.toPartialOrder",
   "lt_of_le_of_ne",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Prod.fst",
   "congrArg",
   "le_inf",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "le_antisymm",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "inf_idem",
   "inf_le_inf_right",
   "right_eq_sup",
   "gt_of_ge_of_gt",
   "ConvexI",
   "LT.lt",
   "Max.max",
   "Min.min",
   "le_of_lt",
   "SemilatticeSup.toMax",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "le_sSup",
   "Ne",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "μmax",
   "right_lt_sup",
   "CompleteLattice"],
  "name": "impl.lem2d4₂I",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ →\n    ∀ (x : ℒ),\n      InIntvl I x →\n        ∀ (w : ℒ),\n          InIntvl I w → ∀ (hxw : ¬x ≤ w) (t : ℒ) (hxwt : x ⊔ w ≤ t), μmax μ ⟨(x ⊓ w, x), ⋯⟩ ≤ μmax μ ⟨(w, t), ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["SupSet", "CompleteSemilatticeSup"],
  "name": "CompleteSemilatticeSup.toSupSet",
  "constType": "{α : Type u_8} → [self : CompleteSemilatticeSup α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "CompleteLattice.le_sSup",
   "CompleteLattice.toLattice",
   "CompleteSemilatticeSup",
   "CompleteLattice.sSup_le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "CompleteSemilatticeSup.mk",
   "CompleteLattice"],
  "name": "CompleteLattice.toCompleteSemilatticeSup",
  "constType":
  "{α : Type u_8} → [self : CompleteLattice α] → CompleteSemilatticeSup α",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "eq_of_le_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["Not", "IsIrrefl", "IsIrrefl.irrefl"],
  "name": "irrefl",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop} [IsIrrefl α r] (a : α), ¬r a a",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "OrderDual", "LT.mk", "LT"],
  "name": "OrderDual.instLT",
  "constType": "(α : Type u_5) → [LT α] → LT αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Exists.intro", "Eq", "forall_exists_index", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_12",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (∃ x, p x) → Prop}, (∀ (h : ∃ x, p x), q h) = ∀ (x : α) (h : p x), q ⋯",
  "constCategory": "Theorem"},
 {"references": ["OrderDual", "LE.le", "LE.mk", "LE"],
  "name": "OrderDual.instLE",
  "constType": "(α : Type u_5) → [LE α] → LE αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.mk",
   "OrderDual.instPreorder",
   "OrderDual",
   "Preorder",
   "PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "inferInstanceAs",
   "Preorder.toLE",
   "le_antisymm"],
  "name": "OrderDual.instPartialOrder",
  "constType": "(α : Type u_5) → [PartialOrder α] → PartialOrder αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["LE", "Bot", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{α : Type u} → {inst : LE α} → [self : OrderBot α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "True",
   "AddZeroClass.toZero",
   "Eq.trans",
   "CommSemiring",
   "CommSemiring.toSemiring",
   "Mathlib.Tactic.Ring.cast_zero.match_1",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "OfNat.ofNat",
   "congrArg",
   "eq_self",
   "AddMonoidWithOne.toNatCast",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "MulZeroClass.toZero",
   "Nat.cast_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddZeroClass"],
  "name": "Mathlib.Tactic.Ring.cast_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R}, Mathlib.Meta.NormNum.IsNat a 0 → a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder",
   "LE.le",
   "Eq",
   "Preorder.toLE",
   "PartialOrder.le_antisymm"],
  "name": "le_antisymm",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["lt_trans",
   "impl.prop4d1₁_seq._proof_5",
   "PartialOrder.toPreorder",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Iff.mp",
   "impl.prop4d1₁_seq._proof_3",
   "Preorder.toLT",
   "_private.Init.Classical.0._proof_9",
   "Membership.mem.out",
   "Subtype.val",
   "Set.Elem",
   "False.elim",
   "Or",
   "letFun",
   "forall_congr",
   "funext",
   "CompleteSemilatticeInf.toPartialOrder",
   "Eq.rec",
   "Eq.ndrec",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "Exists.choose_spec",
   "Or.resolve_left",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Exists.casesOn",
   "Prod",
   "Nat",
   "Iff.of_eq",
   "Eq.refl",
   "Iff.mpr",
   "Lattice",
   "Classical.byContradiction",
   "Top.top",
   "setOf",
   "Subtype",
   "Eq.mp",
   "le_trans",
   "_private.Init.Classical.0._proof_7",
   "_private.Mathlib.Order.Defs.PartialOrder.0._proof_1",
   "Prod.fst",
   "congrArg",
   "_private.Init.PropLemmas.0._proof_15",
   "not_lt_top_iff",
   "Subtype.prop",
   "BoundedOrder.toOrderTop",
   "not_true_eq_false",
   "Eq",
   "Preorder.toLE",
   "propext",
   "Not",
   "Lattice.toSemilatticeInf",
   "impl.prop4d1₁_seq._proof_6",
   "True",
   "Set",
   "_private.Init.Classical.0._proof_13",
   "Exists.choose",
   "exists_prop_congr",
   "LT.lt",
   "Nat.succ",
   "LE.le",
   "Nat.below",
   "False",
   "Subtype.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderTop.toTop",
   "CompleteLattice",
   "And.casesOn"],
  "name": "impl.prop4d1₁_seq._proof_7",
  "constType":
  "∀ {ℒ : Type} [inst : Lattice ℒ] [inst_1 : BoundedOrder ℒ] {S : Type} [inst_2 : CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S),\n  (∀ (z : { p // p.1 < p.2 }) (hz : (↑z).2 < ⊤), μ z ≤ μ ⟨((↑z).1, ⊤), ⋯⟩ ∨ μ ⟨((↑z).2, ⊤), hz⟩ ≤ μ ⟨((↑z).1, ⊤), ⋯⟩) →\n    ∀ (k : ℕ) (x : Nat.below k.succ),\n      ⋯.choose ∈ {YA | ∃ (h : YA < ⊤), ∀ xA < ⊤, ∃ xB, ∃ (hAB : xA < xB), ¬μ ⟨(xA, xB), hAB⟩ ≤ μ ⟨(YA, ⊤), h⟩}",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.isInt_mul.match_1",
   "Ring.toNonAssocRing",
   "Int.mul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Distrib.toMul",
   "HMul.hMul",
   "Int.cast",
   "Int.instMul",
   "Int",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "Ring.toAddGroupWithOne",
   "Int.cast_mul",
   "NonAssocRing.toAddCommGroupWithOne",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.symm",
   "AddGroupWithOne.toIntCast",
   "instHMul",
   "Eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.isInt_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → a'.mul b' = c → Mathlib.Meta.NormNum.IsInt (a * b) c",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_not", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_not_eq",
  "constType": "∀ (p : Prop), (¬¬p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "CompleteSemilatticeSup",
   "Membership.mem",
   "isLUB_sSup",
   "CompleteSemilatticeSup.toSupSet",
   "Set.instMembership",
   "SupSet.sSup",
   "Iff",
   "isLUB_le_iff",
   "LE.le",
   "CompleteSemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sSup_le_iff",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, sSup s ≤ a ↔ ∀ b ∈ s, b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "ne_comm",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LE.le.lt_iff_ne",
   "bot_le",
   "Bot.bot",
   "LT.lt",
   "Iff",
   "PartialOrder",
   "Ne",
   "OrderBot.toBot",
   "Preorder.toLE",
   "OrderBot"],
  "name": "bot_lt_iff_ne_bot",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, ⊥ < a ↔ a ≠ ⊥",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["FunLike",
   "DFunLike.mk",
   "Equiv.instFunLike._proof_2",
   "Equiv.toFun",
   "Equiv"],
  "name": "Equiv.instFunLike",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ≃ β) α β",
  "constCategory": "Definition"},
 {"references": ["Not", "not_and", "And", "Eq", "propext"],
  "name": "Mathlib.Tactic.PushNeg.not_and_eq",
  "constType": "∀ (p q : Prop), (¬(p ∧ q)) = (p → ¬q)",
  "constCategory": "Theorem"},
 {"references": ["CommSemiring", "Semiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Preorder",
   "Preorder.toLT",
   "GT.gt",
   "Preorder.toLE",
   "GE.ge",
   "lt_of_lt_of_le"],
  "name": "gt_of_ge_of_gt",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≥ b → b > c → a > c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.mp",
   "eq_comm",
   "Preorder.toLT",
   "or_assoc",
   "IsComparable",
   "congrArg",
   "LT.lt",
   "or_self",
   "or_comm",
   "Or",
   "PartialOrder",
   "LE.le",
   "Eq.symm",
   "Eq",
   "Preorder.toLE",
   "le_iff_eq_or_lt",
   "propext"],
  "name": "impl.comparable_iff",
  "constType":
  "∀ {L : Type} [inst : PartialOrder L] (x y : L), IsComparable x y → x < y ∨ y ≤ x",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Classical.choose"],
  "name": "Exists.choose",
  "constType": "{α : Sort u_1} → {p : α → Prop} → (∃ a, p a) → α",
  "constCategory": "Definition"},
 {"references": ["Or.rec", "Or.inr", "Or.inl", "Or"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b), (∀ (h : a), motive ⋯) → (∀ (h : b), motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references": ["InfSet", "CompleteSemilatticeInf"],
  "name": "CompleteSemilatticeInf.toInfSet",
  "constType": "{α : Type u_8} → [self : CompleteSemilatticeInf α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeSup",
   "le_refl",
   "PartialOrder.toPreorder",
   "sup_eq_left",
   "Eq.trans",
   "Prod.mk",
   "Membership.mem",
   "Preorder.toLT",
   "Exists.intro",
   "GE.ge",
   "Subtype.val",
   "And.intro",
   "PartialOrder",
   "letFun",
   "sSup_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "forall_congr",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.rec",
   "And.left",
   "SemilatticeInf.toPartialOrder",
   "Exists",
   "inf_eq_right",
   "And.right",
   "And",
   "BoundedOrder",
   "Prod.snd",
   "Set.instMembership",
   "Prod",
   "μmax._proof_2",
   "Iff.mpr",
   "Eq.refl",
   "Nontrivial",
   "Lattice",
   "id",
   "Eq.mpr",
   "setOf",
   "SemilatticeInf.toMin",
   "Subtype",
   "Eq.mp",
   "SemilatticeSup.toPartialOrder",
   "impl.lem2d4₂I",
   "lt_of_le_of_ne",
   "CompleteLattice.toCompleteSemilatticeSup",
   "congrArg",
   "Prod.fst",
   "le_rfl",
   "eq_of_le_of_le",
   "Subtype.prop",
   "_private.Init.PropLemmas.0._proof_12",
   "Preorder.toLE",
   "Eq",
   "InIntvl",
   "inf_lt_left",
   "Not",
   "Lattice.toSemilatticeInf",
   "Set",
   "gt_of_ge_of_gt",
   "not_le_of_gt",
   "ConvexI",
   "LT.lt",
   "Max.max",
   "ne_of_lt",
   "Min.min",
   "le_of_lt",
   "SemilatticeSup.toMax",
   "LE.le",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "Ne",
   "Subtype.mk",
   "right_lt_sup",
   "μmax",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice"],
  "name": "impl.rmk2d5₂",
  "constType":
  "∀ {ℒ : Type} [inst : Nontrivial ℒ] [inst_1 : Lattice ℒ] [inst_2 : BoundedOrder ℒ] {S : Type}\n  [inst_3 : CompleteLattice S] (I : { p // p.1 < p.2 }) (μ : { p // p.1 < p.2 } → S),\n  ConvexI I μ → μmax μ I = μmax (μmax μ) I",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Preorder", "Preorder.toLT"],
  "name": "StrictAnti",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual",
   "Subtype",
   "PartialOrder.toPreorder",
   "Prod.mk",
   "Preorder.toLT",
   "DFunLike.coe",
   "Subtype.val",
   "Equiv",
   "Prod.fst",
   "OrderDual.ofDual",
   "Subtype.prop",
   "OrderDual.instLT",
   "Eq",
   "Preorder.toLE",
   "SemilatticeInf.toPartialOrder",
   "rfl",
   "Lattice.toSemilatticeInf",
   "impl.instCoeSubtypeProdOrderDualLtFstSndOfNontrivialOfBoundedOrder_harderNarasimhan._proof_12",
   "Equiv.instFunLike",
   "BoundedOrder",
   "Prod.snd",
   "LT.lt",
   "Prod",
   "Lattice",
   "Nontrivial",
   "Subtype.mk",
   "CompleteLattice"],
  "name": "impl.fuck",
  "constType":
  "∀ {ℒ : Type} [Nontrivial ℒ] [inst : Lattice ℒ] [BoundedOrder ℒ] {S : Type} [CompleteLattice S]\n  (μ : { p // p.1 < p.2 } → S) (I : { p // p.1 < p.2 }),\n  μ ⟨(OrderDual.ofDual (↑I).2, OrderDual.ofDual (↑I).1), ⋯⟩ = OrderDual.ofDual ((fun p => μ ⟨((↑p).2, (↑p).1), ⋯⟩) I)",
  "constCategory": "Theorem"},
 {"references": ["PartialOrder", "CompleteSemilatticeSup"],
  "name": "CompleteSemilatticeSup.toPartialOrder",
  "constType":
  "{α : Type u_8} → [self : CompleteSemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "True", "exists_true_left", "True.intro", "Eq", "propext"],
  "name": "_private.Init.PropLemmas.0._proof_14",
  "constType": "∀ {p : True → Prop}, Exists p = p True.intro",
  "constCategory": "Theorem"},
 {"references": ["SupSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toSupSet",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["Int.instAddCommGroup",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "inferInstance",
   "AddMonoid",
   "AddGroup.toSubNegMonoid",
   "Int"],
  "name": "Int.instAddMonoid",
  "constType": "AddMonoid ℤ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Max.max",
   "PartialOrder.toPreorder",
   "LT.lt.trans_le",
   "SemilatticeSup.toMax",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLT",
   "SemilatticeSup",
   "le_sup_left"],
  "name": "lt_sup_of_lt_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c < a → c < a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["Inhabited.mk", "True", "True.intro", "Inhabited"],
  "name": "instInhabitedTrue",
  "constType": "Inhabited True",
  "constCategory": "Definition"}]